 return options;
 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl.getInvocations(), invocationMatcher);
 mockingProgress.verificationStarted(mode);
 if (m instanceof CapturesArguments) {
 int strLen = str.length();
 int strLen = str.length();
 for (int i = 0; current != null && i < intIndex; i++) { elem = current;
 return allResultsMatch(n, MAY_BE_STRING_PREDICATE);
 int len = thisBuf.length - strLen;
 return new LocalDate( yearOfEra, calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH) );
 return new LocalDate( date.getYear() + 1900, date.getMonth() + 1, date.getDate() );
 return new LocalDateTime( yearOfEra, calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH), calendar.get(Calendar.HOUR_OF_DAY), calendar.get(Calendar.MINUTE), calendar.get(Calendar.SECOND), calendar.get(Calendar.MILLISECOND) );
 return new LocalDateTime( date.getYear() + 1900, date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), (((int) (date.getTime() % 1000)) + 1000) % 1000 );
 super(paint, stroke, paint, stroke, alpha);
 return method.equals(o);
 return 1;
 this.rows = rowDimension; this.columns = columnDimension;
 return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.getClass() == cal2.getClass());
 int indexOfDot = namespace.indexOf('.');
 max += Math.max(max, Math.abs(a));
 public double getLInfNorm() { double max = 0; Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); max += iter.value(); } return max; }
 if (!type.isSubtype(
 if (maybeTypeOfThis instanceof ObjectType) {
 if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {
 if (!qVar.isTypeInferred()) {
 boolean replacedPrototype = prototype != null;
 return invocation.callRealMethod();
 if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {
 final EigenDecomposition dec = new EigenDecomposition(m);
 Node moduleExportsProp = IR.getprop(IR.name(moduleName),
 return cAvailableLocaleSet.contains(locale);
 if (dataset != null) {
 for (int i = 0; i < fields.length; i++) {
 val.set(fields[i][0], val.get(fields[i][0]) - offset);
 public T[] sample(int sampleSize) throws NotStrictlyPositiveException {
 final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);
 break;
 if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {
 int end = start;
 while(input.charAt(end) != ';')
 return 2 + (end - start) + (isHex ? 1 : 0) + 1;
 if (result != null) {
 coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative); if (basicRow != null) { for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) { if (tableau.getEntry(basicRow, j) == 1) { coefficients[i] = 0; } }
 type = Object.class;
 return (T[]) new Object[] { null };
 if (start == 0 && end == 0) { if (!letters && !numbers) { end = Integer.MAX_VALUE; } else { end = 'z' + 1; start = ' '; }
 if (lTData[i][i] < absolutePositivityThreshold) { throw new NotPositiveDefiniteMatrixException(); }
 ltI[i] = Math.sqrt(ltI[i]);
 years = FieldUtils.safeAdd(years, months / 12); months = months % 12; if (years != 0) { result = result.withYears(years); } if (months != 0) { result = result.withMonths(months);
 this(duration, null, null);
 if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {
 if (basicRows.contains(basicRow)) {
 res[i] = diff * x[i] + boundaries[0][i];
 res[i] = (x[i] - boundaries[0][i]) / diff;
 if (x[i] < 0) {
 if (x[i] > 1.0) {
 addExpr(first, p, context); cc.addOp(opstr, true); addExpr(last, p + 1, rhsContext);
 cc.listSeparator();
 if (getLastChar() != ' ') {
 if (x < 0 && prev == '-') {
 if (length == 0 || !Character.isJavaIdentifierStart(s.charAt(0))) {
 if ( !Character.isJavaIdentifierPart(s.charAt(i))) {
 if (val.startsWith("--")) {
 return next.filterCandidate(mocks, field, fieldInstance);
 if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {
 DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
 return 0;
 boolean isOverride = t.inGlobalScope() && parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop;
 if (n.isGetProp()) {
 JSType type = getJSType(n); if (dereference) { ObjectType dereferenced = type.dereference(); if (dereferenced != null) { type = dereferenced; } } if (type.isFunctionPrototypeType() || (type.toObjectType() != null && type.toObjectType().getConstructor() != null)) { return type.toString(); }
 if (NodeUtil.isName(n) && variable.equals(n.getString())) {
 case Token.AND:
 case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
 if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION
 case Token.AND:
 case Token.HOOK:
 if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {
 public <T> T mock(Class<T> classToMock, MockSettings mockSettings, boolean shouldResetOngoingStubbing) { return mock(classToMock, mockSettings); }
 mockingProgress.resetOngoingStubbing();
 return MOCKITO_CORE.mock((Class<T>) object.getClass(), withSettings() .spiedInstance(object) .defaultAnswer(CALLS_REAL_METHODS));
 return MOCKITO_CORE.mock(classToMock, mockSettings);
 ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;
 return extraInterfaces != null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class);
 return this.extraInterfaces(java.io.Serializable.class);
 weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(dim, dim); for (int i = 0; i < dim; i++) { weightMatrix.setEntry(i, i, weight[i]); }
 final EigenDecomposition dec = new EigenDecomposition(m);
 stopTime = System.currentTimeMillis();
 return newNode( Token.FOR, transform(loopNode.getIterator()), transform(loopNode.getIteratedObject()), transformBlock(loopNode.getBody()));
 MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler); MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));
 int sum = 0;
 final int dp = p1[i] - p2[i];
 Calendar c = new GregorianCalendar(mTimeZone);
 this.elitismRate = elitismRate;
 this.elitismRate = elitismRate;
 if (durationField.isSupported()) { return 1; }
 int compare = lastUnitField.compareTo(loopUnitField);
 } else if (compare == 0) {
 this.seriesKeys = null; this.categoryKeys = null;
 if (categoryKeys.length != this.startData[0].length) {
 return recordDeepStubAnswer( newDeepStubMock(returnTypeGenericMetadata), container );
 : withSettings();  return mockSettings.serializable()
 return mockSettings.serializable()
 return null;
 return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);
 for (int i = 0; i < thisBuf.length; i++) {
 for (int i = startIndex; i < thisBuf.length; i++) {
 public JSType getLeastSupertype(JSType that) { if (!that.isRecordType()) { return super.getLeastSupertype(that); } RecordTypeBuilder builder = new RecordTypeBuilder(registry); for (String property : properties.keySet()) { if (that.toMaybeRecordType().hasProperty(property) && that.toMaybeRecordType().getPropertyType(property).isEquivalentTo( getPropertyType(property))) { builder.addProperty(property, getPropertyType(property), getPropertyNode(property)); } } return builder.build(); }
 return isNoType() || isNoObjectType() || isNoResolvedType();
 private void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) { Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier(); // Make variable names unique to this instance. NodeTraversal.traverse( compiler, fnNode, new MakeDeclaredNamesUnique( new InlineRenamer( idSupplier, "inline_", isCallInLoop))); // Make label names unique to this instance.
 if (li.referenced) {
 } else if (offsetLocal > 0) {
 if (locale != null) { key = new Pair(key, locale);
 FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key);
 if (locale == null) { locale = Locale.getDefault(); }
 if (locale != null) { key = new Pair(key, locale);
 FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key);
 if (locale == null) { locale = Locale.getDefault(); }
 int idx = 1; while (count < index) { count += idx; ++idx; } --idx; indices[last] = idx;
 Partial newPartial = new Partial(iChronology, newTypes, newValues);
 if (field == Calendar.SECOND) { done = true; }
 if (field == Calendar.MINUTE) { done = true; }
 if (nextCfgNode == fallThrough) {
 return realMethod.invoke(mock, rawArguments);
 this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());
 return optimize(f, goal, min, max, 0);
 final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min); final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min); optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));
 return iZone.convertLocalToUTC(localInstant, false);
 return iZone.convertLocalToUTC(localInstant, false);
 return iZone.convertLocalToUTC(localInstant, false);
 return iZone.convertLocalToUTC(localInstant, false);
 return iZone.convertLocalToUTC(localInstant, false);
 long result = iZone.convertLocalToUTC(localInstant, false);
 return iZone.convertLocalToUTC(localInstant, false);
 int lhType = left.getType();
 int rhType = right.getType();
 return solve(f, min, yMin, max, yMax, initial, yInitial);
 return multiplyFast(x);
 visitParameterList(t, n, functionType);
 this.parent = parent;  // only named functions may be hoisted. this.isHoisted = NodeUtil.isHoistedFunctionDeclaration(root);
 return true;
 return cs1.equals(cs2);
 return (Double.isNaN(x) && Double.isNaN(y)) || x == y;
 switch (node.getType()) {
 default: throw new IllegalArgumentException("Node cannot be refined. \n" + node.toStringTree());
 return new BigDecimal(str);
 if (str.startsWith("--")) { return null; }
 this.maybeAliased = !assignNode.getParent().isExprResult();
 if (assignedToUnknownValue && hasPropertyAssign) {
 this.durationMillis = durationMillis;
 if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
 break;
 if (info != null) {
 switch (parent.getType()) {
 if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) { isSet = true; type = Name.Type.OTHER; } } } name = n.getString();
 return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();
 return m.containsKey(value);
 if (fnType != null) {
 final Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; }
 final Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; }
 ++iter;
 if (checker.converged(iter, previous, current)) {
 if (iteration > 0) {
 ++iteration;
 ++iter;
 if (checker.converged(iter, previous, current)) {
 if (iter % n == 0 ||
 iterations = new Incrementor(0, new MaxIterCallback());
 ++iter;
 converged = checker.converged(iter, previous, current);
 ++iter;
 stop = checker.converged(iter, previous, current);
 final RealMatrix arz = randn1(dimension, lambda);
 setResult(yMin, 0);
 setResult(yMax, 0);
 if (isClassOrEnum) { return true; } return (type == Type.FUNCTION || aliasingGets == 0) && (parent == null || parent.canCollapseUnannotatedChildNames());
 if (parseDocumentation) {
 while (n.next != child) {
 } else if (isVar) { Node grandparent = parent.getParent(); Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null; Node varNode = parent;
 if (value != null || v.getJSDocInfo() != null) {
 grandparent.addChildBefore(newDecl, varNode);
 if (index < this.keys.size()) {
 return;
 rowData.removeValue(columnKey);
 if (className == null) {
 int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
 return out;
 if (!Character.isDigit(lastChar)) {
 return false;
 nodes.add(new Node(Token.TRUE));
 if (parent != null && parent.getType() == Token.ASSIGN) {
 if ((Boolean) tree.getAttribute()) {
 return offsetAdjusted;
 if (row >= 0) {
 return rowData.getObject(columnKey);
 rowData.removeValue(columnKey);
 removeRow(index);
 return len > 0;
 return foundDigit && !hasExp;
 if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) { registerMismatch(rightType, leftType, null); } else {
 if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) { registerMismatch(rightType, leftType, null); } else {
 return appendTo == null ? null : appendTo.append(QUOTE);
 cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);
 increasing = gb >= ga;
 registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));
 char[] buffer = new char[count];
 final char ch0 = str.charAt(0);
 final char ch1 = str.charAt(1); if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { throw new IllegalArgumentException("Invalid locale format: " + str); } if (len == 2) { return new Locale(str); } if (len < 5) { throw new IllegalArgumentException("Invalid locale format: " + str); } if (str.charAt(2) != '_') { throw new IllegalArgumentException("Invalid locale format: " + str); } final char ch3 = str.charAt(3); if (ch3 == '_') { return new Locale(str.substring(0, 2), "", str.substring(4)); } final char ch4 = str.charAt(4); if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { throw new IllegalArgumentException("Invalid locale format: " + str); } if (len == 5) { return new Locale(str.substring(0, 2), str.substring(3, 5)); } if (len < 7) { throw new IllegalArgumentException("Invalid locale format: " + str); } if (str.charAt(5) != '_') { throw new IllegalArgumentException("Invalid locale format: " + str); } return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
 String s = trimJsWhiteSpace(rawJsString);
 return TernaryValue.TRUE;
 chiSquare += residual * residual / residualsWeights[i];
 double criterion = 0; for (int i = 0; i < rows; ++i) { final double residual = residuals[i]; criterion += residual * residual * residualsWeights[i]; } return Math.sqrt(criterion / rows);
 classes[i] = array[i].getClass();
 if (constraintObj != null && constraintObj.isRecordType()) { ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined()); if (objType != null) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!objType.isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!objType.hasProperty(prop)) { typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType); } objType.defineInferredProperty(prop, typeToInfer, null); } } }
 mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();
 if (inferred) { // Determining declaration for #2 inferred = !(rhsValue != null && rhsValue.isFunction() && (info != null || !scope.isDeclared(qName, false)));
 parametersNode = paramBuilder.build();
 if (templateTypeName != null && !foundTemplateType) {
 yTmp[j] = y[j] + stepSize * sum;
 computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);
 yTmp[j] = y[j] + stepSize * sum;
 return NodeUtil.isFunctionExpression(n);
 result = lvalInt >>> rvalInt;
 return result;
 return result;
 return escapeJavaStyleString(str, false);
 escapeJavaStyleString(out, str, false);
 return escapeJavaStyleString(str, true);
 escapeJavaStyleString(out, str, true);
 private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) {
 escapeJavaStyleString(writer, str, escapeSingleQuotes);
 private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {
 out.write('\\');
 char c = str.charAt(i);
 if (c > 0x7F) {
 for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {
 Integer minRow = null; int minIndex = tableau.getWidth(); for (Integer row : minRatioPositions) { int i = tableau.getNumObjectiveFunctions(); for (; i < tableau.getWidth() - 1 && minRow != row; i++) { if (row == tableau.getBasicRow(i)) { if (i < minIndex) { minIndex = i; minRow = row; } } } } return minRow;
 if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
 return parseTypeName(token);
 if (zone.useDaylightTime()
 String param = params.getParameter(0);
 loop     = false;
 loop     = false;
 static float toJavaVersionInt(String version) {
 private boolean canInline() {
 switch (input.getType()) {
 return false;
 if (c.canInline()) {
 for (Var s : def.depends) {
 if (n.isName() && jsScope.isDeclared(n.getString(), true)) { Var dep = jsScope.getVar(n.getString()); def.depends.add(dep);
 (new NodeTraversal(compiler, this)).traverse(root);
 Iterator iterator = this.dataset.getKeys().iterator();
 state.setTotal(DatasetUtilities.calculatePieDatasetTotal( plot.getDataset()));
 node = node.getFirstChild();
 return this.domainAxes.indexOf(axis);
 int result = this.rangeAxes.indexOf(axis);
 DateTimeParserBucket bucket = new DateTimeParserBucket( instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);
 millis -= iOffset; } else { int offset = iZone.getOffsetFromLocal(millis); millis -= offset; if (offset != iZone.getOffset(millis)) { String message = "Illegal instant due to time zone offset transition (" + iZone + ')'; if (text != null) { message = "Cannot parse \"" + text + "\": " + message; } throw new IllegalArgumentException(message); } }  return millis;
 new NodeTraversal( compiler, new NormalizeStatements(compiler, assertOnChange)) .traverse(root);
 private void createSynthesizedExternVar(String varName) { Node nameNode = Node.newString(Token.NAME, varName);  // Mark the variable as constant if it matches the coding convention // for constant vars. // NOTE(nicksantos): honestly, i'm not sure how much this matters. // AFAIK, all people who use the CONST coding convention also // compile with undeclaredVars as errors. We have some test // cases for this configuration though, and it makes them happier. if (compiler.getCodingConvention().isConstant(varName)) { nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); }  getSynthesizedExternsRoot().addChildToBack( new Node(Token.VAR, nameNode)); varsToDeclareInExterns.remove(varName);
 return contains(str.toUpperCase(), searchStr.toUpperCase());
 int greater = replacementList[i].length() - searchList[i].length();
 return current;
 return current;
 return (Class) actual;
 if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType() || jsDoc.isOverride())) {
 if (lhs.getType() == Token.GETPROP && lhs.getLastChild().getString().equals("prototype")) { return false; } if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains(".prototype.")) {
 throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);
 return true;
 String[][] zoneStringsLoc = DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings(); String[] setLoc = null; for (String[] strings : zoneStringsLoc) { if (strings != null && strings.length == 5 && id.equals(strings[0])) { setLoc = strings;  byNameKeyCache.put(setLoc[2], new String[] {setLoc[2], setLoc[1]}); // need to handle case where summer and winter have the same // abbreviation, such as EST in Australia [1716305] // we handle this by appending "-Summer", cf ZoneInfoCompiler if (setLoc[2].equals(setLoc[4])) { byNameKeyCache.put(setLoc[4] + "-Summer", new String[] {setLoc[4], setLoc[3]}); } else { byNameKeyCache.put(setLoc[4], new String[] {setLoc[4], setLoc[3]}); } break;
 if (builder.length() > 0) { builder.append(' '); }
 int sum = 0;
 setMillis(type.getField(getChronology()).add(getMillis(), amount));
 setMillis(getChronology().days().add(getMillis(), days));
 setMillis(getChronology().hours().add(getMillis(), hours));
 setMillis(getChronology().millis().add(getMillis(), millis));
 setMillis(getChronology().minutes().add(getMillis(), minutes));
 setMillis(getChronology().months().add(getMillis(), months));
 setMillis(getChronology().seconds().add(getMillis(), seconds));
 setMillis(getChronology().weeks().add(getMillis(), weeks));
 setMillis(getChronology().weekyears().add(getMillis(), weekyears));
 setMillis(getChronology().years().add(getMillis(), years));
 int indexOfDot = namespace.indexOf('.');
 return details.getCause().getMessage();
 throw new NoInteractionsWanted(join( "No interactions wanted here:", new LocationImpl(), "But found this interaction on mock '" + undesired.getMock() + "':", undesired.getLocation(), scenario ));
 throw new VerificationInOrderFailure(join( "No interactions wanted here:", new LocationImpl(), "But found this interaction on mock '" + undesired.getMock() + "':", undesired.getLocation() ));
 Builder x = OriginalMapping.newBuilder() .setOriginalFile(sources[entry.getSourceFileId()]) .setLineNumber(entry.getSourceLine()) .setColumnPosition(entry.getSourceColumn());
 generator.addMapping( sourceFile, originalName, new FilePosition(node.getLineno(), node.getCharno()), outputStartPosition, outputEndPosition);
 return optimizer.getFunctionValue();
 return optimizer.getResult();
 if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); }
 if (target != null) {
 switch (val.getType()) {
 return false;
 isEquals = lhs.equals(rhs);
 String propName = parent.getLastChild().getString(); if (!validProperties.contains(propName)) { if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {
 return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();
 if (!maybeModifiedArguments && !staleVars.contains(v) && referenceInfo.isWellDefined() && referenceInfo.isAssignedOnceInLifetime()) {
 break;
 for (int index = 0; index < len; index++) {
 return len > 0 && s.charAt(0) != '0';
 Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));
 return res;
 return " title=\"" + toolTipText + "\" alt=\"\"";
 calendar = (Calendar) calendar.clone();
 if (o1 == null || o2 == null) {
 try { return 0.5 * (1.0 + Erf.erf((dev) / (standardDeviation * FastMath.sqrt(2.0)))); } catch (MaxIterationsExceededException ex) { if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38 return 0; } else if (x > (mean + 20 * standardDeviation)) { return 1; } else { throw ex; } }
 str.getChars(0, strLen, buffer, size);
 return 0.5 * exp(x);
 if (x < -20) {
 return 0.5 * exp(-x);
 return 0.5 * exp(x);
 if (x < -20) {
 return -0.5 * exp(-x);
 int len = Character.codePointCount(input, 0, input.length());
 else { //          // contract with translators is that they have to understand codepoints //          // and they just took care of a surrogate pair for (int pt = 0; pt < consumed; pt++) { if (pos < len - 2) { pos += Character.charCount(Character.codePointAt(input, pos)); } else { pos++; } } pos--; } pos++;
 if (!NodeUtil.isImmutableValue(right)) {
 String joinString = (right == null) ? "," : NodeUtil.getStringValue(right);
 return multiply(100).doubleValue();
 int[] values = chrono.get(zeroInstance, chrono.set(start, 0L), chrono.set(end, 0L));
 out.write(entityValue);
 throw new UnsupportedOperationException();
 return StringDescription.toString(m).equals(arg.toString());
 incrementIterationsCounter();
 qTy(residuals);
 sum += jacobian[i][pj] * residuals[i];
 return current;
 determineLMParameter(oldRes, delta, diag, work1, work2, work3);
 current = new VectorialPointValuePair(point, objective);
 } else { if (checker.converged(getIterations(), previous, current)) { return current; }
 if (c == 0) {
 if (c == 0) {
 if (c == 0) {
 mockInstance = classInstantiator.instantiate(mockedProxyType);
 throw new MockitoException(join( "ClassCastException occurred while creating the mockito mock :", "  class to mock : " + describeClass(mockedProxyType), "  created class : " + describeClass(settings.getTypeToMock()), "  proxy instance class : " + describeClass(mockInstance), "  instance creation by : " + classInstantiator.getClass().getSimpleName(), "", "You might experience classloading issues, please ask the mockito mailing-list.", "" ),cce);
 return true;
 return chromosomes.iterator();
 if (!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); } if (!Double.isNaN(uvalue)) { maximum = Math.max(maximum, uvalue); }
 if (!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); } if (!Double.isNaN(uvalue)) { maximum = Math.max(maximum, uvalue); }
 if (n.isExprResult()) {
 if (parent.getType() == Token.COMMA) { if (isResultUsed) { return; } if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); if (ancestorType == Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; else break; } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) { return; } } if (
 if (tokenLen >= 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen); } else { rule = TwoDigitYearField.INSTANCE;
 System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
 Collection c = r.getAnnotations();
 if (options.dependencyOptions.needsManagement() && options.closurePass) {
 return null;
 targetY = -REDUCTION_FACTOR * yB;
 targetY = -REDUCTION_FACTOR * yA;
 Node constructor = n.getFirstChild(); scope = traverse(constructor, scope);
 n.setJSType(type); for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) { scope = traverse(arg, scope); }
 return 1;
 return;
 error(DiagnosticType.error("JSC_DIVIDE_BY_0_ERROR", "Divide by 0"), right);
 error(DiagnosticType.error("JSC_DIVIDE_BY_0_ERROR", "Divide by 0"), right);
 int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound) * 255.0);
 if (divisor.getReal() == 0.0 && divisor.getImaginary() == 0.0) {
 return NaN;
 return NaN;
 if (entityValue == -1) {
 buf.append((char) (entityValue));
 case 'x' : { entityValue = Integer.parseInt(entityContent.substring(2), 16);
 if (entityValue == -1) {
 writer.write(entityValue);
 if (excerpt.equals(LINE) && 0 <= charno && charno < sourceExcerpt.length()) {
 if (sign >= 0) {
 throw new IllegalArgumentException ("Function values at endpoints do not have different signs." + "  Endpoints: [" + min + "," + max + "]" + "  Values: [" + yMin + "," + yMax + "]"); } else { // solve using only the first endpoint as initial guess ret = solve(min, yMin, max, yMax, min, yMin); // either min or max is a root }  return ret;
 if (excerpt.equals(LINE) && 0 <= charno && charno < sourceExcerpt.length()) {
 if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && // if LHS has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are some circumstances where we can // proceed even if there are side effects... !mayEffectMutableState(lhs)) {
 token = eatTokensUntilEOL();
 return reportGenericTypeSyntaxWarning();
 return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");
 instant = gregorianToJulian(instant);
 instant = gregorianToJulian(instant);
 ArrayList<GJChronology> chronos = cCache.get(zone); if (chronos == null) { chronos = new ArrayList<GJChronology>(2); cCache.put(zone, chronos); } else { for (int i = chronos.size(); --i >= 0;) { chrono = chronos.get(i); if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() && cutoverInstant.equals(chrono.getGregorianCutover())) {  return chrono; } } } if (zone == DateTimeZone.UTC) { chrono = new GJChronology (JulianChronology.getInstance(zone, minDaysInFirstWeek), GregorianChronology.getInstance(zone, minDaysInFirstWeek), cutoverInstant); } else { chrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek); chrono = new GJChronology (ZonedChronology.getInstance(chrono, zone), chrono.iJulianChronology, chrono.iGregorianChronology, chrono.iCutoverInstant);
 char ch4 = str.charAt(4);
 if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {
 if (a0 > overflow) {
 if ((p2 > overflow) || (q2 > overflow)) {
 return fit(new Gaussian.Parametric(), guess);
 return next;
 if (n.getParent() == null) { List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges(); if (outEdges.size() == 1) { return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue()); } }
 case Token.BLOCK: if (n.hasChildren()) { Node first = n.getFirstChild(); return tryRemoveUnconditionalBranching(first); } else { return tryRemoveUnconditionalBranching(ControlFlowAnalysis.computeFollowNode(n)); }
 Node fallThrough = tryRemoveUnconditionalBranching(computeFollowing(n));
 if (compiler != null && !compiler.hasRegExpGlobalReferences()) { if (nameNode.getFirstChild().getType() == Token.REGEXP && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) { return false; } else if (nameNode.getFirstChild().getType() == Token.STRING && STRING_REGEXP_METHODS.contains( nameNode.getLastChild().getString())) { Node param = nameNode.getNext(); if (param != null && (param.getType() == Token.STRING || param.getType() == Token.REGEXP)) return false; } } }  return true;
 return assign;
 Node node = newNode(type, operand);
 Node nameNode = NodeUtil.newName( compiler.getCodingConvention(), alias, gramps.getFirstChild(), refName.fullName());
 if (type != Type.FUNCTION && aliasingGets > 0) {
 case '\0': sb.append("\\0"); break;
 copy.data = new java.util.ArrayList();
 if (this.data.size() > 0) {
 return (T) reportMatcher(Any.ANY).returnFor(clazz);
 return (T) anyObject();
 return reportMatcher(Any.ANY).returnFalse();
 return reportMatcher(Any.ANY).returnZero();
 return reportMatcher(Any.ANY).returnChar();
 return reportMatcher(Any.ANY).returnList();
 return (Collection) reportMatcher(Any.ANY).returnList();
 return reportMatcher(Any.ANY).returnZero();
 return reportMatcher(Any.ANY).returnZero();
 return reportMatcher(Any.ANY).returnZero();
 return reportMatcher(Any.ANY).returnList();
 return (List) reportMatcher(Any.ANY).returnList();
 return reportMatcher(Any.ANY).returnZero();
 return reportMatcher(Any.ANY).returnMap();
 return reportMatcher(Any.ANY).returnMap();
 return (T) reportMatcher(Any.ANY).returnNull();
 return reportMatcher(Any.ANY).returnSet();
 return (Set) reportMatcher(Any.ANY).returnSet();
 return reportMatcher(Any.ANY).returnZero();
 return reportMatcher(Any.ANY).returnString();
 boolean removed = markers.remove(marker);
 boolean removed = markers.remove(marker);
 boolean removed = markers.remove(marker);
 boolean removed = markers.remove(marker);
 if (name.globalSets == 1 && name.localSets == 0 &&
 switch (n.getType()) {
 return TernaryValue.FALSE;
 final double[] prodHigh = new double[len];
 if (endIndex < 0) {
 return getRegistry().contains(new IDKey(value));
 getRegistry().add(new IDKey(value));
 getRegistry().remove(new IDKey(value));
 if (minutesOffset < 0 || minutesOffset > 59) {
 int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);
 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);
 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);
 String id = printOffset(millisOffset);
 switch (method) {
 default:
 if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),
 return decode(x);
 private boolean hasExceptionHandler(Node cfgNode) { return false; }
 continue;
 Node childVal = child.getFirstChild();
 if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) { if (row == null) { row = i; } else { return null; }
 if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {
 String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));
 if (filename.indexOf(filenamePrefix) == 0) {
 RectangleConstraint c4 = new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h[2], null, LengthConstraintType.FIXED);
 } else if (n.getJSType() != null && parent.isAssign()) { return;
 long result = Math.round(factorialDouble(n)); if (result == Long.MAX_VALUE) {
 return Math.floor(Math.exp(factorialLog(n)) + 0.5);
 for (int i = 2; i <= n; i++) {
 if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {
 if (searchChars[j + 1] == cs.charAt(i + 1)) {
 return false;
 return i;
 continue outer;
 if (searchChars.indexOf(ch) < 0) {
 public void atan2(final double[] y, final int yOffset,
 }
 if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {
 final int hexDigits = str.length() - pfxLen; if (hexDigits > 16) { // too many for Long
 if (hexDigits > 8) { // too many for an int
 days += 31;
 months -= 1;
 milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds); seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds); minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes); hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours); days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days); months -= reduceAndCorrect(start, end, Calendar.MONTH, months); years -= reduceAndCorrect(start, end, Calendar.YEAR, years);
 static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) { end.add( field, -1 * difference ); int endValue = end.get(field); int startValue = start.get(field); if (endValue < startValue) { int newdiff = startValue - endValue; end.add( field, newdiff ); return newdiff; } else { return 0; } }
 currentEvent.stepAccepted(eventT, eventY); isLastStep = currentEvent.stop();
 for (final EventState remaining : occuringEvents) { remaining.stepAccepted(eventT, eventY); }
 boolean needReset = currentEvent.reset(eventT, eventY);
 for (final EventState remaining : occuringEvents) { remaining.stepAccepted(eventT, eventY); }
 double minval = Double.NaN; if (item.getMinOutlier() != null) { minval = item.getMinOutlier().doubleValue(); } double maxval = Double.NaN; if (item.getMaxOutlier() != null) { maxval = item.getMaxOutlier().doubleValue(); }  if (Double.isNaN(this.maximumRangeValue)) { this.maximumRangeValue = maxval; this.maximumRangeValueRow = r; this.maximumRangeValueColumn = c; } else if (maxval > this.maximumRangeValue) { this.maximumRangeValue = maxval; this.maximumRangeValueRow = r; this.maximumRangeValueColumn = c; }  if (Double.isNaN(this.minimumRangeValue)) { this.minimumRangeValue = minval; this.minimumRangeValueRow = r; this.minimumRangeValueColumn = c; } else if (minval < this.minimumRangeValue) { this.minimumRangeValue = minval; this.minimumRangeValueRow = r; this.minimumRangeValueColumn = c; }
 this.minimumRangeValue = Double.NaN; this.maximumRangeValue = Double.NaN;
 if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {
 int start = getNumObjectiveFunctions();
 Integer negativeVarBasicRow = getBasicRow(getNegativeDecisionVariableOffset());
 Integer basicRow = getBasicRow(getNumObjectiveFunctions() + i);
 JsName name = getName(ns.name, false); if (name != null) {
 currentPropertyNames = implicitProto.getOwnPropertyNames();
 if (options.dependencyOptions.needsManagement() && !options.skipAllPasses && options.closurePass) {
 boolean hasSideEffects = false; if (block.hasChildren()) { Preconditions.checkState(block.hasOneChild()); Node stmt = block.getFirstChild(); if (stmt.isReturn()) { hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler); } }
 if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { return CanInlineResult.NO; }
 if (DateTimeUtils.isContiguous(partial)) {
 if ( source.substring(startIndex, endIndex).compareTo( getImaginaryCharacter()) != 0) {
 sb.append(getPropertyType(property).toString());
 if (i == MAX_PRETTY_PRINTED_PROPERTIES) {
 return "{...}";
 for (int position = indexOfVararg; position < matchers.size(); position++) { Matcher m = matchers.get(position); if (m instanceof CapturesArguments) { ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);
 long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime();
 throw new PathIsExploredException(); // XXX
 final int iptMinus1 = ipt; final int jptMinus1 = jpt;
 throw new PathIsExploredException(); // XXX
 if (str.startsWith("0x") || str.startsWith("-0x")) {
 if (!mockitoCore.isTypeMockable(rawType)) {
 container.addAnswer(new Answer<Object>() {
 return mockSettings
 .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));
 description.appendText(wanted.toString());
 if (flags.process_closure_primitives) { options.closurePass = true; }  initOptionsFromFlags(options);
 sb.append(joinString);
 sb.append(NodeUtil.getStringValue(elem));
 foldedSize += sb.length() + 2; arrayFoldedChildren.add(Node.newString(sb.toString()));
 if (sb.length() > 0) {
 final BigDecimal[] out = new BigDecimal[v.length];
 final double[] out = new double[v.length];
 switch (c) {
 if (outputCharsetEncoder != null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { // Unicode-escape the character. appendHexJavaScriptRepresentation(sb, c); } } else { // No charsetEncoder provided - pass straight latin characters // through, and escape the rest.  Doing the explicit character // check is measurably faster than using the CharsetEncoder. if (c > 0x1f && c <= 0x7f) { sb.append(c); } else { // Other characters can be misinterpreted by some js parsers, // or perhaps mangled by proxies along the way, // so we play it safe and unicode escape them. appendHexJavaScriptRepresentation(sb, c);
 if (MAKE_LOCAL_NAMES_UNIQUE) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique(); NodeTraversal t = new NodeTraversal(compiler, renamer); t.traverseRoots(externs, root); } removeDuplicateDeclarations(root);
 double ret;
 ret = d / (d - 2.0);
 if (expPos < decPos) {
 mant = str.substring(0, expPos);
 field.set(testClass, Mockito.spy(instance));
 if (parent.isVar()) { if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {
 report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
 if (!(meanImpl instanceof Mean)) {
 if (!(varianceImpl instanceof Variance)) {
 if (!(geoMeanImpl instanceof GeometricMean)) {
 // compute the intersection on infinite line
 Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));
 Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));
 
 final int cols = problem.getAllParameters().length;
 int p = problem.getAllParameters().length;
 double[] errors = new double[problem.getAllParameters().length];
 if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); }
 if (isNaN) {
 double imaginary2 = 2.0 * imaginary;
 if (isNaN) {
 double real2 = 2.0 * real;
 new FieldSetter(fieldInstance, field).set(matchingMock);
 default: // Other op force a local value: //  x = '' + g (x is now an local string) //  x -= g (x is now an local number) if (isAssignmentOp(value) || isSimpleOperator(value) || isImmutableValue(value)) { return true; }  throw new IllegalStateException( "Unexpected expression node" + value + "\n parent:" + value.getParent());
 switch (n.getType()) {
 default: return false; } }
 if (c > 0x1f && c <= 0x7f) {
 sep = sep.finish(f.getPrinter(), f.getParser());
 if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {
 PathIterator iterator2 = p1.getPathIterator(null);
 return false;
 return true;
 defineObjectLiteral(n);
 return 0.5 * (1.0 + Erf.erf((x - mean) /
 (standardDeviation * Math.sqrt(2.0))));
 eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);
 for (int i = 0; i < p - 1; ++i) {
 ei1 = eData[i + 1];
 wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];
 eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);
 for (int i = 0; i < p - 1; ++i) {
 wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];
 return invocation.getMethod().getName() + "()";
 throw new SmartNullPointerException(join( "You have a NullPointerException here:", new Location(), "Because this method was *not* stubbed correctly:", location, "" ));
 new Reporter().smartNullPointerException(location);
 if ((long) x == x) {
 return getMock(invocation);
 return recordDeepStubMock(invocation, container);
 Class<?> clz = invocation.getMethod().getReturnType(); final Object mock = org.mockito.Mockito.mock(clz, this);
 if (fa * fb >= 0.0 ) {
 return var != null && var.getScope() == s && !blacklistedVars.contains(var);
 defineSlot(astParameter, functionNode, jsDocParameter.getJSType(), true);
 return reportMatcher(new Equals(value)).<T>returnNull();
 return reportMatcher(new InstanceOf(clazz)).<T>returnNull();
 return reportMatcher(new Same(value)).<T>returnNull();
 return best(current, previous, isMinim);
 return best(current, previous, isMinim);
 return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;
 ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));
 switch (n.getType()) {
 for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
 return foundType;
 String name = child.getString();
 if (index >= 0 && !this.allowDuplicateXValues) {
 addToSetIfLocal(lhs, kill);
 addToSetIfLocal(lhs, gen);
 StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);
 StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());
 double value = meanValue.doubleValue();
 double valueDelta = dataset.getStdDevValue(row, column).doubleValue(); double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() + valueDelta, dataArea, yAxisLocation);
 double value = meanValue.doubleValue();
 double valueDelta = dataset.getStdDevValue(row, column).doubleValue(); double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() + valueDelta, dataArea, yAxisLocation);
 if (cls.getTypeParameters().length > 0 || toClass.equals(cls)) {
 for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) { Type toTypeArg = entry.getValue(); Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());
 final Line reverted = new Line(zero, zero.subtract(direction));
 if (map == null) { // Backwards compatibility with TimeZone. map = new HashMap<String, String>(); map.put("GMT", "UTC"); map.put("MIT", "Pacific/Apia"); map.put("HST", "Pacific/Honolulu");  // JDK 1.1 compatible map.put("AST", "America/Anchorage"); map.put("PST", "America/Los_Angeles"); map.put("MST", "America/Denver");  // JDK 1.1 compatible map.put("PNT", "America/Phoenix"); map.put("CST", "America/Chicago"); map.put("EST", "America/New_York");  // JDK 1.1 compatible map.put("IET", "America/Indianapolis"); map.put("PRT", "America/Puerto_Rico"); map.put("CNT", "America/St_Johns"); map.put("AGT", "America/Buenos_Aires"); map.put("BET", "America/Sao_Paulo"); map.put("WET", "Europe/London"); map.put("ECT", "Europe/Paris"); map.put("ART", "Africa/Cairo"); map.put("CAT", "Africa/Harare"); map.put("EET", "Europe/Bucharest"); map.put("EAT", "Africa/Addis_Ababa"); map.put("MET", "Asia/Tehran"); map.put("NET", "Asia/Yerevan"); map.put("PLT", "Asia/Karachi"); map.put("IST", "Asia/Calcutta"); map.put("BST", "Asia/Dhaka"); map.put("VST", "Asia/Saigon"); map.put("CTT", "Asia/Shanghai"); map.put("JST", "Asia/Tokyo"); map.put("ACT", "Australia/Darwin"); map.put("AET", "Australia/Sydney"); map.put("SST", "Pacific/Guadalcanal"); map.put("NST", "Pacific/Auckland"); cZoneIdConversion = map; } return map.get(id);
 if (minutesOffset < 0 || minutesOffset > 59) {
 if (hoursInMinutes < 0) { minutesOffset = hoursInMinutes - minutesOffset; } else { minutesOffset = hoursInMinutes + minutesOffset; } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);
 setMaxEvaluations(Integer.MAX_VALUE); setMaximalIterationCount(100); setAbsoluteAccuracy(1E-10); setRelativeAccuracy(1.0e-14);
 throw new UnsupportedOperationException(); }
 double fx = computeObjectiveValue(f, x); if (goalType == GoalType.MAXIMIZE) {
 int count = 0; while (count < maximalIterationCount) {
 double fu = computeObjectiveValue(f, u); if (goalType == GoalType.MAXIMIZE) {
 setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count); return x; } ++count; } throw new MaxIterationsExceededException(maximalIterationCount);
 return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);
 if (comment.getValue().indexOf("/* @") != -1 || comment.getValue().indexOf("\n * @") != -1) {
 long result = Math.round(binomialCoefficientDouble(n, k)); if (result == Long.MAX_VALUE) { throw new ArithmeticException( "result too large to represent in a long integer"); } // Use symmetry for large k  // We use the formula // (n choose k) = n! / (n-k)! / k! // (n choose k) == ((n-k+1)*...*n) / (1*...*k) // which could be written // (n choose k) == (n-1 choose k-1) * n / k // For n <= 61, the naive implementation cannot overflow. // For n > 61 but n <= 66, the result cannot overflow, // but we must take care not to overflow intermediate values. // We know that (result * i) is divisible by j, // but (result * i) may overflow, so we split j: // Filter out the gcd, d, so j/d and i/d are integer. // result is divisible by (j/d) because (j/d) // is relative prime to (i/d) and is a divisor of // result * (i/d). // For n > 66, a result overflow might occur, so we check // the multiplication, taking care to not overflow // unnecessary. return result;
 return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5);
 for (int i = k + 1; i <= n; i++) {
 a = FastMath.sqrt(c1 / c2);
 return -val1;
 swap[r] = r; for (int i = r + 1; i < order; ++i) { int ii  = index[i]; int isi = index[swap[i]]; if (c[ii][ii] > c[isi][isi]) { swap[r] = i; } }   // swap elements if (swap[r] != r) { int tmp = index[r]; index[r] = index[swap[r]]; index[swap[r]] = tmp; }
 c[ii][ii] -= e * e;
 long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR); long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR); if (instantBefore == instantAfter) {
 long local = convertUTCToLocal(instant); return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);
 Node function = fnScope.getRootNode();
 int j = 4 * n - 1;
 return super.equals(obj);
 final int len = str.length();
 } else { contextualActualTypeParameters.put(typeParameter, actualTypeArgument);
 return false;
 if (parent != null && parent.getType() == Token.ASSIGN) {
 while (arguments.hasNext() && parameters.hasNext()) {
 parameter = parameters.next();
 Context rhsContext = Context.OTHER;
 if (detectImplicitPrototypeCycle()) {
 if (detectImplicitPrototypeCycle()) {
 if(currentStrategy.addRegex(this, regex)) {
 recordDepScope(recordNode, ns);
 return new Fraction(num.intValue(), 1);
 int n = num.intValue();
 Preconditions.checkState(body.getNext() == null &&
 body.isBlock());
 parseDirectives(bodyNode);
 if (options.checkGlobalThisLevel.isOn()) {
 throw new FractionConversionException(value, p2, q2);
 throw new FractionConversionException(value, p2, q2);
 String result = stream.getRemainingJSDocLine();
 return result;
 addValue((Comparable<?>) v);
 final double[] scale; if (vecAbsoluteTolerance == null) { scale = new double[y0.length]; java.util.Arrays.fill(scale, scalAbsoluteTolerance); } else { scale = vecAbsoluteTolerance; }
 int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);
 if (constraintObj.isRecordType()) {
 out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));
 Object clone = createCopy(0, getItemCount() - 1);
 String code = toSource(root, sourceMap);
 builder.setTagAsStrict( options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);
 return VariableLiveness.KILL;
 EntityCollection entities = owner.getEntityCollection();
 if (provided != null) {
 if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP ) {
 instant = iGregorianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
 long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono); int defaultYear = chrono.year().get(instantLocal);
 return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * getExponentTerm(vals);
 pos += Character.charCount(Character.codePointAt(input, pos));
 switch (ch) {
 out.write(ch);
 resetOccurred = false;
 return eventT;
 return eventT;
 return isZero ? NaN : INF;
 return isZero ? NaN : INF;
 for (int i = 0; i < weights.length; i++) {
 Object obj = v;
 catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {
 double nOd = doubleValue();
 double dOn = object.doubleValue();
 if (end - start > 2) {
 for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) {
 if ((work[i + 3] <= TOLERANCE_2 * work[i]) &&
 return NaN;
 boolean wasWhite= false;
 if(Character.isWhitespace(c)) { if(!wasWhite) { wasWhite= true; regex.append("\\s*+"); } continue; } wasWhite= false;
 return canMoveAggressively(value) || canMoveModerately(initialization, reference);
 bucket.setZone(DateTimeZone.forID(id)); return position + id.length();
 return ~position;
 Iterator iter = res.entries.iterator();
 Iterator iter = res.entries.iterator();
 Iterator iter = res.entries.iterator();
 Iterator iter = res.entries.iterator();
 public void validate(Answer<?> answer, Invocation invocation) { if (answer instanceof ThrowsException) { validateException((ThrowsException) answer, invocation); }  if (answer instanceof Returns) { validateReturnValue((Returns) answer, invocation); }  if (answer instanceof DoesNothing) { validateDoNothing((DoesNothing) answer, invocation); }  }
 sum = Math.max(sum, 4);
 buf.append('.'); FormatUtils.appendPaddedInteger(buf, dp, 3);
 return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());
 return solve(min, max);
 if (declarationRoot.getType() == Token.FUNCTION) { for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) { String name = c.getString(); renamer.addDeclaredName(name); } Node functionBody = declarationRoot.getLastChild(); findDeclaredNames(functionBody, null, renamer); }  else
 switch (n.getType()) { case Token.FUNCTION:
 if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) { throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]); }
 double cN = a * hPrev + b * p0; double q2 = a * q1 + b * dPrev; if (Double.isInfinite(cN) || Double.isInfinite(q2)) { double scaleFactor = 1d; double lastScaleFactor = 1d; final int maxPower = 5; final double scale = FastMath.max(a,b); if (scale <= 0) {  // Can't scale throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x); } for (int i = 0; i < maxPower; i++) { lastScaleFactor = scaleFactor; scaleFactor *= scale; if (a != 0.0 && a > b) { cN = hPrev / lastScaleFactor + (b / scaleFactor * p0); q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev); } else if (b != 0) { cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor; q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor; } if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) { break; } } }  final double deltaN = cN / q2 / cPrev; hN = cPrev * deltaN;
 dPrev = q1; cPrev = cN / q2; p0 = hPrev; hPrev = cN; q1 = q2;
 this.lookupMap.put(seq[0], seq[1]);
 final CharSequence result = lookupMap.get(subSeq);
 return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
 return iValue - ((ValuedEnum) other).iValue;
 this.dataset = dataset;
 return new VectorialPointValuePair(point, objective);
 return new VectorialPointValuePair(point, objective);
 return;
 if (lessThan(getZero())) {
 append(newcode);
 dev = ((double) observed[i] - expected[i]); sumSq += dev * dev / expected[i];
 if (parent.getType() == Token.COMMA) { Node gramps = parent.getParent(); if (gramps.isCall() && parent == gramps.getFirstChild()) { if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && "eval".equals(n.getNext().getString())) { return; }
 if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); if (ancestorType == Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; else break; } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) { } else { return; }
 if (n.isQualifiedName() && n.getJSDocInfo() != null) { return; } else if (n.isExprResult()) { return; }
 case 3: {
 }
 Node catchBody = block(catchNode).copyInformationFrom(catchNode);
 Preconditions.checkState(tryBody.isLabelName()); Preconditions.checkState(finallyBody.isLabelName());
 Node cArg = callNode.getFirstChild().getNext();
 if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount( block, fnParam.getString()) > 1) {
 if (scopeToDeclareIn.isDeclared(variableName, false)) {
 return (Math.abs(u) + Math.abs(v));
 return lcm;
 if (upper == -1 || upper > str.length()) {
 final int n1n2prod = n1 * n2;
 return withOuterClass(cls);
 private <T> T withOuterClass(Class<T> cls) {
 Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass()); return c.newInstance(outerClassInstance);
 if (!NodeUtil.isGet(first)) {
 Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnType, n);
 return m1.equals(m2);
 return NodeUtil.isExpressionNode(maybeExpr);
 name = new Name();
 return getCumPct((Comparable<?>) v);
 return sumYY - sumXY * sumXY / sumXX;
 traverse(c);
 if (u * v == 0) {
 typeReference.setString(aliasName);
 aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex)));
 if (value != null) { Node addition = IR.add( IR.string("").srcref(callTarget), value.detachFromParent());
