rank: 1
score: 99.79873657226562
patch: ++ iter ;
rank: 1
score: 99.58700125558036
patch: ++ iter ; ++ iter ;
rank: 1
score: 99.48234340122768
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current ;
rank: 1
score: 99.46799603630515
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 1
score: 99.42527142693015
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current ;
rank: 1
score: 99.42368727463942
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 1
score: 99.41145833333333
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 2
score: 99.46651204427083
patch: while ( true ) {
rank: 2
score: 99.4091796875
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 2
score: 99.40071105957031
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 2
score: 99.38168334960938
patch: int CaMeL Value = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 2
score: 99.34236907958984
patch: ++ iter ; ++ iter ; ;
rank: 2
score: 99.24053083147321
patch: else { ++ iter ; }
rank: 3
score: 99.43648274739583
patch: weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 3
score: 99.42718036358173
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = current ;
rank: 3
score: 99.39181315104166
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 3
score: 99.36724853515625
patch: ++ iter ; ; ++ iter ;
rank: 3
score: 99.36018640854779
patch: qtf = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 3
score: 99.25195990668402
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , ;
rank: 3
score: 99.11827674278847
patch: if ( ! iter . is CaMeL Empty ( ) ) {
rank: 3
score: 99.0870361328125
patch: ++ iter ; if ++ iter ;
rank: 4
score: 99.36126349954044
patch: boolean first CaMeL Iteration = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 4
score: 99.36092529296874
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair
rank: 4
score: 99.36050415039062
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 4
score: 99.24443901909723
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ;
rank: 4
score: 99.07838439941406
patch: ++ iter ; while ( true )
rank: 4
score: 99.06431579589844
patch: ++ iter ; } ++ iter ;
rank: 5
score: 99.34913465711806
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 5
score: 99.34558823529412
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = null ;
rank: 5
score: 99.32737821691177
patch: Convergence CaMeL Checker ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 5
score: 99.3247299194336
patch: checker = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 5
score: 99.27145385742188
patch: ++ iter ; ++ iter ; ++ iter ;
rank: 5
score: 99.2437744140625
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( ;
rank: 5
score: 99.1861572265625
patch: ++ iter ; while ++ iter ;
rank: 5
score: 99.07344563802083
patch: if ( ! iter . is CaMeL Empty ( ) )
rank: 5
score: 99.05965169270833
patch: else { ++ iter ;
rank: 6
score: 99.38446599786931
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current ;
rank: 6
score: 99.3365249633789
patch: compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 6
score: 99.32356770833333
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ) ;
rank: 6
score: 99.32235378689236
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 6
score: 99.26563262939453
patch: ++ iter ; ++ iter ; }
rank: 6
score: 99.2156005859375
patch: Point CaMeL Vector CaMeL Value CaMeL Pair current = new Point CaMeL Vector CaMeL Value CaMeL Pair ( ;
rank: 6
score: 99.06432088216145
patch: if ( ! iter . is CaMeL Empty ( ) ;
rank: 6
score: 99.04259490966797
patch: return iter ; } ++ iter ;
rank: 7
score: 99.35840521918402
patch: weighted CaMeL Jacobian = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 7
score: 99.32114771792763
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current CaMeL Point ;
rank: 7
score: 99.31890190972223
patch: Convergence CaMeL Checker = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 7
score: 99.30731201171875
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ; }
rank: 7
score: 99.302978515625
patch: found = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 7
score: 99.20994567871094
patch: ++ iter ; ++ ++ iter ;
rank: 7
score: 99.20815142463235
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ;
rank: 7
score: 99.05034044053819
patch: ++ iter ; while ( true ) {
rank: 8
score: 99.35654994419643
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = null ;
rank: 8
score: 99.32028037623355
patch: boolean first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 8
score: 99.29603576660156
patch: tmp = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 8
score: 99.19501604352679
patch: ++ iter * / * /
rank: 8
score: 99.12124294704861
patch: ++ iter ; try ; ++ iter ;
rank: 8
score: 99.11529541015625
patch: ++ ++ iter ; ++ iter ;
rank: 8
score: 99.0371805826823
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ; }
rank: 8
score: 99.01278686523438
patch: if ( iter != null ) {
rank: 9
score: 99.35646750710227
patch: weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 9
score: 99.31696633731617
patch: return compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 9
score: 99.31377210115132
patch: qtf = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 9
score: 99.30146135602679
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair ++ ;
rank: 9
score: 99.27063598632813
patch: this . weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 9
score: 99.17809295654297
patch: ++ iter * / * * /
rank: 9
score: 99.11802455357143
patch: ++ iter ; ++ 1 ;
rank: 9
score: 99.1064453125
patch: ++ iter ; ++ iter ; else
rank: 9
score: 99.01737976074219
patch: else { ++ iter ; * /
rank: 9
score: 98.995849609375
patch: ++ iter - 1 ;
rank: 10
score: 99.3455098470052
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 10
score: 99.31353400735294
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = false ;
rank: 10
score: 99.307373046875
patch: return weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 10
score: 99.29371553308823
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ) ;
rank: 10
score: 99.26941596137152
patch: x CaMeL Norm += weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 10
score: 99.11334228515625
patch: ++ iter ; else ++ iter ;
rank: 10
score: 99.10397338867188
patch: } ++ iter ; ++ iter ;
rank: 10
score: 98.95460205078125
patch: ++ iter ; ;
rank: 11
score: 99.34315185546875
patch: double [ ] current CaMeL Objective = current ;
rank: 11
score: 99.31341231496711
patch: boolean first CaMeL Iteration = checker . compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 11
score: 99.30369059244792
patch: qr CaMeL Decomposition = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 11
score: 99.26652526855469
patch: found = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 11
score: 99.16226016773896
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ;
rank: 11
score: 99.10895453559027
patch: ++ iter ; try { ++ iter ;
rank: 11
score: 99.09474012586806
patch: ++ iter ; ++ iter ; / /
rank: 11
score: 99.00577392578126
patch: return iter ; }
rank: 11
score: 98.94708251953125
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ;
rank: 12
score: 99.34290907118056
patch: weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 12
score: 99.31244860197368
patch: boolean first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 12
score: 99.29884739925987
patch: i = final Point CaMeL Vector CaMeL Value CaMeL Pair . operate ( current CaMeL Residuals ) ;
rank: 12
score: 99.26515502929688
patch: this . weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 12
score: 99.14282944623162
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , ;
rank: 12
score: 99.10029432508681
patch: ++ iter ; ++ iter ; break ;
rank: 12
score: 99.05891248914931
patch: ++ iter ; ++ iter ; iter ;
rank: 12
score: 98.98052978515625
patch: else ++ iter ;
rank: 12
score: 98.93131510416667
patch: ++ iter - iter ;
rank: 13
score: 99.34276580810547
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current CaMeL Point ;
rank: 13
score: 99.31065266927084
patch: if ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) {
rank: 13
score: 99.29591471354166
patch: qtf = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 13
score: 99.26211547851562
patch: ret = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 13
score: 99.14215087890625
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , ;
rank: 13
score: 99.09918212890625
patch: ++ iter ; ++ - iter ;
rank: 13
score: 99.04776436941964
patch: ++ 1 ; ++ iter ;
rank: 13
score: 98.96756744384766
patch: if ( iter > 0 ) {
rank: 13
score: 98.93075561523438
patch: if ( ! iter . is CaMeL Empty ; ) {
rank: 14
score: 99.32847193667763
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 14
score: 99.30420639935662
patch: double qr CaMeL Decomposition = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 14
score: 99.28904724121094
patch: iter = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 14
score: 99.28335731907895
patch: Iterator iter = checker . weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 14
score: 99.25967068142361
patch: n CaMeL R = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 14
score: 99.13513997395833
patch: ++ iter ] = new Point CaMeL Vector CaMeL Value CaMeL Pair ( ;
rank: 14
score: 99.03711547851563
patch: ++ iter ; ++ iter ; -- iter ;
rank: 14
score: 98.9249979654948
patch: throw new Unsupported CaMeL Operation CaMeL Exception ( $STRING$ ) ;
rank: 15
score: 99.32562255859375
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > current = current ;
rank: 15
score: 99.30057779947917
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker =
rank: 15
score: 99.2882080078125
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Objective ) ;
rank: 15
score: 99.28155838815789
patch: weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ; }
rank: 15
score: 99.25775146484375
patch: tmp = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 15
score: 99.12820870535714
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair ( ;
rank: 15
score: 99.08551703559027
patch: ++ iter ; ++ iter ; out ;
rank: 15
score: 98.95294189453125
patch: else { ++ * iter ; }
rank: 16
score: 99.32176717122395
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 16
score: 99.29944565716912
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = true ;
rank: 16
score: 99.28792078354779
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = get ;
rank: 16
score: 99.28004286024306
patch: weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Objective ) ;
rank: 16
score: 99.24445452008929
patch: check CaMeL Parameters ( current CaMeL Point , current CaMeL Objective ) ;
rank: 16
score: 99.12626567639802
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point . length ;
rank: 16
score: 99.07904052734375
patch: ++ iter ; iter ; * /
rank: 16
score: 98.93336704799107
patch: ++ < 0 > iter ;
rank: 16
score: 98.91999162946429
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter ) ;
rank: 17
score: 99.31509560032895
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Objective ) ;
rank: 17
score: 99.29717658547794
patch: if ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ,
rank: 17
score: 99.28153991699219
patch: it = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 17
score: 99.27662658691406
patch: Iterator iter = checker . get CaMeL Weight CaMeL Square CaMeL Root ( ) ;
rank: 17
score: 99.24203491210938
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ; }
rank: 17
score: 99.12492540147569
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point . ;
rank: 17
score: 99.072998046875
patch: ++ iter ; ++ iter ; * /
rank: 17
score: 99.01512799944196
patch: ++ iter ; ++ start ;
rank: 17
score: 98.92756870814732
patch: else { return iter ; }
rank: 17
score: 98.91621616908482
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current ) ;
rank: 18
score: 99.31455688476562
patch: int [ ] current CaMeL Objective = current ;
rank: 18
score: 99.27562662760417
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 18
score: 99.23844401041667
patch: x CaMeL Norm += weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 18
score: 99.1075439453125
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current ) ; }
rank: 18
score: 99.06964111328125
patch: ++ iter ; ++ * - iter ;
rank: 18
score: 99.01474831321023
patch: ++ iter ; ++ iter ; } ++ iter ;
rank: 18
score: 98.92315673828125
patch: else ++ iter ; ++ iter ;
rank: 18
score: 98.91534423828125
patch: Iterator iter = iter . iterator ( ) ;
rank: 19
score: 99.28959147135417
patch: double qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 19
score: 99.27691291360294
patch: ++ iter = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 19
score: 99.27480899586396
patch: weighted CaMeL Residual ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 19
score: 99.23612467447917
patch: x CaMeL Norm = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 19
score: 99.1056137084961
patch: ++ iter ; * / * /
rank: 19
score: 98.92313639322917
patch: if ( ! 0 . is CaMeL Empty ( ) ;
rank: 19
score: 98.90293375651042
patch: ++ iter + 1 ;
rank: 20
score: 99.3105135830966
patch: weighted CaMeL Jacobian = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 20
score: 99.28300476074219
patch: qr CaMeL Decomposition = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 20
score: 99.27163357204861
patch: weighted CaMeL Residual = get CaMeL Weight CaMeL Square CaMeL Root ( current CaMeL Point ) ;
rank: 20
score: 99.22952270507812
patch: list = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 20
score: 99.10476684570312
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ;
rank: 20
score: 99.00077056884766
patch: ++ new ++ ; ++ iter ;
rank: 20
score: 98.9154296875
patch: throw new Runtime CaMeL Exception ( $STRING$ ) ;
rank: 20
score: 98.89996744791667
patch: ++ iter ; Thread . current CaMeL Thread ( ) . start ( ;
rank: 21
score: 99.30787353515625
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > checker ;
rank: 21
score: 99.27964872472427
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = this ;
rank: 21
score: 99.26747349330357
patch: Convergence CaMeL Checker ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ) ;
rank: 21
score: 99.22877261513158
patch: comparator . qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 21
score: 99.10323293585526
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , iter ;
rank: 21
score: 99.06023297991071
patch: ++ 0 ; ++ iter ;
rank: 21
score: 98.91002807617187
patch: throw new Runtime CaMeL Exception ( $STRING$ ; }
rank: 22
score: 99.30727317116477
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) current ;
rank: 22
score: 99.27445261101974
patch: if ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ) {
rank: 22
score: 99.26787775213069
patch: weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Objective ) ;
rank: 22
score: 99.25390625
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = get ;
rank: 22
score: 99.22827911376953
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ; }
rank: 22
score: 99.10300856370192
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current ) ;
rank: 22
score: 99.0549087524414
patch: ++ iter ; ++ - 1 ;
rank: 22
score: 98.96827281605114
patch: ++ iter ; ++ iter ; ; ++ iter ;
rank: 22
score: 98.90593872070312
patch: ++ iter ; }
rank: 23
score: 99.30722527754934
patch: int current CaMeL Objective = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 23
score: 99.26671549479167
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker ;
rank: 23
score: 99.22563340928819
patch: n CaMeL R = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 23
score: 99.0956802368164
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point
rank: 23
score: 99.03770616319444
patch: / * ++ iter ; ++ iter ;
rank: 23
score: 98.96768188476562
patch: iter ; ++ ; ++ iter ;
rank: 23
score: 98.903564453125
patch: if ( ! iter == null ;
rank: 23
score: 98.8748291015625
patch: ++ iter ; if ( ! iter . is CaMeL Empty ( ) )
rank: 24
score: 99.30035807291667
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current CaMeL Point = current ;
rank: 24
score: 99.26668875558036
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair -- ;
rank: 24
score: 99.26310221354167
patch: Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 24
score: 99.25242213199013
patch: else qr CaMeL Decomposition = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 24
score: 99.22413465711806
patch: n CaMeL C = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 24
score: 99.09080153245192
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , ;
rank: 24
score: 99.0374755859375
patch: ++ iter ; try ; int iter ;
rank: 24
score: 98.96529134114583
patch: ++ iter ; ; ++ iter ; ;
rank: 24
score: 98.90311431884766
patch: else { ++ iter ; } }
rank: 24
score: 98.865087890625
patch: ++ iter ; if ( ! iter . is CaMeL Empty ( ) ;
rank: 25
score: 99.29715098505434
patch: Point CaMeL Vector CaMeL Value CaMeL Pair checker = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 25
score: 99.26295872738487
patch: int CaMeL Value = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ,
rank: 25
score: 99.25977998621323
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Objective ) ) ;
rank: 25
score: 99.22359525240384
patch: protected Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 25
score: 99.0899169921875
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point . length , ;
rank: 25
score: 98.89173126220703
patch: / * * ; ++ iter ;
rank: 25
score: 98.86494276258681
patch: ++ iter ; ++ n CaMeL C ;
rank: 26
score: 99.2955655184659
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 26
score: 99.26150512695312
patch: qtf ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 26
score: 99.25099182128906
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ;
rank: 26
score: 99.22322845458984
patch: ret = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 26
score: 99.08928833007812
patch: Point CaMeL Vector CaMeL Value CaMeL Pair current = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current
rank: 26
score: 99.03091866629464
patch: ++ iter ; while iter ;
rank: 26
score: 98.95131429036458
patch: ++ iter ; ++ ; ++ iter ;
rank: 26
score: 98.88650851779514
patch: else { ++ iter ; break ; }
rank: 26
score: 98.86456298828125
patch: ++ iter ; while ( false )
rank: 27
score: 99.25885009765625
patch: boolean first CaMeL Iteration = true ;
rank: 27
score: 99.25097045898437
patch: Convergence CaMeL Checker . compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 27
score: 99.24430084228516
patch: weighted CaMeL Residual = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 27
score: 99.21248685396634
patch: private Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 27
score: 99.0890869140625
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = new Point CaMeL Vector CaMeL Value CaMeL Pair ;
rank: 27
score: 98.94690619574652
patch: / ; ++ iter ; ++ iter ;
rank: 28
score: 99.29372271369485
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current ;
rank: 28
score: 99.25760048314145
patch: boolean first CaMeL Iteration = this . compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 28
score: 99.2502108487216
patch: qtf = compute CaMeL Weighted CaMeL Jacobian ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 28
score: 99.21122661389802
patch: this . qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 28
score: 99.08507361778847
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( ; }
rank: 28
score: 99.02666473388672
patch: ++ iter ; ++ * iter ;
rank: 28
score: 98.94285583496094
patch: ++ iter ; iter if ++ ;
rank: 28
score: 98.87285614013672
patch: ++ iter ; * * * /
rank: 28
score: 98.85949028862848
patch: ++ iter ; while ( false ) {
rank: 29
score: 99.29226345486111
patch: weighted CaMeL Jacobian = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 29
score: 99.25517003676471
patch: double first CaMeL Iteration = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 29
score: 99.24968872070312
patch: qr CaMeL Decomposition = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 29
score: 99.2093734741211
patch: v = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 29
score: 98.94072129991319
patch: ++ iter ; ; ++ iter ; }
rank: 29
score: 98.87003326416016
patch: / * * / ++ iter ;
rank: 29
score: 98.85223388671875
patch: if ( ! iter . is CaMeL Empty ( ) ) continue ;
rank: 30
score: 99.2490005493164
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair checker = current ;
rank: 30
score: 99.24073791503906
patch: checker = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 30
score: 99.2089092548077
patch: public Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 30
score: 99.0834716796875
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter ;
rank: 30
score: 99.0116195678711
patch: ++ iter ; iter ; * ;
rank: 30
score: 98.9358797940341
patch: ++ iter ; ++ iter ; ++ iter ; }
rank: 30
score: 98.86468505859375
patch: ++ iter ; return iter ; }
rank: 30
score: 98.8481953938802
patch: throw new Unsupported CaMeL Operation CaMeL Exception ( ) ; }
rank: 31
score: 99.28895786830357
patch: qtf = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 31
score: 99.2067642211914
patch: true = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 31
score: 99.08277130126953
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter ) ;
rank: 31
score: 99.00408935546875
patch: this . ++ iter ; ++ iter ;
rank: 31
score: 98.93084716796875
patch: ++ iter ; ; ++ iter ; ++ ;
rank: 31
score: 98.85589599609375
patch: if ( iter > iter ) {
rank: 31
score: 98.84798758370536
patch: if ( ! iter . is CaMeL Empty ( ) ) break ;
rank: 32
score: 99.285888671875
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) current ;
rank: 32
score: 99.23393322172619
patch: Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current ;
rank: 32
score: 99.20523071289062
patch: iter = get CaMeL Weight CaMeL Square CaMeL Root ( current CaMeL Point ) ;
rank: 32
score: 99.0796890258789
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , ;
rank: 32
score: 99.00389268663194
patch: ++ iter ; try ; if iter ;
rank: 32
score: 98.93064880371094
patch: ++ iter ; ++ iter ; /
rank: 32
score: 98.84785679408482
patch: if ( ! iter . is CaMeL Empty ( ; ) ) {
rank: 33
score: 99.24519617417279
patch: Object current CaMeL Point = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 33
score: 99.24159071180556
patch: final Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current ;
rank: 33
score: 99.2325927734375
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > final ;
rank: 33
score: 99.20506998697917
patch: ! weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 33
score: 99.07656521267361
patch: int iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ;
rank: 33
score: 99.00325317382813
patch: ++ iter ; ++ iter ; while iter ;
rank: 33
score: 98.9286776455966
patch: ++ iter ; ++ ++ iter ; ++ iter ;
rank: 33
score: 98.84624565972223
patch: ++ iter ; if ( true ) {
rank: 33
score: 98.84576416015625
patch: else { if ++ ++ iter ;
rank: 34
score: 99.28278459821429
patch: double [ ] current CaMeL Objective = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 34
score: 99.22942756204044
patch: int iter = get CaMeL Weight CaMeL Square CaMeL Root ( current CaMeL Point ) ;
rank: 34
score: 99.20501708984375
patch: x CaMeL Norm = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 34
score: 99.07548014322917
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , ; }
rank: 34
score: 98.99884033203125
patch: ++ iter ; iter = iter ;
rank: 34
score: 98.9261474609375
patch: ++ iter ; ; if ++ iter ;
rank: 34
score: 98.84550337357955
patch: ++ n CaMeL C ; ++ n CaMeL C ;
rank: 34
score: 98.84545026506696
patch: ++ iter ; while ; {
rank: 35
score: 99.23993997012867
patch: int first CaMeL Iteration = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 35
score: 99.22837136008523
patch: weighted CaMeL Residual = get CaMeL Weight CaMeL Square CaMeL Root ( current CaMeL Point , current CaMeL Objective ) ;
rank: 35
score: 99.19947052001953
patch: children = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 35
score: 99.07429504394531
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , ;
rank: 35
score: 98.98914930555556
patch: ++ iter ; else { ++ iter ;
rank: 35
score: 98.92327008928571
patch: ++ iter ; iter ++ ;
rank: 35
score: 98.84305572509766
patch: else { ++ ++ iter ; }
rank: 35
score: 98.83755929129464
patch: ++ iter ; Thread . current CaMeL Thread ( ) . start ;
rank: 36
score: 99.27527965198864
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = null ;
rank: 36
score: 99.23944450827206
patch: int qr CaMeL Decomposition = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 36
score: 99.23701171875
patch: qtf . qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 36
score: 99.21786644345238
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair ,
rank: 36
score: 99.07295227050781
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair ( current ) ;
rank: 36
score: 98.98770141601562
patch: ++ iter ; try ; break ;
rank: 36
score: 98.92264229910714
patch: ++ $NUMBER$ ; ++ iter ;
rank: 36
score: 98.8398208618164
patch: else { ++ * ++ iter ;
rank: 36
score: 98.83247375488281
patch: if ( iter >= 0 ) {
rank: 37
score: 99.27449253627232
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = get ;
rank: 37
score: 99.23826688878677
patch: String current CaMeL Point = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 37
score: 99.23661534926471
patch: else qr CaMeL Decomposition = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 37
score: 99.19195556640625
patch: res = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 37
score: 99.07237955729167
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , ;
rank: 37
score: 98.98302459716797
patch: ++ iter ; while iter ; ;
rank: 37
score: 98.92157745361328
patch: ++ iter ; ++ ++ 1 ;
rank: 37
score: 98.836669921875
patch: return ++ [ 0 ] ; }
rank: 37
score: 98.83193359375
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter ) ; }
rank: 38
score: 99.237841796875
patch: int iter = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 38
score: 99.23443196614583
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = current CaMeL Point ;
rank: 38
score: 99.21683349609376
patch: weighted CaMeL Residual = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 38
score: 99.18956756591797
patch: iter = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 38
score: 99.07159016927083
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , iter ) ;
rank: 38
score: 98.91885375976562
patch: iter ; ++ iter ;
rank: 39
score: 99.27109888980263
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Point ) ;
rank: 39
score: 99.23483115748355
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = this . current ;
rank: 39
score: 99.233251953125
patch: ++ iter ; Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 39
score: 99.187255859375
patch: n CaMeL C = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 39
score: 99.06896158854167
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , ; }
rank: 39
score: 98.91790093315973
patch: ++ iter ; ++ iter ; / ;
rank: 39
score: 98.83140563964844
patch: if ( iter > 0 ; {
rank: 39
score: 98.8235595703125
patch: if ( ! iter . is CaMeL Empty ( ) ) ++ iter ;
rank: 40
score: 99.23057338169643
patch: int CaMeL Value = final Point CaMeL Vector CaMeL Value CaMeL Pair . operate ( current CaMeL Residuals ) ;
rank: 40
score: 99.2115478515625
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ,
rank: 40
score: 99.18662923177084
patch: ! weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 40
score: 99.06893310546874
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point . length ) ;
rank: 40
score: 98.97142682756696
patch: ++ iter ; if iter ;
rank: 40
score: 98.9176025390625
patch: ++ iter ; ++ iter ; return iter ;
rank: 40
score: 98.83098602294922
patch: else { ++ * * iter ;
rank: 40
score: 98.8234130859375
patch: final ++ iter ;
rank: 41
score: 99.2626316236413
patch: Point CaMeL Vector CaMeL Value CaMeL Pair checker = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 41
score: 99.23001302083334
patch: qtf = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ;
rank: 41
score: 99.18649291992188
patch: list = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 41
score: 99.06841719777961
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current ;
rank: 41
score: 98.96766008649554
patch: finally { ++ iter ; }
rank: 41
score: 98.91592407226562
patch: ++ iter ; iter / ; /
rank: 41
score: 98.82949829101562
patch: ++ iter [ 0 ] ; }
rank: 41
score: 98.82318115234375
patch: ++ iter ; Thread . current CaMeL Thread ( ) . ++ ;
rank: 42
score: 99.23335988898026
patch: boolean first CaMeL Iteration = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ,
rank: 42
score: 99.20921979631696
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair current ;
rank: 42
score: 99.18489583333333
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Cost ) ;
rank: 42
score: 99.06712510850694
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ; ;
rank: 42
score: 98.96253204345703
patch: i * ++ ; ++ iter ;
rank: 42
score: 98.91477966308594
patch: ++ iter ; iter / / /
rank: 42
score: 98.82471466064453
patch: ++ [ ] iter = iter ;
rank: 42
score: 98.8226826985677
patch: ++ iter ; Thread . current CaMeL Thread ( ) ;
rank: 43
score: 99.25747841282895
patch: double current CaMeL Objective = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 43
score: 99.23049747242646
patch: int current CaMeL Objective = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 43
score: 99.22884971217105
patch: qtf = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Residuals ) ;
rank: 43
score: 99.20601981026786
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = get CaMeL Weight CaMeL Square CaMeL Root ( ) ;
rank: 43
score: 99.1844482421875
patch: state = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 43
score: 99.06575012207031
patch: ++ iter ; ++ iter * /
rank: 43
score: 98.91468811035156
patch: ++ iter ; ++ iter ; try
rank: 43
score: 98.82332066127232
patch: else { return null ; }
rank: 43
score: 98.81608442826705
patch: throw new Unsupported CaMeL Operation CaMeL Exception ( ) ;
rank: 44
score: 99.25584501378677
patch: qtf = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 44
score: 99.22553453947368
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ,
rank: 44
score: 99.20189073350694
patch: { qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 44
score: 99.18441772460938
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 44
score: 99.06489393446181
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point . length ;
rank: 44
score: 98.9531478881836
patch: ++ iter ; try + iter ;
rank: 44
score: 98.91283569335937
patch: ++ iter ; ++ iter ; ++ 1 ;
rank: 44
score: 98.82062639508929
patch: if ( iter > 0 ;
rank: 44
score: 98.81256103515625
patch: if ( old CaMeL Obj . length > 0 ) {
rank: 45
score: 99.25562395368304
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = this ;
rank: 45
score: 99.2261493389423
patch: ++ iter = checker . operate ( current CaMeL Residuals ) ;
rank: 45
score: 99.22367858886719
patch: boolean first CaMeL Iteration = false ;
rank: 45
score: 98.95220184326172
patch: ++ iter ; synchronized ++ iter ;
rank: 45
score: 98.9019775390625
patch: ++ iter ; ++ iter ; if iter ;
rank: 45
score: 98.81976318359375
patch: if ( ! 0 . is CaMeL Empty ( ) )
rank: 45
score: 98.81234402126736
patch: iter = iter . iter ( ) ;
rank: 46
score: 99.25442843967014
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair current CaMeL Point = current ;
rank: 46
score: 99.22214762369792
patch: e = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 46
score: 99.22043282645089
patch: if ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) )
rank: 46
score: 99.20117797851563
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > current ;
rank: 46
score: 99.17977142333984
patch: r = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 46
score: 99.05845289963942
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , ;
rank: 46
score: 98.90156773158482
patch: ++ iter ; ++ 0 ;
rank: 46
score: 98.8144775390625
patch: ++ ++ iter ;
rank: 46
score: 98.81163611778847
patch: while ( ! iter . is CaMeL Empty ( ) ) {
rank: 47
score: 99.22186889648438
patch: ++ iter = final Point CaMeL Vector CaMeL Value CaMeL Pair . operate ( current CaMeL Residuals ) ;
rank: 47
score: 99.17366027832031
patch: v = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 47
score: 99.0580825805664
patch: ++ iter * / ++ iter ;
rank: 47
score: 98.94719102647569
patch: / * ] iter ; ++ iter ;
rank: 47
score: 98.89497375488281
patch: ++ iter ; iter ; / /
rank: 47
score: 98.81398703835227
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ;
rank: 47
score: 98.80459359975961
patch: if ( ! iter . is CaMeL Empty ( ; ) )
rank: 48
score: 99.21160888671875
patch: boolean first CaMeL Iteration = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 48
score: 99.16912841796875
patch: true = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 48
score: 99.057470703125
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , iter ) ;
rank: 48
score: 98.94459364149306
patch: ++ iter ; iter ; ++ iter ;
rank: 48
score: 98.81352996826172
patch: return iter [ 0 ] ; }
rank: 48
score: 98.80452473958333
patch: try { ++ iter ;
rank: 49
score: 99.2528766134511
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) current ;
rank: 49
score: 99.21085611979167
patch: int qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 49
score: 99.19957275390625
patch: checker = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Objective ) ;
rank: 49
score: 99.16832478841145
patch: < Point CaMeL Vector CaMeL Value CaMeL Pair > checker ;
rank: 49
score: 99.05662434895834
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , iter , ;
rank: 49
score: 98.94036865234375
patch: ++ iter ; try { iter ;
rank: 49
score: 98.884521484375
patch: ++ iter ; ++ 1 ; ++ iter ;
rank: 49
score: 98.81327056884766
patch: / * * * ++ iter ;
rank: 50
score: 99.25275213068181
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > current = current ;
rank: 50
score: 99.21756114130434
patch: compute CaMeL Weighted CaMeL Jacobian ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ) ;
rank: 50
score: 99.16193033854167
patch: synchronized ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) {
rank: 50
score: 99.05650983537946
patch: long start = System . current CaMeL Time CaMeL Millis ( ) ;
rank: 50
score: 98.93904113769531
patch: ++ iter ; ++ iter ; *
rank: 50
score: 98.88226318359375
patch: ++ iter ; iter ; ++ ;
rank: 50
score: 98.80665806361607
patch: else { if ++ iter ;
rank: 50
score: 98.80330113002232
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair [ 0 ] ;
rank: 51
score: 99.2525570518092
patch: ++ weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 51
score: 99.21632690429688
patch: Convergence CaMeL Checker = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 51
score: 99.20876736111111
patch: if ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) )
rank: 51
score: 99.19916130514706
patch: Iterator iter = get CaMeL Weight CaMeL Square CaMeL Root ( current CaMeL Point ) ;
rank: 51
score: 99.15797424316406
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Objective ) ;
rank: 51
score: 98.93696594238281
patch: if ++ iter ; ++ iter ;
rank: 51
score: 98.80625915527344
patch: if ( iter ; > 0 ;
rank: 51
score: 98.80082563920455
patch: ++ iter ; Thread . current CaMeL Thread ( ;
rank: 52
score: 99.2146465594952
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair final = current ;
rank: 52
score: 99.15576171875
patch: false = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 52
score: 99.04806082589286
patch: ++ iter ; break ; }
rank: 52
score: 98.93663872612848
patch: ++ iter ; iter ; int iter ;
rank: 52
score: 98.88138427734376
patch: ++ iter ; ++ start ; ++ iter ;
rank: 52
score: 98.80518687855114
patch: throw new Runtime CaMeL Exception ( $STRING$ ) ; }
rank: 52
score: 98.8006083170573
patch: final ; ++ iter ;
rank: 53
score: 99.15432739257812
patch: children = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 53
score: 99.04634312220982
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , iter ;
rank: 53
score: 98.93514251708984
patch: ++ iter ; if iter ; ;
rank: 53
score: 98.88049926757813
patch: ++ iter ; ++ iter ; = iter ;
rank: 53
score: 98.80027262369792
patch: else { ++ [ 1 ] ; }
rank: 53
score: 98.79997907366071
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , ;
rank: 54
score: 99.24843343098958
patch: Point CaMeL Vector CaMeL Value CaMeL Pair checker = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ;
rank: 54
score: 99.21400282118056
patch: it = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 54
score: 99.20758734809027
patch: String qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 54
score: 99.19388253348214
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair new ;
rank: 54
score: 99.15425872802734
patch: self = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 54
score: 98.93397352430556
patch: ++ iter ; ++ iter ; try ;
rank: 54
score: 98.87968306107955
patch: ++ iter ; ++ iter ; if ++ iter ;
rank: 54
score: 98.79938213641827
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + 1 ;
rank: 54
score: 98.7963623046875
patch: ++ iter ; Thread . current CaMeL Thread ( ) . interrupt ( ;
rank: 55
score: 99.24774724786931
patch: weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Point ) ;
rank: 55
score: 99.20277806332237
patch: compute CaMeL Weighted CaMeL Jacobian ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 55
score: 99.19362278988487
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Objective ) ;
rank: 55
score: 99.14942842371323
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ; }
rank: 55
score: 99.04551786534927
patch: inst = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ;
rank: 55
score: 98.9339599609375
patch: ++ iter ; ++ iter ; ; *
rank: 55
score: 98.87880161830357
patch: ++ start ; ++ iter ;
rank: 55
score: 98.79827880859375
patch: else ++ iter * iter ; }
rank: 56
score: 99.21231515066964
patch: e = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 56
score: 99.2005256204044
patch: final int CaMeL Value = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 56
score: 99.19183349609375
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair new = current ;
rank: 56
score: 99.14876556396484
patch: result = get CaMeL Weight CaMeL Square CaMeL Root ( current CaMeL Point ) ;
rank: 56
score: 99.04418131510417
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter ) ;
rank: 56
score: 98.9327392578125
patch: ++ iter ; int iter = iter ;
rank: 56
score: 98.87762451171875
patch: ++ iter ; iter / 1 ;
rank: 56
score: 98.79668634588069
patch: throw new Runtime CaMeL Exception ( $STRING$ + iter ;
rank: 56
score: 98.79349190848214
patch: ++ iter ; return new Point CaMeL Vector CaMeL Value CaMeL Pair ;
rank: 57
score: 99.24493117559524
patch: Point CaMeL Vector CaMeL Value CaMeL Pair current = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) current ;
rank: 57
score: 99.21188015407986
patch: i = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 57
score: 99.18913269042969
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair list = current ;
rank: 57
score: 99.14814758300781
patch: removed = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 57
score: 99.03984239366319
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , ;
rank: 57
score: 98.93251546223958
patch: ++ iter ; iter ; * * /
rank: 57
score: 98.87291870117187
patch: ++ iter ; ++ iter ; / / /
rank: 57
score: 98.79520416259766
patch: return null ; } ++ iter ;
rank: 57
score: 98.79227388822116
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter ;
rank: 58
score: 99.19830322265625
patch: current CaMeL Point = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 58
score: 99.18788146972656
patch: ++ iter ; final Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair
rank: 58
score: 99.147119140625
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Objective ) ;
rank: 58
score: 99.03841145833333
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , ;
rank: 58
score: 98.92810736762152
patch: ++ iter ; ++ iter ; * *
rank: 58
score: 98.87034776475694
patch: ++ iter ; ++ iter ; else ;
rank: 58
score: 98.7935791015625
patch: else { ++ iter ; ; }
rank: 58
score: 98.7917724609375
patch: ++ iter ; throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ;
rank: 59
score: 99.24231974283855
patch: Point CaMeL Vector CaMeL Value CaMeL Pair > checker = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 59
score: 99.18726748511905
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals , current CaMeL Objective ) ) ;
rank: 59
score: 99.14691925048828
patch: p = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 59
score: 98.9205093383789
patch: ++ iter ; * ++ iter ;
rank: 59
score: 98.87023315429687
patch: ++ 1 ; ++ iter ; ++ iter ;
rank: 59
score: 98.79200439453125
patch: else { throw new Runtime CaMeL Exception ; }
rank: 60
score: 99.24203636532738
patch: int [ ] current CaMeL Objective = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 60
score: 99.19618135340073
patch: check CaMeL Parameters ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 60
score: 99.18719123391544
patch: Iterator iter = checker . compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 60
score: 99.14435577392578
patch: state = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 60
score: 99.03629557291667
patch: ++ iter * / * ++ iter ;
rank: 60
score: 98.91966029575893
patch: ++ iter ; int iter ;
rank: 60
score: 98.86915172230114
patch: ++ iter ; ++ iter ; ++ ++ iter ;
rank: 61
score: 99.23960367838542
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Objective ) ;
rank: 61
score: 99.18656616210937
patch: checker = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 61
score: 99.14298248291016
patch: res = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 61
score: 99.0345818014706
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , ; }
rank: 61
score: 98.91933865017361
patch: ++ iter ; ++ iter ; iterator ;
rank: 61
score: 98.8680752840909
patch: ++ iter ; ++ iter ; else ++ iter ;
rank: 61
score: 98.78694915771484
patch: } else { ++ iter ; }
rank: 61
score: 98.78433227539062
patch: ++ iter ; if ( true )
rank: 62
score: 99.20881791548295
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 62
score: 99.19367133246527
patch: qtf ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ,
rank: 62
score: 99.18546977796052
patch: ++ iter ; final Convergence CaMeL Checker . get CaMeL Weight CaMeL Square CaMeL Root ( ) ;
rank: 62
score: 99.14273071289062
patch: c = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 62
score: 99.0336555032169
patch: inst = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , ;
rank: 62
score: 98.91887555803571
patch: / * ++ ++ iter ;
rank: 62
score: 98.86640930175781
patch: ++ ++ 1 ; ++ iter ;
rank: 62
score: 98.78557586669922
patch: if ( iter > 1 ) {
rank: 62
score: 98.78412737165179
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair [ iter ] ;
rank: 63
score: 99.23588053385417
patch: Point CaMeL Vector CaMeL Value CaMeL Pair current = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ;
rank: 63
score: 99.19341362847223
patch: Object qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 63
score: 99.18284970238095
patch: weighted CaMeL Residual ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ) ;
rank: 63
score: 99.03181008731617
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , iter ;
rank: 63
score: 98.91824001736111
patch: ++ iter ; int iter + iter ;
rank: 63
score: 98.86510120738636
patch: ++ iter ; ; ++ iter ; ++ iter ;
rank: 63
score: 98.78526306152344
patch: else { return new ++ ; }
rank: 63
score: 98.78406439887152
patch: if ( iter == null ) break ;
rank: 64
score: 99.23243248980978
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = ( Point CaMeL Vector CaMeL Value CaMeL Pair > ) current ;
rank: 64
score: 99.2057113647461
patch: Convergence CaMeL Checker = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 64
score: 99.19265567555146
patch: String qr CaMeL Decomposition = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 64
score: 99.18140411376953
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair start = current ;
rank: 64
score: 99.136328125
patch: check CaMeL Parameters ( current CaMeL Point ) ;
rank: 64
score: 99.03143988715277
patch: int iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , ;
rank: 64
score: 98.91802300347223
patch: ++ iter ; / * * / /
rank: 64
score: 98.86461385091145
patch: / ; ++ iter ;
rank: 64
score: 98.78319295247395
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ; ;
rank: 64
score: 98.78315873579545
patch: if ( ! iter . is CaMeL Empty ; )
rank: 65
score: 99.23219129774306
patch: double [ ] current CaMeL Objective = get CaMeL Weight CaMeL Square CaMeL Root ( ) ;
rank: 65
score: 99.20526801215277
patch: final Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = get ;
rank: 65
score: 99.19135199652777
patch: boolean first CaMeL Iteration = checker . compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 65
score: 99.17984811883224
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > {
rank: 65
score: 99.13581085205078
patch: t = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 65
score: 99.02703857421875
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , iter ) ;
rank: 65
score: 98.91287994384766
patch: ++ iter ; ++ iter ; ++
rank: 65
score: 98.86338975694444
patch: ++ iter ; ++ ++ iter ; ;
rank: 65
score: 98.78312174479167
patch: ++ n CaMeL C ;
rank: 65
score: 98.78254699707031
patch: else { return ++ iter ; }
rank: 66
score: 99.1912841796875
patch: int iter = Point CaMeL Vector CaMeL Value CaMeL Pair . operate ( current CaMeL Point ) ;
rank: 66
score: 99.17974562872024
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > = current ;
rank: 66
score: 99.13458251953125
patch: rs = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 66
score: 99.02359008789062
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current ) ;
rank: 66
score: 98.90949842664931
patch: ++ iter ; ++ - - iter ;
rank: 66
score: 98.86002197265626
patch: ++ iter ; ++ iter ; ++ start ;
rank: 66
score: 98.78125
patch: while ( true ) { ++ iter ;
rank: 67
score: 99.2316162109375
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > checker =
rank: 67
score: 99.20436497738487
patch: i = final Point CaMeL Vector CaMeL Value CaMeL Pair . operate ( current CaMeL Point ) ;
rank: 67
score: 99.18960391773896
patch: int current CaMeL Point = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 67
score: 99.13434600830078
patch: retval = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 67
score: 99.02354672080592
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , ; ;
rank: 67
score: 98.85735212053571
patch: ++ iter ; ++ max ;
rank: 67
score: 98.77933175223214
patch: ++ iter ; Thread . current CaMeL Thread ( ) . interrupt ;
rank: 67
score: 98.77556501116071
patch: else { ++ * iter ;
rank: 68
score: 99.23023681640625
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = current CaMeL Point [ n CaMeL C ] ;
rank: 68
score: 99.1851806640625
patch: return weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 68
score: 99.178955078125
patch: Iterator iter = checker . get CaMeL Weight CaMeL Square CaMeL Root ( current CaMeL Point ) ;
rank: 68
score: 99.13229031032986
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , 0 ) ;
rank: 68
score: 99.02092827690973
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point [ ;
rank: 68
score: 98.90487670898438
patch: ++ iter ; ++ iter ; for iter ;
rank: 68
score: 98.85680474175348
patch: ++ iter ; ++ iter ; ++ ;
rank: 68
score: 98.77780151367188
patch: ++ iter ; while ( iter != null )
rank: 68
score: 98.7755596454327
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + iter ;
rank: 69
score: 99.22920445033482
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = false ;
rank: 69
score: 99.20316745923913
patch: qr CaMeL Decomposition = compute CaMeL Weighted CaMeL Jacobian ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 69
score: 99.18329216452206
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = 0 ;
rank: 69
score: 99.1787338256836
patch: checker = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Objective ) ;
rank: 69
score: 99.13111877441406
patch: r = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 69
score: 99.0202880859375
patch: ++ iter ; iter = iter . iter ;
rank: 69
score: 98.90370396205357
patch: / * ] ++ iter ;
rank: 69
score: 98.8526611328125
patch: ++ iter ; ++ iter ; while ++ iter ;
rank: 69
score: 98.77635192871094
patch: ++ iter 1 [ 0 ] ;
rank: 69
score: 98.76802062988281
patch: else { / * ++ iter ;
rank: 70
score: 99.22699737548828
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > current CaMeL Point = current ;
rank: 70
score: 99.20235443115234
patch: i = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 70
score: 99.18234592013889
patch: pk = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 70
score: 99.177001953125
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair = current ;
rank: 70
score: 99.02009582519531
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , ;
rank: 70
score: 98.9029541015625
patch: ++ iter ; else ; ++ iter ;
rank: 70
score: 98.849853515625
patch: ++ iter ; ++ -- iter ;
rank: 70
score: 98.77481783353366
patch: ++ iter ; if ( ! iter . is CaMeL Empty ;
rank: 70
score: 98.76591491699219
patch: return false ; } ++ iter ;
rank: 71
score: 99.20104370117187
patch: qtf ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ) ;
rank: 71
score: 99.18000231291118
patch: qr CaMeL Decomposition = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ,
rank: 71
score: 99.17542613636364
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > {
rank: 71
score: 98.89998626708984
patch: ++ iter ; ++ - 0 ;
rank: 71
score: 98.84813690185547
patch: ++ iter ; iter / * /
rank: 71
score: 98.77387152777777
patch: ++ iter ; ++ n CaMeL R ;
rank: 71
score: 98.75794982910156
patch: ++ * iter ; ++ iter ;
rank: 72
score: 99.22620442708333
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = current CaMeL Point ;
rank: 72
score: 99.19971466064453
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Residuals ) ;
rank: 72
score: 99.17826080322266
patch: return compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ,
rank: 72
score: 99.17509380139802
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair = checker . operate ( current CaMeL Point ) ;
rank: 72
score: 99.12961832682292
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Objective ) ;
rank: 72
score: 99.01567993164062
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ; ++ iter ;
rank: 72
score: 98.89995465959821
patch: / * ; ++ iter ;
rank: 72
score: 98.77240397135417
patch: int iter = Arrays . as CaMeL List ( iter ) . length ;
rank: 72
score: 98.75745567908653
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + $NUMBER$ ;
rank: 73
score: 99.2251708984375
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair [ ] current = current ;
rank: 73
score: 99.19953748914931
patch: else qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 73
score: 99.17810821533203
patch: double qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 73
score: 99.12956237792969
patch: changed = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 73
score: 99.01487330386513
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ; ;
rank: 73
score: 98.89803059895833
patch: ++ iter ; ++ iter ; * ;
rank: 73
score: 98.84524197048611
patch: ++ iter ; ; ; ++ iter ;
rank: 73
score: 98.77196155894886
patch: ++ iter ; while ( iter != null ) {
rank: 73
score: 98.74590301513672
patch: ++ * * * * iter ;
rank: 74
score: 99.1977771577381
patch: e = compute CaMeL Weighted CaMeL Jacobian ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 74
score: 99.17759794347427
patch: return weighted CaMeL Residual = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 74
score: 99.1720034950658
patch: Iterator iter = checker . weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 74
score: 99.12918090820312
patch: s = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 74
score: 99.01378522600446
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current ; }
rank: 74
score: 98.89549255371094
patch: ++ iter ; try { break ;
rank: 74
score: 98.84197998046875
patch: ++ iter ; ; ++ 1 ;
rank: 74
score: 98.7703125
patch: ++ iter ; return new Point CaMeL Vector CaMeL Value CaMeL Pair ( ;
rank: 74
score: 98.74416775173611
patch: else { ++ * ++ iter ; }
rank: 75
score: 99.22432767427884
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair list = current ;
rank: 75
score: 99.19570486886161
patch: ( ( Point CaMeL Vector CaMeL Value CaMeL Pair ) checker ) ;
rank: 75
score: 99.17031860351562
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair contains = current ;
rank: 75
score: 99.12771606445312
patch: tmp = get CaMeL Weight CaMeL Square CaMeL Root ( current CaMeL Point ) ;
rank: 75
score: 99.01177619485294
patch: int iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ;
rank: 75
score: 98.89376068115234
patch: ++ iter ; ++ * * ;
rank: 75
score: 98.84040971235795
patch: ++ iter ; ++ iter ; ++ iter ; ;
rank: 75
score: 98.77022298177083
patch: ++ iter ; break ;
rank: 75
score: 98.74214935302734
patch: else { ++ iter ; } ;
rank: 76
score: 99.1947605298913
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 76
score: 99.17665100097656
patch: double qr CaMeL Decomposition = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 76
score: 99.16932983398438
patch: for ( Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > {
rank: 76
score: 99.12687544389205
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 76
score: 99.01108620383523
patch: ++ iter ; while ( iter < iter ) {
rank: 76
score: 98.89267985026042
patch: ++ iter ; * / int iter ;
rank: 76
score: 98.83926391601562
patch: ++ iter ; iter / iter ;
rank: 76
score: 98.76927771935097
patch: if ( ! iter . is CaMeL Empty ( ; ) {
rank: 77
score: 99.222119140625
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 77
score: 99.17640686035156
patch: x CaMeL Norm = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 77
score: 99.1685458096591
patch: weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Residuals ) ;
rank: 77
score: 99.12555694580078
patch: success = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 77
score: 99.01080322265625
patch: ++ iter ; while ( iter < iter )
rank: 77
score: 98.88836669921875
patch: ++ iter ; ++ * 1 ;
rank: 77
score: 98.83889431423611
patch: iter ; ++ iter ; ++ iter ;
rank: 77
score: 98.7682772549716
patch: ++ iter ; if ( iter != null ) {
rank: 77
score: 98.74128723144531
patch: ++ * * * ++ iter ;
rank: 78
score: 99.19151000976562
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = current CaMeL Point [ current CaMeL Objective ] ;
rank: 78
score: 99.17605154854911
patch: pk = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 78
score: 99.16724742542614
patch: ++ iter . final Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Objective ) ;
rank: 78
score: 99.12388700597427
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , 0 ) ;
rank: 78
score: 99.010791015625
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , ++ iter ;
rank: 78
score: 98.88761138916016
patch: ++ - iter ; ++ iter ;
rank: 78
score: 98.83714076450893
patch: ++ true ; ++ iter ;
rank: 78
score: 98.7681884765625
patch: if ( iter == null ) continue ;
rank: 78
score: 98.74022827148437
patch: if ( iter == 0 ) return null ;
rank: 79
score: 99.21991838727679
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair checker ;
rank: 79
score: 99.19137573242188
patch: int CaMeL Value = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 79
score: 99.1759392233456
patch: Object qr CaMeL Decomposition = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 79
score: 99.16577962239583
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair += current ;
rank: 79
score: 99.121826171875
patch: children = get CaMeL Weight CaMeL Square CaMeL Root ( current CaMeL Point ) ;
rank: 79
score: 99.00941819411058
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ;
rank: 79
score: 98.8870849609375
patch: ++ iter ; ++ 1 ; ;
rank: 79
score: 98.83380126953125
patch: ++ iter ; iter / ; ++ iter ;
rank: 79
score: 98.7680419921875
patch: ++ iter ; throw new Illegal CaMeL State CaMeL Exception ( ) ; }
rank: 79
score: 98.73981391059027
patch: else { ++ [ iter ] ; }
rank: 80
score: 99.19105360243056
patch: final Convergence CaMeL Checker ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 80
score: 99.17496530633224
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current CaMeL Residuals ;
rank: 80
score: 99.16567160866477
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ) ; }
rank: 80
score: 99.1214599609375
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ; }
rank: 80
score: 99.00716145833333
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , iter ;
rank: 80
score: 98.88687896728516
patch: ++ iter ; else + iter ;
rank: 80
score: 98.83324323381696
patch: ++ iter ; iter / ;
rank: 80
score: 98.76754557291666
patch: ++ iter ; throw new Illegal CaMeL State CaMeL Exception ( $STRING$ ) ;
rank: 80
score: 98.7393310546875
patch: } ++ iter ;
rank: 81
score: 99.21574964021382
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair = checker . operate ( current CaMeL Residuals ) ;
rank: 81
score: 99.1908820657169
patch: ++ compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 81
score: 99.17415677584134
patch: return compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 81
score: 99.16469997829861
patch: ++ iter ; final Convergence CaMeL Checker ;
rank: 81
score: 99.12052917480469
patch: other = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 81
score: 99.00703699448529
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current . ++ , ; }
rank: 81
score: 98.88633219401042
patch: ++ iter ; ++ * ++ iter ;
rank: 81
score: 98.83027787642045
patch: ++ iter ; ++ iter ; / ++ iter ;
rank: 81
score: 98.76241455078124
patch: ++ iter ; while ( iter == 0 )
rank: 81
score: 98.73836263020833
patch: else { ++ * * iter ; }
rank: 82
score: 99.21327561598558
patch: Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current ;
rank: 82
score: 99.173583984375
patch: boolean first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ,
rank: 82
score: 99.12014770507812
patch: added = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 82
score: 99.00633951822917
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair . ++ ;
rank: 82
score: 98.88494873046875
patch: ++ iter ; ++ iter ; 0 ;
rank: 82
score: 98.83021545410156
patch: ++ iter ; iter / ++ ;
rank: 82
score: 98.76139322916667
patch: ++ n CaMeL C ; ++ iter ;
rank: 82
score: 98.73621283637152
patch: / * * * / ++ iter ;
rank: 83
score: 99.21146647135417
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current CaMeL Point = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) current ;
rank: 83
score: 99.18766784667969
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair 1 = current ;
rank: 83
score: 99.16459147135417
patch: qr CaMeL Decomposition = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 83
score: 99.11819458007812
patch: removed = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 83
score: 99.00531877790179
patch: ++ iter * / * ;
rank: 83
score: 98.82509155273438
patch: ++ 0 ; ++ iter ; ++ iter ;
rank: 83
score: 98.75923978365384
patch: ++ iter = Arrays . as CaMeL List ( iter ) ;
rank: 83
score: 98.73599243164062
patch: ++ iter ; / * * /
rank: 84
score: 99.18765113467262
patch: Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = get ;
rank: 84
score: 99.1674740439967
patch: double [ ] current CaMeL Objective = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 84
score: 99.11785125732422
patch: rs = get CaMeL Weight CaMeL Square CaMeL Root ( current CaMeL Point ) ;
rank: 84
score: 99.00529479980469
patch: ++ iter ] = new Point CaMeL Vector CaMeL Value CaMeL Pair ( ; }
rank: 84
score: 98.757763671875
patch: final ; if ( ! iter . is CaMeL Empty ( ) ) {
rank: 84
score: 98.73569742838542
patch: if ( . is CaMeL Empty ( ; ) ) {
rank: 85
score: 99.21006266276042
patch: Point CaMeL Vector CaMeL Value CaMeL Pair > checker = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 85
score: 99.16671752929688
patch: Point CaMeL Vector CaMeL Value CaMeL Pair checker = current ;
rank: 85
score: 99.162841796875
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker . operate ( current CaMeL Residuals ) ;
rank: 85
score: 99.11640930175781
patch: prev = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 85
score: 99.00496419270833
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair ( current ;
rank: 85
score: 98.88240356445313
patch: ++ iter ; ++ iter ; int iter ;
rank: 85
score: 98.81809779575893
patch: ++ $STRING$ ; ++ iter ;
rank: 85
score: 98.75767299107143
patch: if ( iter != null )
rank: 85
score: 98.73514404296876
patch: else { ++ iter ; } ++ iter ;
rank: 86
score: 99.2092815896739
patch: Point CaMeL Vector CaMeL Value CaMeL Pair checker = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ,
rank: 86
score: 99.16666452508224
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Objective ,
rank: 86
score: 99.16266632080078
patch: checker = get CaMeL Weight CaMeL Square CaMeL Root ( current CaMeL Point ) ;
rank: 86
score: 99.11634826660156
patch: size = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 86
score: 99.00456019810268
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair ) ;
rank: 86
score: 98.81745741102431
patch: ++ iter ; ; if iter ++ ;
rank: 86
score: 98.75752563476563
patch: ++ iter 1 [ n CaMeL C ] ;
rank: 86
score: 98.73503282335069
patch: return new ++ [ iter ] ; }
rank: 87
score: 99.20787992931548
patch: double [ ] current CaMeL Objective = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 87
score: 99.18537902832031
patch: e = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 87
score: 99.16126360212054
patch: while ( true ) { {
rank: 87
score: 99.11601257324219
patch: false = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 87
score: 99.00443761488971
patch: ++ iter ] = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter ) ;
rank: 87
score: 98.80771213107639
patch: ++ iter ; iter / ; / /
rank: 87
score: 98.75672912597656
patch: final ++ iter ; ++ iter ;
rank: 87
score: 98.73502022879464
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + 1 ) ;
rank: 88
score: 99.20714047080592
patch: return weighted CaMeL Jacobian = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 88
score: 99.18496222245066
patch: int CaMeL Value = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ;
rank: 88
score: 99.16526692708334
patch: int CaMeL Value = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 88
score: 99.16122671274039
patch: Iterator iter = checker . operate ( current CaMeL Residuals ) ;
rank: 88
score: 99.11579895019531
patch: self = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 88
score: 99.00384200246711
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point . length ) ;
rank: 88
score: 98.87734646267361
patch: ++ iter ; iter ; * / /
rank: 88
score: 98.80668131510417
patch: ++ ; ++ iter ; ++ iter ;
rank: 88
score: 98.73191615513393
patch: else ++ iter * iter ;
rank: 89
score: 99.2068758877841
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = this ;
rank: 89
score: 99.1849006204044
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current CaMeL Point = current CaMeL Point ;
rank: 89
score: 99.16417020909927
patch: Point CaMeL Vector CaMeL Value CaMeL Pair checker = current CaMeL Point [ iter ] ;
rank: 89
score: 99.16042073567708
patch: checker = weight CaMeL Matrix CaMeL Sqrt . operate . operate ( current CaMeL Residuals ) ;
rank: 89
score: 99.11467742919922
patch: finished = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 89
score: 99.00380987870066
patch: Point CaMeL Vector CaMeL Value CaMeL Pair current = new Point CaMeL Vector CaMeL Value CaMeL Pair ;
rank: 89
score: 98.87684461805556
patch: ++ iter ; * * ++ iter ;
rank: 89
score: 98.80532004616477
patch: ++ iter ; } ++ iter ; ++ iter ;
rank: 89
score: 98.7545166015625
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( ;
rank: 89
score: 98.73169759114583
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + iter + $STRING$ ;
rank: 90
score: 99.20642671130952
patch: Point CaMeL Vector CaMeL Value CaMeL Pair checker = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 90
score: 99.16328260633681
patch: int CaMeL Value = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ,
rank: 90
score: 99.11000061035156
patch: list = get CaMeL Weight CaMeL Square CaMeL Root ( current CaMeL Point ) ;
rank: 90
score: 99.0030517578125
patch: ++ iter ; * / * * /
rank: 90
score: 98.87677001953125
patch: / * ++ iter ; / /
rank: 90
score: 98.80349731445312
patch: ++ -- iter ; ++ iter ;
rank: 90
score: 98.75081787109374
patch: ++ iter ; if ( iter != null )
rank: 90
score: 98.73163519965277
patch: else { if ++ iter > 0 ;
rank: 91
score: 99.18446416440217
patch: Point CaMeL Vector CaMeL Value CaMeL Pair current = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ,
rank: 91
score: 99.10965983072917
patch: Iterator < Point CaMeL Vector CaMeL Value CaMeL Pair > iter = current ;
rank: 91
score: 99.00275065104167
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current ;
rank: 91
score: 98.80169677734375
patch: ++ iter ; ++ max ; ++ iter ;
rank: 91
score: 98.7483243075284
patch: if ( ! is CaMeL Empty ( ) ) {
rank: 91
score: 98.73101043701172
patch: else { if ++ iter ; }
rank: 92
score: 99.20567975725446
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = true ;
rank: 92
score: 99.1844482421875
patch: Convergence CaMeL Checker ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ) ;
rank: 92
score: 99.1597541360294
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = checker ;
rank: 92
score: 99.15927269345238
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair {
rank: 92
score: 99.10756964432566
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Objective ) ;
rank: 92
score: 99.00228445870536
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair ++ ;
rank: 92
score: 98.87394714355469
patch: this . iter ; ++ iter ;
rank: 92
score: 98.7994384765625
patch: ++ iter ; ++ $STRING$ ;
rank: 92
score: 98.74693298339844
patch: ++ iter ; if ( ! ;
rank: 92
score: 98.72940826416016
patch: return iter ; } return iter ;
rank: 93
score: 99.2051289876302
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = ( Point CaMeL Vector CaMeL Value CaMeL Pair > ) current ;
rank: 93
score: 99.18381958007812
patch: return compute CaMeL Weighted CaMeL Jacobian ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 93
score: 99.15899658203125
patch: while ( true )
rank: 93
score: 99.10658365885416
patch: Iterator < Point CaMeL Vector CaMeL Value CaMeL Pair > iter = true ;
rank: 93
score: 99.0017578125
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , iter ;
rank: 93
score: 98.87344360351562
patch: ++ iter ; else return iter ;
rank: 93
score: 98.79932861328125
patch: ++ iter ; ++ iter ; for ++ ;
rank: 93
score: 98.74442232572116
patch: if ( Arrays . is CaMeL Empty ( iter ) ) {
rank: 93
score: 98.72858428955078
patch: if ( ! iter == 0 ;
rank: 94
score: 99.20488823784723
patch: weighted CaMeL Jacobian = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Objective ) ;
rank: 94
score: 99.18327530570652
patch: Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current CaMeL Point ;
rank: 94
score: 99.15822056361607
patch: ( ( Point CaMeL Vector CaMeL Value CaMeL Pair ) checker ) .
rank: 94
score: 99.10641479492188
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , 0 ) ;
rank: 94
score: 98.87228732638889
patch: ++ iter ; * ; ++ iter ;
rank: 94
score: 98.79876708984375
patch: / ++ iter ; ++ iter ;
rank: 94
score: 98.74258188100961
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; }
rank: 94
score: 98.72786712646484
patch: / * ++ ; ++ iter ;
rank: 95
score: 99.20350060096153
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = null ;
rank: 95
score: 99.18189348493304
patch: i = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 95
score: 99.15748087565105
patch: double [ ] current CaMeL Objective = current CaMeL Point ;
rank: 95
score: 99.10556265024039
patch: <= Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 95
score: 98.99946594238281
patch: ++ iter * / * / ;
rank: 95
score: 98.87162272135417
patch: ++ iter ; ++ ; int iter ;
rank: 95
score: 98.79730224609375
patch: ++ iter ; iter ;
rank: 95
score: 98.72725677490234
patch: / * * ++ ++ iter ;
rank: 96
score: 99.1815185546875
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair final = current ;
rank: 96
score: 99.15729437934027
patch: iter = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 96
score: 99.157177734375
patch: ++ iter ; final Convergence CaMeL Checker . compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 96
score: 99.10501861572266
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Cost ) ;
rank: 96
score: 98.99945831298828
patch: Iterator < Point CaMeL Vector CaMeL Value CaMeL Pair > iter = iter . ;
rank: 96
score: 98.87096405029297
patch: ++ iter ; try ; iter ;
rank: 96
score: 98.7914794921875
patch: ++ iter ; ++ 0 ; ++ iter ;
rank: 96
score: 98.741259765625
patch: final ; return new Point CaMeL Vector CaMeL Value CaMeL Pair ( ; }
rank: 96
score: 98.72644856770833
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + 1 , $STRING$ ;
rank: 97
score: 99.20020249310662
patch: int iter = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 97
score: 99.15427943638393
patch: iter = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 97
score: 99.10341796875
patch: Iterator < Point CaMeL Vector CaMeL Value CaMeL Pair > iter = iter ;
rank: 97
score: 98.99926039751838
patch: ++ iter ] = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , ;
rank: 97
score: 98.86933051215277
patch: ++ iter ; iter ; if iter ;
rank: 97
score: 98.78825160435268
patch: ++ iter ; ++ false ;
rank: 97
score: 98.73970540364583
patch: while ( ! iter . is CaMeL Empty ( ) )
rank: 97
score: 98.7263916015625
patch: else { this . iter = iter ; }
rank: 98
score: 99.18044115149456
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair qtf = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 98
score: 99.15282524956598
patch: boolean first CaMeL Iteration ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 98
score: 99.10283660888672
patch: p = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 98
score: 98.9986083984375
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , iter , ;
rank: 98
score: 98.86907196044922
patch: ++ iter ; ++ - $NUMBER$ ;
rank: 98
score: 98.78760375976563
patch: ++ $NUMBER$ ; ++ iter ; ++ iter ;
rank: 98
score: 98.73956976996527
patch: iter = iter . iterator ( ) ;
rank: 98
score: 98.72560813210227
patch: throw new Runtime CaMeL Exception ( $STRING$ + 1 ;
rank: 99
score: 99.19902111235119
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 99
score: 99.17957827919408
patch: it = final Point CaMeL Vector CaMeL Value CaMeL Pair . operate ( current CaMeL Residuals ) ;
rank: 99
score: 99.15363420758929
patch: Iterator iter = get CaMeL Weight CaMeL Square CaMeL Root ( ) ;
rank: 99
score: 99.151220703125
patch: boolean first CaMeL Iteration = checker . operate ( current CaMeL Point ) ;
rank: 99
score: 99.10252162388393
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( checker ) ;
rank: 99
score: 98.99847881610577
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair ;
rank: 99
score: 98.86881510416667
patch: ++ iter ; * ; int iter ;
rank: 99
score: 98.73726712740384
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current ;
rank: 99
score: 98.7247543334961
patch: if ( iter > $NUMBER$ ) {
rank: 100
score: 99.198720703125
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current ;
rank: 100
score: 99.17882428850446
patch: it = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 100
score: 99.15288543701172
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair copy = current ;
rank: 100
score: 99.10032435825893
patch: result = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 100
score: 98.99786376953125
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point . length ; ;
rank: 100
score: 98.86553192138672
patch: ++ iter ; final ++ iter ;
rank: 100
score: 98.73719133649554
patch: final int iter = iter ;
rank: 100
score: 98.72439575195312
patch: if ( ++ iter > 0 ;
rank: 101
score: 99.17827690972223
patch: qtf = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ;
rank: 101
score: 99.15271674262152
patch: weighted CaMeL Residual = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ,
rank: 101
score: 99.1491634971217
patch: check CaMeL Parameters ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ,
rank: 101
score: 99.0990219116211
patch: changed = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 101
score: 98.99725811298077
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( ;
rank: 101
score: 98.86173502604167
patch: ++ iter ; try { int iter ;
rank: 101
score: 98.78364780970982
patch: ++ iter ; iter -- ;
rank: 101
score: 98.73704310825893
patch: ++ iter ; throw new Illegal CaMeL State CaMeL Exception ( ) ;
rank: 101
score: 98.72341918945312
patch: ++ iter ; } return iter ;
rank: 102
score: 99.19768732244319
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = false ;
rank: 102
score: 99.17762822690217
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = Point CaMeL Vector CaMeL Value CaMeL Pair ;
rank: 102
score: 99.15190197172619
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Objective , current CaMeL Objective ) ) ;
rank: 102
score: 99.14903157552084
patch: double iter = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 102
score: 99.09842529296876
patch: found = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 102
score: 98.99623460036058
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair ;
rank: 102
score: 98.86056518554688
patch: ++ iter ; ; * * /
rank: 102
score: 98.77979387555804
patch: iter ++ ; ++ iter ;
rank: 102
score: 98.73676409040179
patch: final ; return new Point CaMeL Vector CaMeL Value CaMeL Pair ( ;
rank: 103
score: 99.17681884765625
patch: x CaMeL Norm = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 103
score: 99.15029009650735
patch: weighted CaMeL Jacobian ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 103
score: 99.09782409667969
patch: c = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 103
score: 98.99439290364583
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter ;
rank: 103
score: 98.77860260009766
patch: ++ iter ; ; iter / /
rank: 103
score: 98.73661804199219
patch: if ( iter != 0 ) {
rank: 103
score: 98.7198486328125
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ; } else {
rank: 104
score: 99.19731212797619
patch: Point CaMeL Vector CaMeL Value CaMeL Pair checker = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) current ;
rank: 104
score: 99.17681884765625
patch: ++ compute CaMeL Weighted CaMeL Jacobian ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 104
score: 99.14905894886364
patch: qr CaMeL Decomposition = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Objective ) ;
rank: 104
score: 99.09632110595703
patch: added = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 104
score: 98.99421961167279
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , iter ) ;
rank: 104
score: 98.85807037353516
patch: ++ iter ; while ++ 1 ;
rank: 104
score: 98.77402072482639
patch: ++ iter ; ++ iter ; ; /
rank: 104
score: 98.7361572265625
patch: if ( ! iter . is CaMeL Empty ( ) ) return null ;
rank: 104
score: 98.71951293945312
patch: else { / * ++ * /
rank: 105
score: 99.19722707648026
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Point ) ;
rank: 105
score: 99.1480712890625
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > {
rank: 105
score: 99.14771864149306
patch: qtf = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ,
rank: 105
score: 98.99376220703125
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point . trim ( ;
rank: 105
score: 98.85740152994792
patch: ++ iter ; / * ++ iter ;
rank: 105
score: 98.77330433238636
patch: ++ ++ iter ; ++ iter ; ++ iter ;
rank: 105
score: 98.7337890625
patch: ++ iter ; while ( Arrays . is CaMeL Empty ( ) ) {
rank: 105
score: 98.7180908203125
patch: if ( iter == 0 ; return null ;
rank: 106
score: 99.14710908777573
patch: int CaMeL Value ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 106
score: 99.14651150173611
patch: qr CaMeL Decomposition = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Objective ) ;
rank: 106
score: 99.09584350585938
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point . length ) ;
rank: 106
score: 98.99223327636719
patch: ++ iter ; return new Point CaMeL Vector CaMeL Value CaMeL Pair ( ; }
rank: 106
score: 98.85445827907986
patch: ++ iter ; * / ++ iter ;
rank: 106
score: 98.77321166992188
patch: ++ iter ; ++ iter ; while ++ ;
rank: 106
score: 98.73213704427083
patch: block = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter ) ;
rank: 106
score: 98.71714782714844
patch: * * * / ++ iter ;
rank: 107
score: 99.19695723684211
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Residuals ) ;
rank: 107
score: 99.17393663194444
patch: ++ qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 107
score: 99.09536743164062
patch: p = get CaMeL Weight CaMeL Square CaMeL Root ( current CaMeL Point ) ;
rank: 107
score: 98.99214895148026
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , iter ) ;
rank: 107
score: 98.77236106178977
patch: } ++ iter ; ++ iter ; ++ iter ;
rank: 107
score: 98.71629115513393
patch: ++ iter ; * * /
rank: 108
score: 99.19645552201705
patch: weighted CaMeL Jacobian = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Point ) ;
rank: 108
score: 99.1462466591283
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair += checker . operate ( current CaMeL Residuals ) ;
rank: 108
score: 99.14341107536765
patch: int n CaMeL R = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 108
score: 99.0950927734375
patch: retval = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 108
score: 98.99190266927083
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ;
rank: 108
score: 98.71620396205357
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + $NUMBER$ ) ;
rank: 109
score: 99.19549239309211
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current CaMeL Point [ iter ] ;
rank: 109
score: 99.17333221435547
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair max = current ;
rank: 109
score: 99.14535958426339
patch: qr CaMeL Decomposition ( current CaMeL Point , current CaMeL Objective ) ;
rank: 109
score: 99.142822265625
patch: boolean first CaMeL Iteration = this . compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 109
score: 99.09363555908203
patch: s = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 109
score: 98.9904849403783
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point . length , ;
rank: 109
score: 98.85219319661458
patch: ++ iter ; ++ iter + iter ;
rank: 109
score: 98.72900390625
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + iter ) ;
rank: 109
score: 98.71619415283203
patch: ++ [ ] 0 = iter ;
rank: 110
score: 99.19512261284723
patch: int [ ] current CaMeL Objective = get CaMeL Weight CaMeL Square CaMeL Root ( ) ;
rank: 110
score: 99.17293508429276
patch: qtf = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Point ) ;
rank: 110
score: 99.14410079152961
patch: qr CaMeL Decomposition = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ; }
rank: 110
score: 99.142578125
patch: double current CaMeL Objective = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 110
score: 99.09361267089844
patch: t = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 110
score: 98.98966471354167
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ;
rank: 110
score: 98.84966278076172
patch: / * ++ iter ; * /
rank: 110
score: 98.76994493272569
patch: ++ iter ; ++ ++ ++ iter ;
rank: 110
score: 98.72793344350961
patch: ++ iter ; Thread . current CaMeL Thread ( ) . ;
rank: 110
score: 98.7156494140625
patch: if ( . is CaMeL Empty ( ) ;
rank: 111
score: 99.17288368626645
patch: x CaMeL Norm = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ;
rank: 111
score: 99.14352596507354
patch: checker = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ; }
rank: 111
score: 99.1417236328125
patch: int iter = Point CaMeL Vector CaMeL Value CaMeL Pair . operate ( current CaMeL Residuals ) ;
rank: 111
score: 99.09239501953125
patch: tmp = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 111
score: 98.98934500558036
patch: ++ iter ; if ( ;
rank: 111
score: 98.84901936848958
patch: ++ iter ; / ; int iter ;
rank: 111
score: 98.72744750976562
patch: iter = Arrays . as CaMeL List ( iter ) ;
rank: 111
score: 98.71493869357639
patch: else { ++ [ 0 ] ; }
rank: 112
score: 99.1940585049716
patch: weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Point ) ;
rank: 112
score: 99.14309853001645
patch: weighted CaMeL Jacobian = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ; }
rank: 112
score: 99.09226989746094
patch: -- iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 112
score: 98.98878784179688
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ; ++ iter )
rank: 112
score: 98.76822916666667
patch: ++ iter ; ++ iter ; else }
rank: 113
score: 99.17176513671875
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Residuals ) ;
rank: 113
score: 99.14186789772727
patch: weighted CaMeL Jacobian = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Objective ) ;
rank: 113
score: 99.14090768914474
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = jac CaMeL Norm ;
rank: 113
score: 99.09071260340073
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ; }
rank: 113
score: 98.98858642578125
patch: ++ iter ] = ++ iter ;
rank: 113
score: 98.84574381510417
patch: ++ iter ; else * ++ iter ;
rank: 113
score: 98.76744079589844
patch: ++ iter ; iter * ; /
rank: 113
score: 98.72508021763393
patch: ++ iter ; Thread . current CaMeL Thread ( ) . ; }
rank: 113
score: 98.7130126953125
patch: } if ++ iter ;
rank: 114
score: 99.19352213541667
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current CaMeL Objective = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 114
score: 99.17105865478516
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair ++ = current ;
rank: 114
score: 99.14119466145833
patch: weighted CaMeL Residual = get CaMeL Weight CaMeL Square CaMeL Root ( ) ;
rank: 114
score: 99.14080132378473
patch: k = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 114
score: 99.08961704799107
patch: < Point CaMeL Vector CaMeL Value CaMeL Pair > current = current ;
rank: 114
score: 98.98769705636161
patch: ++ iter ] = new Point CaMeL Vector CaMeL Value CaMeL Pair ;
rank: 114
score: 98.84525844029018
patch: ++ iter ; ++ value ;
rank: 114
score: 98.76708306206598
patch: ++ iter ; ++ iter ; / *
rank: 114
score: 98.72301136363636
patch: if ( ++ n CaMeL C > 0 ) {
rank: 114
score: 98.71290588378906
patch: try { ++ iter ; * /
rank: 115
score: 99.19289679276316
patch: int current CaMeL Objective = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 115
score: 99.17015438988095
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = this . current CaMeL Point ;
rank: 115
score: 99.14035516036184
patch: ++ iter ; final Convergence CaMeL Checker . get CaMeL Weight CaMeL Square CaMeL Root ( ) .
rank: 115
score: 99.08805338541667
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Cost ) ;
rank: 115
score: 98.98765804893092
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point . trim ;
rank: 115
score: 98.84498426649306
patch: try { ++ iter ; ++ iter ;
rank: 115
score: 98.76652696397569
patch: ++ iter ; ++ iter ; ; ;
rank: 115
score: 98.72292751736111
patch: if ( iter == 0 ) break ;
rank: 115
score: 98.71289825439453
patch: ++ iter ; for ++ * /
rank: 116
score: 99.16929931640625
patch: Convergence CaMeL Checker . compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Residuals ) ;
rank: 116
score: 99.14030187270221
patch: weighted CaMeL Residual ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ) ;
rank: 116
score: 99.13996438419117
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = $STRING$ ;
rank: 116
score: 99.08590359157986
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point . length ) ;
rank: 116
score: 98.987060546875
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , iter ;
rank: 116
score: 98.84494357638889
patch: / * ++ iter ; int iter ;
rank: 116
score: 98.76561279296875
patch: ++ iter ; ++ iter ; if ++ ;
rank: 116
score: 98.7227313701923
patch: block = new Point CaMeL Vector CaMeL Value CaMeL Pair ( ;
rank: 117
score: 99.19261067708334
patch: ++ weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 117
score: 99.14017526726974
patch: Iterator iter = checker . weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Objective ) ;
rank: 117
score: 99.13752297794117
patch: pk = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ,
rank: 117
score: 99.08580258018092
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ; }
rank: 117
score: 98.98675178079044
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ;
rank: 117
score: 98.76504855685764
patch: ++ iter ; iter ; if ++ ;
rank: 117
score: 98.72261555989583
patch: ++ iter ; try {
rank: 117
score: 98.71261596679688
patch: ++ iter [ iter ] ; }
rank: 118
score: 99.19147491455078
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current CaMeL Point ,
rank: 118
score: 99.16788482666016
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair 0 = current ;
rank: 118
score: 99.13966369628906
patch: checker = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ,
rank: 118
score: 99.1357421875
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = first CaMeL Iteration ;
rank: 118
score: 99.08551025390625
patch: ( ( Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > )
rank: 118
score: 98.84261067708333
patch: ++ iter ; else ; int iter ;
rank: 118
score: 98.76460096571181
patch: ++ iter ; iter ; / / /
rank: 118
score: 98.7213134765625
patch: ++ iter ; if ( false ) {
rank: 118
score: 98.71155724158653
patch: throw new Runtime CaMeL Exception ( $STRING$ + iter + $STRING$ ;
rank: 119
score: 99.191162109375
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > current CaMeL Point = current ;
rank: 119
score: 99.16673278808594
patch: ( ( Point CaMeL Vector CaMeL Value CaMeL Pair ) current CaMeL Point ) ;
rank: 119
score: 99.13951873779297
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair name = current ;
rank: 119
score: 99.13557434082031
patch: double CaMeL Value = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 119
score: 98.98472086588542
patch: Iterator < Point CaMeL Vector CaMeL Value CaMeL Pair > iter = iter . iterator ( ;
rank: 119
score: 98.84129333496094
patch: ++ iter ; ; * * ;
rank: 119
score: 98.76358032226562
patch: ++ iter ; ; iter ++ ;
rank: 119
score: 98.72063337053571
patch: if ( iter == null )
rank: 119
score: 98.71072387695312
patch: ++ iter ; if ;
rank: 120
score: 99.19102567784927
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = null ;
rank: 120
score: 99.13825017755681
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ,
rank: 120
score: 99.13495744977679
patch: int iter = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 120
score: 99.083251953125
patch: x CaMeL Norm += weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ; }
rank: 120
score: 98.98452322823661
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , ;
rank: 120
score: 98.84088897705078
patch: ++ iter ; for ++ iter ;
rank: 120
score: 98.76304931640625
patch: ++ iter ; ++ iter ; / / ;
rank: 120
score: 98.7196044921875
patch: final int iter = Arrays . as CaMeL List ( iter ) ;
rank: 120
score: 98.7102279663086
patch: * * * * ++ iter ;
rank: 121
score: 99.1905453330592
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Point ) ;
rank: 121
score: 99.16654459635417
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = current CaMeL Point [ 0 ] ;
rank: 121
score: 99.13805541992187
patch: iter = get CaMeL Weight CaMeL Square CaMeL Root ( current CaMeL Point , current CaMeL Objective ) ;
rank: 121
score: 99.134521484375
patch: compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Point ) ;
rank: 121
score: 99.08277130126953
patch: other = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 121
score: 98.83857073102679
patch: ++ iter ; ++ $NUMBER$ ;
rank: 121
score: 98.71629231770834
patch: ++ iter ; Thread . current CaMeL Thread ( ) . wait ( ;
rank: 122
score: 99.18965076264881
patch: Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = null ;
rank: 122
score: 99.1370849609375
patch: checker = get CaMeL Weight CaMeL Square CaMeL Root ( current CaMeL Point , current CaMeL Objective ) ;
rank: 122
score: 99.13441975911458
patch: boolean first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ,
rank: 122
score: 99.08275604248047
patch: finished = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 122
score: 98.98004828559027
patch: ++ iter - 1 ; ++ iter ;
rank: 122
score: 98.83671739366319
patch: int iter ; ++ iter ; * /
rank: 122
score: 98.71204630533855
patch: ++ iter ; iter = iter . iterator ( ) ;
rank: 122
score: 98.7094393643466
patch: if ( . is CaMeL Empty ( ; ) ;
rank: 123
score: 99.18900390625
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ;
rank: 123
score: 99.16638764880952
patch: qtf = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Objective ) ;
rank: 123
score: 99.136865234375
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Objective , current CaMeL Objective ) ;
rank: 123
score: 99.13418399586396
patch: int current CaMeL Cost = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 123
score: 99.07987976074219
patch: success = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 123
score: 98.97942793996711
patch: ++ iter ] = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ;
rank: 123
score: 98.83546956380208
patch: ++ iter ; ++ * * iter ;
rank: 123
score: 98.76030883789062
patch: ++ iter ; ++ iter ; ; / /
rank: 123
score: 98.70940692608173
patch: throw new Unsupported CaMeL Operation CaMeL Exception ( $STRING$ ) ; }
rank: 123
score: 98.70928955078125
patch: else { return iter ; } }
rank: 124
score: 99.18896484375
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair > current = current ;
rank: 124
score: 99.13622174944196
patch: int iter = get CaMeL Weight CaMeL Square CaMeL Root ( ) ;
rank: 124
score: 99.07965850830078
patch: prev = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 124
score: 98.97920735677083
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current . get CaMeL Point ( ) ;
rank: 124
score: 98.75966574928977
patch: ++ iter ; ++ ++ 1 ; ++ iter ;
rank: 124
score: 98.70920817057292
patch: return ++ iter ; }
rank: 124
score: 98.7088955965909
patch: ++ iter ; Thread . sleep ( $NUMBER$ ) ;
rank: 125
score: 99.16502796519886
patch: Convergence CaMeL Checker = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Objective ) ;
rank: 125
score: 99.13597470238095
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 125
score: 99.13097381591797
patch: final Convergence CaMeL Checker compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 125
score: 99.0784912109375
patch: ret = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 125
score: 98.8329849243164
patch: / * ] iter = iter ;
rank: 125
score: 98.75879516601563
patch: ++ $STRING$ ; ++ iter ; ++ iter ;
rank: 125
score: 98.70680338541666
patch: ++ iter ; if ( ! iter . is CaMeL Empty ; ) {
rank: 125
score: 98.70586395263672
patch: if ( iter < 0 ) {
rank: 126
score: 99.16356360394022
patch: weighted CaMeL Residual = compute CaMeL Weighted CaMeL Jacobian ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 126
score: 99.13520951704545
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair ++ ;
rank: 126
score: 99.13066549862133
patch: boolean first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt ( current CaMeL Point ) ;
rank: 126
score: 99.07578735351562
patch: result = Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Objective ) ;
rank: 126
score: 98.97896575927734
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current ;
rank: 126
score: 98.75859917534723
patch: ++ iter ; ++ iter ; / }
rank: 126
score: 98.70530192057292
patch: ++ iter ; while ( true ) { ++ iter ;
rank: 126
score: 98.70439147949219
patch: else { / * * * /
rank: 127
score: 99.18837483723958
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current CaMeL Point ;
rank: 127
score: 99.13518928079044
patch: weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ,
rank: 127
score: 99.13028757195724
patch: Point CaMeL Vector CaMeL Value CaMeL Pair checker = current CaMeL Point [ current CaMeL Point ] ;
rank: 127
score: 99.07380894252232
patch: ( iter < Point CaMeL Vector CaMeL Value CaMeL Pair > ) {
rank: 127
score: 98.9780029296875
patch: Point CaMeL Vector CaMeL Value CaMeL Pair current = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter
rank: 127
score: 98.832275390625
patch: ++ iter ; ++ iter ; System . iter ;
rank: 127
score: 98.75839233398438
patch: ++ iter ; ++ iter ; throw iter ;
rank: 127
score: 98.7050048828125
patch: result = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter ) ;
rank: 128
score: 99.16304154829545
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = 0 ;
rank: 128
score: 99.13511827256944
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ) ; }
rank: 128
score: 99.0736083984375
patch: Iterator <= Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 128
score: 98.97775750411184
patch: int iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , iter ;
rank: 128
score: 98.83116658528645
patch: ++ iter ; try ;
rank: 128
score: 98.75835503472223
patch: ++ iter ; ++ iter ; ; }
rank: 128
score: 98.7048568725586
patch: ++ iter ? iter : iter ;
rank: 128
score: 98.70274353027344
patch: if ( iter < iter ) {
rank: 129
score: 99.18768310546875
patch: int current CaMeL Objective = get CaMeL Weight CaMeL Square CaMeL Root ( ) ;
rank: 129
score: 99.16281960227273
patch: qtf = compute CaMeL Weighted CaMeL Jacobian ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ) ;
rank: 129
score: 99.13457961309524
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , n CaMeL C ) ) ;
rank: 129
score: 99.12812243009868
patch: if ( compute CaMeL Weighted CaMeL Jacobian ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 129
score: 99.0732780905331
patch: found = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ; }
rank: 129
score: 98.7572509765625
patch: ++ iter ; ++ iter ; else iter ;
rank: 129
score: 98.70477294921875
patch: if ( ! iter . compare CaMeL To ( iter ) ) {
rank: 129
score: 98.70234680175781
patch: else { ++ -- iter ; }
rank: 130
score: 99.18727805397727
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = true ;
rank: 130
score: 99.16237386067708
patch: ++ iter ] = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 130
score: 99.1271260579427
patch: if ( n CaMeL C < n CaMeL C ) {
rank: 130
score: 99.07280939275569
patch: public Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > current = current ;
rank: 130
score: 98.97624655330883
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ; }
rank: 130
score: 98.83042907714844
patch: ++ iter ; ++ * false ;
rank: 130
score: 98.756103515625
patch: ++ iter ; ++ ++ iter ; }
rank: 130
score: 98.70303683810764
patch: if ( ! is CaMeL Empty ) {
rank: 130
score: 98.70069231305804
patch: if ( . is CaMeL Empty ( ) ) . ++ iter ;
rank: 131
score: 99.16106818704044
patch: ++ qr CaMeL Decomposition = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 131
score: 99.13340541294643
patch: Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > current = current ;
rank: 131
score: 99.0709228515625
patch: rs = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 131
score: 98.9757144325658
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , ; }
rank: 131
score: 98.82725524902344
patch: ++ 0 ; ++ iter ; ;
rank: 131
score: 98.755859375
patch: iter ; ++ iter ; ++ ;
rank: 131
score: 98.70291900634766
patch: ++ iter ; while ( true ;
rank: 131
score: 98.70043006310097
patch: if ( . is CaMeL Empty ( ) ) return null ;
rank: 132
score: 99.185810546875
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 132
score: 99.13197085731908
patch: weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Objective ) ; }
rank: 132
score: 99.06910118689903
patch: Iterator < Point CaMeL Vector CaMeL Value CaMeL Pair > checker ;
rank: 132
score: 98.97516190378289
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ; ++ iter )
rank: 132
score: 98.82577175564236
patch: int iter ; ++ iter + iter ;
rank: 132
score: 98.70281982421875
patch: ++ iter ; ++ iterator ;
rank: 132
score: 98.69905090332031
patch: ++ iter ; * * * ;
rank: 133
score: 99.18548177083333
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = current ; / *
rank: 133
score: 99.15938895089286
patch: it = compute CaMeL Weighted CaMeL Jacobian ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 133
score: 99.1313007061298
patch: Iterator iter = checker . operate ( current CaMeL Point ) ;
rank: 133
score: 99.12408447265625
patch: k = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 133
score: 99.0667724609375
patch: this . weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Objective ) ;
rank: 133
score: 98.97492327008929
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ iter , ;
rank: 133
score: 98.82559204101562
patch: ++ iter ; iter ; out ;
rank: 133
score: 98.70176866319444
patch: if ( iter == 0 ) continue ;
rank: 133
score: 98.69843292236328
patch: return new Object [ ] ; }
rank: 134
score: 99.18548029119319
patch: weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Residuals ) ;
rank: 134
score: 99.15936279296875
patch: ++ iter ; Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current ;
rank: 134
score: 99.13007146661931
patch: qr CaMeL Decomposition ( qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ) ;
rank: 134
score: 99.06652018229167
patch: Iterator < Point CaMeL Vector CaMeL Value CaMeL Pair > iter = checker ;
rank: 134
score: 98.8249282836914
patch: ++ iter ; ++ * $NUMBER$ ;
rank: 134
score: 98.74919976128473
patch: ++ iter ; ; iter if ++ ;
rank: 134
score: 98.7007568359375
patch: if ( this . iter != null ) {
rank: 134
score: 98.69783528645833
patch: if ( iter == 0 ; / ;
rank: 135
score: 99.18400772758152
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ,
rank: 135
score: 99.06642061121323
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point . length ) ;
rank: 135
score: 98.97173309326172
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ; }
rank: 135
score: 98.82489013671875
patch: ++ value ; ++ iter ;
rank: 135
score: 98.74661865234376
patch: ++ start ; ++ iter ; ++ iter ;
rank: 135
score: 98.69979422433036
patch: if ( ! iter . is CaMeL Empty ( ) ) { }
rank: 135
score: 98.69772774832589
patch: ++ iter ; while ; ;
rank: 136
score: 99.18248697916667
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair > checker ;
rank: 136
score: 99.12990500710227
patch: qr CaMeL Decomposition = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 136
score: 99.12286017922794
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = $NUMBER$ ;
rank: 136
score: 99.06557395241477
patch: private Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > current = current ;
rank: 136
score: 98.97052001953125
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , iter ;
rank: 136
score: 98.82452392578125
patch: / ] iter ; ++ iter ;
rank: 136
score: 98.74553765190973
patch: ++ iter ; ; ++ ++ iter ;
rank: 136
score: 98.69931640625
patch: ++ iter ; while ( ! iter . is CaMeL Empty ( ) )
rank: 136
score: 98.69762420654297
patch: if ( ! iter == $NUMBER$ ;
rank: 137
score: 99.1821819802989
patch: Point CaMeL Vector CaMeL Value CaMeL Pair checker = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Objective ) ;
rank: 137
score: 99.12940131293402
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , ) ) ;
rank: 137
score: 99.12217712402344
patch: double first CaMeL Iteration = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 137
score: 99.06434215198864
patch: n CaMeL R = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 137
score: 98.9698486328125
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point [ 0 ] ;
rank: 137
score: 98.82388916015626
patch: try { ++ iter ; } ++ iter ;
rank: 137
score: 98.74449920654297
patch: ++ iter ; ; return iter ;
rank: 137
score: 98.6973388671875
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ; } ++ iter ;
rank: 137
score: 98.696533203125
patch: ++ iter ; Thread . current CaMeL Thread ( ) . start ; }
rank: 138
score: 99.18202275815217
patch: Point CaMeL Vector CaMeL Value CaMeL Pair checker = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) current CaMeL Point ;
rank: 138
score: 99.15721299913194
patch: d = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 138
score: 99.12784830729167
patch: weighted CaMeL Residual ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ; }
rank: 138
score: 99.12164306640625
patch: compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 138
score: 98.96981048583984
patch: int iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point
rank: 138
score: 98.822314453125
patch: ++ iter ; try ; if ++ iter ;
rank: 138
score: 98.74447970920139
patch: ++ iter ; iter / / / /
rank: 138
score: 98.69579206194196
patch: final ; if ( ! iter . is CaMeL Empty ( ) )
rank: 138
score: 98.6941250887784
patch: if ( iter == null ; return iter ; }
rank: 139
score: 99.1272860440341
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair ) {
rank: 139
score: 99.12135823567708
patch: int iter = Point CaMeL Vector CaMeL Value CaMeL Pair . operate ( current CaMeL Point ,
rank: 139
score: 99.06102752685547
patch: found = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Objective ) ;
rank: 139
score: 98.96897259880515
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point . ;
rank: 139
score: 98.82193332248264
patch: ++ iter ; else { int iter ;
rank: 139
score: 98.74333360460069
patch: ++ iter ; iter ++ ; ++ ;
rank: 139
score: 98.69564115084134
patch: int iter = Arrays . as CaMeL List ( iter ) ;
rank: 139
score: 98.69397989908855
patch: else { throw new Runtime CaMeL Exception ( $STRING$ ; }
rank: 140
score: 99.18001708984374
patch: iter = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 140
score: 99.15603637695312
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair iter = current ;
rank: 140
score: 99.12659801136364
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ,
rank: 140
score: 99.12102912454044
patch: int compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 140
score: 99.0599365234375
patch: size = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 140
score: 98.96832682291667
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , iter , ;
rank: 140
score: 98.82170274522569
patch: ++ iter ; while iter ; 0 ;
rank: 140
score: 98.74310302734375
patch: ++ ++ iter ; ++ 1 ;
rank: 140
score: 98.69539969308036
patch: ++ iter ; if ( ! iter . is CaMeL Empty ; )
rank: 140
score: 98.69293975830078
patch: else { / * = iter ;
rank: 141
score: 99.17954323508523
patch: Point CaMeL Vector CaMeL Value CaMeL Pair current = ( Point CaMeL Vector CaMeL Value CaMeL Pair > ) current ;
rank: 141
score: 99.156005859375
patch: int CaMeL Value = final Point CaMeL Vector CaMeL Value CaMeL Pair . operate ( current CaMeL Point ) ;
rank: 141
score: 99.12564086914062
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair value = current ;
rank: 141
score: 99.12067413330078
patch: final Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker =
rank: 141
score: 99.05977199388587
patch: comparator . qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ) ;
rank: 141
score: 98.96830444335937
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = new Point CaMeL Vector CaMeL Value CaMeL Pair (
rank: 141
score: 98.82122802734375
patch: ++ iter ; start - iter ;
rank: 141
score: 98.69482421875
patch: final ; if ( ! iter . is CaMeL Empty ( ) ;
rank: 142
score: 99.12543801700367
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) .
rank: 142
score: 99.05839206861413
patch: if ( weight CaMeL Matrix CaMeL Sqrt . weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ) {
rank: 142
score: 98.9675537109375
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( ; }
rank: 142
score: 98.82094319661458
patch: / * ++ iter ; / / /
rank: 142
score: 98.74266052246094
patch: ++ iter ; ; -- iter ;
rank: 142
score: 98.69144439697266
patch: * * * ; ++ iter ;
rank: 143
score: 99.17759399414062
patch: double [ ] current CaMeL Objective = 0 ;
rank: 143
score: 99.15591430664062
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Residuals , current CaMeL Objective ) ;
rank: 143
score: 98.96737670898438
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current . ++ , ;
rank: 143
score: 98.82065158420139
patch: ++ iter ; * * int iter ;
rank: 143
score: 98.74102228338069
patch: ++ iter ; ++ iter ; / -- iter ;
rank: 143
score: 98.6935791015625
patch: if ( ! iter [ 0 ] . equals CaMeL Ignore CaMeL Case ;
rank: 143
score: 98.69135284423828
patch: } if ++ iter > 0 ;
rank: 144
score: 99.15440063476562
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = current CaMeL Point [ current CaMeL Residuals ] ;
rank: 144
score: 99.12514426491477
patch: weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Objective , current CaMeL Objective ) ;
rank: 144
score: 99.11888292100694
patch: final Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = null ;
rank: 144
score: 99.05769617417279
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , 0 ) ;
rank: 144
score: 98.96653747558594
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current . ++ ; }
rank: 144
score: 98.6931640625
patch: ++ iter ; if ( old CaMeL Obj . length > 0 ) {
rank: 144
score: 98.69110107421875
patch: return this ; } ++ iter ;
rank: 145
score: 99.175048828125
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair current CaMeL Objective = current ;
rank: 145
score: 99.12490362870066
patch: weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ; }
rank: 145
score: 99.11792710248162
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > current = current ;
rank: 145
score: 99.05709838867188
patch: [ ] weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 145
score: 98.96619937294408
patch: int iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point . length ;
rank: 145
score: 98.81892225477431
patch: int iter ; try ; ++ iter ;
rank: 145
score: 98.73998151506696
patch: ++ iter ; ++ true ;
rank: 145
score: 98.69295043945313
patch: ++ iter ; if ( iter == 0 )
rank: 145
score: 98.69068145751953
patch: ++ iter ; return ++ iter ;
rank: 146
score: 99.17405395507812
patch: weighted CaMeL Jacobian = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 146
score: 99.12300618489583
patch: weighted CaMeL Residual = get CaMeL Weight CaMeL Square CaMeL Root ( current CaMeL Residuals ) ;
rank: 146
score: 99.056884765625
patch: if ( true ) {
rank: 146
score: 98.96450323807566
patch: ++ iter ] = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , ;
rank: 146
score: 98.81886800130208
patch: ++ iter ; int iter ; * /
rank: 146
score: 98.738818359375
patch: ++ iter ; ++ iter ; iter ; }
rank: 146
score: 98.69283040364583
patch: ++ iter ; Thread . current CaMeL Thread ( ) . stop ( ;
rank: 146
score: 98.69052463107639
patch: else { if ( iter > 0 ;
rank: 147
score: 99.15315551757813
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = current CaMeL Point [ current CaMeL Objective ] ;
rank: 147
score: 99.12249755859375
patch: / / compute CaMeL Cost ( current CaMeL Objective ) ;
rank: 147
score: 99.0567118326823
patch: Iterator < Point CaMeL Vector CaMeL Value CaMeL Pair > ;
rank: 147
score: 98.96326446533203
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ current CaMeL Point ;
rank: 147
score: 98.81778971354167
patch: this . ++ iter ; ++ iter ; ++ iter ;
rank: 147
score: 98.73869493272569
patch: ++ ( ++ iter ; ++ iter ;
rank: 147
score: 98.69268798828125
patch: ++ n CaMeL R ; ++ iter ;
rank: 147
score: 98.68995666503906
patch: ++ iter ; ++ * * /
rank: 148
score: 99.17352294921875
patch: double [ ] current CaMeL Objective = weight CaMeL Matrix CaMeL Sqrt . operate (
rank: 148
score: 99.15284365699405
patch: i = compute CaMeL Weighted CaMeL Jacobian ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 148
score: 99.12241617838542
patch: / * compute CaMeL Cost ( current CaMeL Objective ) ;
rank: 148
score: 99.11774359809027
patch: boolean qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 148
score: 99.05634099786931
patch: x CaMeL Norm += weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 148
score: 98.9629150390625
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , iter ) ;
rank: 148
score: 98.81614854600694
patch: ++ iter ; / ; ++ iter ;
rank: 148
score: 98.73661586216518
patch: ++ iter ; ++ Math ;
rank: 148
score: 98.6923828125
patch: ++ iter ; if ( ! iter . ;
rank: 148
score: 98.68935139973958
patch: if ( . is CaMeL Empty ( ) ) return ;
rank: 149
score: 99.17096819196429
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = new Point CaMeL Vector CaMeL Value CaMeL Pair (
rank: 149
score: 99.15224387428977
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair final = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 149
score: 99.12199571397569
patch: weighted CaMeL Residual = get CaMeL Weight CaMeL Square CaMeL Root ( current CaMeL Objective ) ;
rank: 149
score: 99.11595394736842
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = checker . current ;
rank: 149
score: 99.05520762567934
patch: if ( weight CaMeL Matrix CaMeL Sqrt . weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ) {
rank: 149
score: 98.8159408569336
patch: ++ iter ; iter + 0 ;
rank: 149
score: 98.73590959821429
patch: ++ iter ; ++ this ;
rank: 149
score: 98.69132080078126
patch: if ( ! is CaMeL Empty ( ) )
rank: 149
score: 98.68763427734375
patch: if ( iter == null ; return iter ;
rank: 150
score: 99.170947265625
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current CaMeL Objective = current ;
rank: 150
score: 99.15201822916667
patch: Convergence CaMeL Checker ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Residuals ) ) ;
rank: 150
score: 99.11555561266448
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = diag CaMeL R ;
rank: 150
score: 98.96123504638672
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current . ;
rank: 150
score: 98.81590053013393
patch: ++ iter ; return iter ;
rank: 150
score: 98.73511505126953
patch: iter else ++ ; ++ iter ;
rank: 150
score: 98.69126383463542
patch: if ( ! iter . is CaMeL Empty ( ; )
rank: 150
score: 98.6868896484375
patch: else { ++ iter ; * ;
rank: 151
score: 99.16891479492188
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = new Point CaMeL Vector CaMeL Value CaMeL Pair (
rank: 151
score: 99.15152994791667
patch: ++ iter = Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker ;
rank: 151
score: 99.1146304481908
patch: weighted CaMeL Residual = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ,
rank: 151
score: 99.05435884915866
patch: Iterator < Point CaMeL Vector CaMeL Value CaMeL Pair > iter ;
rank: 151
score: 98.96104431152344
patch: ++ iter ] = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter ;
rank: 151
score: 98.81398228236607
patch: ++ iter ; synchronized iter ;
rank: 151
score: 98.73463948567708
patch: iter ++ ; ++ ; ++ iter ;
rank: 151
score: 98.69078369140625
patch: ++ iter ; if ( iter != 0 )
rank: 151
score: 98.68675231933594
patch: ++ < 0 ; ++ iter ;
rank: 152
score: 99.16846865699405
patch: qtf = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Point ) ;
rank: 152
score: 99.15086669921875
patch: qr CaMeL Decomposition = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Residuals ) ;
rank: 152
score: 99.12022489659927
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair
rank: 152
score: 99.11324912623355
patch: Point CaMeL Vector CaMeL Value CaMeL Pair checker = current CaMeL Point [ current CaMeL Point ) ;
rank: 152
score: 99.05374145507812
patch: tmp = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Objective ) ;
rank: 152
score: 98.96025085449219
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , iter ;
rank: 152
score: 98.81351725260417
patch: / * ] iter ; int iter ;
rank: 152
score: 98.73308715820312
patch: ++ iter ; ++ $STRING$ ; ++ iter ;
rank: 152
score: 98.6906026204427
patch: if ( ! iter . contains ( current ) ) {
rank: 152
score: 98.68657684326172
patch: ++ iter ; for ; ) {
rank: 153
score: 99.16810021033653
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair value = current ;
rank: 153
score: 99.15020141601562
patch: qtf . qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ) ;
rank: 153
score: 99.1183853149414
patch: while ( iter < get CaMeL Weight CaMeL Square CaMeL Root ( ) ) {
rank: 153
score: 99.11307525634766
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker [ ;
rank: 153
score: 99.05373313210227
patch: protected Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > current = current ;
rank: 153
score: 98.95962524414062
patch: result [ iter ] = new Point CaMeL Vector CaMeL Value CaMeL Pair ( ;
rank: 153
score: 98.80829620361328
patch: ++ iter ; * - iter ;
rank: 153
score: 98.73306274414062
patch: ++ iter ; iter / / = iter ;
rank: 153
score: 98.6884521484375
patch: if ( ! iter [ 0 ] . is CaMeL Empty ( ) ;
rank: 153
score: 98.6864501953125
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + 1 ) ; }
rank: 154
score: 99.16802657277961
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Residuals ) ;
rank: 154
score: 99.14969675164474
patch: int CaMeL Value = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Residuals ) ;
rank: 154
score: 99.05317993164063
patch: this . weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Cost ) ;
rank: 154
score: 98.80818684895833
patch: ++ iter ; if iter + iter ;
rank: 154
score: 98.73261108398438
patch: ++ iter ; ; if iter = iter ;
rank: 154
score: 98.68825461647727
patch: ++ iter ; while ( iter . ; ) {
rank: 154
score: 98.68643951416016
patch: if ( iter ; > 1 ;
rank: 155
score: 99.16734375
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ;
rank: 155
score: 99.1114501953125
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = current CaMeL Point [ iter ] ;
rank: 155
score: 99.05107678865132
patch: x CaMeL Norm += weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ; }
rank: 155
score: 98.9580307006836
patch: ++ iter * / * * ;
rank: 155
score: 98.80649820963542
patch: ++ iter ; while iter + iter ;
rank: 155
score: 98.73007202148438
patch: ++ ! iter ; ++ iter ;
rank: 155
score: 98.68821498325893
patch: ++ iter ; Thread . current CaMeL Thread ( ) . stop ;
rank: 155
score: 98.68582153320312
patch: if ( iter >= iter ) {
rank: 156
score: 99.16665251358695
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = new Point CaMeL Vector CaMeL Value CaMeL Pair * current ;
rank: 156
score: 99.1163265830592
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Residuals ) ;
rank: 156
score: 99.11137120863971
patch: Point CaMeL Vector CaMeL Value CaMeL Pair checker = current CaMeL Point [ 0 ] ;
rank: 156
score: 99.05081787109376
patch: comparator . qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ; }
rank: 156
score: 98.95759662828948
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , 0 ;
rank: 156
score: 98.80601501464844
patch: ++ iter ; else iter out ;
rank: 156
score: 98.7282943725586
patch: ++ 1 ; ; ++ iter ;
rank: 156
score: 98.6878662109375
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( this ) ;
rank: 156
score: 98.68508911132812
patch: if ( iter > 0 ; return null ;
rank: 157
score: 99.16657104492188
patch: i = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 157
score: 99.14881243024554
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair $NUMBER$ checker = current ;
rank: 157
score: 99.11067708333333
patch: checker = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 157
score: 99.0501708984375
patch: Iterator < Point CaMeL Vector CaMeL Value CaMeL Pair > iter = 0 ;
rank: 157
score: 98.95638020833333
patch: inst = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point . length ;
rank: 157
score: 98.80570068359376
patch: ++ iter ; else
rank: 157
score: 98.72808283025569
patch: ++ iter ; iter ; ++ ; ++ iter ;
rank: 157
score: 98.68735177176339
patch: ++ iter ; throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ;
rank: 157
score: 98.68495178222656
patch: return iter ; } return false ;
rank: 158
score: 99.14879692925348
patch: Convergence CaMeL Checker = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 158
score: 99.11512756347656
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair add = current ;
rank: 158
score: 99.11011614118304
patch: if ( current CaMeL Point . length < n CaMeL R ) {
rank: 158
score: 99.04685668945312
patch: [ ] weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 158
score: 98.95616149902344
patch: inst = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ;
rank: 158
score: 98.80546739366319
patch: ++ iter ; try { if iter ;
rank: 158
score: 98.72694227430556
patch: ++ iter ; ++ iter ; try /
rank: 159
score: 99.16562721946023
patch: Point CaMeL Vector CaMeL Value CaMeL Pair > checker = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) current ;
rank: 159
score: 99.11473446800595
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = weight CaMeL Matrix CaMeL Sqrt .
rank: 159
score: 99.10892980238971
patch: boolean qr CaMeL Decomposition = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 159
score: 99.04596557617188
patch: protected Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > do {
rank: 159
score: 98.95562385110294
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , iter ) ;
rank: 159
score: 98.80506727430556
patch: ++ iter ; if iter ; iter ;
rank: 159
score: 98.72685102982955
patch: ++ iter ; ++ iter ; -- iter ; }
rank: 159
score: 98.68546549479167
patch: if ( ! iter [ 0 ] . is CaMeL Empty ( ) )
rank: 159
score: 98.68391557173295
patch: ++ < 0 > iter = iter . length ;
rank: 160
score: 99.16559307391827
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair new = current ;
rank: 160
score: 99.11472681949013
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point . length ) ) ;
rank: 160
score: 99.1082763671875
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > = current ;
rank: 160
score: 99.04588681175595
patch: result = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Objective ) ;
rank: 160
score: 98.95547049386161
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter ;
rank: 160
score: 98.803466796875
patch: ++ iter ; / * * ; /
rank: 160
score: 98.72254028320313
patch: ++ true ; ++ iter ; ++ iter ;
rank: 160
score: 98.6837491122159
patch: if ( iter > 0 ; return iter ; }
rank: 161
score: 99.1652599516369
patch: int [ ] current CaMeL Objective = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 161
score: 99.14734497070313
patch: current CaMeL Point = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 161
score: 99.11445697985198
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair = checker . operate ( current CaMeL Objective ) ;
rank: 161
score: 99.10824584960938
patch: int qr CaMeL Decomposition = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 161
score: 99.04588623046875
patch: [ ] weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 161
score: 98.95352172851562
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current ; ;
rank: 161
score: 98.80177001953125
patch: ++ iter ; try { ++ iter ; ;
rank: 161
score: 98.72223455255681
patch: ++ new ++ ; ++ iter ; ++ iter ;
rank: 161
score: 98.68299865722656
patch: ++ iter - iter - iter ;
rank: 162
score: 99.16413959703948
patch: double current CaMeL Objective = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 162
score: 99.11436244419643
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , compute CaMeL Weighted CaMeL Jacobian (
rank: 162
score: 99.10706922743056
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = current CaMeL Point [ iter ] ;
rank: 162
score: 99.04586659307066
patch: this . qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ) ;
rank: 162
score: 98.95107550370066
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , $NUMBER$ ;
rank: 162
score: 98.801025390625
patch: ++ iter ; ++ - * ;
rank: 162
score: 98.72180853949652
patch: ++ iter ; ; ++ iter ; else
rank: 163
score: 99.11395554315476
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair >
rank: 163
score: 99.10701751708984
patch: compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Residuals ) ;
rank: 163
score: 99.04581705729167
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , iter ) ;
rank: 163
score: 98.9496826171875
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , iter ;
rank: 163
score: 98.7210693359375
patch: ++ iter ; iter / * ++ iter ;
rank: 163
score: 98.68339029947917
patch: / * * * ; ++ iter ;
rank: 163
score: 98.68208451704545
patch: ++ iter ; System . exit ( 0 ) ;
rank: 164
score: 99.16322678786058
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair max = current ;
rank: 164
score: 99.11247702205883
patch: if ( checker . compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) {
rank: 164
score: 99.10518391927083
patch: return compute CaMeL Weighted CaMeL Jacobian ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 164
score: 99.04564490685097
patch: ! compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 164
score: 98.94963836669922
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , ;
rank: 164
score: 98.79798126220703
patch: / * ] iter ; * /
rank: 164
score: 98.72083629261364
patch: ++ iter ; ++ iter ; iter ; ++ ;
rank: 164
score: 98.6833724975586
patch: return new Object [ iter ] ;
rank: 164
score: 98.680712890625
patch: r = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter ) ;
rank: 165
score: 99.14486083984374
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = current CaMeL Point [ current CaMeL Point ) ;
rank: 165
score: 99.10514322916667
patch: compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ,
rank: 165
score: 99.04445393880208
patch: x CaMeL Norm += weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Objective ) ;
rank: 165
score: 98.94899204799107
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ iter ;
rank: 165
score: 98.79551696777344
patch: ++ iter ; ++ ( iter ;
rank: 165
score: 98.71974400111607
patch: ++ max ; ++ iter ;
rank: 165
score: 98.68140326605902
patch: if ( iter > 0 ; / ;
rank: 165
score: 98.68053089488636
patch: if ( ! iter . contains ( iter ) )
rank: 166
score: 99.11214192708333
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current CaMeL Point . length ;
rank: 166
score: 99.10508817784927
patch: double current CaMeL Point = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 166
score: 99.04435591264205
patch: this . weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , 0 ) ;
rank: 166
score: 98.94878472222223
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current ;
rank: 166
score: 98.79271782769098
patch: ++ iter ; ++ iter ; continue ;
rank: 166
score: 98.71914672851562
patch: ++ iter ; ; ++ start ;
rank: 166
score: 98.68050130208333
patch: if ( . is CaMeL Empty ( ) ) continue ;
rank: 167
score: 99.15940551757812
patch: it = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 167
score: 99.11208274147727
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) checker ;
rank: 167
score: 99.10446648848684
patch: x CaMeL Norm = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ,
rank: 167
score: 99.04292224702381
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Objective ) ; }
rank: 167
score: 98.94852905273437
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ;
rank: 167
score: 98.79258219401042
patch: super . ++ iter ; ++ iter ;
rank: 167
score: 98.71773274739583
patch: ++ iter ; ++ iter ; } else
rank: 167
score: 98.67974853515625
patch: return ++ [ 0 ] ;
rank: 167
score: 98.679443359375
patch: if ( ! iter . is CaMeL Empty ( ; ; ) {
rank: 168
score: 99.14422200520833
patch: qtf = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Objective ) ;
rank: 168
score: 99.11125946044922
patch: / * compute CaMeL Cost ( current CaMeL Point , current CaMeL Objective ) ;
rank: 168
score: 99.10392038445724
patch: boolean first CaMeL Iteration = Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > ;
rank: 168
score: 99.04187729779412
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , iter ) ;
rank: 168
score: 98.94755859375
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , iter ; ;
rank: 168
score: 98.79230608258929
patch: int iter ; ++ iter ;
rank: 168
score: 98.67933654785156
patch: / * * * ++ iter /
rank: 168
score: 98.67921549479166
patch: ++ iter ; while ( super . is CaMeL Empty ( ) ) {
rank: 169
score: 99.15913696289063
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = current CaMeL Point [ current CaMeL Point ] ;
rank: 169
score: 99.143994140625
patch: n CaMeL R = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 169
score: 99.10354434742646
patch: double qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ,
rank: 169
score: 99.04176161024306
patch: found = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , 0 ) ;
rank: 169
score: 98.78952026367188
patch: ++ iter ; if ++ 1 ;
rank: 169
score: 98.71687825520833
patch: ++ iter ; ; if ++ 1 ;
rank: 169
score: 98.67667061941964
patch: else ++ ++ iter ; }
rank: 170
score: 99.1582919034091
patch: Point CaMeL Vector CaMeL Value CaMeL Pair > checker = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 170
score: 99.04075985863095
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( weight CaMeL Matrix CaMeL Sqrt . operate ( ) ) ;
rank: 170
score: 98.9466488486842
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , $STRING$ ;
rank: 170
score: 98.71636090959821
patch: ++ iter ; iter / /
rank: 170
score: 98.67835150824652
patch: ++ iter 1 [ iter 1 ] ;
rank: 170
score: 98.6761703491211
patch: return iter ;
rank: 171
score: 99.14341334292763
patch: Convergence CaMeL Checker = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ;
rank: 171
score: 99.11051860608552
patch: Iterator iter = checker . get CaMeL Weight CaMeL Square CaMeL Root ( current CaMeL Residuals ) ;
rank: 171
score: 99.10284782858456
patch: Convergence CaMeL Checker checker = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 171
score: 99.04019504123264
patch: n CaMeL R = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Objective ) ;
rank: 171
score: 98.94620768229167
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ;
rank: 171
score: 98.71480887276786
patch: ++ iter ; ; / /
rank: 171
score: 98.67788899739584
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , current ;
rank: 171
score: 98.67612711588542
patch: ++ * ++ iter ;
rank: 172
score: 99.15728759765625
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = current CaMeL Point [ n CaMeL R ] ;
rank: 172
score: 99.14248318142361
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair current CaMeL Residuals = current ;
rank: 172
score: 99.10992140997024
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > < Point CaMeL Vector CaMeL Value CaMeL Pair
rank: 172
score: 99.1026382446289
patch: int qtf = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 172
score: 99.03923950195312
patch: result = weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 172
score: 98.94597311580883
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , ++ n CaMeL C ;
rank: 172
score: 98.71370849609374
patch: ++ iter ; ++ iter ; ++ 0 ;
rank: 172
score: 98.67708042689732
patch: if ( ! iter . starts CaMeL With ( iter ) ) {
rank: 172
score: 98.67598876953124
patch: ++ iter ; else { ++ iter ; }
rank: 173
score: 99.1571628736413
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > checker ;
rank: 173
score: 99.14178466796875
patch: ++ iter = final Point CaMeL Vector CaMeL Value CaMeL Pair . operate ( current CaMeL Point ) ;
rank: 173
score: 99.1096923828125
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair < int ;
rank: 173
score: 99.10250693873355
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > current CaMeL Point = current ;
rank: 173
score: 99.03874067826705
patch: n CaMeL C = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 173
score: 98.94550916883681
patch: ++ iter ] = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ;
rank: 173
score: 98.78436279296875
patch: } ++ iter ; int iter ;
rank: 173
score: 98.71351928710938
patch: ++ iter ; ++ iter ; else / /
rank: 173
score: 98.67565104166667
patch: if ( ! iter . is CaMeL Empty ( ) ; ++ iter )
rank: 173
score: 98.67562430245536
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ; ++ iter ;
rank: 174
score: 99.15707397460938
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = current CaMeL Point [ n CaMeL C ] ;
rank: 174
score: 99.14075469970703
patch: qr CaMeL Decomposition = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ;
rank: 174
score: 99.10966564360119
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair ;
rank: 174
score: 99.1020443564967
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = this . get ;
rank: 174
score: 98.94469604492187
patch: int iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , iter ) ;
rank: 174
score: 98.7840805053711
patch: ++ iter ; ++ iter ; int
rank: 174
score: 98.6748934659091
patch: else { throw new Runtime CaMeL Exception ++ ; }
rank: 174
score: 98.67478590745192
patch: result = new Point CaMeL Vector CaMeL Value CaMeL Pair ( ;
rank: 175
score: 99.14072552849265
patch: else qr CaMeL Decomposition = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ;
rank: 175
score: 99.10906982421875
patch: ++ true ; final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair
rank: 175
score: 99.03818230879934
patch: n CaMeL R = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ; }
rank: 175
score: 98.94438620174633
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ,
rank: 175
score: 98.78397623697917
patch: / * ] iter ;
rank: 175
score: 98.71284993489583
patch: ++ iter ; iter if iter ++ ;
rank: 175
score: 98.67445373535156
patch: / * * * ++ ; /
rank: 175
score: 98.67442321777344
patch: int iter = iter - iter ;
rank: 176
score: 99.1568539268092
patch: int current CaMeL Objective = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Objective ) ;
rank: 176
score: 99.14070209703948
patch: Point CaMeL Vector CaMeL Value CaMeL Pair current = current CaMeL Point [ current CaMeL Objective ] ;
rank: 176
score: 99.10866292317708
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ; ;
rank: 176
score: 99.0380626860119
patch: this . weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ; }
rank: 176
score: 98.94303171258224
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current . get CaMeL Point ( ) ;
rank: 176
score: 98.7835205078125
patch: this . ++ iter ; ++ iter ; ;
rank: 176
score: 98.71230246803977
patch: ++ iter ; ++ iter ; else -- iter ;
rank: 176
score: 98.67416381835938
patch: if ( ! iter . contains ( iter ) ) {
rank: 176
score: 98.673583984375
patch: ++ < 0 > iter * /
rank: 177
score: 99.15678325452302
patch: int current CaMeL Objective = get CaMeL Weight CaMeL Square CaMeL Root ( current CaMeL Point ) ;
rank: 177
score: 99.14057849702381
patch: qtf = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Residuals ) ;
rank: 177
score: 99.10111730238971
patch: return compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Point ) ;
rank: 177
score: 99.0378085049716
patch: x CaMeL Norm = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 177
score: 98.78337097167969
patch: ++ iter ; for iter ; ;
rank: 177
score: 98.71070556640625
patch: ++ iter ; ++ false ; ++ iter ;
rank: 177
score: 98.67401123046875
patch: ++ iter ; throw new Illegal CaMeL State CaMeL Exception ( $STRING$ ;
rank: 177
score: 98.6732666015625
patch: else { ++ iter ; } return iter ;
rank: 178
score: 99.15623563878677
patch: int iter = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 178
score: 99.10813210227273
patch: ++ iter ; final Convergence CaMeL Checker . get CaMeL Weight CaMeL Square CaMeL Root ( current CaMeL Residuals ) ;
rank: 178
score: 99.10043816817434
patch: Point CaMeL Vector CaMeL Value CaMeL Pair checker = current CaMeL Point [ current CaMeL Objective ] ;
rank: 178
score: 99.03759765625
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Residuals ) ;
rank: 178
score: 98.94240025111607
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ iter ) ;
rank: 178
score: 98.78321184430804
patch: ++ iter ; int 1 ;
rank: 178
score: 98.71018288352273
patch: ++ iter ; ++ iter ; ; -- iter ;
rank: 178
score: 98.67290496826172
patch: return new ? ( ++ iter ;
rank: 178
score: 98.67265625
patch: final ; return new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter ;
rank: 179
score: 99.15615012428977
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair list = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) current ;
rank: 179
score: 99.14008246527777
patch: list = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 179
score: 99.1081210049716
patch: weighted CaMeL Residual = get CaMeL Weight CaMeL Square CaMeL Root ( current CaMeL Point , n CaMeL C ) ;
rank: 179
score: 99.10008329503677
patch: iter = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ,
rank: 179
score: 99.03688401442308
patch: Iterator Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 179
score: 98.94239807128906
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ n CaMeL R ;
rank: 179
score: 98.78288269042969
patch: ++ 1 ; ++ iter ; ;
rank: 179
score: 98.70820617675781
patch: ++ ( iter ; ++ iter ;
rank: 179
score: 98.67269193209134
patch: if ( ! 0 . is CaMeL Empty ( ) ) {
rank: 179
score: 98.67235107421875
patch: if ( iter < n CaMeL C ) {
rank: 180
score: 99.15607561383929
patch: final final Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 180
score: 99.13918235085227
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ;
rank: 180
score: 99.10665893554688
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair arraycopy = current ;
rank: 180
score: 99.09972272600446
patch: / * Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 180
score: 99.03668767755681
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) . operate ( current CaMeL Residuals ) ;
rank: 180
score: 98.94182739257812
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point . length ; }
rank: 180
score: 98.78272247314453
patch: catch ++ iter ; ++ iter ;
rank: 180
score: 98.7080307006836
patch: ++ iter ; ++ ! iter ;
rank: 180
score: 98.67135620117188
patch: if ( . is CaMeL Empty ( ) ) break ;
rank: 181
score: 99.15594773065476
patch: double [ ] current CaMeL Residuals = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 181
score: 99.10638718377976
patch: checker = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Objective ) ;
rank: 181
score: 99.03629150390626
patch: list = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 181
score: 98.94176567925348
patch: int iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , iter ) ;
rank: 181
score: 98.78193969726563
patch: ++ iter ; try { ++ iter ; }
rank: 181
score: 98.70693969726562
patch: ++ iter ; iter * ++ ;
rank: 181
score: 98.67214731069711
patch: ++ iter ; throw new Illegal CaMeL State CaMeL Exception ( ;
rank: 181
score: 98.67115783691406
patch: else { ++ iter * iter ;
rank: 182
score: 99.10620835248162
patch: weighted CaMeL Residual ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Objective ) ) ;
rank: 182
score: 99.09817843967014
patch: return weighted CaMeL Residual ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 182
score: 99.0361328125
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Point ) ;
rank: 182
score: 98.94143194901316
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , 1 ;
rank: 182
score: 98.78074645996094
patch: ++ iter ; else - iter ;
rank: 182
score: 98.7067642211914
patch: iter ; ++ iter ; / /
rank: 182
score: 98.67213134765625
patch: if ( iter >= n CaMeL C ) {
rank: 182
score: 98.67115020751953
patch: return new ++ [ iter ] ;
rank: 183
score: 99.15561745383523
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) true ;
rank: 183
score: 99.13822428385417
patch: qtf = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Residuals ) ;
rank: 183
score: 99.10599975585937
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > { {
rank: 183
score: 99.09813017003677
patch: k = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ,
rank: 183
score: 99.0347412109375
patch: public Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > do {
rank: 183
score: 98.94140014648437
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , ++ iter ;
rank: 183
score: 98.78063201904297
patch: ++ iter ; ++ * ; ;
rank: 183
score: 98.70586603338069
patch: ++ iter ; ++ iter ; return iter ; }
rank: 183
score: 98.67128499348958
patch: ++ iter ; if ( ! is CaMeL Empty ) {
rank: 183
score: 98.670654296875
patch: ++ iter ; return false ; }
rank: 184
score: 99.15510864257813
patch: double [ ] current CaMeL Objective = null ;
rank: 184
score: 99.096923828125
patch: int [ ] current CaMeL Objective = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 184
score: 99.0340805053711
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Cost ) ; }
rank: 184
score: 98.9413818359375
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter . get CaMeL Value ( ;
rank: 184
score: 98.77991832386364
patch: this . iter ; ++ iter ; ++ iter ;
rank: 184
score: 98.70509338378906
patch: ++ iter ; ; if iter ;
rank: 184
score: 98.6708272298177
patch: ++ iter ; iter = iter . iter ( ) ;
rank: 184
score: 98.66988118489583
patch: else { else { ++ iter ; }
rank: 185
score: 99.10550537109376
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > ++ ;
rank: 185
score: 99.09688527960526
patch: int CaMeL Value = Point CaMeL Vector CaMeL Value CaMeL Pair . operate ( current CaMeL Point ,
rank: 185
score: 99.03314819335938
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point . current CaMeL Point ) ;
rank: 185
score: 98.939892578125
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , ; ++ iter )
rank: 185
score: 98.77950710720486
patch: int iter + iter ; ++ iter ;
rank: 185
score: 98.70487976074219
patch: ++ iter ; ++ iter ; this
rank: 185
score: 98.67071533203125
patch: throw new Unsupported CaMeL Operation CaMeL Exception ( $STRING$ + iter ) ;
rank: 185
score: 98.66899108886719
patch: / * ; if ++ iter ;
rank: 186
score: 99.09683388157895
patch: Convergence CaMeL Checker ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ,
rank: 186
score: 99.03285127527573
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , true ) ;
rank: 186
score: 98.93938131893383
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , iter ;
rank: 186
score: 98.77915954589844
patch: ++ iter ; start + iter ;
rank: 186
score: 98.70393880208333
patch: ++ iter ; ++ iter ; } }
rank: 186
score: 98.67020357572116
patch: ++ iter ; throw new Illegal CaMeL Argument CaMeL Exception ( ;
rank: 186
score: 98.66862487792969
patch: if ( iter > 1 ; {
rank: 187
score: 99.13663736979167
patch: p = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 187
score: 99.09522769325658
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = this . this ;
rank: 187
score: 99.0325066061581
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , true ) ;
rank: 187
score: 98.93875885009766
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ; ++ iter ;
rank: 187
score: 98.77864583333333
patch: ++ iter ; ++ iter ; start ;
rank: 187
score: 98.7037353515625
patch: ++ iter ; iter / - / /
rank: 187
score: 98.6700439453125
patch: ++ iter ; while ( ! iter . is CaMeL Empty ( ) ;
rank: 187
score: 98.66810191761364
patch: throw new Runtime CaMeL Exception ( $STRING$ + $NUMBER$ ;
rank: 188
score: 99.15350896661931
patch: weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , n CaMeL C ) ;
rank: 188
score: 99.13656277126736
patch: e = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Residuals ) ;
rank: 188
score: 99.10400390625
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair . checker = current ;
rank: 188
score: 99.031787109375
patch: this . qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ; }
rank: 188
score: 98.93815532483552
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ; }
rank: 188
score: 98.77834065755208
patch: ++ iter ; ; * ++ iter ;
rank: 188
score: 98.66994803292411
patch: ++ iter ; if ( old CaMeL Obj . length > 0 )
rank: 188
score: 98.66786193847656
patch: / * * * ++ * /
rank: 189
score: 99.15320841471355
patch: Point CaMeL Vector CaMeL Value CaMeL Pair checker = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Residuals ) ;
rank: 189
score: 99.10381317138672
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair in = current ;
rank: 189
score: 99.09442545572917
patch: double [ ] current CaMeL Objective = current CaMeL Point [ 0 ] ;
rank: 189
score: 99.03122845818015
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( weight CaMeL Matrix CaMeL Sqrt ) ;
rank: 189
score: 98.93807779947916
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ iter , iter ;
rank: 189
score: 98.77831159319196
patch: ++ name ; ++ iter ;
rank: 189
score: 98.70263671875
patch: ++ iter ; ++ iter ; ++ max ;
rank: 189
score: 98.669677734375
patch: block = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter ;
rank: 189
score: 98.66741943359375
patch: } if ++ iter & iter ;
rank: 190
score: 99.13508605957031
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair -- = current ;
rank: 190
score: 99.103271484375
patch: ++ iter ; final Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker ;
rank: 190
score: 99.09368133544922
patch: final Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker ;
rank: 190
score: 99.03056066176471
patch: Iterator < Point CaMeL Vector CaMeL Value CaMeL Pair > iter = current CaMeL Point ;
rank: 190
score: 98.9378662109375
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ; ++ iter ;
rank: 190
score: 98.77699110243056
patch: int iter ; try ; int iter ;
rank: 190
score: 98.70257568359375
patch: ++ this ; ++ iter ;
rank: 190
score: 98.66952950613839
patch: ++ iter ; ++ iter )
rank: 190
score: 98.6672134399414
patch: else { ++ * ; * /
rank: 191
score: 99.15274047851562
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair > ( current CaMeL Point , current CaMeL Objective ) ;
rank: 191
score: 99.13292846679687
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Point ) ;
rank: 191
score: 99.10303344726563
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ,
rank: 191
score: 99.09292763157895
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = this . false ;
rank: 191
score: 99.0302490234375
patch: n CaMeL R = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , 0 ) ;
rank: 191
score: 98.93730163574219
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ iter ;
rank: 191
score: 98.77609592013889
patch: / ; ++ iter ; int iter ;
rank: 191
score: 98.70201958550348
patch: ++ ++ ++ iter ; ++ iter ;
rank: 191
score: 98.66939290364583
patch: ++ n CaMeL C ; ++ n CaMeL C ; }
rank: 191
score: 98.6670913696289
patch: ++ iter ; while ++ false ;
rank: 192
score: 99.152685546875
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = current ; / *
rank: 192
score: 99.13255399816177
patch: i = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ;
rank: 192
score: 99.10251871744792
patch: / / compute CaMeL Cost ( current CaMeL Residuals ) ;
rank: 192
score: 99.09272003173828
patch: int first CaMeL Iteration = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 192
score: 99.0285400390625
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , n CaMeL C ) ;
rank: 192
score: 98.93665364583333
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ iter ; }
rank: 192
score: 98.7759033203125
patch: this . ++ iter ; ++ iter ; }
rank: 192
score: 98.69944763183594
patch: ++ 0 ; ; ++ iter ;
rank: 192
score: 98.66914585658482
patch: ++ iter ; Thread . current CaMeL Thread ( ) . set ;
rank: 192
score: 98.66698455810547
patch: ++ iter * 0 . 0 ;
rank: 193
score: 99.15237559442934
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = ( Point CaMeL Vector CaMeL Value CaMeL Pair > ) current ;
rank: 193
score: 99.1024169921875
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > ;
rank: 193
score: 99.0926513671875
patch: int CaMeL Value = Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ;
rank: 193
score: 99.02752278645833
patch: result = new Point CaMeL Vector CaMeL Value CaMeL Pair ( checker ) ;
rank: 193
score: 98.93631320529514
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ; ;
rank: 193
score: 98.69914245605469
patch: ++ iter ; ++ start ; ;
rank: 193
score: 98.66903921274039
patch: if ( ! iter . is CaMeL Empty ( ; ) ;
rank: 193
score: 98.66645812988281
patch: else { ++ [ 1 ] ;
rank: 194
score: 99.15227716619319
patch: weighted CaMeL Jacobian = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Point ) ;
rank: 194
score: 99.09259354440789
patch: qtf [ compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 194
score: 99.02729724702381
patch: this . weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ; }
rank: 194
score: 98.93581814236111
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , iter ) ;
rank: 194
score: 98.69880676269531
patch: ++ - 1 ; ++ iter ;
rank: 194
score: 98.6688983623798
patch: if ( ! iter . starts CaMeL With ( iter ) )
rank: 194
score: 98.66630249023437
patch: if ( iter != null ; return iter ;
rank: 195
score: 99.15160193810097
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = null ;
rank: 195
score: 99.13054456208882
patch: x CaMeL Norm = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Residuals ) ;
rank: 195
score: 99.10186767578125
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair min = current ;
rank: 195
score: 99.09252211626838
patch: return compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Residuals ) ;
rank: 195
score: 99.02713012695312
patch: result = compute CaMeL Cost ( current CaMeL Point ) ;
rank: 195
score: 98.93527703536184
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point . length ; ;
rank: 195
score: 98.69719696044922
patch: iter } ++ ; ++ iter ;
rank: 195
score: 98.66803385416667
patch: ++ iter ; throw new Illegal CaMeL Argument CaMeL Exception ( ) ; }
rank: 195
score: 98.6653076171875
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + $NUMBER$ ) ; }
rank: 196
score: 99.15095658735795
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ;
rank: 196
score: 99.1304931640625
patch: iter = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Objective ) ;
rank: 196
score: 99.10050455729167
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Objective ) ) ; }
rank: 196
score: 99.09182559742646
patch: double compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 196
score: 99.02618408203125
patch: tmp = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , 0 ) ;
rank: 196
score: 98.9352294921875
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current . get CaMeL Point ( ) ; }
rank: 196
score: 98.77392578125
patch: / * ++ iter ;
rank: 196
score: 98.69611358642578
patch: ++ iter ; ; ++ 0 ;
rank: 196
score: 98.66440158420139
patch: ++ iter ; if ; ++ iter ;
rank: 197
score: 99.14990234375
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = current ; / /
rank: 197
score: 99.09083557128906
patch: String qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 197
score: 99.02559037642045
patch: this . weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point . length ) ;
rank: 197
score: 98.9344482421875
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , iter ) ;
rank: 197
score: 98.77179718017578
patch: ++ iter ; else iter * ;
rank: 197
score: 98.69586736505681
patch: ++ iter ; ++ iter ; ; return iter ;
rank: 197
score: 98.66722819010417
patch: p = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter ) ;
rank: 197
score: 98.66421274038461
patch: else { throw new Runtime CaMeL Exception ( $STRING$ ) ; }
rank: 198
score: 99.14985795454545
patch: weighted CaMeL Jacobian = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Residuals ) ;
rank: 198
score: 99.12933670847039
patch: compute CaMeL Weighted CaMeL Jacobian ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ) ;
rank: 198
score: 99.09881232766544
patch: qr CaMeL Decomposition = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ; }
rank: 198
score: 99.09065755208333
patch: Iterator < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current ;
rank: 198
score: 99.02477155412946
patch: < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = null ;
rank: 198
score: 98.93402099609375
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter ; }
rank: 198
score: 98.77133178710938
patch: ++ iter ; iter ; / ;
rank: 198
score: 98.69532121930804
patch: ++ null ; ++ iter ;
rank: 198
score: 98.66631401909723
patch: switch ( iter ) { case iter :
rank: 198
score: 98.6640957919034
patch: else throw new Runtime CaMeL Exception ( $STRING$ ) ;
rank: 199
score: 99.14942691200658
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , weighted CaMeL Residual ) ;
rank: 199
score: 99.12853422619048
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 199
score: 99.09819030761719
patch: iter = final Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ,
rank: 199
score: 99.09044596354167
patch: Map < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current ;
rank: 199
score: 99.02442626953125
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Objective ) ;
rank: 199
score: 98.93336588541666
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current ) . ++ ;
rank: 199
score: 98.77035522460938
patch: ++ iter ; int iter * ;
rank: 199
score: 98.69286237444196
patch: ++ iter ; ++ null ;
rank: 199
score: 98.66624866832386
patch: ++ iter ; if ( iter != 0 ) {
rank: 199
score: 98.66382598876953
patch: else { / * ; * /
rank: 200
score: 99.1477559407552
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ,
rank: 200
score: 99.09798177083333
patch: iter = checker . operate ( current CaMeL Residuals ) ;
rank: 200
score: 99.08985811121323
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair [ ] current CaMeL Objective = current ;
rank: 200
score: 98.93334350585937
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current . get CaMeL Point ( ;
rank: 200
score: 98.77024536132812
patch: ++ iter ; ++ * ; ++ iter ;
rank: 200
score: 98.69284396701389
patch: ++ iter ; iter ; -- iter ;
rank: 200
score: 98.66622220552884
patch: ++ iter ; if ( Arrays . is CaMeL Empty ( ;
rank: 200
score: 98.66206359863281
patch: else { / * / * /
rank: 201
score: 99.14693777901786
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = current CaMeL Point [ current CaMeL Point . length ;
rank: 201
score: 99.12808663504464
patch: qtf = compute CaMeL Weighted CaMeL Jacobian ( qtf ) ;
rank: 201
score: 99.08985093060662
patch: i = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ,
rank: 201
score: 99.0235595703125
patch: CaMeL Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 201
score: 98.93332391036184
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current . get CaMeL Point ( ) , ;
rank: 201
score: 98.69117320667614
patch: ++ iter ; iter / 1 ; ++ iter ;
rank: 201
score: 98.66591389973958
patch: ++ iter - iter ; ++ iter ;
rank: 201
score: 98.66163048377403
patch: if ( . is CaMeL Empty ( ) ) return iter ;
rank: 202
score: 99.14643297697368
patch: return weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Objective ) ;
rank: 202
score: 99.12771124588816
patch: Point CaMeL Vector CaMeL Value CaMeL Pair current = current CaMeL Point [ current CaMeL Residuals ] ;
rank: 202
score: 99.08931238511029
patch: String current CaMeL Objective = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 202
score: 99.02327104048295
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Residuals ) ;
rank: 202
score: 98.93299018012152
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current . get CaMeL Point ( ;
rank: 202
score: 98.7700528231534
patch: ++ iter ; ++ iter ; * / iter ;
rank: 202
score: 98.69019571940105
patch: ++ ; ++ iter ;
rank: 202
score: 98.665576171875
patch: int iter = Arrays . as CaMeL List ( current ) . length ;
rank: 202
score: 98.66151258680556
patch: if ( iter == 0 ) return ;
rank: 203
score: 99.14641779119319
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair value = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) current ;
rank: 203
score: 99.1275146484375
patch: n CaMeL C = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 203
score: 99.09689812911184
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair += checker . operate ( current CaMeL Point ) ;
rank: 203
score: 99.08885433799342
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = n CaMeL R ;
rank: 203
score: 99.02318396935097
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 203
score: 98.93297054893092
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , ++ ;
rank: 203
score: 98.76983642578125
patch: / * ++ iter ; * / /
rank: 203
score: 98.68930886008523
patch: ++ iter ; iter if ++ ; ++ iter ;
rank: 203
score: 98.66332194010417
patch: block = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current ) ;
rank: 203
score: 98.65931919642857
patch: else { ++ out ; }
rank: 204
score: 99.12679036458333
patch: final Convergence CaMeL Checker qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 204
score: 99.08833530970982
patch: / * Point CaMeL Vector CaMeL Value CaMeL Pair checker = current ;
rank: 204
score: 99.02298409598214
patch: first CaMeL Iteration = compute CaMeL Cost ( current CaMeL Point ) ;
rank: 204
score: 98.93285260881696
patch: int iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( ;
rank: 204
score: 98.76932525634766
patch: ++ iter ; try = iter ;
rank: 204
score: 98.688671875
patch: ++ iter ; ++ Math ; ++ iter ;
rank: 204
score: 98.66314227764423
patch: if ( ! iter . compare CaMeL To ( iter ) )
rank: 204
score: 98.65914154052734
patch: else { ++ += iter ; }
rank: 205
score: 99.12665405273438
patch: it = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Objective ) ;
rank: 205
score: 99.0963643391927
patch: iter = checker . operate ( current CaMeL Objective ) ;
rank: 205
score: 98.93283081054688
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ iter , ; }
rank: 205
score: 98.68813650948661
patch: ++ iter ; ++ name ;
rank: 205
score: 98.66306966145834
patch: ++ iter ; Thread . current CaMeL Thread ( ) . join ( ;
rank: 205
score: 98.65903049045139
patch: else ++ iter [ 0 ] ; }
rank: 206
score: 99.1448974609375
patch: return weighted CaMeL Jacobian = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 206
score: 99.12654418945313
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = current CaMeL Point [ current CaMeL Point ) ;
rank: 206
score: 99.09613800048828
patch: { qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 206
score: 99.08661566840277
patch: final Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = false ;
rank: 206
score: 98.93150499131944
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , iter ) ;
rank: 206
score: 98.76861572265625
patch: ++ iter ; start ; ++ iter ;
rank: 206
score: 98.68812561035156
patch: ++ iter ; iter * 1 ;
rank: 206
score: 98.66222330729167
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ iter ) ;
rank: 206
score: 98.65888129340277
patch: else { ++ iter ; * * /
rank: 207
score: 99.14481608072917
patch: Point CaMeL Vector CaMeL Value CaMeL Pair checker = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Objective ) ;
rank: 207
score: 99.12636108398438
patch: compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective , current CaMeL Objective ) ;
rank: 207
score: 99.08613666735198
patch: int CaMeL Value ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ,
rank: 207
score: 99.02222397748162
patch: found = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ; }
rank: 207
score: 98.93140326605902
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , iter , ;
rank: 207
score: 98.68655056423611
patch: ++ iter ; ; iter / / /
rank: 207
score: 98.66197858537946
patch: ++ iter ; while ( Arrays . is CaMeL Empty ( ) )
rank: 207
score: 98.65886094835069
patch: throw new Runtime CaMeL Exception ( $STRING$ ;
rank: 208
score: 99.14473470052083
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = weight CaMeL Matrix CaMeL Sqrt . get ( current CaMeL Point ) ;
rank: 208
score: 99.1260498046875
patch: int iter = final Point CaMeL Vector CaMeL Value CaMeL Pair . operate ( current CaMeL Residuals ) ;
rank: 208
score: 99.09605055588942
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair start = current ;
rank: 208
score: 99.08599175347223
patch: j = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 208
score: 99.02198621961806
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , true ) ;
rank: 208
score: 98.93079969618056
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current . ++ , ;
rank: 208
score: 98.76707240513393
patch: / * ++ iter ; /
rank: 208
score: 98.6612548828125
patch: ++ iter ; Thread . sleep ( iter ) ;
rank: 208
score: 98.6584716796875
patch: else { if ( iter > 0 ) {
rank: 209
score: 99.09588982077206
patch: weighted CaMeL Residual = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ; }
rank: 209
score: 99.02197875976563
patch: true = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 209
score: 98.93074035644531
patch: while ( iter < iter ) {
rank: 209
score: 98.76671006944444
patch: ++ iter ; ; ; int iter ;
rank: 209
score: 98.68512517755681
patch: ++ iter ; ++ iter ; / = iter ;
rank: 209
score: 98.661181640625
patch: ++ iter ; throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ; }
rank: 209
score: 98.65795135498047
patch: try { ++ * ++ iter ;
rank: 210
score: 99.14394996279762
patch: double [ ] current CaMeL Objective = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Objective ) ;
rank: 210
score: 99.09544613486842
patch: weighted CaMeL Residual = get CaMeL Weight CaMeL Square CaMeL Root ( current CaMeL Point ) ; }
rank: 210
score: 99.08535427517361
patch: current = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 210
score: 99.021875
patch: x CaMeL Norm += weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point . length ) ;
rank: 210
score: 98.93023322610294
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ iter ) ;
rank: 210
score: 98.68407592773437
patch: ++ iter ; ; ++ iter ; iter ;
rank: 210
score: 98.65692138671875
patch: return ++ [ iter ] ; }
rank: 211
score: 99.14351712740384
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = get ;
rank: 211
score: 99.12566375732422
patch: weighted CaMeL Residual = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ;
rank: 211
score: 99.09510387073864
patch: ++ iter ; final Convergence CaMeL Checker . get CaMeL Weight CaMeL Square CaMeL Root ( current CaMeL Point ) ;
rank: 211
score: 99.08451120476974
patch: if ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Point ) ) {
rank: 211
score: 99.0217056274414
patch: ret = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Objective ) ;
rank: 211
score: 98.93022604549633
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ; ;
rank: 211
score: 98.76482391357422
patch: ++ iter ; iter * 0 ;
rank: 211
score: 98.68401544744319
patch: ++ iter ; ++ iter ; iter ; / /
rank: 211
score: 98.65962219238281
patch: while ( iter != null ) {
rank: 211
score: 98.65657552083333
patch: return new Object [ ] = iter ;
rank: 212
score: 99.1428731282552
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair = current ;
rank: 212
score: 99.09480285644531
patch: if ( checker . get CaMeL Weight CaMeL Square CaMeL Root ( ) ) {
rank: 212
score: 99.08435997596153
patch: boolean first CaMeL Iteration = current CaMeL Point [ iter ] ;
rank: 212
score: 99.02159423828125
patch: x CaMeL Norm += weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , 0 ) ;
rank: 212
score: 98.92999674479167
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current ) ;
rank: 212
score: 98.76468505859376
patch: ++ iter ; ++ iter ; int 1 ;
rank: 212
score: 98.68386840820312
patch: ++ iter ; ; / / /
rank: 212
score: 98.65709510216347
patch: if ( ! iter . compare CaMeL To ( iter ) ;
rank: 212
score: 98.65606689453125
patch: if ( ! 0 . is CaMeL Empty ( ) ) . ;
rank: 213
score: 99.12335759943181
patch: Convergence CaMeL Checker = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Residuals ) ;
rank: 213
score: 99.09449404761905
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , first CaMeL Iteration ) ) ;
rank: 213
score: 99.08424287683823
patch: String compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 213
score: 99.02090454101562
patch: v = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 213
score: 98.92925618489583
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , false ) ;
rank: 213
score: 98.68344455295139
patch: ++ * ++ iter ; ++ iter ;
rank: 213
score: 98.65703582763672
patch: ++ iter ; ++ iter ) {
rank: 213
score: 98.65605926513672
patch: / * * * * ++ ;
rank: 214
score: 99.14176940917969
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair current CaMeL Point ;
rank: 214
score: 99.09397259880515
patch: qtf [ iter ] = get CaMeL Weight CaMeL Square CaMeL Root ( ) ;
rank: 214
score: 99.0841064453125
patch: int qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 214
score: 99.01974148220486
patch: [ ] weight CaMeL Matrix CaMeL Sqrt . operate ( weight CaMeL Matrix CaMeL Sqrt ) ;
rank: 214
score: 98.92845916748047
patch: ++ iter ; * / * ;
rank: 214
score: 98.76431274414062
patch: ++ iter ; iter + iter ;
rank: 214
score: 98.68304443359375
patch: ++ iter ; iter = iter / iter ;
rank: 214
score: 98.656640625
patch: final ; return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current ;
rank: 214
score: 98.65389578683036
patch: ++ * * * iter ;
rank: 215
score: 99.1417236328125
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = ( Point CaMeL Vector CaMeL Value CaMeL Pair )
rank: 215
score: 99.0840202780331
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = 1 ;
rank: 215
score: 99.01951840049342
patch: result = qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 215
score: 98.92752414279514
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point . trim ;
rank: 215
score: 98.7621841430664
patch: ++ iter ; * ; * /
rank: 215
score: 98.68150745738636
patch: ++ iter ; ++ iter ; ++ iter ; else
rank: 215
score: 98.65606689453125
patch: ++ iter ] ;
rank: 216
score: 99.141357421875
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > checker =
rank: 216
score: 99.12134951636905
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair ( checker ) ;
rank: 216
score: 99.09270276521382
patch: { qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ; }
rank: 216
score: 99.08360799153645
patch: Point CaMeL Vector CaMeL Value CaMeL Pair final = current ;
rank: 216
score: 99.01945944393383
patch: tmp = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ; }
rank: 216
score: 98.92648315429688
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , $NUMBER$ ) ;
rank: 216
score: 98.6811279296875
patch: ++ iter ; ++ $NUMBER$ ; ++ iter ;
rank: 216
score: 98.65581597222223
patch: ++ iter + 1 ; ++ iter ;
rank: 216
score: 98.65341186523438
patch: return new ++ ; }
rank: 217
score: 99.14125569661458
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current ; / *
rank: 217
score: 99.12132568359375
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = current CaMeL Point [ current CaMeL Point ] ;
rank: 217
score: 99.09205211292614
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair -- ;
rank: 217
score: 99.0826480263158
patch: int CaMeL Value = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Point ,
rank: 217
score: 99.0192806846217
patch: x CaMeL Norm = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ; }
rank: 217
score: 98.92553032769098
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , ; }
rank: 217
score: 98.76145241477273
patch: ++ iter ; ++ iter ; current . iter ;
rank: 217
score: 98.68109130859375
patch: ++ iter ; ++ iter ; break ; ;
rank: 217
score: 98.6553955078125
patch: ++ iter = iter ;
rank: 217
score: 98.6530532836914
patch: else { ++ $NUMBER$ * iter ;
rank: 218
score: 99.14091352982955
patch: weighted CaMeL Jacobian = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Residuals ) ;
rank: 218
score: 99.12107155539773
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair $NUMBER$ ;
rank: 218
score: 99.09177652994792
patch: while ( ! weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ) {
rank: 218
score: 99.08217259457237
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = $NUMBER$ . 0 ;
rank: 218
score: 99.01927083333334
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ,
rank: 218
score: 98.92531331380208
patch: int iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point . ;
rank: 218
score: 98.76045532226563
patch: ++ iter ; try ; ++ iter ; ;
rank: 218
score: 98.68070983886719
patch: ++ iter ; iter } ++ ;
rank: 218
score: 98.65267944335938
patch: ++ * * * iter ; /
rank: 219
score: 99.14058061079545
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) null ;
rank: 219
score: 99.12094116210938
patch: return ( Point CaMeL Vector CaMeL Value CaMeL Pair ) checker . operate ( current CaMeL Residuals ) ;
rank: 219
score: 99.09162454044117
patch: int iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ,
rank: 219
score: 99.08181326729911
patch: checker = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 219
score: 99.0184326171875
patch: found = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point . length ) ;
rank: 219
score: 98.76034206814236
patch: ++ iter ; start ; int iter ;
rank: 219
score: 98.67962036132812
patch: ++ iter ; ++ this ; ++ iter ;
rank: 219
score: 98.65480393629808
patch: b = new Point CaMeL Vector CaMeL Value CaMeL Pair ( ;
rank: 219
score: 98.65261840820312
patch: if ( iter > 0 ; return iter ;
rank: 220
score: 99.14049275716145
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) current CaMeL Point ;
rank: 220
score: 99.12084282769098
patch: c = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 220
score: 98.92438354492188
patch: int iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point . length , ;
rank: 220
score: 98.67958984375
patch: ++ iter ; ++ iter ; -- 1 ;
rank: 220
score: 98.65217420789931
patch: else { ++ iter ; * / }
rank: 221
score: 99.13993326822917
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair [ ] checker = current ;
rank: 221
score: 99.12049211774554
patch: it = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ;
rank: 221
score: 99.09133911132812
patch: / / compute CaMeL Cost ( current CaMeL Point , current CaMeL Objective ) ;
rank: 221
score: 99.08145944695724
patch: Point CaMeL Vector CaMeL Value CaMeL Pair checker = ( Point CaMeL Vector CaMeL Value CaMeL Pair )
rank: 221
score: 99.01793619791667
patch: [ ] final Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 221
score: 98.92435495476974
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current . get CaMeL Point ( ) ) ;
rank: 221
score: 98.76005554199219
patch: ++ iter ; iter ; break ;
rank: 221
score: 98.67843017578124
patch: ++ iter ; ++ iter ; break ; }
rank: 221
score: 98.653564453125
patch: ++ n CaMeL R ;
rank: 221
score: 98.65206909179688
patch: return ++ [ 1 ] ; }
rank: 222
score: 99.13980765964673
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ;
rank: 222
score: 99.080322265625
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = diag ;
rank: 222
score: 99.01783447265625
patch: children = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 222
score: 98.92417279411765
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , iter , ;
rank: 222
score: 98.75995635986328
patch: ++ iter ; int iter ++ ;
rank: 222
score: 98.67799207899306
patch: iter ; ++ iter ; -- iter ;
rank: 222
score: 98.65309448242188
patch: Iterator iter = iter . iter ( ) ;
rank: 222
score: 98.65185546875
patch: if ( < 0 ; ++ iter ;
rank: 223
score: 99.1394775390625
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair && current ;
rank: 223
score: 99.12037963867188
patch: Convergence CaMeL Checker = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Residuals ) ;
rank: 223
score: 99.09090383429276
patch: weighted CaMeL Residual = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Objective ) ;
rank: 223
score: 99.0796142578125
patch: boolean iter = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 223
score: 99.01776733398438
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , n CaMeL R ) ;
rank: 223
score: 98.92373046875
patch: int iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point . length ) ;
rank: 223
score: 98.75978597005208
patch: ++ iter ; / * int iter ;
rank: 223
score: 98.67720947265624
patch: ++ iter ; ++ min ; ++ iter ;
rank: 223
score: 98.65272874098558
patch: p = new Point CaMeL Vector CaMeL Value CaMeL Pair ( ;
rank: 223
score: 98.64820556640625
patch: if ( iter == 0 ; ++ iter ;
rank: 224
score: 99.13919503348214
patch: qtf = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Point ) ;
rank: 224
score: 99.0893618935033
patch: try { qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 224
score: 99.07913028492646
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = this .
rank: 224
score: 99.01678466796875
patch: [ ] current CaMeL Residuals = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 224
score: 98.92323303222656
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current . get ; }
rank: 224
score: 98.75920104980469
patch: ++ iter ; else { iter ;
rank: 224
score: 98.65230984157986
patch: final int iter = iter - iter ;
rank: 224
score: 98.64793090820312
patch: if ( iter == 0 ; return ; }
rank: 225
score: 99.1387939453125
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ;
rank: 225
score: 99.12018500434027
patch: it = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Residuals ) ;
rank: 225
score: 99.08918108258929
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair list ;
rank: 225
score: 99.0789730674342
patch: / * Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current ;
rank: 225
score: 99.01668090820313
patch: [ ] current CaMeL Residuals = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 225
score: 98.92318386501736
patch: ++ iter ; return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current ) ; }
rank: 225
score: 98.75782775878906
patch: } ++ iter ; if iter ;
rank: 225
score: 98.67683549360795
patch: ++ iter ; if ++ iter ; ++ iter ;
rank: 225
score: 98.65130060369319
patch: ++ iter 1 [ n CaMeL C ] ; }
rank: 225
score: 98.64776611328125
patch: * * * * / ++ iter ;
rank: 226
score: 99.08833821614583
patch: weighted CaMeL Residual ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 226
score: 99.07890625
patch: double qr CaMeL Decomposition ( current CaMeL Point , current CaMeL Objective ) ;
rank: 226
score: 99.01633814761513
patch: ! weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 226
score: 98.92292785644531
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter . ;
rank: 226
score: 98.75747341579861
patch: ++ iter ; ; / * / /
rank: 226
score: 98.67507934570312
patch: ++ iter ; ++ iter ; ++ false ;
rank: 226
score: 98.64675903320312
patch: if ( ! $NUMBER$ == iter ;
rank: 227
score: 99.13834635416667
patch: Point CaMeL Vector CaMeL Value CaMeL Pair current = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Residuals ) ;
rank: 227
score: 99.11969604492188
patch: first CaMeL Iteration = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 227
score: 99.08759014423077
patch: Iterator iter = checker . operate ( current CaMeL Objective ) ;
rank: 227
score: 99.07865142822266
patch: Point CaMeL Vector CaMeL Value CaMeL Pair [ ] current CaMeL Objective = current ;
rank: 227
score: 99.01558837890624
patch: [ ] current CaMeL Objective = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 227
score: 98.92267809416118
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point . ; ;
rank: 227
score: 98.75694928850446
patch: ++ iter ; ++ break ;
rank: 227
score: 98.67486572265625
patch: ++ iter ; ++ true ; ++ iter ;
rank: 227
score: 98.64914376395089
patch: while ( ! iter . is CaMeL Empty ( ) ; ) {
rank: 227
score: 98.64649454752605
patch: ++ * * iter ;
rank: 228
score: 99.13780146059783
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair = checker . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 228
score: 99.11946105957031
patch: Convergence CaMeL Checker = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ;
rank: 228
score: 99.08722330729167
patch: ( ( Point CaMeL Vector CaMeL Value CaMeL Pair ) checker ) . {
rank: 228
score: 99.07763671875
patch: if ( current CaMeL Point . length < n CaMeL C ) {
rank: 228
score: 99.0155029296875
patch: synchronized ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) )
rank: 228
score: 98.92266082763672
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ n CaMeL C ;
rank: 228
score: 98.75661892361111
patch: ++ iter ; break ; if iter ;
rank: 228
score: 98.67404174804688
patch: } iter ++ ; ++ iter ;
rank: 228
score: 98.64886881510417
patch: b = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter ) ;
rank: 228
score: 98.64625549316406
patch: if ( iter == 0 ) {
rank: 229
score: 99.13730690696023
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Objective ) ;
rank: 229
score: 99.1189852627841
patch: qtf = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Objective ) ;
rank: 229
score: 99.08683558872768
patch: weighted CaMeL Residual = checker . operate ( current CaMeL Residuals ) ;
rank: 229
score: 99.07743326822917
patch: return compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ; }
rank: 229
score: 99.01455508961396
patch: ( ( Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > ) {
rank: 229
score: 98.92197265625
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current ) ;
rank: 229
score: 98.75540161132812
patch: ++ iter ; ++ iter iter ;
rank: 229
score: 98.67387251420455
patch: ++ iter ; iter / ++ ; ++ iter ;
rank: 229
score: 98.64604187011719
patch: / * * * ++ ++ ;
rank: 230
score: 99.13677423650569
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) get ;
rank: 230
score: 99.11875697544643
patch: d = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 230
score: 99.086376953125
patch: Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > = current ;
rank: 230
score: 99.076171875
patch: tmp = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 230
score: 99.014111328125
patch: result = weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 230
score: 98.92136517693015
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , iter ) ; }
rank: 230
score: 98.75525580512152
patch: / * ++ ++ ; ++ iter ;
rank: 230
score: 98.67378540039063
patch: ++ this ; ++ iter ; ++ iter ;
rank: 230
score: 98.64837091619319
patch: ++ iter ; while ( iter == 0 ) {
rank: 230
score: 98.64559500558036
patch: ++ < iter > iter ;
rank: 231
score: 99.13578464673913
patch: return weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 231
score: 99.11820220947266
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair current = null ;
rank: 231
score: 99.08623046875
patch: Iterator iter = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 231
score: 99.07613332648026
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > current CaMeL Objective = current ;
rank: 231
score: 99.01319795496323
patch: ret = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ; }
rank: 231
score: 98.92129281850961
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ iter ;
rank: 231
score: 98.67345081676136
patch: ++ iter ; ++ iter ; / / / /
rank: 231
score: 98.64800470525569
patch: if ( old CaMeL Obj . length > 0 )
rank: 231
score: 98.64501190185547
patch: try { ++ iter ; while ;
rank: 232
score: 99.13557572798295
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current CaMeL Point = current CaMeL Point [ n CaMeL C ] ;
rank: 232
score: 99.08622602982955
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current ;
rank: 232
score: 99.07608235677084
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair final = current CaMeL Point ;
rank: 232
score: 99.0128173828125
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Point ) ;
rank: 232
score: 98.92091128700658
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , ; ++ iter )
rank: 232
score: 98.6733065518466
patch: ++ iter ; ++ iter ; else if iter ;
rank: 232
score: 98.6475830078125
patch: result = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter ;
rank: 232
score: 98.64495849609375
patch: return new ++ [ 1 ] ; }
rank: 233
score: 99.13502807617188
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair new = current CaMeL Point [ n CaMeL C ] ;
rank: 233
score: 99.08605194091797
patch: while ( ! compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) {
rank: 233
score: 99.0755615234375
patch: int CaMeL Value = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Residuals ,
rank: 233
score: 99.01278250558036
patch: entry = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) current ;
rank: 233
score: 98.92074245876736
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter . iter , ;
rank: 233
score: 98.7540512084961
patch: ++ iter ; else * iter ;
rank: 233
score: 98.67305131392045
patch: ++ iter ; ++ iter ; if iter ++ ;
rank: 233
score: 98.6466397372159
patch: if ( ++ n CaMeL C != 0 ) {
rank: 233
score: 98.64482879638672
patch: else { ++ iter ] ; }
rank: 234
score: 99.13382090692934
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current ;
rank: 234
score: 99.07540732935855
patch: Point CaMeL Vector CaMeL Value CaMeL Pair checker = current CaMeL Point [ n CaMeL R ] ;
rank: 234
score: 99.01272583007812
patch: [ ] current CaMeL Objective = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 234
score: 98.92035989200367
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point [ ;
rank: 234
score: 98.7540283203125
patch: int iter ; ++ - iter ;
rank: 234
score: 98.67293294270833
patch: ++ iter ; ++ iter ; } iter
rank: 234
score: 98.64593505859375
patch: if ( ! iter ) {
rank: 234
score: 98.64453125
patch: else {
rank: 235
score: 99.133544921875
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = get ;
rank: 235
score: 99.01226251775569
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , n CaMeL C ) ;
rank: 235
score: 98.92015838623047
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , ++ iter ) ;
rank: 235
score: 98.75382856889205
patch: ++ iter ; ++ iter ; out . out ;
rank: 235
score: 98.67267456054688
patch: ++ iter ; iter / / ++ iter ;
rank: 235
score: 98.6448974609375
patch: ++ iter = Arrays . as CaMeL List ( iter ) . length ;
rank: 235
score: 98.64448765345982
patch: ++ < 1 > iter ;
rank: 236
score: 99.13346000339673
patch: Point CaMeL Vector CaMeL Value CaMeL Pair current = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) current CaMeL Point ;
rank: 236
score: 99.11635916573661
patch: i = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ;
rank: 236
score: 99.08468467310855
patch: Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > checker ;
rank: 236
score: 99.01220703125
patch: x CaMeL Norm = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Objective ) ;
rank: 236
score: 98.75379774305556
patch: int iter = iter ; ++ iter ;
rank: 236
score: 98.67244873046874
patch: ++ iter ; iter / ; -- iter ;
rank: 236
score: 98.64483642578125
patch: ++ iter ; while ( iter . ; )
rank: 236
score: 98.64301006610577
patch: if ( . is CaMeL Empty ( ) ) throw null ;
rank: 237
score: 99.13289388020833
patch: qtf = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Residuals ) ;
rank: 237
score: 99.07472139246323
patch: Point CaMeL Vector CaMeL Value CaMeL Pair current = current CaMeL Point [ iter ] ;
rank: 237
score: 99.01181030273438
patch: n CaMeL R = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point . length ) ;
rank: 237
score: 98.91934543185764
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( get CaMeL Context ( ;
rank: 237
score: 98.75376892089844
patch: ++ iter ; ++ * true ;
rank: 237
score: 98.67244096235795
patch: ++ iter ; ; ++ 1 ; ++ iter ;
rank: 237
score: 98.64404907226563
patch: ++ iter ; ++ n CaMeL C ; }
rank: 237
score: 98.64265950520833
patch: else ++ iter ; ++ iter ; }
rank: 238
score: 99.13283284505208
patch: Point CaMeL Vector CaMeL Value CaMeL Pair > checker = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Objective ) ;
rank: 238
score: 99.08446326622597
patch: int iter = checker . operate ( current CaMeL Residuals ) ;
rank: 238
score: 99.07467447916666
patch: Object current = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 238
score: 99.01161193847656
patch: [ ] weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 238
score: 98.91917588975694
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair . double CaMeL Value ( ;
rank: 238
score: 98.7533671061198
patch: ++ iter ; * ;
rank: 238
score: 98.64354858398437
patch: ++ iter ; ++ n CaMeL R ; }
rank: 238
score: 98.64127291165866
patch: if ( ! 0 . is CaMeL Empty ( ; ) ;
rank: 239
score: 99.08401828342014
patch: ++ n CaMeL C ; weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate (
rank: 239
score: 99.01007080078125
patch: found = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Cost ) ;
rank: 239
score: 98.91864013671875
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , iter , ;
rank: 239
score: 98.75282796223958
patch: ++ iter ; int iter + 0 ;
rank: 239
score: 98.67141723632812
patch: ++ iter ; ++ if iter ;
rank: 239
score: 98.64307579627403
patch: if ( ! iter . is CaMeL Empty ; ++ iter )
rank: 239
score: 98.64097290039062
patch: return null ; }
rank: 240
score: 99.13247282608695
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) true ;
rank: 240
score: 99.1159423828125
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = current CaMeL Point [ current CaMeL Residuals ] ;
rank: 240
score: 99.08365885416667
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , n CaMeL R ) ) ;
rank: 240
score: 99.07327431126645
patch: current CaMeL Point = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ,
rank: 240
score: 99.00928344726563
patch: x CaMeL Norm = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point . length ) ;
rank: 240
score: 98.91847737630208
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , ++ n CaMeL C ) ;
rank: 240
score: 98.64261203342014
patch: switch ( iter ) { case 0 :
rank: 240
score: 98.64049183238636
patch: if ( iter != null ; return iter ; }
rank: 241
score: 99.1156982421875
patch: weighted CaMeL Residual = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Residuals ) ;
rank: 241
score: 99.08281017485119
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , x CaMeL Norm ) ) ;
rank: 241
score: 99.07315402560764
patch: final Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = true ;
rank: 241
score: 99.0091552734375
patch: Iterator < Point CaMeL Vector CaMeL Value CaMeL Pair > Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 241
score: 98.918212890625
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , false ) ;
rank: 241
score: 98.75090196397569
patch: ++ iter ; ++ - * iter ;
rank: 241
score: 98.67078857421875
patch: ++ iter ; ++ iter ; } iter ;
rank: 241
score: 98.64241536458333
patch: ++ iter ; iter = iter . clone ( ) ;
rank: 241
score: 98.64048767089844
patch: if ( iter > $NUMBER$ ; {
rank: 242
score: 99.13055419921875
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > current CaMeL Objective = current ;
rank: 242
score: 99.115576171875
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = current . current ;
rank: 242
score: 99.08273315429688
patch: ++ weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ; }
rank: 242
score: 99.07312729779412
patch: Map < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current CaMeL Point ;
rank: 242
score: 99.00823364257812
patch: res = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 242
score: 98.7497787475586
patch: this . ++ ; ++ iter ;
rank: 242
score: 98.67037527901786
patch: ++ iter ; ++ min ;
rank: 242
score: 98.64043719951923
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ; } }
rank: 242
score: 98.64041137695312
patch: if ( Arrays . is CaMeL Empty ( iter ) )
rank: 243
score: 99.12965152138158
patch: ++ weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Point ) ;
rank: 243
score: 99.11484200613839
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair 1 checker = current ;
rank: 243
score: 99.08270263671875
patch: ++ iter ; final Convergence CaMeL Checker . get CaMeL Weight CaMeL Square CaMeL Root ( ) . {
rank: 243
score: 99.07294921875
patch: int < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current ;
rank: 243
score: 98.91684977213542
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point . length
rank: 243
score: 98.74960327148438
patch: ++ iter ; * ; * ;
rank: 243
score: 98.66864013671875
patch: ++ 1 ; ++ iter ; }
rank: 243
score: 98.64030151367187
patch: if ( iter > 0 ; return false ;
rank: 243
score: 98.64003342848558
patch: if ( ! iter . starts CaMeL With ( iter ) ;
rank: 244
score: 99.12940738075658
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current CaMeL Point [ 0 ] ;
rank: 244
score: 99.08239164806548
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair )
rank: 244
score: 99.0729248046875
patch: qr CaMeL Decomposition = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 244
score: 99.00799560546875
patch: result = Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 244
score: 98.91676161024306
patch: Iterator iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , ;
rank: 244
score: 98.7495450106534
patch: / * ++ iter ; * / ++ iter ;
rank: 244
score: 98.6660385131836
patch: / iter ++ ; ++ iter ;
rank: 244
score: 98.63971354166667
patch: result = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current ) ;
rank: 244
score: 98.6378173828125
patch: return iter [ iter ] ; }
rank: 245
score: 99.12917073567708
patch: Point CaMeL Vector CaMeL Value CaMeL Pair current = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Objective ) ;
rank: 245
score: 99.1144287109375
patch: ++ iter ; Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = get ;
rank: 245
score: 99.0819091796875
patch: / * compute CaMeL Cost ( current CaMeL Objective , current CaMeL Objective ) ;
rank: 245
score: 99.07276746961806
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = current CaMeL Point [ 0 ] ;
rank: 245
score: 99.00782189002403
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( checker ) ;
rank: 245
score: 98.66593933105469
patch: ++ iter ; ; iter -- ;
rank: 245
score: 98.6384765625
patch: if ( ! iter . is CaMeL Empty ( ) ) continue false ;
rank: 245
score: 98.63703748914931
patch: else ++ iter [ 1 ] ; }
rank: 246
score: 99.12872869318181
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current ;
rank: 246
score: 99.07261149088542
patch: int CaMeL Value = current CaMeL Point [ 0 ] ;
rank: 246
score: 99.00712585449219
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( weighted CaMeL Residual ) ;
rank: 246
score: 98.91664475661058
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter ) ;
rank: 246
score: 98.74896918402777
patch: ++ iter ; for iter ; 0 ;
rank: 246
score: 98.66590033637152
patch: ++ iter ; ; else ++ iter ;
rank: 246
score: 98.63845590444711
patch: if ( ! iter . is CaMeL Empty ( ; ; )
rank: 246
score: 98.63649495442708
patch: if ( . is CaMeL Empty ( ) ) { }
rank: 247
score: 99.12850516183036
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = 0 ;
rank: 247
score: 99.07179478236607
patch: boolean first CaMeL Iteration = n CaMeL C < n CaMeL C ;
rank: 247
score: 99.00710042317708
patch: tmp = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point . length ) ;
rank: 247
score: 98.91574532645089
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ ; }
rank: 247
score: 98.74863009982639
patch: ++ iter ; for iter { ++ ;
rank: 247
score: 98.6380106608073
patch: if ( Arrays . is CaMeL Empty ( iter ) ;
rank: 247
score: 98.63612365722656
patch: else { if ++ < iter ;
rank: 248
score: 99.11385091145833
patch: i = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Residuals ) ;
rank: 248
score: 99.08160109747024
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , weighted CaMeL Residual ) ) ;
rank: 248
score: 99.00575256347656
patch: Iterator < Point CaMeL Vector CaMeL Value CaMeL Pair > iter = ++ iter ;
rank: 248
score: 98.91563585069444
patch: Iterator < Point CaMeL Vector CaMeL Value CaMeL Pair > iter = iter . iter ( ;
rank: 248
score: 98.74831717354911
patch: ++ iter ; for iter ;
rank: 248
score: 98.66484375
patch: ++ iter ; ++ name ; ++ iter ;
rank: 248
score: 98.63798828125
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair [ 0 ] ; }
rank: 248
score: 98.63602905273437
patch: if ( iter == 0 ; return iter ;
rank: 249
score: 99.12789916992188
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker ;
rank: 249
score: 99.08123168945312
patch: checker = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Objective , current CaMeL Objective ) ;
rank: 249
score: 99.07078150699013
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = this . true ;
rank: 249
score: 99.00571899414062
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , iter ) ;
rank: 249
score: 98.915283203125
patch: ++ iter ] = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current ;
rank: 249
score: 98.74812825520833
patch: ++ iter + iter ; ++ iter ;
rank: 249
score: 98.66475677490234
patch: / ; ++ ; ++ iter ;
rank: 249
score: 98.63781127929687
patch: if ( is CaMeL Empty ( ) ) {
rank: 249
score: 98.63583374023438
patch: if ( iter < 0 ) return null ;
rank: 250
score: 99.11312063116776
patch: qtf = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals , current CaMeL Residuals ) ;
rank: 250
score: 99.08118785511364
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > iter = current ;
rank: 250
score: 99.07020327919408
patch: if ( current CaMeL Point = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) {
rank: 250
score: 99.00445877878289
patch: void weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 250
score: 98.91458565848214
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair iter ;
rank: 250
score: 98.74798583984375
patch: ( new ++ ; ++ iter ;
rank: 250
score: 98.66346435546875
patch: ++ iter ; iter = iter ; ++ ;
rank: 250
score: 98.6373779296875
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + iter ) ; }
rank: 250
score: 98.63574981689453
patch: return new ++ [ 1 ] ;
rank: 251
score: 99.08104359019886
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > final = current ;
rank: 251
score: 99.07007649739583
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ,
rank: 251
score: 99.00442023026316
patch: n CaMeL C = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ; }
rank: 251
score: 98.91391427176339
patch: ++ iter ; * / ;
rank: 251
score: 98.66182861328124
patch: ++ iter ; ; if ++ ++ iter ;
rank: 251
score: 98.63656005859374
patch: ++ iter ; if ( iter == null )
rank: 251
score: 98.6352294921875
patch: if ( . is CaMeL Empty ( ) ) { ++ iter ; }
rank: 252
score: 99.12717982700893
patch: int CaMeL Value = current CaMeL Point [ n CaMeL C ] ;
rank: 252
score: 99.11163330078125
patch: it = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 252
score: 99.08085123697917
patch: iter = checker . operate ( current CaMeL Point ) ;
rank: 252
score: 99.06962076822917
patch: final Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = this ;
rank: 252
score: 98.91362561677632
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , iter , ;
rank: 252
score: 98.74684651692708
patch: ++ iter ; ++ iter ; value ;
rank: 252
score: 98.66079711914062
patch: ++ iter ; ++ iter ; / * /
rank: 252
score: 98.63632202148438
patch: ++ iter 1 [ n CaMeL R ] ;
rank: 252
score: 98.63518415178571
patch: if ( iter > 0 )
rank: 253
score: 99.1270168138587
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 253
score: 99.0808337983631
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Residuals ) ) ;
rank: 253
score: 99.06950298108552
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = get CaMeL Point ;
rank: 253
score: 99.00377061631944
patch: ret = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , 0 ) ;
rank: 253
score: 98.9134521484375
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current . get CaMeL Value ( ) ;
rank: 253
score: 98.7466153231534
patch: this . ++ iter ; ++ iter ; iter ;
rank: 253
score: 98.65999348958333
patch: ++ iter ; ++ Math + iter ;
rank: 253
score: 98.63576096754808
patch: r = new Point CaMeL Vector CaMeL Value CaMeL Pair ( ;
rank: 253
score: 98.63459995814732
patch: } else { ++ iter ;
rank: 254
score: 99.12688446044922
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current ; / *
rank: 254
score: 99.11107288707386
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current CaMeL Point [ iter ] ;
rank: 254
score: 99.07990056818181
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker . operate ( current CaMeL Point ) ;
rank: 254
score: 99.06946614583333
patch: int name = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 254
score: 98.91341824001736
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current ; }
rank: 254
score: 98.74583217075893
patch: ++ iter ; else break ;
rank: 254
score: 98.6598892211914
patch: ++ iter ; ; ++ max ;
rank: 254
score: 98.63514055524554
patch: if ( ! iter . starts CaMeL With ( current ) ) {
rank: 254
score: 98.63451131184895
patch: ++ iter ; while ;
rank: 255
score: 99.11107113486842
patch: Point CaMeL Vector CaMeL Value CaMeL Pair current = current CaMeL Point [ current CaMeL Point ] ;
rank: 255
score: 99.07973761307566
patch: Iterator iter = checker . get CaMeL Weight CaMeL Square CaMeL Root ( current CaMeL Objective ) ;
rank: 255
score: 99.06924599095395
patch: Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > checker =
rank: 255
score: 99.00366889105902
patch: n CaMeL C = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Objective ) ;
rank: 255
score: 98.91310119628906
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair ) . ++ ;
rank: 255
score: 98.74552917480469
patch: ++ iter ; ++ iter ; public
rank: 255
score: 98.65973663330078
patch: iter if ++ ; ++ iter ;
rank: 255
score: 98.6350326538086
patch: ++ iter ++ ; ++ iter ;
rank: 255
score: 98.63447570800781
patch: if ( ! iter > 0 ;
rank: 256
score: 99.07967979029605
patch: weighted CaMeL Residual = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Residuals ) ;
rank: 256
score: 99.0036288174716
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , n CaMeL R ) ;
rank: 256
score: 98.91291246916118
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current . get CaMeL Point ( ; }
rank: 256
score: 98.7453842163086
patch: ++ iter ; ++ 1 iter ;
rank: 256
score: 98.65972345525569
patch: ++ iter ; iter / * / ++ iter ;
rank: 256
score: 98.63381723257211
patch: if ( ! iter [ 0 ] . is CaMeL Empty ;
rank: 257
score: 99.12427775065105
patch: int [ ] current CaMeL Objective = current CaMeL Point ;
rank: 257
score: 99.11074683779762
patch: iter = compute CaMeL Weighted CaMeL Jacobian ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 257
score: 99.06887335526316
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = n CaMeL C ;
rank: 257
score: 99.00360107421875
patch: x CaMeL Norm += weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Cost ) ;
rank: 257
score: 98.9124820106908
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair . double CaMeL Value ( ) ;
rank: 257
score: 98.74527994791667
patch: / * ++ iter ; if iter ;
rank: 257
score: 98.65912628173828
patch: ++ < iter ; ++ iter ;
rank: 257
score: 98.63358248197116
patch: throw new Runtime CaMeL Exception ( $STRING$ + 1 , null ;
rank: 257
score: 98.6332674893466
patch: if ( iter == null ) { break ; }
rank: 258
score: 99.11066032858456
patch: Point CaMeL Vector CaMeL Value CaMeL Pair current = current CaMeL Point [ 0 ] ;
rank: 258
score: 99.06884002685547
patch: int CaMeL Value = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) current ;
rank: 258
score: 99.00299072265625
patch: if ( Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker ) {
rank: 258
score: 98.91208783318015
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ current CaMeL Point ;
rank: 258
score: 98.74524797712054
patch: try { ++ iter ; ;
rank: 258
score: 98.6590909090909
patch: ++ iter ; ++ iter ; } return iter ;
rank: 258
score: 98.63309733072917
patch: ++ [ ] iter = ++ iter ;
rank: 258
score: 98.63194986979167
patch: ++ iter ; Thread . current CaMeL Thread ( ) . ++ ; }
rank: 259
score: 99.12398097826087
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > qtf = current ;
rank: 259
score: 99.11064220610119
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > current CaMeL Point = current CaMeL Point ;
rank: 259
score: 99.07927703857422
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair break = current ;
rank: 259
score: 99.0678775185033
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current CaMeL Point [
rank: 259
score: 99.00225830078125
patch: long current CaMeL Cost = current CaMeL Point . length ;
rank: 259
score: 98.91180741159539
patch: inst = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point . length ) ;
rank: 259
score: 98.74334038628473
patch: ++ iter ; ++ iter ; ] ;
rank: 259
score: 98.65816243489583
patch: ++ iter ; ++ iter ; } ;
rank: 259
score: 98.6330057779948
patch: else { throw new Runtime CaMeL Exception ++ iter ; }
rank: 259
score: 98.63178045099431
patch: if ( ++ n CaMeL C >= 0 ) {
rank: 260
score: 99.1239597486413
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ,
rank: 260
score: 99.10999644886364
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current CaMeL Point = current CaMeL Point [ current CaMeL Point ) ;
rank: 260
score: 99.06781684027777
patch: int iter = Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker ;
rank: 260
score: 99.00119018554688
patch: r = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 260
score: 98.91146850585938
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , iter , ;
rank: 260
score: 98.65703125
patch: ++ iter ; ++ iter ; -= iter ;
rank: 260
score: 98.63223266601562
patch: else ++ iter ; }
rank: 260
score: 98.63128192608173
patch: ++ iter ; Thread . current CaMeL Thread ( ) . }
rank: 261
score: 99.10973539806548
patch: Convergence CaMeL Checker ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals , current CaMeL Objective ) ) ;
rank: 261
score: 99.07915649414062
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > ) {
rank: 261
score: 99.06728108723958
patch: int CaMeL Value = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , 0 ) ;
rank: 261
score: 99.00082397460938
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point . current CaMeL Objective ) ;
rank: 261
score: 98.9109245749081
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current . ++ ;
rank: 261
score: 98.65690474076705
patch: ++ iter ; ++ -- iter ; ++ iter ;
rank: 261
score: 98.63201904296875
patch: return new ++ ; } ++ iter ;
rank: 261
score: 98.63126627604167
patch: ++ iter ; while ( iter ) {
rank: 262
score: 99.12265846946023
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > current CaMeL Point ;
rank: 262
score: 99.10940115792411
patch: e = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ;
rank: 262
score: 99.07900855654762
patch: weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Objective ,
rank: 262
score: 99.06695963541667
patch: boolean checker = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 262
score: 99.000732421875
patch: private Point CaMeL Vector CaMeL Value CaMeL Pair ( Point CaMeL Vector CaMeL Value CaMeL Pair current CaMeL Point ) {
rank: 262
score: 98.91019694010417
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair ( ; }
rank: 262
score: 98.74183654785156
patch: ++ iter ; / * / /
rank: 262
score: 98.65529563210227
patch: ++ iter ; ++ - iter ; ++ iter ;
rank: 262
score: 98.6316909790039
patch: / * * ++ iter * /
rank: 262
score: 98.6294833096591
patch: if ( ! is CaMeL Empty ; ++ iter )
rank: 263
score: 99.12180494225544
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) null ;
rank: 263
score: 99.1093017578125
patch: int iter = jac CaMeL Norm . operate ( current CaMeL Residuals ) ;
rank: 263
score: 99.07892523871527
patch: Convergence CaMeL Checker ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ; }
rank: 263
score: 99.06638881138393
patch: if ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ,
rank: 263
score: 99.00041060014205
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Objective ) ;
rank: 263
score: 98.91018337673611
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , ++ n CaMeL C , ;
rank: 263
score: 98.7416748046875
patch: ++ iter ; ++ iter ; * * /
rank: 263
score: 98.65510697798295
patch: ++ iter ; ; ++ iter ; -- iter ;
rank: 263
score: 98.63167114257813
patch: / * * * * / ++ iter ;
rank: 263
score: 98.62919108072917
patch: ++ iter ; throw new Illegal CaMeL State CaMeL Exception ( $STRING$ ; }
rank: 264
score: 99.10833129882812
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = current CaMeL Point [ current CaMeL Objective ) ;
rank: 264
score: 99.07838199013158
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , this ) ) ;
rank: 264
score: 99.00010986328125
patch: n CaMeL C = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , 0 ) ;
rank: 264
score: 98.90992736816406
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ iter , iter ;
rank: 264
score: 98.74107666015625
patch: ++ iter ; ++ iter ; System . ;
rank: 264
score: 98.65475124782986
patch: ++ iter ; ++ iter ; } /
rank: 264
score: 98.63101535373264
patch: if ( iter == 0 ; return ;
rank: 264
score: 98.62815755208334
patch: ++ iter ; if ( ! iterator . is CaMeL Empty ( ) )
rank: 265
score: 99.12141927083333
patch: Point CaMeL Vector CaMeL Value CaMeL Pair checker = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) true ;
rank: 265
score: 99.10774230957031
patch: Convergence CaMeL Checker . compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 265
score: 99.07830200195312
patch: checker = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Residuals ) ;
rank: 265
score: 99.06586100260417
patch: boolean first CaMeL Iteration = checker . operate ( current CaMeL Residuals ) ;
rank: 265
score: 98.99937220982143
patch: tmp = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 265
score: 98.90981158088235
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , current ;
rank: 265
score: 98.740478515625
patch: / * ++ iter ; / ;
rank: 265
score: 98.6546963778409
patch: ++ iter ; while ++ iter ; ++ iter ;
rank: 265
score: 98.63088989257812
patch: if ( iter > 0 ; break ; }
rank: 265
score: 98.62726236979167
patch: ++ iter ; Thread . current CaMeL Thread ( ) . interrupt ; }
rank: 266
score: 99.12137858072917
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ,
rank: 266
score: 99.10711115056819
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current CaMeL Residuals [ 0 ] ;
rank: 266
score: 99.07816354851974
patch: weighted CaMeL Residual = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ;
rank: 266
score: 99.06520482113487
patch: if ( current CaMeL Residuals = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) {
rank: 266
score: 98.90966118706598
patch: Iterator iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ;
rank: 266
score: 98.74025656960227
patch: ++ iter ; ++ iter ; this . iter ;
rank: 266
score: 98.65440150669643
patch: ++ false ; ++ iter ;
rank: 266
score: 98.63079071044922
patch: else { / * ++ iter /
rank: 266
score: 98.62673514229911
patch: ++ iter ; throw new Illegal CaMeL Argument CaMeL Exception ( ) ;
rank: 267
score: 99.07805432771382
patch: ++ iter ; final Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker =
rank: 267
score: 99.06500603170956
patch: boolean compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 267
score: 98.99876302083334
patch: ! weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Cost ) ;
rank: 267
score: 98.90961100260417
patch: final ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair ++ ;
rank: 267
score: 98.65429009331598
patch: ++ iter ; ; } ++ iter ;
rank: 267
score: 98.63074408637152
patch: else { ++ [ $NUMBER$ ] ; }
rank: 267
score: 98.62635387073864
patch: if ( iter == null ) { continue ; }
rank: 268
score: 99.12128448486328
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair checker = null ;
rank: 268
score: 99.10604654947916
patch: ++ iter = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 268
score: 99.07802327473958
patch: / * compute CaMeL Cost ( current CaMeL Residuals ) ;
rank: 268
score: 99.0634296123798
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair 1 = current ;
rank: 268
score: 98.99835205078125
patch: x CaMeL Norm = Fast CaMeL Math . sqrt ( x CaMeL Norm ) ;
rank: 268
score: 98.90941619873047
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair ( current . ;
rank: 268
score: 98.73958333333333
patch: ++ iter ; * ; if iter ;
rank: 268
score: 98.65318467881944
patch: iter ; ++ ; ++ iter ; ;
rank: 268
score: 98.6306485262784
patch: if ( iter > 0 ; return . ; }
rank: 268
score: 98.625244140625
patch: final ; return new Point CaMeL Vector CaMeL Value CaMeL Pair ;
rank: 269
score: 99.12112862723214
patch: int [ ] current CaMeL Residuals = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 269
score: 99.10587350945724
patch: Point CaMeL Vector CaMeL Value CaMeL Pair current = current CaMeL Point [ current CaMeL Point ) ;
rank: 269
score: 99.07796805245536
patch: ++ checker . get CaMeL Weight CaMeL Square CaMeL Root ( ) ;
rank: 269
score: 98.99745396205357
patch: < Point CaMeL Vector CaMeL Value CaMeL Pair > < Point CaMeL Vector CaMeL Value CaMeL Pair > checker ;
rank: 269
score: 98.90908474392361
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , true ) ;
rank: 269
score: 98.73902723524306
patch: ++ 0 ; ++ iter ; iter ;
rank: 269
score: 98.630615234375
patch: if ( iter == null ;
rank: 269
score: 98.62506510416667
patch: ++ iter ; Thread . current CaMeL Thread ( ) . log ( ;
rank: 270
score: 99.1206585427989
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Point , current CaMeL Objective ) ;
rank: 270
score: 99.10544996995192
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair 0 = current ;
rank: 270
score: 99.07735443115234
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ,
rank: 270
score: 99.06269387637867
patch: compute CaMeL Weighted CaMeL Jacobian ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 270
score: 98.99715576171874
patch: state = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 270
score: 98.90904541015625
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point . trim ( ) ;
rank: 270
score: 98.73882378472223
patch: / * ++ iter ; iter * /
rank: 270
score: 98.65199279785156
patch: ++ iter ; iter / ] ;
rank: 270
score: 98.63050842285156
patch: if ( . iter == 0 ;
rank: 270
score: 98.624462890625
patch: ++ iter = Arrays . as CaMeL List ( current ) . length ;
rank: 271
score: 99.12007279829545
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) this ;
rank: 271
score: 99.10497107872597
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair iter = current ;
rank: 271
score: 99.07626522288604
patch: ++ solved CaMeL Cols ; compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 271
score: 99.06133674172794
patch: System . arraycopy ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 271
score: 98.99713812934027
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , 0 ) ;
rank: 271
score: 98.90887451171875
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ current CaMeL Point , ;
rank: 271
score: 98.73809814453125
patch: ++ iter ; / * / ;
rank: 271
score: 98.65170627170139
patch: ++ iter ; iter / - * /
rank: 271
score: 98.63037109375
patch: else { return iter ; ; }
rank: 271
score: 98.62385697798295
patch: ++ iter ; if ( is CaMeL Empty ) {
rank: 272
score: 99.12005615234375
patch: int Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current ;
rank: 272
score: 99.1047130766369
patch: d = compute CaMeL Weighted CaMeL Jacobian ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 272
score: 99.07621837797619
patch: weighted CaMeL Jacobian ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ) ;
rank: 272
score: 98.99705103824013
patch: < Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Objective ) ;
rank: 272
score: 98.90877492804276
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , false ;
rank: 272
score: 98.7379379272461
patch: ++ iter ; / ] iter ;
rank: 272
score: 98.65118408203125
patch: iter ; ++ iter ; break ;
rank: 272
score: 98.6299819946289
patch: / * / * ++ iter ;
rank: 272
score: 98.62259347098214
patch: ++ iter ; while ( super . is CaMeL Empty ( ) )
rank: 273
score: 99.11991743607955
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair && checker . operate ( current CaMeL Residuals ) ;
rank: 273
score: 99.10464332217262
patch: e = compute CaMeL Weighted CaMeL Jacobian ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ) ;
rank: 273
score: 99.07598586309524
patch: checker = weight CaMeL Matrix CaMeL Sqrt . operate ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 273
score: 99.05866156684027
patch: int iter = ( Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > )
rank: 273
score: 98.99691162109374
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ; }
rank: 273
score: 98.90820922851563
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , 1 ) ;
rank: 273
score: 98.7378817471591
patch: ++ iter ; / * * / ++ iter ;
rank: 273
score: 98.62952423095703
patch: else { / * * ++ ;
rank: 273
score: 98.62179361979166
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair [ iter ] ; }
rank: 274
score: 99.11952561598558
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = this ;
rank: 274
score: 99.10459271599265
patch: int current CaMeL Objective = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ;
rank: 274
score: 99.0754623413086
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair Math = current ;
rank: 274
score: 99.05833435058594
patch: compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , n CaMeL R ) ;
rank: 274
score: 98.99598693847656
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Objective ) ; }
rank: 274
score: 98.90768771701389
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter . iter ) ;
rank: 274
score: 98.73760308159723
patch: ++ iter ; try ; for iter ;
rank: 274
score: 98.65026245117187
patch: ++ iter ; ++ iter ; ++ $NUMBER$ ;
rank: 274
score: 98.62934875488281
patch: } if ++ iter > iter ;
rank: 274
score: 98.62132568359375
patch: if ( ++ n CaMeL C == 0 )
rank: 275
score: 99.07532456341912
patch: checker = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Objective ) ;
rank: 275
score: 98.99550170898438
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , 0 ) ;
rank: 275
score: 98.90687962582237
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point [ 0 ] ;
rank: 275
score: 98.7373046875
patch: ++ iter ; out ; ++ iter ;
rank: 275
score: 98.6502352627841
patch: ++ iter ; ++ iter ; * ++ iter ;
rank: 275
score: 98.62809922960069
patch: return ++ iter ; } ++ iter ;
rank: 275
score: 98.6207763671875
patch: block = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , ;
rank: 276
score: 99.11911349826389
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current CaMeL Residuals ( ) ;
rank: 276
score: 99.10326334635417
patch: ++ iter = final Point CaMeL Vector CaMeL Value CaMeL Pair > checker ;
rank: 276
score: 99.07518768310547
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair iterator = current ;
rank: 276
score: 99.056884765625
patch: double [ ] current CaMeL Objective = current CaMeL Point [ iter ] ;
rank: 276
score: 98.99521484375
patch: x CaMeL Norm = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , 0 ) ;
rank: 276
score: 98.90634334788604
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , iter ;
rank: 276
score: 98.73716735839844
patch: try { ++ iter ; break ;
rank: 276
score: 98.649462890625
patch: ++ iter ; ++ iter ; ++ break ;
rank: 276
score: 98.6276123046875
patch: else { ++ iter ; } return false ;
rank: 276
score: 98.61949811662946
patch: final ; if ( ! iter . is CaMeL Empty ; ) {
rank: 277
score: 99.11867453835227
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = weight CaMeL Matrix CaMeL Sqrt . operate ( ) ;
rank: 277
score: 99.07505446213942
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair contains = current ;
rank: 277
score: 98.99480646306819
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point . current CaMeL Point ) ;
rank: 277
score: 98.90620252821181
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ; }
rank: 277
score: 98.73682318793402
patch: ++ iter ; / / * / /
rank: 277
score: 98.64936967329545
patch: ++ iter ; ++ iter ; -- ++ iter ;
rank: 277
score: 98.62736511230469
patch: else { if ++ iter ++ ;
rank: 277
score: 98.6192138671875
patch: ++ iter $NUMBER$ [ n CaMeL C ] ;
rank: 278
score: 99.11819118923611
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ;
rank: 278
score: 99.10301971435547
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair $NUMBER$ = current ;
rank: 278
score: 99.0746737393466
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker . operate ( current CaMeL Objective ) ;
rank: 278
score: 98.99474158653847
patch: FrePoint CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 278
score: 98.90584891183036
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair -- ;
rank: 278
score: 98.73634168836806
patch: ++ iter ; int iter ; break ;
rank: 278
score: 98.64797973632812
patch: ++ iter ; ++ iter ; ++ true ;
rank: 278
score: 98.62674967447917
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + $NUMBER$ , $STRING$ ;
rank: 278
score: 98.61881510416667
patch: ++ iter ; Thread . sleep ( $NUMBER$ ) ; }
rank: 279
score: 99.11785016741071
patch: double [ ] current CaMeL Objective = get CaMeL Weight CaMeL Square CaMeL Root ( current CaMeL Point ) ;
rank: 279
score: 99.07423400878906
patch: weighted CaMeL Residual = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Objective ) ;
rank: 279
score: 98.99435264185855
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , ) ;
rank: 279
score: 98.9039306640625
patch: throw new Unsupported CaMeL Operation CaMeL Exception ( $STRING$ ; }
rank: 279
score: 98.73589477539062
patch: this . iter ; ++ iter ; iter ;
rank: 279
score: 98.6477383700284
patch: ++ iter ; ++ iter ; = ++ iter ;
rank: 279
score: 98.62637765066964
patch: if ( ! 0 . is CaMeL Empty ( ; ) ) {
rank: 279
score: 98.61847330729167
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair [ ] { ; }
rank: 280
score: 99.1177645596591
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) false ;
rank: 280
score: 99.10260331003289
patch: Convergence CaMeL Checker = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Residuals ) ;
rank: 280
score: 99.07400173611111
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Residuals ) ;
rank: 280
score: 99.05587005615234
patch: throw new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ;
rank: 280
score: 98.99403381347656
patch: tmp = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Cost ) ;
rank: 280
score: 98.90369873046875
patch: ++ iter * / * ++ iter * /
rank: 280
score: 98.73527018229167
patch: ++ iter ; ++ iter ; System . arraycopy iter ;
rank: 280
score: 98.6473388671875
patch: ++ iter ; ++ if ++ iter ;
rank: 280
score: 98.62617631392045
patch: if ( . is CaMeL Empty ( ) ) {
rank: 280
score: 98.61805308948864
patch: ++ iter ; if ( ! is CaMeL Empty ;
rank: 281
score: 99.1177288552989
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current CaMeL Point = current CaMeL Point [ current CaMeL Point . length ;
rank: 281
score: 99.1021728515625
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = checker ;
rank: 281
score: 99.073486328125
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair == current ;
rank: 281
score: 99.05583360460069
patch: int CaMeL Value = compute CaMeL Cost ( current CaMeL Point , current CaMeL Objective ) ;
rank: 281
score: 98.9939697265625
patch: Iterator < Point CaMeL Vector CaMeL Value CaMeL Pair > current = current ;
rank: 281
score: 98.903466796875
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current . ; }
rank: 281
score: 98.73526000976562
patch: ++ iter ; ++ + iter ;
rank: 281
score: 98.64697265625
patch: iter * ++ ; ++ iter ;
rank: 281
score: 98.62615966796875
patch: if ( iter == 0 ;
rank: 281
score: 98.61745383522727
patch: if ( ++ n CaMeL R > 0 ) {
rank: 282
score: 99.1169766512784
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) 0 ;
rank: 282
score: 99.10187377929688
patch: int CaMeL Value = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Residuals ) ;
rank: 282
score: 99.07323109019886
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair this ;
rank: 282
score: 99.05574544270833
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair final = current CaMeL Point [ 0 ] ;
rank: 282
score: 98.99383903952206
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , ) ;
rank: 282
score: 98.9033954326923
patch: int iter = current CaMeL Point . length ; ++ iter ;
rank: 282
score: 98.7348299893466
patch: ++ iter ; ++ iter ; / * / /
rank: 282
score: 98.64622497558594
patch: ++ iter ; ; = iter ;
rank: 282
score: 98.62615966796875
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ iter ;
rank: 282
score: 98.61744035993304
patch: ++ iter ; while ( Arrays . is CaMeL Empty ( ) ;
rank: 283
score: 99.11683485243056
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = weight CaMeL Matrix CaMeL Sqrt ;
rank: 283
score: 99.10186004638672
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair ( checker ) ;
rank: 283
score: 99.07305908203125
patch: while ( ! first CaMeL Iteration ) {
rank: 283
score: 99.05540556066177
patch: checker = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ,
rank: 283
score: 98.99253216911765
patch: Iterator < Point CaMeL Vector CaMeL Value CaMeL Pair > iter = n CaMeL C ;
rank: 283
score: 98.90296088324652
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , ; ;
rank: 283
score: 98.73358154296875
patch: int iter ; while ++ iter ;
rank: 283
score: 98.64566802978516
patch: ++ iter ; iter = 1 ;
rank: 283
score: 98.62588065011161
patch: else { ++ 0 ; }
rank: 283
score: 98.61717122395834
patch: if ( ! iter . is CaMeL Empty ; ) { ++ iter ;
rank: 284
score: 99.11656605113636
patch: weighted CaMeL Jacobian = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , n CaMeL C ) ;
rank: 284
score: 99.10184054904514
patch: t = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 284
score: 99.07302856445312
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair append = current ;
rank: 284
score: 99.05528259277344
patch: Object qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 284
score: 98.99246651785714
patch: return protected Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 284
score: 98.90283203125
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , iter ; }
rank: 284
score: 98.73299153645833
patch: ++ iter ; ; * int iter ;
rank: 284
score: 98.64502563476563
patch: ++ iter ; ++ iter ; else / ;
rank: 284
score: 98.62481134588069
patch: if ( . is CaMeL Empty ( ; ) )
rank: 284
score: 98.61703055245536
patch: if ( iter == 0 )
rank: 285
score: 99.1164909811581
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair = current CaMeL Point ;
rank: 285
score: 99.10182100183823
patch: ++ compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Residuals ) ;
rank: 285
score: 99.0729736328125
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair != current ;
rank: 285
score: 99.05463409423828
patch: String qr CaMeL Decomposition = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 285
score: 98.99236701516544
patch: if ( weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ) {
rank: 285
score: 98.90275743272569
patch: ++ iter * / * * * /
rank: 285
score: 98.73295593261719
patch: int iter ; ++ - 1 ;
rank: 285
score: 98.64485931396484
patch: ++ iter ; ++ iter ; iter
rank: 285
score: 98.62434217664931
patch: else { ++ < 0 > iter ;
rank: 285
score: 98.61620483398437
patch: Iterator iter = iter . clone ( ) ;
rank: 286
score: 99.10166422526042
patch: result = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 286
score: 99.07265218098958
patch: / / compute CaMeL Cost ( current CaMeL Point ) ;
rank: 286
score: 98.9920654296875
patch: result = get CaMeL Weight CaMeL Square CaMeL Root ( current CaMeL Point , current CaMeL Objective ) ;
rank: 286
score: 98.90234375
patch: Iterator iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ;
rank: 286
score: 98.73285675048828
patch: ++ iter ; ++ ; * ;
rank: 286
score: 98.64479758522727
patch: ++ iter ; ++ iter ; ++ -- iter ;
rank: 286
score: 98.6231918334961
patch: else { if ; ++ iter ;
rank: 286
score: 98.61598510742188
patch: switch ( iter ) { case - 1 :
rank: 287
score: 99.10165244654605
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = Convergence CaMeL Checker ;
rank: 287
score: 99.072509765625
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair !=
rank: 287
score: 99.0540771484375
patch: / * Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker =
rank: 287
score: 98.99177381727431
patch: n CaMeL R = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Cost ) ;
rank: 287
score: 98.90230305989583
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current . ++ , ;
rank: 287
score: 98.64434259588069
patch: ++ iter ; ++ iter ; -- iter ; ;
rank: 287
score: 98.6227518717448
patch: if ( . is CaMeL Empty ( ) ; return ;
rank: 287
score: 98.61512247721355
patch: ++ iter 1 [ n CaMeL C ] ; break ;
rank: 288
score: 99.11614990234375
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current CaMeL Point . current ;
rank: 288
score: 99.0724868774414
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair out = current ;
rank: 288
score: 99.05343967013889
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair final = current CaMeL Point [ iter ] ;
rank: 288
score: 98.99163818359375
patch: current CaMeL Point = compute CaMeL Cost ( current CaMeL Point ) ;
rank: 288
score: 98.90217420789931
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ; }
rank: 288
score: 98.73233371310764
patch: ++ iter ; int iter ; out ;
rank: 288
score: 98.643798828125
patch: { ++ iter ; ++ iter ;
rank: 288
score: 98.62133178710937
patch: if ( iter == null ; return null ;
rank: 288
score: 98.6138916015625
patch: if ( ! iter [ iter ] . is CaMeL Empty ( ) )
rank: 289
score: 99.11602020263672
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = $NUMBER$ . 0 ;
rank: 289
score: 99.10031609786184
patch: Point CaMeL Vector CaMeL Value CaMeL Pair checker = current CaMeL Point [ current CaMeL Residuals ] ;
rank: 289
score: 99.0724628155048
patch: int iter = checker . operate ( current CaMeL Point ) ;
rank: 289
score: 99.05341045673077
patch: if ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 289
score: 98.99094752261513
patch: n CaMeL R = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ; }
rank: 289
score: 98.90081428079044
patch: int iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , iter ;
rank: 289
score: 98.73162163628473
patch: ++ iter ; ++ iter ; System ;
rank: 289
score: 98.64248657226562
patch: ++ iter ; ++ start ; }
rank: 289
score: 98.62049102783203
patch: if ( iter ; > $NUMBER$ ;
rank: 290
score: 99.115869140625
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = weight CaMeL Matrix CaMeL Sqrt . operate (
rank: 290
score: 99.09999778053977
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = new Point CaMeL Vector CaMeL Value CaMeL Pair ( ) ;
rank: 290
score: 99.0723876953125
patch: / * compute CaMeL Cost ( current CaMeL Point ) ;
rank: 290
score: 99.05336626838235
patch: boolean first CaMeL Iteration = Fast CaMeL Math . sqrt ( current CaMeL Point ) ;
rank: 290
score: 98.90068969726562
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , true ) ;
rank: 290
score: 98.73116048177083
patch: ++ iter ; try ; while iter ;
rank: 290
score: 98.61993408203125
patch: return new ++ [ 0 ] ; }
rank: 290
score: 98.6136474609375
patch: if ( ! iter [ iter ] . is CaMeL Empty ( ) ;
rank: 291
score: 99.09991164434524
patch: qtf ( qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ) ;
rank: 291
score: 99.07180786132812
patch: while ( iter <= get CaMeL Weight CaMeL Square CaMeL Root ( ) ) {
rank: 291
score: 99.05269368489583
patch: return weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ,
rank: 291
score: 98.99050903320312
patch: list = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Objective ) ;
rank: 291
score: 98.90037777549342
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point . trim ( ;
rank: 291
score: 98.73114013671875
patch: ++ iter ; / * * ++ iter ;
rank: 291
score: 98.64157104492188
patch: ++ ++ iter ; ++ start ;
rank: 291
score: 98.61983913845486
patch: if ( iter == 0 ; break ;
rank: 291
score: 98.6130859375
patch: ++ iter ; Thread . current CaMeL Thread ( ) . exit ( ;
rank: 292
score: 99.11481475830078
patch: int [ ] current CaMeL Objective = weight CaMeL Matrix CaMeL Sqrt . operate (
rank: 292
score: 99.07157970610119
patch: weighted CaMeL Residual = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ; }
rank: 292
score: 99.05228424072266
patch: return weighted CaMeL Residual = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 292
score: 98.99000379774306
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , qtf ) ;
rank: 292
score: 98.7304931640625
patch: ++ iter ; while iter ; while iter ;
rank: 292
score: 98.64127349853516
patch: iter ++ ; ; ++ iter ;
rank: 292
score: 98.6197979266827
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + 0 ;
rank: 292
score: 98.61279296875
patch: ++ iter ; if ( iter == 0 ) break ;
rank: 293
score: 99.11427935431985
patch: double iter = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 293
score: 99.0996326264881
patch: else qr CaMeL Decomposition = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 293
score: 99.0712890625
patch: / / compute CaMeL Cost ( current CaMeL Objective , current CaMeL Objective ) ;
rank: 293
score: 99.05160861545139
patch: / * compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 293
score: 98.9897705078125
patch: check CaMeL Parameters ( current CaMeL Point , current CaMeL Objective ) ; }
rank: 293
score: 98.89902072482639
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair ( current . ++ , ;
rank: 293
score: 98.73032633463542
patch: ++ iter ; out ; int iter ;
rank: 293
score: 98.64055786132812
patch: ++ iter ; ++ iter ; iter ; count
rank: 293
score: 98.61958821614583
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + 1 , null ;
rank: 293
score: 98.61232688210227
patch: if ( ++ n CaMeL C < iter ) {
rank: 294
score: 99.07098388671875
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Objective ) ;
rank: 294
score: 99.05137634277344
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = current CaMeL Point ) ;
rank: 294
score: 98.98903937088816
patch: ! weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 294
score: 98.89849853515625
patch: int iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ; ++ iter )
rank: 294
score: 98.72895812988281
patch: ( ++ iter ; ++ iter ;
rank: 294
score: 98.64041137695312
patch: ++ iter ; ++ ++ iter ; iter ;
rank: 294
score: 98.61953299386161
patch: ++ * * ++ iter ;
rank: 294
score: 98.61158752441406
patch: ++ iter $NUMBER$ [ 0 ] ;
rank: 295
score: 99.11405613111413
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > current = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) current ;
rank: 295
score: 99.09910673253677
patch: it = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ;
rank: 295
score: 99.07094439338235
patch: Iterator iter = checker . weight CaMeL Matrix CaMeL Sqrt ( current CaMeL Point ) ;
rank: 295
score: 99.05137416294643
patch: Point CaMeL Vector CaMeL Value CaMeL Pair checker = current CaMeL Point ;
rank: 295
score: 98.98884800502232
patch: { final Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 295
score: 98.898193359375
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , false ) ;
rank: 295
score: 98.72865125868056
patch: int iter ; ++ iter = iter ;
rank: 295
score: 98.64004516601562
patch: ++ iter ; ++ null ; ++ iter ;
rank: 295
score: 98.61846051897321
patch: if ( ! 0 . is CaMeL Empty ( ) ) continue ;
rank: 296
score: 99.114013671875
patch: weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Objective , current CaMeL Point ) ;
rank: 296
score: 99.09867931547619
patch: list = compute CaMeL Weighted CaMeL Jacobian ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 296
score: 98.98820356889205
patch: if ( weight CaMeL Matrix CaMeL Sqrt . weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) )
rank: 296
score: 98.89793701171875
patch: Point CaMeL Vector CaMeL Value CaMeL Pair current = new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++
rank: 296
score: 98.72861056857639
patch: ++ iter ; iter ; while iter ;
rank: 296
score: 98.63982599431819
patch: ++ iter ; ++ iter ; ; ++ 1 ;
rank: 296
score: 98.61839463975694
patch: if ( iter > 0 ; break ;
rank: 296
score: 98.61061604817708
patch: ++ iter ; else {
rank: 297
score: 99.113623046875
patch: ++ weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 297
score: 99.09862171519886
patch: qr CaMeL Decomposition = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Residuals ) ;
rank: 297
score: 99.07080078125
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , weighted CaMeL Jacobian ) ) ;
rank: 297
score: 99.05113874162946
patch: j = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 297
score: 98.98804389105902
patch: list = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , 0 ) ;
rank: 297
score: 98.89784458705357
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current ) ; }
rank: 297
score: 98.72822875976563
patch: ++ iter ; ++ iter ; - iter ;
rank: 297
score: 98.63970947265625
patch: ++ iter ; ++ iter ; } / /
rank: 297
score: 98.61786566840277
patch: ++ iter ; return ++ iter ; }
rank: 297
score: 98.61025565011161
patch: ++ iter ; if ( ! this . is CaMeL Empty ) {
rank: 298
score: 99.09834369860198
patch: qtf = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals , current CaMeL Objective ) ;
rank: 298
score: 99.07034737723214
patch: iter = final Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Objective ) ;
rank: 298
score: 99.05096435546875
patch: qtf ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 298
score: 98.89763726128473
patch: ++ iter ; return new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , ; }
rank: 298
score: 98.72811889648438
patch: return iter ; ++ iter ; ;
rank: 298
score: 98.63930442116477
patch: ++ iter ; ++ iter ; else return iter ;
rank: 298
score: 98.61785888671875
patch: else { ++ iter * iter ; }
rank: 298
score: 98.610107421875
patch: ++ iter ; ++ n CaMeL C ; ++ ;
rank: 299
score: 99.09833374023438
patch: qtf = compute CaMeL Weighted CaMeL Jacobian ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 299
score: 99.0703125
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair += checker . operate ( current CaMeL Objective ) ;
rank: 299
score: 99.05068790211396
patch: boolean first CaMeL Iteration = Fast CaMeL Math . sqrt ( x CaMeL Norm ) ;
rank: 299
score: 98.98726029829545
patch: [ ] weight CaMeL Matrix CaMeL Sqrt = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 299
score: 98.89762660435268
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current
rank: 299
score: 98.63869018554688
patch: ++ iter ; ++ iter ; / / }
rank: 299
score: 98.61780657087054
patch: return iter ; } else {
rank: 300
score: 99.11295572916667
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = ( Point CaMeL Vector CaMeL Value CaMeL Pair )
rank: 300
score: 99.07001696134868
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ; break ;
rank: 300
score: 99.05063883463542
patch: if ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective , (
rank: 300
score: 98.98683860085227
patch: [ ] weight CaMeL Matrix CaMeL Sqrt = get CaMeL Weight CaMeL Square CaMeL Root ( current CaMeL Point ) ;
rank: 300
score: 98.89727020263672
patch: int iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter ) ;
rank: 300
score: 98.72769927978516
patch: ++ iter ; * / iter ;
rank: 300
score: 98.63861846923828
patch: ++ iter ; ++ 1 ; }
rank: 300
score: 98.6176986694336
patch: else { / * * * ;
rank: 300
score: 98.60928548177084
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + n CaMeL C ;
rank: 301
score: 99.11285807291667
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair > checker =
rank: 301
score: 99.097900390625
patch: qtf = weight CaMeL Matrix CaMeL Sqrt ( current CaMeL Point , current CaMeL Objective ) ;
rank: 301
score: 99.05035400390625
patch: return compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ; }
rank: 301
score: 98.98668619791667
patch: < Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ;
rank: 301
score: 98.89639621310764
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current . get CaMeL Value ( ;
rank: 301
score: 98.72764369419643
patch: / * ] iter ++ ;
rank: 301
score: 98.63856724330357
patch: ++ new ; ++ iter ;
rank: 301
score: 98.61652374267578
patch: if ( iter == 0 ; {
rank: 301
score: 98.60892944335937
patch: if ( iter != null ) ++ iter ;
rank: 302
score: 99.09752133018092
patch: else qr CaMeL Decomposition = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 302
score: 99.06983857996323
patch: iter = final Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ;
rank: 302
score: 98.98653738839286
patch: private Point CaMeL Vector CaMeL Value CaMeL Pair ( Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 302
score: 98.89622587316177
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair ( current ) ; }
rank: 302
score: 98.6381591796875
patch: ++ iter ; ++ iter ; else break ;
rank: 302
score: 98.61590576171875
patch: if ( iter > 1 ;
rank: 302
score: 98.60889543805804
patch: r = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter ;
rank: 303
score: 99.11222534179687
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = ( Point CaMeL Vector CaMeL Value CaMeL Pair )
rank: 303
score: 99.0694515830592
patch: iter = checker . operate ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 303
score: 99.05019802517361
patch: boolean first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( qtf ) ;
rank: 303
score: 98.98647925967262
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) . double CaMeL Value ( ) ;
rank: 303
score: 98.89591710707721
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , iter ) . ++ ;
rank: 303
score: 98.72747039794922
patch: ++ iter ; ++ * ) ;
rank: 303
score: 98.63781127929687
patch: ++ iter ; iter * ; ++ iter ;
rank: 303
score: 98.61525315504808
patch: if ( . is CaMeL Empty ( ) ; ++ iter ;
rank: 303
score: 98.60821940104167
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , new ;
rank: 304
score: 99.11221168154762
patch: Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = this ;
rank: 304
score: 99.0972900390625
patch: final Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = checker ;
rank: 304
score: 99.06937081473214
patch: weighted CaMeL Residual ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals , current CaMeL Objective ) ) ;
rank: 304
score: 99.04985700334821
patch: current = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 304
score: 98.98553757440476
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ; }
rank: 304
score: 98.89574432373047
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter ) ;
rank: 304
score: 98.72711181640625
patch: try { ++ iter ; }
rank: 304
score: 98.63685607910156
patch: ++ $STRING$ ; ; ++ iter ;
rank: 304
score: 98.61476135253906
patch: else { / * ++ ; }
rank: 304
score: 98.60770961216518
patch: if ( ! iter . is CaMeL Empty ( ) ; else {
rank: 305
score: 99.09728240966797
patch: qtf ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ) ;
rank: 305
score: 99.0690982216283
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > ;
rank: 305
score: 99.04955291748047
patch: boolean first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( ) ;
rank: 305
score: 98.98486328125
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( get CaMeL Weight CaMeL Square CaMeL Root ( ) ) ;
rank: 305
score: 98.89552066200658
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point . substring ;
rank: 305
score: 98.7267074584961
patch: / * ] iter ; / /
rank: 305
score: 98.63642883300781
patch: ++ iter ; iter / - /
rank: 305
score: 98.61474609375
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + $NUMBER$ + $STRING$ ;
rank: 305
score: 98.60726224459134
patch: while ( ! iter . is CaMeL Empty ( ) ; )
rank: 306
score: 99.09718017578125
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Residuals , current CaMeL Residuals ) ;
rank: 306
score: 99.06887978001645
patch: weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ; {
rank: 306
score: 98.98422241210938
patch: first CaMeL Iteration = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) current ;
rank: 306
score: 98.89542061941964
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ;
rank: 306
score: 98.63589477539062
patch: iter ; ++ iter ; ; ++ iter ;
rank: 306
score: 98.61465115017361
patch: else { if ( iter > 0 )
rank: 306
score: 98.60659790039062
patch: if ( ! index CaMeL Of ( current ) ) {
rank: 307
score: 99.11185455322266
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > current = current CaMeL Point ;
rank: 307
score: 99.09705461774554
patch: p = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 307
score: 99.06722586495536
patch: compute CaMeL Cost ( current CaMeL Point , current CaMeL Objective ) ;
rank: 307
score: 99.0475212545956
patch: String qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ,
rank: 307
score: 98.9840839092548
patch: Iterator < Point CaMeL Vector CaMeL Value CaMeL Pair > ++ ;
rank: 307
score: 98.89541015625
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point . trim ; ;
rank: 307
score: 98.72639973958333
patch: ++ iter ; try ; return iter ;
rank: 307
score: 98.63426208496094
patch: ++ start ; ; ++ iter ;
rank: 307
score: 98.61414930555556
patch: } if ++ iter ] = iter ;
rank: 307
score: 98.60656127929687
patch: if ( iter == this . ++ ) {
rank: 308
score: 99.11151444284539
patch: double current CaMeL Objective = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Objective ) ;
rank: 308
score: 99.06574249267578
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair chars = current ;
rank: 308
score: 98.98404541015626
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , true ) ;
rank: 308
score: 98.8946533203125
patch: inst = new Point CaMeL Vector CaMeL Value CaMeL Pair ( ;
rank: 308
score: 98.72637261284723
patch: ++ iter ; / ; if iter ;
rank: 308
score: 98.63401489257812
patch: ++ iter ; ++ iter ; iter ; ;
rank: 308
score: 98.61407470703125
patch: if ( ! 0 . is CaMeL Empty ( ) ) break ;
rank: 308
score: 98.60616629464286
patch: if ( ! iter . is CaMeL Empty ; ++ iter ) {
rank: 309
score: 99.09649103338069
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current CaMeL Point = current CaMeL Point [ current CaMeL Objective ] ;
rank: 309
score: 98.98349397078805
patch: < Point CaMeL Vector CaMeL Value CaMeL Pair > < Point CaMeL Vector CaMeL Value CaMeL Pair > current = current ;
rank: 309
score: 98.89431280838816
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current . to CaMeL String ( ) ;
rank: 309
score: 98.72608531605114
patch: / * ++ iter ; / / ++ iter ;
rank: 309
score: 98.6140380859375
patch: if ( ! 0 . is CaMeL Empty ( ) ) return null ;
rank: 309
score: 98.60528564453125
patch: ++ iter ; ++ iter - 1 ;
rank: 310
score: 99.11087472098214
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = compute CaMeL Weighted CaMeL Jacobian ( qtf ) ;
rank: 310
score: 99.06549944196429
patch: checker = get CaMeL Weight CaMeL Square CaMeL Root ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 310
score: 99.04648166232639
patch: int CaMeL Value = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) current CaMeL Point ;
rank: 310
score: 98.98310990767045
patch: private Point CaMeL Vector CaMeL Value CaMeL Pair ( Point CaMeL Vector CaMeL Value CaMeL Pair current CaMeL Objective ) {
rank: 310
score: 98.89421530330883
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , iter , ; }
rank: 310
score: 98.72593858506944
patch: int iter ; else ; ++ iter ;
rank: 310
score: 98.6336898803711
patch: iter / ++ ; ++ iter ;
rank: 310
score: 98.61378580729166
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + 0 , $STRING$ ;
rank: 311
score: 99.11076216264205
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = < Point CaMeL Vector CaMeL Value CaMeL Pair > current ;
rank: 311
score: 99.09564568014706
patch: ++ iter = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 311
score: 99.06546359592014
patch: ++ n CaMeL R ; weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate (
rank: 311
score: 99.04618566176471
patch: if ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Residuals ,
rank: 311
score: 98.98239135742188
patch: false = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 311
score: 98.89280299136513
patch: inst = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point . length , ;
rank: 311
score: 98.72549438476562
patch: ++ iter ; iter ; if ++ iter ;
rank: 311
score: 98.63362260298295
patch: ++ iter ; ; ++ iter ; ++ ++ ;
rank: 311
score: 98.61377631293402
patch: ++ iter ; } if ++ iter ;
rank: 311
score: 98.60481770833333
patch: while ( false ) {
rank: 312
score: 99.11048473011364
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = < Point CaMeL Vector CaMeL Value CaMeL Pair > ;
rank: 312
score: 99.0654052734375
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , qtf ) ) ;
rank: 312
score: 98.98219517299107
patch: < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = this ;
rank: 312
score: 98.89279014185855
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , start ;
rank: 312
score: 98.72528631036931
patch: / * ++ iter ; / / int iter ;
rank: 312
score: 98.63325805664063
patch: ++ iter ; ++ iter ; += iter ;
rank: 312
score: 98.61328996930804
patch: else { ++ 1 ; }
rank: 312
score: 98.60470581054688
patch: if ( ! iter . equals ( iter ) ) {
rank: 313
score: 99.1094970703125
patch: Point CaMeL Vector CaMeL Value CaMeL Pair checker = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ,
rank: 313
score: 99.09555951286765
patch: i = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Residuals ) ;
rank: 313
score: 99.064892578125
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > final ,
rank: 313
score: 98.98218451605902
patch: if ( weight CaMeL Matrix CaMeL Sqrt . weight CaMeL Matrix CaMeL Sqrt ( ) ) {
rank: 313
score: 98.89266628689236
patch: ++ iter ] = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter ) ; }
rank: 313
score: 98.63306884765625
patch: ++ iter ; ; if iter * ++ ;
rank: 313
score: 98.612939453125
patch: else { if ++ iter ; break ; }
rank: 313
score: 98.60463169642857
patch: p = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter ;
rank: 314
score: 99.06449962797619
patch: qr CaMeL Decomposition = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ; }
rank: 314
score: 99.04405975341797
patch: return compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Point ,
rank: 314
score: 98.98213918585526
patch: <= Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Objective ) ;
rank: 314
score: 98.89259248621323
patch: ++ iter ; return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current ) ;
rank: 314
score: 98.72502983940973
patch: / * ++ iter ; / * /
rank: 314
score: 98.63302273220486
patch: ++ iter ; iter / ; * /
rank: 314
score: 98.61257595486111
patch: if ( iter < 0 ) return ;
rank: 314
score: 98.60390403053977
patch: throw new Unsupported CaMeL Operation CaMeL Exception ( $STRING$ ;
rank: 315
score: 99.108935546875
patch: Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current CaMeL Point [ n CaMeL C ] ;
rank: 315
score: 99.09518093532986
patch: r = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 315
score: 98.98201293945313
patch: Iterator < Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > ;
rank: 315
score: 98.89253065321181
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current . ++ ) ;
rank: 315
score: 98.72489166259766
patch: * ++ iter ; ++ iter ;
rank: 315
score: 98.63236083984376
patch: ++ iter ; ; ++ iter ; break ;
rank: 315
score: 98.6100082397461
patch: ++ iter ; * * / /
rank: 315
score: 98.6038309733073
patch: ++ iter ; Thread . current CaMeL Thread ( ; }
rank: 316
score: 99.1089200106534
patch: Point CaMeL Vector CaMeL Value CaMeL Pair checker = ( Point CaMeL Vector CaMeL Value CaMeL Pair > ) current ;
rank: 316
score: 99.09508514404297
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 316
score: 99.06393229166666
patch: weighted CaMeL Residual = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 316
score: 98.9818115234375
patch: if ( weight CaMeL Matrix CaMeL Sqrt . operate ( ) ) {
rank: 316
score: 98.8923828125
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , true ) ;
rank: 316
score: 98.72451443142361
patch: ++ iter ; ++ - - 1 ;
rank: 316
score: 98.63195190429687
patch: ++ iter ; ++ iter ; -- start ;
rank: 316
score: 98.60857391357422
patch: / * * ++ * * /
rank: 316
score: 98.60333251953125
patch: ++ iter ; Thread . current CaMeL Thread ( ) . join ;
rank: 317
score: 99.10840905230978
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = weight CaMeL Matrix CaMeL Sqrt . operate (
rank: 317
score: 99.09499289772727
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = $STRING$ ;
rank: 317
score: 99.06361299402573
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ,
rank: 317
score: 99.04241071428571
patch: c = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 317
score: 98.980712890625
patch: x CaMeL Norm = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ; }
rank: 317
score: 98.8919677734375
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ iter ;
rank: 317
score: 98.63156127929688
patch: ++ null ; ++ iter ; ++ iter ;
rank: 317
score: 98.60837131076389
patch: else ++ iter [ iter ] ; }
rank: 317
score: 98.60328674316406
patch: ++ iter - iter + 1 ;
rank: 318
score: 99.10823567708333
patch: Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = false ;
rank: 318
score: 99.09499224494485
patch: e = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ;
rank: 318
score: 99.06339111328126
patch: ++ iter ; final Convergence CaMeL Checker . get CaMeL Weight CaMeL Square CaMeL Root ( ) ; }
rank: 318
score: 99.04207611083984
patch: boolean first CaMeL Iteration = current CaMeL Point . length < n CaMeL R ;
rank: 318
score: 98.98043020148026
patch: instanceof Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Objective ) ;
rank: 318
score: 98.8918816061581
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , iter ;
rank: 318
score: 98.63127305772569
patch: ++ iter ; ++ ( ++ iter ;
rank: 318
score: 98.60777282714844
patch: else { ++ iter ; break ;
rank: 318
score: 98.60177951388889
patch: while ( false ) { ++ iter ;
rank: 319
score: 99.108154296875
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair list = ( Point CaMeL Vector CaMeL Value CaMeL Pair > ) current ;
rank: 319
score: 99.09459228515625
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair final = current CaMeL Point [ current CaMeL Objective ] ;
rank: 319
score: 99.04123360770089
patch: int CaMeL Value ( current CaMeL Point , current CaMeL Objective ) ;
rank: 319
score: 98.97990337171052
patch: void weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 319
score: 98.89071044921874
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point . substring ( ;
rank: 319
score: 98.72268337673611
patch: ++ iter ; if ++ iter ; ;
rank: 319
score: 98.6307040127841
patch: ++ iter ; ++ ++ iter ; if iter ;
rank: 319
score: 98.60706380208333
patch: if ( . is CaMeL Empty ( ) ) { return null ; }
rank: 319
score: 98.60088500976562
patch: if ( ! is CaMeL Empty ( ) ;
rank: 320
score: 99.10786946614583
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current ; / /
rank: 320
score: 99.09439522879464
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = current ; {
rank: 320
score: 99.06255026424633
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ,
rank: 320
score: 99.04118516710069
patch: int ! compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 320
score: 98.97959206321023
patch: if ( weight CaMeL Matrix CaMeL Sqrt . weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) )
rank: 320
score: 98.72239176432292
patch: ++ iter ; ++ iter ; in ;
rank: 320
score: 98.63039143880208
patch: ++ iter ; ; if iter -- ;
rank: 320
score: 98.5999043782552
patch: if ( ! is CaMeL Empty ( ; ) ) {
rank: 321
score: 99.10753580729167
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = current ; / /
rank: 321
score: 99.09413364955357
patch: p = compute CaMeL Weighted CaMeL Jacobian ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 321
score: 99.06249321831598
patch: while ( iter < checker . get CaMeL Weight CaMeL Square CaMeL Root ( ) ) {
rank: 321
score: 99.04090033637152
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = qtf ;
rank: 321
score: 98.97889927455357
patch: Iterator protected Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 321
score: 98.89031661184211
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter . get CaMeL Value ( ;
rank: 321
score: 98.72233751085069
patch: ++ iter ; ++ 1 + iter ;
rank: 321
score: 98.62996049360795
patch: ++ iter ; ++ iter ; } -- iter ;
rank: 321
score: 98.60655381944444
patch: else { if ; return iter ; }
rank: 321
score: 98.59815392127403
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( new ;
rank: 322
score: 99.10751342773438
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current . current ;
rank: 322
score: 99.06219803659539
patch: ++ iter ; final Convergence CaMeL Checker . compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 322
score: 98.9787841796875
patch: n CaMeL C = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point . length ) ;
rank: 322
score: 98.88996887207031
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , ++ iter ;
rank: 322
score: 98.72221235795455
patch: ++ iter ; ++ iter ; System . out ;
rank: 322
score: 98.6296053799716
patch: ++ iter ; ++ iter ; ++ * iter ;
rank: 322
score: 98.60601806640625
patch: if ( iter > $NUMBER$ ;
rank: 322
score: 98.59806605747768
patch: ++ iter ; while ( Arrays . is CaMeL Empty ; ) {
rank: 323
score: 99.1074855638587
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) get ;
rank: 323
score: 99.06199544270834
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair < double ;
rank: 323
score: 99.03867013113839
patch: double iter = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 323
score: 98.97847707648026
patch: comparator . qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Objective ) ) ;
rank: 323
score: 98.88990542763158
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point . length ,
rank: 323
score: 98.6288729580966
patch: ++ iter ; ++ iter ; / return iter ;
rank: 323
score: 98.60523681640625
patch: else { ++ iter ; break ; } }
rank: 323
score: 98.59798758370536
patch: if ( ++ iter ) {
rank: 324
score: 99.10719700863487
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = current CaMeL Point [ current CaMeL Point ;
rank: 324
score: 99.0936279296875
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = current CaMeL Residuals [ qtf ] ;
rank: 324
score: 99.06186810661765
patch: checker = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ; }
rank: 324
score: 99.03853352864583
patch: if ( n CaMeL C < n CaMeL R ) {
rank: 324
score: 98.978271484375
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , ) ;
rank: 324
score: 98.88950805664062
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current . get CaMeL Value ( ) ; }
rank: 324
score: 98.62875705295139
patch: ++ iter ; ++ iter ; try }
rank: 324
score: 98.60506497896634
patch: if ( . is CaMeL Empty ( ) ) ++ iter ;
rank: 324
score: 98.59778703962054
patch: if ( ! iter . compare CaMeL To ( current ) ) {
rank: 325
score: 99.10716417100694
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current . current CaMeL Point ;
rank: 325
score: 99.06169577205883
patch: Iterator iter = checker . weight CaMeL Matrix CaMeL Sqrt ( current CaMeL Residuals ) ;
rank: 325
score: 99.03794860839844
patch: ( ( Point CaMeL Vector CaMeL Value CaMeL Pair ) current CaMeL Point ) .
rank: 325
score: 98.97800699869792
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals [ iter ] ) ;
rank: 325
score: 98.88921042049633
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , ; }
rank: 325
score: 98.72114701704545
patch: ++ iter ; ++ iter ; / * / ;
rank: 325
score: 98.62871636284723
patch: iter ; ++ iter ; / / /
rank: 325
score: 98.60478210449219
patch: else { ++ * * iter /
rank: 325
score: 98.59559122721355
patch: if ( iter != null ) { ++ iter ; }
rank: 326
score: 99.09339488636364
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current CaMeL Point = current CaMeL Point [ current CaMeL Point ] ;
rank: 326
score: 99.06117466517857
patch: qr CaMeL Decomposition = compute CaMeL Weighted CaMeL Jacobian ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 326
score: 99.03776550292969
patch: int CaMeL Value = compute CaMeL Weighted CaMeL Jacobian [ current CaMeL Point ) ;
rank: 326
score: 98.97788373161765
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , iter ) ;
rank: 326
score: 98.88919406467014
patch: ++ iter ] = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , ; }
rank: 326
score: 98.72096761067708
patch: / * ++ iter ; / / ;
rank: 326
score: 98.62789306640624
patch: ++ max ; ++ iter ; ++ iter ;
rank: 326
score: 98.6046875
patch: if ( iter > 0 ; return ; }
rank: 326
score: 98.59555489676339
patch: block = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current ;
rank: 327
score: 99.06061662946429
patch: weighted CaMeL Residual = compute CaMeL Weighted CaMeL Jacobian ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 327
score: 99.03755457261029
patch: boolean first CaMeL Iteration = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current ;
rank: 327
score: 98.97738444010416
patch: ! weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Objective ) ;
rank: 327
score: 98.88888549804688
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current ;
rank: 327
score: 98.7197265625
patch: ++ iter ; while iter ; ++ iter ;
rank: 327
score: 98.60446166992188
patch: throw new Runtime CaMeL Exception ( $STRING$ + 1 ) ;
rank: 327
score: 98.59547729492188
patch: ++ iter ; while ( iter != 0 )
rank: 328
score: 99.09296209161931
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current CaMeL Point = current CaMeL Point [ current CaMeL Residuals ] ;
rank: 328
score: 99.06059337797619
patch: ++ iter ; final Convergence CaMeL Checker . compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ; }
rank: 328
score: 98.97720157398896
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ,
rank: 328
score: 98.88825225830078
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , ++ iter , ;
rank: 328
score: 98.718505859375
patch: / * ++ ++ iter ; ++ iter ;
rank: 328
score: 98.62573920355902
patch: iter ; ++ iter ; ; / /
rank: 328
score: 98.604345703125
patch: else { ++ iter [ 0 ] ; }
rank: 328
score: 98.59530639648438
patch: if ( ! iter [ 0 ] . equals ( ;
rank: 329
score: 99.10663396661931
patch: weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Cost ) ;
rank: 329
score: 99.05970674402573
patch: Convergence CaMeL Checker ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Objective ) ) ;
rank: 329
score: 99.037109375
patch: Point CaMeL Vector CaMeL Value CaMeL Pair current CaMeL Point = current ;
rank: 329
score: 98.97654371995192
patch: ( Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 329
score: 98.88824103860294
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current ) ;
rank: 329
score: 98.71794128417969
patch: / * ++ ++ ++ iter ;
rank: 329
score: 98.62495727539063
patch: ++ iter ; ++ iter ; iter ; iter
rank: 329
score: 98.60432942708333
patch: / * * * ++ iter * /
rank: 329
score: 98.5946273803711
patch: if ( iter >= 1 ) {
rank: 330
score: 99.10660453464673
patch: Point CaMeL Vector CaMeL Value CaMeL Pair > checker = ( Point CaMeL Vector CaMeL Value CaMeL Pair > ) current ;
rank: 330
score: 99.09272317325367
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair qtf = current ;
rank: 330
score: 99.05951397235577
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair copy = current ;
rank: 330
score: 99.03669084821429
patch: Point CaMeL Vector CaMeL Value CaMeL Pair [ ] current = current ;
rank: 330
score: 98.97626287286931
patch: [ ] weight CaMeL Matrix CaMeL Sqrt = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 330
score: 98.88802083333333
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point
rank: 330
score: 98.71772596571181
patch: int iter ; / * * / /
rank: 330
score: 98.6246670809659
patch: ++ iter ; ++ iter ; else / / /
rank: 330
score: 98.60426635742188
patch: if ( iter == 0 ) return iter ;
rank: 330
score: 98.59449351917614
patch: if ( ! iter . contains ( current ) )
rank: 331
score: 99.1064453125
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair -- ; final Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 331
score: 99.09236450195313
patch: return compute CaMeL Weighted CaMeL Jacobian ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ) ;
rank: 331
score: 99.03668891059027
patch: key = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 331
score: 98.97610134548611
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , 0 ) ; }
rank: 331
score: 98.88762872869319
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( ;
rank: 331
score: 98.71731131417411
patch: ++ iter ; break ; ;
rank: 331
score: 98.6245849609375
patch: ++ iter ; ++ iter ; ++ null ;
rank: 331
score: 98.60231018066406
patch: ++ iter ; while ; * /
rank: 331
score: 98.5927734375
patch: ++ iter ; Thread . current CaMeL Thread ( ) .
rank: 332
score: 99.10630731997283
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current ;
rank: 332
score: 99.05911690848214
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Objective ) ;
rank: 332
score: 99.03649088541667
patch: Map < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = null ;
rank: 332
score: 98.97516424005681
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) . operate ( current CaMeL Point ) ;
rank: 332
score: 98.88762350643383
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , ++ n CaMeL R ;
rank: 332
score: 98.71675618489583
patch: ++ iter ; ++ iter ; * / ++ iter ;
rank: 332
score: 98.62447781032986
patch: ++ ++ iter ; ++ iter ; ;
rank: 332
score: 98.60208565848214
patch: else ; ++ iter ; }
rank: 333
score: 99.10561301491477
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) checker ;
rank: 333
score: 99.0590350811298
patch: int iter = current CaMeL Point [ n CaMeL C ] ;
rank: 333
score: 98.9747314453125
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Cost ) ;
rank: 333
score: 98.8875503540039
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ iter ) ; }
rank: 333
score: 98.71634928385417
patch: ++ iter ; ++ iter ; while ;
rank: 333
score: 98.6241455078125
patch: ++ iter ; iter / iter ; ++ ;
rank: 333
score: 98.60078938802083
patch: / * * ++ ; ++ iter ;
rank: 334
score: 99.10560366981908
patch: boolean first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Objective ) ;
rank: 334
score: 99.09170386904762
patch: result = compute CaMeL Weighted CaMeL Jacobian ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 334
score: 99.05840743215461
patch: weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ; ;
rank: 334
score: 99.03599717881944
patch: compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective , 0 ) ;
rank: 334
score: 98.71624755859375
patch: ++ iter ; while iter ; iter ;
rank: 334
score: 98.62403021918402
patch: ++ iter ; iter / ; / ;
rank: 334
score: 98.60050455729167
patch: ++ iter ; else return iter ; }
rank: 334
score: 98.59165736607143
patch: if ( ! iter . is CaMeL Empty ( ) ; break ;
rank: 335
score: 99.10529119318181
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = < Point CaMeL Vector CaMeL Value CaMeL Pair > checker ;
rank: 335
score: 99.09101795014881
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = this . current CaMeL Residuals ;
rank: 335
score: 99.05819091796874
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair new = new Point CaMeL Vector CaMeL Value CaMeL Pair (
rank: 335
score: 99.03571234809027
patch: Point CaMeL Vector CaMeL Value CaMeL Pair checker = current CaMeL Point [ current CaMeL Point ;
rank: 335
score: 98.97440831801471
patch: result = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ;
rank: 335
score: 98.88656455592105
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , true ;
rank: 335
score: 98.71622314453126
patch: ++ iter ; * * / ++ iter ;
rank: 335
score: 98.62386745876736
patch: ++ iter ; iter / - 1 ;
rank: 335
score: 98.60050455729167
patch: else throw new Runtime CaMeL Exception ( $STRING$ ) ; }
rank: 335
score: 98.59121268136161
patch: b = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter ;
rank: 336
score: 99.10457710597827
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > = current CaMeL Point ;
rank: 336
score: 99.09081420898437
patch: qtf ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Residuals ) ) ;
rank: 336
score: 99.03538602941177
patch: j = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ,
rank: 336
score: 98.9723762063419
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point . ) ;
rank: 336
score: 98.88642321134868
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter ) ; ++ iter ;
rank: 336
score: 98.71620178222656
patch: synchronized ++ iter ; ++ iter ;
rank: 336
score: 98.62351296164773
patch: ++ iter ; ++ ++ iter ; ++ 1 ;
rank: 336
score: 98.59111993963069
patch: if ( ! iter . equals ( iter ) )
rank: 337
score: 99.09047980057566
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = current . current CaMeL Residuals ( ) ;
rank: 337
score: 99.05787658691406
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair continue = current ;
rank: 337
score: 99.03536224365234
patch: / * Point CaMeL Vector CaMeL Value CaMeL Pair checker = current CaMeL Point ;
rank: 337
score: 98.97188720703124
patch: removed = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 337
score: 98.8864013671875
patch: ++ iter * / * / ++ iter ;
rank: 337
score: 98.71613905164931
patch: ++ iter ; ++ iter ; } *
rank: 337
score: 98.6228915127841
patch: ++ ++ 1 ; ++ iter ; ++ iter ;
rank: 337
score: 98.59992009943181
patch: else throw new Runtime CaMeL Exception ( $STRING$ ; }
rank: 337
score: 98.59078979492188
patch: if ( ++ n CaMeL C > 0 )
rank: 338
score: 99.10361735026042
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = weight CaMeL Matrix CaMeL Sqrt . get ( current CaMeL Residuals ) ;
rank: 338
score: 99.05774688720703
patch: weighted CaMeL Residual = get CaMeL Weight CaMeL Square CaMeL Root ( ) ; }
rank: 338
score: 99.03490532769098
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair = checker . operate ( current CaMeL Point ,
rank: 338
score: 98.97171724759616
patch: instanceof Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 338
score: 98.88567437065973
patch: ++ iter ; return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , ; }
rank: 338
score: 98.71607801649306
patch: ++ iter ; break ; int iter ;
rank: 338
score: 98.62284342447917
patch: ++ iter ; ; iter / ++ ;
rank: 338
score: 98.59974500868056
patch: else { this . iter = iter ;
rank: 338
score: 98.59075317382812
patch: ++ iter ; while ( true ) { ;
rank: 339
score: 99.10323079427083
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = ( Point CaMeL Vector CaMeL Value CaMeL Pair > ) true ;
rank: 339
score: 99.08968955592105
patch: i = final Point CaMeL Vector CaMeL Value CaMeL Pair . operate ( current CaMeL Objective ) ;
rank: 339
score: 99.0574951171875
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair -= current ;
rank: 339
score: 99.03486902573529
patch: boolean first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt [ current CaMeL Point ] ;
rank: 339
score: 98.97110324435764
patch: x CaMeL Norm = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Cost ) ;
rank: 339
score: 98.88551161024306
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point [ 0 ] ;
rank: 339
score: 98.71603054470486
patch: ++ iter ; else if ++ iter ;
rank: 339
score: 98.62214799360795
patch: ++ iter ; ++ iter ; else = iter ;
rank: 339
score: 98.59959581163194
patch: if ( iter > 0 ; * ;
rank: 339
score: 98.59049479166667
patch: ++ iter ; if ( iter == 0 ) continue ;
rank: 340
score: 99.10302734375
patch: weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ,
rank: 340
score: 99.05716103001645
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , 0 ) ) ;
rank: 340
score: 99.03429497612848
patch: compute CaMeL Weighted CaMeL Jacobian ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ,
rank: 340
score: 98.97101702008929
patch: Iterator < Point CaMeL Vector CaMeL Value CaMeL Pair > Point CaMeL Vector CaMeL Value CaMeL Pair = current ;
rank: 340
score: 98.8853400735294
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter . iter ) ;
rank: 340
score: 98.71592712402344
patch: iter { ++ ; ++ iter ;
rank: 340
score: 98.62212371826172
patch: ++ 0 ; ++ iter ; }
rank: 340
score: 98.59935913085937
patch: else { ++ iter ; return iter ; }
rank: 340
score: 98.59040178571429
patch: if ( ! iter . is CaMeL Empty ( ) ++ iter )
rank: 341
score: 99.1030209189967
patch: ++ weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Residuals ) ;
rank: 341
score: 99.08895670572916
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( qtf ) ;
rank: 341
score: 99.05714326746323
patch: checker = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ;
rank: 341
score: 99.03412272135417
patch: qtf [ compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 341
score: 98.97072531960227
patch: private Point CaMeL Vector CaMeL Value CaMeL Pair ( Point CaMeL Vector CaMeL Value CaMeL Pair current CaMeL Residuals ) {
rank: 341
score: 98.88528442382812
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( get CaMeL Context ( ;
rank: 341
score: 98.59915924072266
patch: if ( ! iter != null ;
rank: 341
score: 98.59017944335938
patch: if ( ! is CaMeL Empty ; ++ iter ) {
rank: 342
score: 99.10175916883681
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > current CaMeL Point = current CaMeL Point ;
rank: 342
score: 99.08820134943181
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current CaMeL Point [ 0 ] ;
rank: 342
score: 99.05659484863281
patch: while ( true ) { final Point CaMeL Vector CaMeL Value CaMeL Pair ++ ;
rank: 342
score: 99.0340935202206
patch: final Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > = current ;
rank: 342
score: 98.97062683105469
patch: ret = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Cost ) ;
rank: 342
score: 98.71563042534723
patch: ++ iter ; iter ; / * /
rank: 342
score: 98.62138536241319
patch: ++ iter ; ++ ++ iter ; else
rank: 342
score: 98.59915500217014
patch: ++ iter ; if ++ ++ iter ;
rank: 342
score: 98.58973693847656
patch: ++ iter ; while ( iter )
rank: 343
score: 99.10172526041667
patch: int [ ] current CaMeL Objective = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Objective ) ;
rank: 343
score: 99.03385416666667
patch: if ( n CaMeL R < n CaMeL C ) {
rank: 343
score: 98.97011108398438
patch: self = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 343
score: 98.8846435546875
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , iter , ;
rank: 343
score: 98.71522521972656
patch: ++ iter ; else if iter ;
rank: 343
score: 98.61924235026042
patch: iter ; ++ 0 ; ++ iter ;
rank: 343
score: 98.59862060546875
patch: if ( iter == null ) return null ;
rank: 343
score: 98.58863067626953
patch: ++ iter ; if ( false )
rank: 344
score: 99.10141473067434
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair > current CaMeL Point = current ;
rank: 344
score: 99.05617161800987
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals , current CaMeL Objective ,
rank: 344
score: 99.03354899088542
patch: final Convergence CaMeL Checker checker = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 344
score: 98.97003580729167
patch: ( iter < Point CaMeL Vector CaMeL Value CaMeL Pair > checker ) {
rank: 344
score: 98.88438505284927
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ n CaMeL R ; }
rank: 344
score: 98.71460639105902
patch: int iter ; try ; if iter ;
rank: 344
score: 98.61907404119319
patch: ++ iter ; ++ iter ; / * iter ;
rank: 344
score: 98.59851752387152
patch: ++ iter ; * * * * /
rank: 344
score: 98.58634730747768
patch: ++ iter ; if ( old CaMeL Obj . length == 0 )
rank: 345
score: 99.1012951078869
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = weight CaMeL Matrix CaMeL Sqrt . operate ( ) ;
rank: 345
score: 99.0550896139706
patch: checker = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Residuals ) ;
rank: 345
score: 99.0334716796875
patch: int iter = jac CaMeL Norm . operate ( current CaMeL Point ) ;
rank: 345
score: 98.969970703125
patch: this . weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , iter ) ;
rank: 345
score: 98.8834228515625
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point [ 0 ] ;
rank: 345
score: 98.71410454644098
patch: int iter ; ++ * - iter ;
rank: 345
score: 98.61811659071181
patch: ++ iter ; ++ start ; iter ;
rank: 345
score: 98.59781087239584
patch: if ( . is CaMeL Empty ( ) ) . ++ iter ; }
rank: 345
score: 98.58594621930804
patch: ++ iter Math . max ( 0 , n CaMeL C ) ;
rank: 346
score: 99.10102395450367
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = this ;
rank: 346
score: 99.08758835565476
patch: Convergence CaMeL Checker ( compute CaMeL Weighted CaMeL Jacobian ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 346
score: 99.05495876736111
patch: int iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Objective ) ;
rank: 346
score: 98.96930541992188
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point . current CaMeL Point ) ;
rank: 346
score: 98.88320743336396
patch: ++ iter ; return new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , ;
rank: 346
score: 98.61796569824219
patch: ++ iter ; iter * / /
rank: 346
score: 98.59444580078124
patch: if ( iter < 0 ) return iter ;
rank: 346
score: 98.58529227120536
patch: if ( ! iter . is CaMeL Empty ; ) ++ iter ;
rank: 347
score: 99.08734809027777
patch: int iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Residuals ) ;
rank: 347
score: 99.05411783854167
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals , current CaMeL Residuals ) ) ;
rank: 347
score: 99.03314208984375
patch: double [ ] current CaMeL Objective = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 347
score: 98.96924889605978
patch: first CaMeL Iteration = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Objective ) ;
rank: 347
score: 98.88276890345982
patch: Iterator iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( ;
rank: 347
score: 98.71353488498264
patch: if ++ iter ; ++ iter ; ;
rank: 347
score: 98.61762237548828
patch: ++ iter ; iter / 1 /
rank: 347
score: 98.59379069010417
patch: else { this . iter = iter ; break ; }
rank: 348
score: 99.1007080078125
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair && current = current ;
rank: 348
score: 99.08677045036765
patch: i = final Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ;
rank: 348
score: 99.05399322509766
patch: iter = checker . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 348
score: 99.03305053710938
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair $NUMBER$ checker = current CaMeL Point ;
rank: 348
score: 98.9689712524414
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , ) ;
rank: 348
score: 98.88245985243056
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current . iter , ;
rank: 348
score: 98.71325005425348
patch: ++ iter ; ++ iter ; current ;
rank: 348
score: 98.61750623914931
patch: ++ iter ; iter -- ; ++ ;
rank: 348
score: 98.59366861979167
patch: else { ++ < iter > iter ;
rank: 348
score: 98.58426513671876
patch: if ( iter < n CaMeL R ) {
rank: 349
score: 99.09992009943181
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = new Point CaMeL Vector CaMeL Value CaMeL Pair * current ;
rank: 349
score: 99.08665829613095
patch: t = compute CaMeL Weighted CaMeL Jacobian ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 349
score: 99.05349731445312
patch: / / compute CaMeL Cost ( n CaMeL R , current CaMeL Objective ) ;
rank: 349
score: 99.03298770680146
patch: qtf ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ; }
rank: 349
score: 98.96857048483456
patch: v = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ; }
rank: 349
score: 98.88224069695724
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point . length ; }
rank: 349
score: 98.71225992838542
patch: / * ++ 1 ; ++ iter ;
rank: 349
score: 98.6174560546875
patch: iter ; ++ iter ; while ++ iter ;
rank: 349
score: 98.59326850043402
patch: else { if ++ iter < 0 ;
rank: 349
score: 98.58417619977679
patch: if ( iter >= 0 )
rank: 350
score: 99.09991455078125
patch: int [ ] current CaMeL Objective = 0 ;
rank: 350
score: 99.08638218470982
patch: list = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 350
score: 99.05307186351104
patch: int iter = get CaMeL Weight CaMeL Square CaMeL Root ( current CaMeL Objective ) ;
rank: 350
score: 99.03248426649306
patch: return weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ,
rank: 350
score: 98.88143920898438
patch: ++ iter ; this . iter = iter ;
rank: 350
score: 98.7112548828125
patch: ++ iter ; ++ - ; ++ iter ;
rank: 350
score: 98.61707652698864
patch: ++ iter ; ++ iter ; if ++ 1 ;
rank: 350
score: 98.59112955729167
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + 1 , ) ;
rank: 350
score: 98.5834209735577
patch: if ( ! is CaMeL Empty ) { ++ iter ; }
rank: 351
score: 99.09983317057292
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = ( Point CaMeL Vector CaMeL Value CaMeL Pair > ) null ;
rank: 351
score: 99.0530646829044
patch: ++ solved CaMeL Cols ; compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ;
rank: 351
score: 99.03125
patch: final Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > current = current ;
rank: 351
score: 98.96815185546875
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Cost ) ;
rank: 351
score: 98.71057891845703
patch: if iter ; ++ iter ; ;
rank: 351
score: 98.6170321377841
patch: ++ iter ; ++ iter ; else * iter ;
rank: 351
score: 98.58998325892857
patch: / * * ++ * /
rank: 352
score: 99.09963989257812
patch: int [ ] current = current ;
rank: 352
score: 99.08555908203125
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = current CaMeL Point [ current CaMeL Residuals ) ;
rank: 352
score: 99.0519157858456
patch: weighted CaMeL Residual = get CaMeL Weight CaMeL Square CaMeL Root ( current CaMeL Point ,
rank: 352
score: 99.0308609008789
patch: final int CaMeL Value = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 352
score: 98.96806335449219
patch: iter = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Objective ) ;
rank: 352
score: 98.88034539473684
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , iter ;
rank: 352
score: 98.71023559570312
patch: int iter + iter ; * /
rank: 352
score: 98.61636013454861
patch: ++ iter ; iter / / / ;
rank: 352
score: 98.58963623046876
patch: if ( ! iter == is CaMeL Empty ;
rank: 352
score: 98.58217551491477
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ;
rank: 353
score: 99.0994540127841
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = ( Point CaMeL Vector CaMeL Value CaMeL Pair > )
rank: 353
score: 99.08554909446023
patch: Convergence CaMeL Checker = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Point ) ;
rank: 353
score: 99.05187310112848
patch: int [ ] current CaMeL Residuals = get CaMeL Weight CaMeL Square CaMeL Root ( ) ;
rank: 353
score: 99.03047180175781
patch: int CaMeL Value = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) checker ;
rank: 353
score: 98.9680508700284
patch: [ ] weight CaMeL Matrix CaMeL Sqrt . operate ( weight CaMeL Matrix CaMeL Sqrt . operate ( ) ) ;
rank: 353
score: 98.88031364889706
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( get CaMeL Context ( ) , ;
rank: 353
score: 98.71006944444444
patch: / * ++ 0 ; ++ iter ;
rank: 353
score: 98.616162109375
patch: iter ; ++ ; ++ iter ; ++ ;
rank: 353
score: 98.58910522460937
patch: if ( iter == 0 ; break ; }
rank: 353
score: 98.57846901633523
patch: ++ Math . max ( 0 , iter ) ;
rank: 354
score: 99.09932277513587
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) false ;
rank: 354
score: 99.0855484008789
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair * = current ;
rank: 354
score: 99.05164930555556
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Objective ) ;
rank: 354
score: 99.03042423023896
patch: current = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ,
rank: 354
score: 98.96756591796876
patch: synchronized ( weight CaMeL Matrix CaMeL Sqrt ) {
rank: 354
score: 98.88021850585938
patch: int iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , ;
rank: 354
score: 98.6154452237216
patch: ++ iter ; ++ iter ; } ++ 1 ;
rank: 354
score: 98.58840942382812
patch: if ( iter == 0 ; / * ;
rank: 354
score: 98.57843017578125
patch: ++ iter + iter + 1 ;
rank: 355
score: 99.09928072415866
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair name = current ;
rank: 355
score: 99.05122680664063
patch: ++ iter ; final Convergence CaMeL Checker . compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ;
rank: 355
score: 99.030029296875
patch: int ! compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 355
score: 98.96726989746094
patch: v = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Objective ) ;
rank: 355
score: 98.70893859863281
patch: ++ iter ; try ; * ;
rank: 355
score: 98.61536322699652
patch: ++ iter ; ; if iter / /
rank: 355
score: 98.58837890625
patch: } if ; ++ iter ;
rank: 355
score: 98.57840983072917
patch: synchronized ( this ) {
rank: 356
score: 99.09900580512152
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair [ ] current = current ;
rank: 356
score: 99.05118815104167
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair ?
rank: 356
score: 99.02938406808036
patch: / / compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 356
score: 98.96707763671876
patch: tmp = get CaMeL Weight CaMeL Square CaMeL Root ( current CaMeL Point , current CaMeL Objective ) ;
rank: 356
score: 98.8798095703125
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current . ++ ;
rank: 356
score: 98.70889282226562
patch: / ] ++ iter ;
rank: 356
score: 98.61532253689236
patch: iter ; if ++ ; ++ iter ;
rank: 356
score: 98.58777965198864
patch: if ( iter == 0 ; return iter ; }
rank: 356
score: 98.57822672526042
patch: ++ iter ; Thread . current CaMeL Thread ( ; ;
rank: 357
score: 99.08497529871323
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair $NUMBER$ checker = current ;
rank: 357
score: 99.05081939697266
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair double = current ;
rank: 357
score: 98.9670654296875
patch: retval = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 357
score: 98.87874603271484
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , iter ) ;
rank: 357
score: 98.70844184027777
patch: ++ iter ; ++ iter ; 1 ;
rank: 357
score: 98.61519775390624
patch: ++ iter ; ++ iter ; ; / ;
rank: 357
score: 98.58746948242188
patch: return false ; }
rank: 357
score: 98.57777404785156
patch: ++ iter ] ; ++ iter ;
rank: 358
score: 99.026611328125
patch: int current = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 358
score: 98.96697998046875
patch: changed = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 358
score: 98.87846105238971
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter . iter ;
rank: 358
score: 98.70823838975694
patch: ++ iter ; / / int iter ;
rank: 358
score: 98.61465115017361
patch: ++ iter ; iter if ++ ; ;
rank: 358
score: 98.58711547851563
patch: / * * * ++ ; ++ iter ;
rank: 358
score: 98.57776988636364
patch: if ( ! iter . contains ( iter ) ;
rank: 359
score: 99.09814453125
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current CaMeL Point ( ) ;
rank: 359
score: 99.08482142857143
patch: Point CaMeL Vector CaMeL Value CaMeL Pair current = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current ;
rank: 359
score: 99.05015869140625
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = weight CaMeL Matrix CaMeL Sqrt
rank: 359
score: 99.02649603949652
patch: name = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 359
score: 98.96686662946429
patch: result = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) current ;
rank: 359
score: 98.87751850328948
patch: Point CaMeL Vector CaMeL Value CaMeL Pair current = new Point CaMeL Vector CaMeL Value CaMeL Pair (
rank: 359
score: 98.70787048339844
patch: ++ iter ; int * * ;
rank: 359
score: 98.61458129882813
patch: ++ iter ; ++ iter ; / ; /
rank: 359
score: 98.58658175998264
patch: if ( iter > 0 ; return ;
rank: 359
score: 98.5767822265625
patch: if ( ! iter . is CaMeL Empty ( ) ; }
rank: 360
score: 99.09803355823864
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair >> checker = current ;
rank: 360
score: 99.0844970703125
patch: qr CaMeL Decomposition = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Point ) ;
rank: 360
score: 99.04954833984375
patch: checker = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , n CaMeL C ) ;
rank: 360
score: 99.02645874023438
patch: int current CaMeL Objective = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 360
score: 98.96647563733552
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , n CaMeL C ) ;
rank: 360
score: 98.87745496961806
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ iter , iter ;
rank: 360
score: 98.70744323730469
patch: ++ iter ; ++ value ; ;
rank: 360
score: 98.61445756392045
patch: ++ iter ; else ++ iter ; ++ iter ;
rank: 360
score: 98.58646240234376
patch: if ( . is CaMeL Empty ( ) )
rank: 360
score: 98.57676344651442
patch: Set < Point CaMeL Vector CaMeL Value CaMeL Pair > ++ ;
rank: 361
score: 99.09795735677083
patch: ++ final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current ;
rank: 361
score: 99.08418201264881
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current CaMeL Residuals ( ) ;
rank: 361
score: 99.04931640625
patch: while ( true && true ) {
rank: 361
score: 99.02613176618304
patch: / * compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 361
score: 98.96632690429688
patch: t = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 361
score: 98.87705365349265
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter . iter , ;
rank: 361
score: 98.70686340332031
patch: j * ++ ; ++ iter ;
rank: 361
score: 98.61404418945312
patch: ++ iter ; ++ iter ; / ; ;
rank: 361
score: 98.58614676339286
patch: if ( . is CaMeL Empty ( ) ; return ++ iter ;
rank: 361
score: 98.57636052911931
patch: if ( ! is CaMeL Empty ( ; ) )
rank: 362
score: 99.0979534646739
patch: int current CaMeL Objective = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 362
score: 99.04930962456598
patch: { qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ) ;
rank: 362
score: 99.0259521484375
patch: double [ ] current CaMeL Objective = current CaMeL Residuals [ 0 ] ;
rank: 362
score: 98.96625518798828
patch: true = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Objective ) ;
rank: 362
score: 98.87673052619485
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , iter , ;
rank: 362
score: 98.70663791232639
patch: / * ++ iter ; * * /
rank: 362
score: 98.6129638671875
patch: ++ iter ; ; ++ iter ; / /
rank: 362
score: 98.58451625279018
patch: / * * ++ iter ;
rank: 362
score: 98.57621256510417
patch: if ( ! iter . equals ( current ) ) {
rank: 363
score: 99.09795270647321
patch: double [ ] current CaMeL Objective = current CaMeL Point . length ;
rank: 363
score: 99.08407738095238
patch: Convergence CaMeL Checker ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Point ) ) ;
rank: 363
score: 99.0259521484375
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker .
rank: 363
score: 98.96624077690973
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , true ) ;
rank: 363
score: 98.87631225585938
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair . ++ ; }
rank: 363
score: 98.70523410373264
patch: ++ iter ; ++ iter ; max ;
rank: 363
score: 98.61282958984376
patch: ++ iter ; ++ iter ; / break ;
rank: 363
score: 98.58441162109375
patch: else { ++ ++ iter ;
rank: 363
score: 98.57611638849431
patch: ++ iter ; while ( iter != 0 ) {
rank: 364
score: 99.09780051491477
patch: weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , x CaMeL Norm ) ;
rank: 364
score: 99.04898410373264
patch: Iterator iter = checker . weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ,
rank: 364
score: 99.02588608685662
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair [ ] current CaMeL Point = current ;
rank: 364
score: 98.87566266741071
patch: final ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair ;
rank: 364
score: 98.70503373579545
patch: / * ++ iter ; * / int iter ;
rank: 364
score: 98.61252663352273
patch: ++ iter ; ++ iter ; / / ; /
rank: 364
score: 98.58373006184895
patch: else ; ++ iter ;
rank: 364
score: 98.57588195800781
patch: if ( iter == - 1 )
rank: 365
score: 99.04829406738281
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair char = current ;
rank: 365
score: 98.9656512920673
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( operate ) ;
rank: 365
score: 98.87531594669117
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , iter ;
rank: 365
score: 98.70448133680556
patch: int iter ; else ; int iter ;
rank: 365
score: 98.61249542236328
patch: ++ iter ; iter / ; ;
rank: 365
score: 98.58336791992187
patch: if ( iter == null ; return false ;
rank: 365
score: 98.57551574707031
patch: while ( true ) ++ iter ;
rank: 366
score: 99.097314453125
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current CaMeL Point = current CaMeL Point [ iter ] ;
rank: 366
score: 99.08328247070312
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = current CaMeL Point [ current CaMeL Objective ) ;
rank: 366
score: 99.04779815673828
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair [ ] current ;
rank: 366
score: 99.02533637152777
patch: Iterator ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) )
rank: 366
score: 98.96486990792411
patch: check CaMeL Parameters ( current CaMeL Point , current CaMeL Point ) ;
rank: 366
score: 98.87464488636364
patch: ++ iter ; while ( iter < iter ) ;
rank: 366
score: 98.7036465731534
patch: this . ++ iter ; ++ iter ; break ;
rank: 366
score: 98.61150568181819
patch: iter ; ++ iter ; ++ ; ++ iter ;
rank: 366
score: 98.58323160807292
patch: if ( iter == null ; / ;
rank: 366
score: 98.57412283761161
patch: ++ iter ; Thread . current CaMeL Thread ( ) . wait ;
rank: 367
score: 99.09711248224431
patch: weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , n CaMeL R ) ;
rank: 367
score: 99.08250325520834
patch: qtf = weight CaMeL Matrix CaMeL Sqrt ( current CaMeL Point ) ;
rank: 367
score: 99.04768371582031
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair read = current ;
rank: 367
score: 98.9644775390625
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point . ) ;
rank: 367
score: 98.87453206380208
patch: ++ iter ; this . ++ iter ;
rank: 367
score: 98.70363159179688
patch: ++ iter ; ++ value ; ++ iter ;
rank: 367
score: 98.61119079589844
patch: ++ 1 ; ++ ++ iter ;
rank: 367
score: 98.58292933872768
patch: if ( ! 0 . is CaMeL Empty ( ) ) { }
rank: 367
score: 98.57354736328125
patch: ++ iter ; ++ iter ; System . out . ;
rank: 368
score: 99.09699096679688
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = checker . operate ( current CaMeL Residuals ) ;
rank: 368
score: 99.08206515842014
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = current CaMeL Residuals [ 0 ] ;
rank: 368
score: 99.04744720458984
patch: / / compute CaMeL Cost ( current CaMeL Residuals , current CaMeL Objective ) ;
rank: 368
score: 98.96434190538194
patch: public Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > current = current ;
rank: 368
score: 98.87422449448529
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ iter , ;
rank: 368
score: 98.70362684461806
patch: ++ iter ; try { iter ; *
rank: 368
score: 98.61114501953125
patch: ++ iter ; iter / ; *
rank: 368
score: 98.5828857421875
patch: else { ++ iter ; * * * /
rank: 368
score: 98.57314828725961
patch: ++ iter ; while ( n CaMeL C < iter ) {
rank: 369
score: 99.08185173483456
patch: ++ iter ; Point CaMeL Vector CaMeL Value CaMeL Pair current = current CaMeL Point ;
rank: 369
score: 99.0469906455592
patch: Iterator iter = checker . get CaMeL Weight CaMeL Square CaMeL Root ( ) . ( ) ;
rank: 369
score: 99.02413177490234
patch: Point CaMeL Vector CaMeL Value CaMeL Pair current CaMeL Point = current CaMeL Point ;
rank: 369
score: 98.96427778764205
patch: x CaMeL Norm += weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Residuals ) ;
rank: 369
score: 98.87405056423611
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ++ ;
rank: 369
score: 98.70346901633523
patch: ++ iter ; ++ iter ; ++ - iter ;
rank: 369
score: 98.61089533025569
patch: ++ iter ; iter } ++ ; ++ iter ;
rank: 369
score: 98.58265380859375
patch: ++ * iter ;
rank: 369
score: 98.57269287109375
patch: ++ iter ; throw new Illegal CaMeL State CaMeL Exception ;
rank: 370
score: 99.09652506510416
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = current CaMeL Point ,
rank: 370
score: 99.04668511284723
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair ,
rank: 370
score: 99.02406939338235
patch: Point CaMeL Vector CaMeL Value CaMeL Pair final = current CaMeL Point [ iter ] ;
rank: 370
score: 98.96414523654514
patch: children = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , 0 ) ;
rank: 370
score: 98.87370219983552
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current . get CaMeL Value ( ; }
rank: 370
score: 98.61088562011719
patch: ++ iter ; ; iter * /
rank: 370
score: 98.58043561662946
patch: else { new ++ ; }
rank: 371
score: 99.09650213068181
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = new Point CaMeL Vector CaMeL Value CaMeL Pair ] ;
rank: 371
score: 99.08062133789062
patch: iter = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Residuals ) ;
rank: 371
score: 99.04653930664062
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > -- ;
rank: 371
score: 99.02378845214844
patch: else qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 371
score: 98.96332397460938
patch: p = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 371
score: 98.87339872472427
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , ; ++ iter ) ;
rank: 371
score: 98.70200602213542
patch: ++ iter ; * / if iter ;
rank: 371
score: 98.61076524522569
patch: ++ iter ; iter / * / /
rank: 371
score: 98.58014594184027
patch: else { if ( iter == 0 ;
rank: 371
score: 98.57150268554688
patch: final ; if ( iter != null ) {
rank: 372
score: 99.09647993607955
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) this ;
rank: 372
score: 99.0805419921875
patch: qtf = weight CaMeL Matrix CaMeL Sqrt ( current CaMeL Residuals ) ;
rank: 372
score: 99.02313232421875
patch: if ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) { {
rank: 372
score: 98.96304660373264
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) [ iter ] ;
rank: 372
score: 98.87335526315789
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , null ;
rank: 372
score: 98.70167846679688
patch: finally { ++ iter ; } ++ iter ;
rank: 372
score: 98.6106185913086
patch: ++ start ; ++ iter ; ;
rank: 372
score: 98.58009643554688
patch: if ( iter < iter ) return null ;
rank: 372
score: 98.57107543945312
patch: Iterator iter = iter . iterator ( ) ; while ;
rank: 373
score: 99.09635620117187
patch: Point CaMeL Vector CaMeL Value CaMeL Pair checker = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 373
score: 99.04590606689453
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair exp = current ;
rank: 373
score: 99.02300618489583
patch: ++ iter ; Point CaMeL Vector CaMeL Value CaMeL Pair checker = current ;
rank: 373
score: 98.96292917351974
patch: ! weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 373
score: 98.873046875
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ iter , ;
rank: 373
score: 98.70081922743056
patch: ++ iter ; ++ * int iter ;
rank: 373
score: 98.61054992675781
patch: ++ true ; ; ++ iter ;
rank: 373
score: 98.58004995492789
patch: if ( . is CaMeL Empty ( ) ; return iter ;
rank: 373
score: 98.56998116629464
patch: ++ iter ; ++ iter ; Thread . current CaMeL Thread ( ;
rank: 374
score: 99.09621360085227
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) get ;
rank: 374
score: 99.02232530381944
patch: / / compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 374
score: 98.96267520680146
patch: tmp = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ; }
rank: 374
score: 98.87291802300348
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , iter , ;
rank: 374
score: 98.70077950613839
patch: / * ++ iter ; ;
rank: 374
score: 98.6101407137784
patch: ++ iter ; ++ iter ; ; iter ++ ;
rank: 374
score: 98.57921752929687
patch: else { else { ++ iter ; } }
rank: 374
score: 98.56991141183036
patch: ++ iter ; while ( iter . is CaMeL Empty ( ) )
rank: 375
score: 99.09606255425348
patch: ++ Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current ;
rank: 375
score: 99.07990180121527
patch: final Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = 0 ;
rank: 375
score: 99.0454345703125
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair list = new Point CaMeL Vector CaMeL Value CaMeL Pair (
rank: 375
score: 99.02225748697917
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Objective ,
rank: 375
score: 98.96262904575893
patch: < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = 0 ;
rank: 375
score: 98.70030517578125
patch: ++ iter ; if iter ; ++ iter ;
rank: 375
score: 98.60948944091797
patch: ++ iter ; iter return iter ;
rank: 375
score: 98.57906668526786
patch: else { ++ value ; }
rank: 375
score: 98.56908069957386
patch: if ( ++ n CaMeL C < 0 ) {
rank: 376
score: 99.09555199032738
patch: Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = true ;
rank: 376
score: 99.04542893629808
patch: iter = get CaMeL Weight CaMeL Square CaMeL Root ( ) ;
rank: 376
score: 99.02212185329861
patch: compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective , true ) ;
rank: 376
score: 98.96254319411058
patch: private Point CaMeL Vector CaMeL Value CaMeL Pair current = null ;
rank: 376
score: 98.87217610677084
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair ; ++ ;
rank: 376
score: 98.6093417080966
patch: ++ ( iter ; ++ iter ; ++ iter ;
rank: 376
score: 98.57863071986607
patch: / * * * ++ ;
rank: 376
score: 98.56898716517857
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair [ ] { ;
rank: 377
score: 99.09552680121527
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current CaMeL Objective ( ) ;
rank: 377
score: 99.07956949869792
patch: pos = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 377
score: 99.04537760416666
patch: Convergence CaMeL Checker ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 377
score: 99.02198893229166
patch: int [ ] current CaMeL Objective = current CaMeL Point [ 0 ] ;
rank: 377
score: 98.96248372395833
patch: true = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , 0 ) ;
rank: 377
score: 98.87190246582031
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ n CaMeL R , ;
rank: 377
score: 98.69905395507813
patch: ++ iter ; ++ iter ; for iter {
rank: 377
score: 98.60915798611111
patch: ++ ++ iter ; ++ iter ; }
rank: 377
score: 98.5784200032552
patch: throw new Runtime CaMeL Exception ( $STRING$ ; } else {
rank: 377
score: 98.5688809481534
patch: if ( ! iter . contains ( current ) ;
rank: 378
score: 99.0448859719669
patch: weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ,
rank: 378
score: 99.02127075195312
patch: Object qr CaMeL Decomposition = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 378
score: 98.96241978236607
patch: get CaMeL Point ( current CaMeL Point , current CaMeL Objective ) ;
rank: 378
score: 98.87175436580883
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ iter , ;
rank: 378
score: 98.69843207465277
patch: / * ] iter ; / / /
rank: 378
score: 98.60914611816406
patch: ++ iter ; ++ ++ $NUMBER$ ;
rank: 378
score: 98.57839965820312
patch: throw new Runtime CaMeL Exception ( $STRING$ + iter ; }
rank: 379
score: 99.07952325994319
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair new = new Point CaMeL Vector CaMeL Value CaMeL Pair ( ) ;
rank: 379
score: 99.044873046875
patch: checker ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 379
score: 99.02125651041666
patch: double [ ] compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 379
score: 98.962353515625
patch: Iterator < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = null ;
rank: 379
score: 98.87127278645833
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ current CaMeL Point ;
rank: 379
score: 98.69797770182292
patch: int iter ; * / int iter ;
rank: 379
score: 98.60808715820312
patch: ++ iter ; ++ iter ; ++ ++ ;
rank: 379
score: 98.5776123046875
patch: if ( . is CaMeL Empty ( ) ; return ++ iter ; }
rank: 379
score: 98.5679931640625
patch: if ( iter == null ) ++ iter ;
rank: 380
score: 99.04454281455592
patch: weighted CaMeL Residual ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ,
rank: 380
score: 99.02117919921875
patch: pk = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Point ) ;
rank: 380
score: 98.96199035644531
patch: children = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Objective ) ;
rank: 380
score: 98.87086486816406
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + n CaMeL C ) ;
rank: 380
score: 98.60727761008523
patch: ++ iter ; ; ++ iter ; ++ ; ;
rank: 380
score: 98.57727922712054
patch: if ( ! 0 . is CaMeL Empty ( ) ) return ;
rank: 380
score: 98.56740500710227
patch: if ( iter != null ) { ++ iter ;
rank: 381
score: 99.02100287543402
patch: boolean first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt [ current CaMeL Point ) ] ;
rank: 381
score: 98.96161852384868
patch: [ ] weight CaMeL Matrix CaMeL Sqrt = get CaMeL Weight CaMeL Square CaMeL Root ( ) ;
rank: 381
score: 98.87079620361328
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , iter , iter ;
rank: 381
score: 98.69680786132812
patch: / * ++ iter ; / ++ iter ;
rank: 381
score: 98.606787109375
patch: iter ++ ; ++ iter ; ++ iter ;
rank: 381
score: 98.57708333333333
patch: if ( ! 0 . is CaMeL Empty ( ) ; ++ iter ;
rank: 381
score: 98.56629527698864
patch: ++ iter ; if ( ! is CaMeL Empty )
rank: 382
score: 99.09376061480978
patch: int CaMeL Value = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Objective ) ;
rank: 382
score: 99.04418182373047
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair set = current ;
rank: 382
score: 99.01997644761029
patch: tmp = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ,
rank: 382
score: 98.87050267269737
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current ;
rank: 382
score: 98.69674343532986
patch: ++ iter ; iter ; * * *
rank: 382
score: 98.6060791015625
patch: ++ iter ; ++ iter ; ; / / /
rank: 382
score: 98.57698880709134
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ; } ;
rank: 382
score: 98.56516810825893
patch: ++ iter ; if ( old CaMeL Obj . length > iter )
rank: 383
score: 99.09348551432292
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair new = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ,
rank: 383
score: 99.07908935546875
patch: int CaMeL Value = new Point CaMeL Vector CaMeL Value CaMeL Pair > ( current CaMeL Point ) ;
rank: 383
score: 99.04390869140624
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Objective ) ; }
rank: 383
score: 99.0196533203125
patch: qtf [ compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ,
rank: 383
score: 98.96156529017857
patch: ? final Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 383
score: 98.87040710449219
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current . iter , ;
rank: 383
score: 98.69645182291667
patch: ++ iter ; ++ 1 ; iter ;
rank: 383
score: 98.5766357421875
patch: if ( iter == null ; ++ iter ;
rank: 383
score: 98.56330217633929
patch: ++ iter ; while ( super . is CaMeL Empty ( ) ;
rank: 384
score: 99.09348366477273
patch: weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , n CaMeL C ) ;
rank: 384
score: 99.043603515625
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > final {
rank: 384
score: 98.9614013671875
patch: success = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 384
score: 98.87008506373355
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , ; ++ iter ;
rank: 384
score: 98.69640435112848
patch: ++ iter ; / * / / /
rank: 384
score: 98.60485076904297
patch: ++ iter ; iter - 1 ;
rank: 384
score: 98.57644653320312
patch: if ( iter > 0 ) return iter ;
rank: 384
score: 98.562255859375
patch: if ( iter == null ) {
rank: 385
score: 99.09345446134868
patch: int current CaMeL Objective = get CaMeL Weight CaMeL Square CaMeL Root ( current CaMeL Residuals ) ;
rank: 385
score: 99.07880859375
patch: ( ( Point CaMeL Vector CaMeL Value CaMeL Pair ) current CaMeL Point , current CaMeL Objective ) ;
rank: 385
score: 99.04340209960938
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > new ;
rank: 385
score: 99.01887512207031
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = }
rank: 385
score: 98.961279296875
patch: rs = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 385
score: 98.8698371438419
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ n CaMeL C ; }
rank: 385
score: 98.69552951388889
patch: / * ] iter ; if iter ;
rank: 385
score: 98.60475158691406
patch: ++ $NUMBER$ ; ; ++ iter ;
rank: 385
score: 98.57619065504808
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ; ; }
rank: 385
score: 98.562255859375
patch: ++ iter 1 [ 0 ] ; break ;
rank: 386
score: 99.09324048913044
patch: weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ; }
rank: 386
score: 99.04295590049342
patch: Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > final ;
rank: 386
score: 99.01831993689903
patch: double [ ] current CaMeL Objective = current CaMeL Residuals ) ;
rank: 386
score: 98.96082763671875
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point . current CaMeL Residuals ) ;
rank: 386
score: 98.86954538445724
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current . get CaMeL Id ( ) ;
rank: 386
score: 98.69544067382813
patch: ++ iter ; try ; ++ iter ; }
rank: 386
score: 98.6047119140625
patch: ++ new ; ++ iter ; ++ iter ;
rank: 386
score: 98.57546997070312
patch: ++ iter ; * /
rank: 386
score: 98.56143798828126
patch: if ( ++ n CaMeL C != 0 )
rank: 387
score: 99.07855583639706
patch: return weighted CaMeL Residual = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ;
rank: 387
score: 99.04290771484375
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Objective ) ; }
rank: 387
score: 99.0180305032169
patch: / * Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker ;
rank: 387
score: 98.96044243706598
patch: v = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , 0 ) ;
rank: 387
score: 98.69491238064236
patch: / ] ++ iter ; ++ iter ;
rank: 387
score: 98.60423278808594
patch: } ++ iter ; ++ 1 ;
rank: 387
score: 98.57539198133681
patch: ++ < 0 > iter : iter ;
rank: 388
score: 99.09309188179348
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = weight CaMeL Matrix CaMeL Sqrt . operate ( qtf ) ;
rank: 388
score: 99.04263070913461
patch: int iter = current CaMeL Point [ n CaMeL R ] ;
rank: 388
score: 99.01714324951172
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker ++ ;
rank: 388
score: 98.95987277560764
patch: iter = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , 0 ) ;
rank: 388
score: 98.86929660373264
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , ++ iter ;
rank: 388
score: 98.69437081473214
patch: ++ iter ; ++ * ;
rank: 388
score: 98.60400390625
patch: ++ iter ; iter ; ;
rank: 388
score: 98.57535129123264
patch: else { ++ * iter ; * /
rank: 388
score: 98.56120161576705
patch: ++ iter ; while ( true ) ++ iter ;
rank: 389
score: 99.09308416193181
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = weight CaMeL Matrix CaMeL Sqrt ( current CaMeL Point ) ;
rank: 389
score: 99.07835804332386
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Objective ) ;
rank: 389
score: 99.01683134191177
patch: compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ; }
rank: 389
score: 98.959716796875
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ; break ;
rank: 389
score: 98.86917317708334
patch: int iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter ;
rank: 389
score: 98.69415283203125
patch: ++ iter ; ++ iter ; synchronized iter ;
rank: 389
score: 98.6029940518466
patch: ++ iter ; ++ * iter ; ++ iter ;
rank: 389
score: 98.57526991102431
patch: ++ ++ iter ; if ++ iter ;
rank: 389
score: 98.56048583984375
patch: if ( ++ n CaMeL C == 0 ) break ;
rank: 390
score: 99.09306640625
patch: final final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current ;
rank: 390
score: 99.04251098632812
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair length = current ;
rank: 390
score: 99.01655847886029
patch: if ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Point ,
rank: 390
score: 98.95966539884868
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Cost ) ;
rank: 390
score: 98.86910850123355
patch: int iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current ;
rank: 390
score: 98.69390869140625
patch: ++ iter ; ++ iter ; out ; ++ iter ;
rank: 390
score: 98.60270385742187
patch: ++ iter ; iter if iter = iter ;
rank: 390
score: 98.57471812855114
patch: if ( iter > 0 ; return null ; }
rank: 390
score: 98.55938251201923
patch: ++ iter ; throw new Illegal CaMeL Argument CaMeL Exception ; }
rank: 391
score: 99.093017578125
patch: boolean first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 391
score: 99.07815372242646
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair > ( current CaMeL Point ) ;
rank: 391
score: 99.04181671142578
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ,
rank: 391
score: 98.95909423828125
patch: children = get CaMeL Weight CaMeL Square CaMeL Root ( current CaMeL Point , current CaMeL Objective ) ;
rank: 391
score: 98.86891575863487
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current ) ;
rank: 391
score: 98.69367133246527
patch: ++ iter ; else ; if iter ;
rank: 391
score: 98.60216522216797
patch: if iter ++ ; ++ iter ;
rank: 391
score: 98.57454223632813
patch: else { ++ iter ; ++ iter ; }
rank: 392
score: 99.0926005045573
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > current = ( Point CaMeL Vector CaMeL Value CaMeL Pair > ) current ;
rank: 392
score: 99.07801513671875
patch: ++ compute CaMeL Weighted CaMeL Jacobian ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ) ;
rank: 392
score: 99.04181315104167
patch: checker = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ,
rank: 392
score: 99.01629638671875
patch: if ( current CaMeL Point = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) )
rank: 392
score: 98.95903986150569
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) . operate ( current CaMeL Residuals ) ;
rank: 392
score: 98.86882781982422
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , ++ ;
rank: 392
score: 98.69292534722223
patch: ++ iter ; ++ * * ; /
rank: 392
score: 98.57448323567708
patch: ++ iter ; if ++ iter ; }
rank: 392
score: 98.55911959134616
patch: if ( ! iter . starts CaMeL With ( current ) ;
rank: 393
score: 99.09259905133929
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Point ) ) ;
rank: 393
score: 99.07796438116776
patch: qtf = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals , current CaMeL Point ) ;
rank: 393
score: 99.04091796875
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair , int ;
rank: 393
score: 99.01612764246323
patch: boolean first CaMeL Iteration = Fast CaMeL Math . sqrt ( current CaMeL Residuals ) ;
rank: 393
score: 98.95875379774306
patch: iter = get CaMeL Weight CaMeL Square CaMeL Root ( current CaMeL Point , 0 ) ;
rank: 393
score: 98.86878204345703
patch: ++ iter * / * ; ;
rank: 393
score: 98.69166259765625
patch: ++ value ; ++ iter ; ++ iter ;
rank: 393
score: 98.60087076822917
patch: ++ iter ; ++ iter ; ; else
rank: 393
score: 98.57357177734374
patch: if ( iter > 0 ; throw null ;
rank: 393
score: 98.55908203125
patch: ++ iter ; while ( false ) { ++ iter ;
rank: 394
score: 99.09255149147727
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = current CaMeL Point [ current CaMeL Point . length ] ;
rank: 394
score: 98.95833333333333
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) . double CaMeL Value ( ) ;
rank: 394
score: 98.86867388556985
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current , ;
rank: 394
score: 98.69146728515625
patch: return iter ; ++ iter ;
rank: 394
score: 98.59989929199219
patch: ++ iter ; ++ iter ; start
rank: 394
score: 98.57288953993056
patch: else { ++ < 1 > iter ;
rank: 394
score: 98.55884660993304
patch: ++ iter ; Thread . current CaMeL Thread ( ) . exit ;
rank: 395
score: 99.0773681640625
patch: it = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Residuals ) ;
rank: 395
score: 99.04022216796875
patch: Iterator iter = checker . compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 395
score: 99.01575385199652
patch: double ! compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ;
rank: 395
score: 98.95829441236413
patch: Iterator < Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > iter = current ;
rank: 395
score: 98.69094848632812
patch: ++ iter ; ++ iter ; / * ++ iter ;
rank: 395
score: 98.59972534179687
patch: iter ; ++ iter ; if ++ iter ;
rank: 395
score: 98.57229614257812
patch: if ( iter == iter ) return null ;
rank: 395
score: 98.557470703125
patch: if ( ++ n CaMeL C < 0 )
rank: 396
score: 99.09209442138672
patch: double [ ] current CaMeL Objective = weight CaMeL Matrix CaMeL Sqrt . length ;
rank: 396
score: 99.04015350341797
patch: / * compute CaMeL Cost ( current CaMeL Residuals , current CaMeL Objective ) ;
rank: 396
score: 99.01571316189236
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair 1 = current CaMeL Point [ 0 ] ;
rank: 396
score: 98.95824032738095
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , weight CaMeL Matrix CaMeL Sqrt ) ;
rank: 396
score: 98.86765834263393
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , ; }
rank: 396
score: 98.69085015190973
patch: ++ iter ; int iter { ++ ;
rank: 396
score: 98.59964328342014
patch: ++ iter ; ++ iter ; else /
rank: 396
score: 98.57166205512152
patch: else { ++ iter ; * ; }
rank: 396
score: 98.55594482421876
patch: ++ iter ; if ( ! this . ;
rank: 397
score: 99.09187147352431
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = this . current CaMeL Point ;
rank: 397
score: 99.07691650390625
patch: return weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ; }
rank: 397
score: 99.04000051398026
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair ) {
rank: 397
score: 98.95818413628473
patch: ret = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point . length ) ;
rank: 397
score: 98.86759679457721
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current ;
rank: 397
score: 98.59944291548295
patch: ++ iter ; ++ iter ; } if iter ;
rank: 397
score: 98.57139078776042
patch: else { if ++ iter >= iter ;
rank: 397
score: 98.5551249186198
patch: ++ n CaMeL C ; ++ n CaMeL C ; ;
rank: 398
score: 99.0917635830966
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) null ;
rank: 398
score: 99.0768710049716
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair new = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current ;
rank: 398
score: 99.01484231387867
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair = current CaMeL Point [ 0 ] ;
rank: 398
score: 98.9581631747159
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point . current CaMeL Residuals ) ;
rank: 398
score: 98.86758083767361
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , iter ) ;
rank: 398
score: 98.68999565972223
patch: ++ iter ; if iter ; break ;
rank: 398
score: 98.59867720170455
patch: ++ iter ; ++ iter ; while ++ 1 ;
rank: 398
score: 98.57121930803571
patch: else { return false ; }
rank: 398
score: 98.55267803485577
patch: ++ iter ; if ( ! this . is CaMeL Empty ;
rank: 399
score: 99.0916389016544
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair ( checker , current CaMeL Point ) ;
rank: 399
score: 99.07649739583333
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current CaMeL Residuals = current ;
rank: 399
score: 99.03917236328125
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair max = new Point CaMeL Vector CaMeL Value CaMeL Pair (
rank: 399
score: 99.01414579503677
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = new ;
rank: 399
score: 98.958056640625
patch: c = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 399
score: 98.86692181755515
patch: ++ iter ] = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current ) ;
rank: 399
score: 98.68911743164062
patch: this . ++ iter ;
rank: 399
score: 98.59856414794922
patch: ++ iter ; ; ++ $NUMBER$ ;
rank: 399
score: 98.57091606987848
patch: else { / * ; ++ iter ;
rank: 399
score: 98.55246988932292
patch: ++ iter ; if ( Arrays . is CaMeL Empty ;
rank: 400
score: 99.09147135416667
patch: weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective , 0 ) ;
rank: 400
score: 99.07616577148437
patch: ++ iter ; Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = null ;
rank: 400
score: 99.03875262920673
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair {
rank: 400
score: 99.01378580729167
patch: int start = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 400
score: 98.95770584909539
patch: this . qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Objective ) ) ;
rank: 400
score: 98.86691463694854
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current . iter , ; }
rank: 400
score: 98.68870960582386
patch: ++ iter ; ++ iter ; int * 1 ;
rank: 400
score: 98.59828879616477
patch: ++ iter ; iter ; * / ++ iter ;
rank: 400
score: 98.5703457919034
patch: else { ++ iter ; } return iter ; }
rank: 400
score: 98.55220249720982
patch: ++ iter ; if ( old CaMeL Obj . length > 0 ;
rank: 401
score: 99.09146118164062
patch: ++ iter ; Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current ;
rank: 401
score: 99.07596261160714
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = compute CaMeL Weighted CaMeL Jacobian ( qtf ) ;
rank: 401
score: 99.03854370117188
patch: weighted CaMeL Residual = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , n CaMeL C ) ;
rank: 401
score: 99.01377240349265
patch: c = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ,
rank: 401
score: 98.9574836282169
patch: ret = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ; }
rank: 401
score: 98.68797471788194
patch: else { ++ iter ; ++ iter ;
rank: 401
score: 98.59791148792614
patch: ++ iter ; ; ++ iter ; ++ 1 ;
rank: 401
score: 98.5697021484375
patch: if ( iter > 0 ; ++ iter ;
rank: 401
score: 98.5509033203125
patch: if ( ++ iter == 0 )
rank: 402
score: 99.09126420454545
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) 0 ;
rank: 402
score: 99.01304716222427
patch: boolean first CaMeL Iteration = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Objective ) ;
rank: 402
score: 98.9574203491211
patch: result = Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ;
rank: 402
score: 98.86519368489583
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current . ++ , current ; }
rank: 402
score: 98.68783569335938
patch: ++ iter ; ++ iter ; ++ * ;
rank: 402
score: 98.59782104492187
patch: ++ iter ; ++ iter ; ++ $STRING$ ;
rank: 402
score: 98.56940252130681
patch: throw new Runtime CaMeL Exception ( $STRING$ + 0 ;
rank: 402
score: 98.55074368990384
patch: if ( ! iter . is CaMeL Empty ( ) ; ;
rank: 403
score: 99.07572856702302
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , qtf ) ;
rank: 403
score: 99.03831787109375
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > checker {
rank: 403
score: 99.01271057128906
patch: String current CaMeL Point = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 403
score: 98.86510467529297
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current ) ; ++ iter ;
rank: 403
score: 98.68765597873264
patch: ++ iter ; ++ * - 1 ;
rank: 403
score: 98.59748077392578
patch: ++ 1 ;
rank: 403
score: 98.56912667410714
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + 0 ) ;
rank: 403
score: 98.54986572265625
patch: if ( ! ++ iter ) {
rank: 404
score: 99.03675537109375
patch: weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , 0 ) ;
rank: 404
score: 99.0126091452206
patch: Point CaMeL Vector CaMeL Value CaMeL Pair final = current CaMeL Point [ 0 ] ;
rank: 404
score: 98.95723876953124
patch: found = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Residuals ) ;
rank: 404
score: 98.86494276258681
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , ++ ;
rank: 404
score: 98.68755548650569
patch: ++ iter ; ++ iter ; ++ - 1 ;
rank: 404
score: 98.59673461914062
patch: iter iter ++ ; ++ ; ++ iter ;
rank: 404
score: 98.568994140625
patch: else { if ( iter > 0 ; {
rank: 404
score: 98.54903157552083
patch: if ( ++ n CaMeL C == 0 ) continue ;
rank: 405
score: 99.09104410807292
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) current CaMeL Point ;
rank: 405
score: 99.07514880952381
patch: it = compute CaMeL Weighted CaMeL Jacobian ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ) ;
rank: 405
score: 99.03662109375
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ,
rank: 405
score: 99.01073455810547
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair 1 checker = current CaMeL Point ;
rank: 405
score: 98.95698686079545
patch: x CaMeL Norm += weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , n CaMeL C ) ;
rank: 405
score: 98.8647101907169
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( get CaMeL Context ( ;
rank: 405
score: 98.68752219460227
patch: / * ] iter ; * / ++ iter ;
rank: 405
score: 98.56743028428819
patch: try { ++ iter ; } catch ;
rank: 405
score: 98.54871215820313
patch: if ( ++ n CaMeL C == 0 ;
rank: 406
score: 99.08921305338542
patch: double [ ] current CaMeL Objective = weight CaMeL Matrix CaMeL Sqrt . operate ( ) ;
rank: 406
score: 99.03645629882813
patch: weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , permutation ) ;
rank: 406
score: 99.00950520833334
patch: String current = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 406
score: 98.9566650390625
patch: ! qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 406
score: 98.8636245727539
patch: long start = System . current CaMeL Time CaMeL Millis ( ) - start ;
rank: 406
score: 98.68688286675348
patch: ++ iter ; iter ; * / ;
rank: 406
score: 98.59650421142578
patch: iter ; ++ ; = iter ;
rank: 406
score: 98.5669921875
patch: else { ++ iter ; return false ; }
rank: 406
score: 98.54807535807292
patch: ++ iter ; throw new Illegal CaMeL Argument CaMeL Exception ;
rank: 407
score: 99.08919583834134
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = this ;
rank: 407
score: 99.07463073730469
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair checker = get ;
rank: 407
score: 99.03620147705078
patch: weighted CaMeL Residual ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ,
rank: 407
score: 99.009033203125
patch: int iter = current CaMeL Residuals . operate ( current CaMeL Residuals ) ;
rank: 407
score: 98.95651084498355
patch: this . weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ,
rank: 407
score: 98.86353975183823
patch: ++ iter ] = new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ iter ;
rank: 407
score: 98.68677978515625
patch: / * ] ++ iter ; ++ iter ;
rank: 407
score: 98.54669189453125
patch: if ( ! index CaMeL Of ( iter ) ) {
rank: 408
score: 99.08917236328125
patch: double [ ] current CaMeL Objective = jac CaMeL Norm ;
rank: 408
score: 99.07433500744048
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = current . compute CaMeL Weighted CaMeL Jacobian ( ) ;
rank: 408
score: 99.03385202508224
patch: Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > current ;
rank: 408
score: 99.00844029017857
patch: qtf = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 408
score: 98.95639377170139
patch: found = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , iter ) ;
rank: 408
score: 98.863525390625
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ n CaMeL R , ; }
rank: 408
score: 98.68660888671874
patch: ++ iter ; ++ iter ; * / {
rank: 408
score: 98.59635416666667
patch: } ++ iter ; ++ iter ; }
rank: 408
score: 98.56612548828124
patch: else { ++ iter ; } return true ;
rank: 408
score: 98.54639610877403
patch: ++ iter ; throw new Illegal CaMeL State CaMeL Exception ; }
rank: 409
score: 99.08910071331522
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current CaMeL Objective = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 409
score: 99.03366524832589
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair >> ;
rank: 409
score: 99.0081787109375
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = ;
rank: 409
score: 98.95639217601104
patch: Iterator < Point CaMeL Vector CaMeL Value CaMeL Pair > iter = n CaMeL R ;
rank: 409
score: 98.86317545572916
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( ) ;
rank: 409
score: 98.68610975477431
patch: ++ iter ; iter ; * ; *
rank: 409
score: 98.59626770019531
patch: ++ iter ; iter ++ ; }
rank: 409
score: 98.56569417317708
patch: if ( . is CaMeL Empty ( ) ) throw ;
rank: 409
score: 98.54518345424107
patch: ++ iter ; while ( super . is CaMeL Empty ; ) {
rank: 410
score: 99.0890780362216
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) true ;
rank: 410
score: 99.0335693359375
patch: ++ ( ( Point CaMeL Vector CaMeL Value CaMeL Pair ) checker ) .
rank: 410
score: 99.00764973958333
patch: double current = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 410
score: 98.95613236860795
patch: this . weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , 0 ) ;
rank: 410
score: 98.86181640625
patch: ++ iter * / ;
rank: 410
score: 98.68576388888889
patch: ++ 1 ; ++ iter ; iter ;
rank: 410
score: 98.59520874023437
patch: ++ iter ; ++ iter ; / * ;
rank: 410
score: 98.56539916992188
patch: else { if ( iter > iter ) {
rank: 410
score: 98.54507211538461
patch: final ; if ( ! iter . is CaMeL Empty ; )
rank: 411
score: 99.08887657752403
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair case = current ;
rank: 411
score: 99.07349917763158
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Residuals , qtf ) ;
rank: 411
score: 99.03337860107422
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair throws = current ;
rank: 411
score: 99.00743192784927
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair [ ] current CaMeL Residuals = current ;
rank: 411
score: 98.95609323601974
patch: n CaMeL C = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ; }
rank: 411
score: 98.68488226996527
patch: ++ iter ; ++ iter ; list ;
rank: 411
score: 98.595166015625
patch: ++ iter ; ; iter ++ ; ++ ;
rank: 411
score: 98.56531700721153
patch: throw new Runtime CaMeL Exception ( $STRING$ + 1 , $STRING$ ;
rank: 411
score: 98.54451810396634
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter ,
rank: 412
score: 99.08839246961806
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = compute CaMeL Weighted CaMeL Jacobian (
rank: 412
score: 99.03325737847223
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Residuals ) ;
rank: 412
score: 99.00694274902344
patch: int ++ iter = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 412
score: 98.95585704985119
patch: tmp = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Objective ) ;
rank: 412
score: 98.86143663194444
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point + ;
rank: 412
score: 98.68462579900569
patch: ++ iter ; ++ iter ; int * * ;
rank: 412
score: 98.56514485677083
patch: if ( iter ; > 0 ) {
rank: 412
score: 98.54409790039062
patch: ++ iter ; if ( iter == null ) break ;
rank: 413
score: 99.08832077752976
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = new
rank: 413
score: 99.03319373497597
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair }
rank: 413
score: 99.00579474954044
patch: int CaMeL Value = Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ,
rank: 413
score: 98.9557217684659
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Residuals ) ;
rank: 413
score: 98.86139594184027
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , 0 ;
rank: 413
score: 98.68400065104167
patch: ++ iter ; * ? ++ iter ;
rank: 413
score: 98.59401633522727
patch: ++ iter ; ++ iter ; iter ; break ;
rank: 413
score: 98.5623779296875
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + iter * $STRING$ ;
rank: 414
score: 99.08821614583333
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point . length ) ;
rank: 414
score: 99.0728824013158
patch: it = final Point CaMeL Vector CaMeL Value CaMeL Pair . operate ( current CaMeL Point ) ;
rank: 414
score: 99.03303079044117
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair . current = current ;
rank: 414
score: 99.00566864013672
patch: double [ ] current = current ;
rank: 414
score: 98.95538884943181
patch: n CaMeL R = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , n CaMeL C ) ;
rank: 414
score: 98.86122041590073
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , ++ iter ; }
rank: 414
score: 98.68387179904514
patch: ++ iter ; iter ; for iter ;
rank: 414
score: 98.56196732954545
patch: Iterator iter = iter . iterator ++ ; while ;
rank: 414
score: 98.5433349609375
patch: final ; if ( ! is CaMeL Empty ) {
rank: 415
score: 99.07255249023437
patch: x CaMeL Norm = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Residuals ) ;
rank: 415
score: 99.00540161132812
patch: boolean first CaMeL Iteration = current CaMeL Point . length < n CaMeL C ;
rank: 415
score: 98.95515950520833
patch: instanceof Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ;
rank: 415
score: 98.8602627840909
patch: ++ iter ; * / * / ++ iter ;
rank: 415
score: 98.593798828125
patch: ++ false ; ++ iter ; ++ iter ;
rank: 415
score: 98.55971116286058
patch: throw new Runtime CaMeL Exception ( $STRING$ + this . iter ;
rank: 415
score: 98.543212890625
patch: ++ iter 1 ;
rank: 416
score: 99.03234049479167
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair < double )
rank: 416
score: 99.00526529947916
patch: double name = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 416
score: 98.95515580610795
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point . current CaMeL Objective ) ;
rank: 416
score: 98.86001586914062
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ n CaMeL C , ;
rank: 416
score: 98.68316040039062
patch: ++ iter ; try { iter ; * /
rank: 416
score: 98.55902099609375
patch: else { ++ false ; }
rank: 416
score: 98.54303741455078
patch: ++ iter ; while ( iter ;
rank: 417
score: 99.08677455357143
patch: int [ ] current CaMeL Objective = get CaMeL Weight CaMeL Square CaMeL Root ( current CaMeL Point ) ;
rank: 417
score: 99.07243208451705
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair qtf = compute CaMeL Weighted CaMeL Jacobian ( qtf ) ;
rank: 417
score: 99.00476792279412
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = operate ;
rank: 417
score: 98.95465766059027
patch: n CaMeL C = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Cost ) ;
rank: 417
score: 98.85989815848214
patch: ++ iter ; / * ;
rank: 417
score: 98.683154296875
patch: int iter ; ++ iter ; ++ iter ;
rank: 417
score: 98.5932950106534
patch: ++ iter ; ++ start ; ; ++ iter ;
rank: 417
score: 98.55885823567708
patch: / * * * * ++ iter ;
rank: 418
score: 99.08650716145833
patch: Point CaMeL Vector CaMeL Value CaMeL Pair current = current ; final Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 418
score: 99.0721435546875
patch: e = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Point ) ;
rank: 418
score: 99.03169080946181
patch: if ( checker . get CaMeL Weight CaMeL Square CaMeL Root ( ) != 0 ) {
rank: 418
score: 99.00472819010416
patch: boolean first CaMeL Iteration = current CaMeL Point [ n CaMeL R ] ;
rank: 418
score: 98.95458984375
patch: Iterator < Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > iter = true ;
rank: 418
score: 98.8597640991211
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , ; ;
rank: 418
score: 98.68309936523437
patch: ++ iter ; / * / ++ iter ;
rank: 418
score: 98.59285278320313
patch: ++ iter ; ; if ++ iter ; ;
rank: 418
score: 98.55872521033653
patch: else { throw new Runtime CaMeL Exception ; } ++ iter ;
rank: 418
score: 98.54242412860577
patch: if ( ! iter . is CaMeL Empty ; ; ) {
rank: 419
score: 99.08573774857955
patch: final double [ ] current CaMeL Objective = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 419
score: 99.03099060058594
patch: while ( iter = get CaMeL Weight CaMeL Square CaMeL Root ( ) ) {
rank: 419
score: 99.00427964154412
patch: e = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ,
rank: 419
score: 98.95413208007812
patch: s = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 419
score: 98.8593521118164
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , iter , iter ;
rank: 419
score: 98.68307495117188
patch: ++ iter ; ++ iter ; try ; ++ iter ;
rank: 419
score: 98.592578125
patch: ++ iter ; iter if ++ ; ++ ;
rank: 419
score: 98.54224504743304
patch: if ( ! iter . is CaMeL Empty ( ) ) return ;
rank: 420
score: 99.0852581521739
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker ; final Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 420
score: 99.03086751302084
patch: ++ checker . get CaMeL Weight CaMeL Square CaMeL Root ( ) ; }
rank: 420
score: 99.00422886439732
patch: case Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current ;
rank: 420
score: 98.85887858072917
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ ;
rank: 420
score: 98.68294949001736
patch: int iter ; / ; ++ iter ;
rank: 420
score: 98.5919522372159
patch: ++ iter ; ++ iter ; } = iter ;
rank: 420
score: 98.55765991210937
patch: if ( iter > 0 ; / * ;
rank: 420
score: 98.54191758897569
patch: switch ( iter ) { case 1 :
rank: 421
score: 99.08524946732955
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = new Point CaMeL Vector CaMeL Value CaMeL Pair iter ;
rank: 421
score: 99.03036499023438
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair delta = current ;
rank: 421
score: 99.00415757123162
patch: ( ( Point CaMeL Vector CaMeL Value CaMeL Pair > ) current CaMeL Point ) .
rank: 421
score: 98.95334759880515
patch: list = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ; }
rank: 421
score: 98.85858513327206
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current . ++ , current ;
rank: 421
score: 98.68223741319444
patch: / * ++ ++ iter ; / /
rank: 421
score: 98.59178466796875
patch: ++ iter ; iter / ; = iter ;
rank: 421
score: 98.55718315972223
patch: else { if ++ iter ++ ; }
rank: 422
score: 99.08500339673913
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) this ;
rank: 422
score: 99.0716552734375
patch: ++ iter = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ;
rank: 422
score: 99.0034538717831
patch: int qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ,
rank: 422
score: 98.95317526424633
patch: if ( weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ) {
rank: 422
score: 98.85819738051471
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , true ;
rank: 422
score: 98.68151177300348
patch: ++ iter ; iter ; * * ;
rank: 422
score: 98.591455078125
patch: ++ iter ; ++ iter ; iter ++ ;
rank: 422
score: 98.55714111328125
patch: if ( iter == 0 ) throw null ;
rank: 422
score: 98.54145643446181
patch: if ( ++ iter >= 0 ) {
rank: 423
score: 99.08494984019886
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = $NUMBER$ ;
rank: 423
score: 99.07147771661931
patch: qtf = compute CaMeL Weighted CaMeL Jacobian ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Objective ) ) ;
rank: 423
score: 99.03014264787946
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair private ;
rank: 423
score: 99.00311279296875
patch: double ! compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 423
score: 98.95313784950658
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , qtf ) ;
rank: 423
score: 98.85759420955883
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current ) ; ++ iter ++ ;
rank: 423
score: 98.68136257595486
patch: int iter ; * / ++ iter ;
rank: 423
score: 98.591015625
patch: ++ iter ; iter * / ++ iter ;
rank: 423
score: 98.55690354567308
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + start ;
rank: 423
score: 98.54135470920139
patch: final ; ++ iter ; ++ iter ;
rank: 424
score: 99.08492024739583
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = ( Point CaMeL Vector CaMeL Value CaMeL Pair > ) false ;
rank: 424
score: 99.03001403808594
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair trim = current ;
rank: 424
score: 98.95313439002403
patch: < Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 424
score: 98.85672200520834
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , ++ iter ;
rank: 424
score: 98.68109130859375
patch: ++ iter ; ++ iter = iter ;
rank: 424
score: 98.59097629123264
patch: ++ iter ; ++ iter ; null ;
rank: 424
score: 98.55685860770089
patch: / * = ++ iter ;
rank: 424
score: 98.5409912109375
patch: ++ iter ; Thread . sleep ( $NUMBER$ ;
rank: 425
score: 99.08477228338069
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair && checker . operate ( current CaMeL Point ) ;
rank: 425
score: 99.00285339355469
patch: Object current CaMeL Point = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 425
score: 98.9530362215909
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) . operate ( current CaMeL Point ) ;
rank: 425
score: 98.85629272460938
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , this . ++ ;
rank: 425
score: 98.67955186631944
patch: int iter ; * ; int iter ;
rank: 425
score: 98.59088812934027
patch: ++ iter ; ++ / ++ iter ;
rank: 425
score: 98.55677141462054
patch: if ( . is CaMeL Empty ( ) ) { ++ iter ;
rank: 425
score: 98.5405782063802
patch: if ( ! iter . is CaMeL Empty ; ; )
rank: 426
score: 99.08460693359375
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = current CaMeL Point [ n CaMeL R ] ;
rank: 426
score: 99.07118530273438
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Residuals , current CaMeL Point ) ;
rank: 426
score: 98.95302124023438
patch: other = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 426
score: 98.85625143612133
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , iter ) ; }
rank: 426
score: 98.67847789417614
patch: ++ iter ; ++ iter ; out . ++ ;
rank: 426
score: 98.59073893229167
patch: ++ new ++ ; ++ iter ; ;
rank: 426
score: 98.55583360460069
patch: else { if ++ ++ iter ; }
rank: 426
score: 98.5404803936298
patch: if ( ! iter . starts CaMeL With ( current ) )
rank: 427
score: 99.0845235188802
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current CaMeL Objective = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ;
rank: 427
score: 99.07107979910714
patch: i = compute CaMeL Weighted CaMeL Jacobian ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ) ;
rank: 427
score: 99.02802276611328
patch: while ( true ) { final Point CaMeL Vector CaMeL Value CaMeL Pair -- ;
rank: 427
score: 98.9529541015625
patch: found = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Point ) ;
rank: 427
score: 98.85612218520221
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current . ++ , iter ;
rank: 427
score: 98.67811414930556
patch: ++ iter ; for iter ; iter ;
rank: 427
score: 98.59026421440973
patch: iter ; ++ iter ; ++ 1 ;
rank: 427
score: 98.55511944110577
patch: if ( ! 0 . is CaMeL Empty ( this ) ;
rank: 427
score: 98.54004923502605
patch: if ( ! name . equals ( iter ) ) {
rank: 428
score: 99.08451334635417
patch: Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current CaMeL Point ;
rank: 428
score: 99.0708366842831
patch: d = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ;
rank: 428
score: 98.99931117466518
patch: Point CaMeL Vector CaMeL Value CaMeL Pair [ ] checker = current ;
rank: 428
score: 98.95292358398437
patch: added = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 428
score: 98.85610961914062
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , ; ++ iter ;
rank: 428
score: 98.6776631673177
patch: ++ iter ; try ; ++ iter ; ++ iter ;
rank: 428
score: 98.58965454101562
patch: iter ; ++ iter ; } ++ iter ;
rank: 428
score: 98.5548095703125
patch: if ( iter > 0 ) { continue ; }
rank: 428
score: 98.54004845252403
patch: if ( ! iter . is CaMeL Empty ( ) ; else
rank: 429
score: 99.02742084703948
patch: qr CaMeL Decomposition = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ; }
rank: 429
score: 98.99915313720703
patch: if ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) break ;
rank: 429
score: 98.952880859375
patch: x CaMeL Norm += weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Point ) ;
rank: 429
score: 98.85448500689338
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair ( current . ++ ;
rank: 429
score: 98.67709689670139
patch: ++ iter ; for iter ; ; *
rank: 429
score: 98.5888671875
patch: ++ iter ; ; iter / * /
rank: 429
score: 98.55470106336806
patch: / * * * ++ ++ iter ;
rank: 429
score: 98.53980601917614
patch: while ( true ) { ++ n CaMeL C ;
rank: 430
score: 99.08395565257354
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = false ;
rank: 430
score: 99.07068634033203
patch: ++ iter ] = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 430
score: 99.0273681640625
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair { final ;
rank: 430
score: 98.99882238051471
patch: / * compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ,
rank: 430
score: 98.95263671875
patch: <= Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ;
rank: 430
score: 98.85406853170956
patch: ++ iter ; return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current ; }
rank: 430
score: 98.67709011501736
patch: ++ iter ; ++ * ; iter ;
rank: 430
score: 98.58815511067708
patch: ++ iter ; ++ iter ; ; iter
rank: 430
score: 98.55451311383929
patch: else { ++ * ; }
rank: 430
score: 98.53880896935097
patch: if ( ! iter . is CaMeL Empty ( ) ) }
rank: 431
score: 99.08377511160714
patch: Point CaMeL Vector CaMeL Value CaMeL Pair current = current ; / *
rank: 431
score: 99.0706787109375
patch: final Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 431
score: 98.99736022949219
patch: compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective , (
rank: 431
score: 98.95219116210937
patch: finished = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 431
score: 98.85385131835938
patch: Iterator iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point
rank: 431
score: 98.67683241102431
patch: if ++ iter ; ; ++ iter ;
rank: 431
score: 98.58733520507812
patch: ++ iter ; ; / ; ++ iter ;
rank: 431
score: 98.55423583984376
patch: if ( iter == 0 ; return false ;
rank: 431
score: 98.53865559895833
patch: ++ iter ; while ( n CaMeL C < iter )
rank: 432
score: 99.0833740234375
patch: ++ 0 ; final Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 432
score: 99.07063293457031
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair current = this ;
rank: 432
score: 98.9963623046875
patch: int qr CaMeL Decomposition ( current CaMeL Point , current CaMeL Objective ) ;
rank: 432
score: 98.95214165581598
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , qtf ) ;
rank: 432
score: 98.85295952690973
patch: ++ iter ; * / * * ;
rank: 432
score: 98.67560492621527
patch: ++ iter ; while ++ iter ; ;
rank: 432
score: 98.58708360460069
patch: iter ; ++ ++ ; ++ iter ;
rank: 432
score: 98.55339898003473
patch: / * * * ++ ++ * /
rank: 432
score: 98.53851787860577
patch: ++ iter ; if ( this . is CaMeL Empty ) {
rank: 433
score: 99.08332375919117
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair = current CaMeL Point [ iter ] ;
rank: 433
score: 98.99574381510416
patch: boolean first CaMeL Iteration = compute CaMeL Cost ( current CaMeL Point ) ;
rank: 433
score: 98.95213734019886
patch: n CaMeL R = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Residuals ) ;
rank: 433
score: 98.85277506510417
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair . ++ ;
rank: 433
score: 98.6750821200284
patch: ++ iter ; ++ iter ; * - iter ;
rank: 433
score: 98.58683268229167
patch: ++ iter ; iter ; return iter ;
rank: 433
score: 98.55324009486607
patch: if ( . is CaMeL Empty ( ) ) { break ; }
rank: 433
score: 98.53819056919643
patch: ++ iter ; while ( ! iter . is CaMeL Empty ; )
rank: 434
score: 99.08330426897321
patch: final final Point CaMeL Vector CaMeL Value CaMeL Pair checker = current ;
rank: 434
score: 99.07036946614583
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = this . current ;
rank: 434
score: 99.02670467601104
patch: if ( checker . compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ) {
rank: 434
score: 98.95212227957589
patch: n CaMeL C = compute CaMeL Cost ( current CaMeL Point ) ;
rank: 434
score: 98.85243135340073
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , iter ) ;
rank: 434
score: 98.5866470336914
patch: ++ iter ; ++ ; / /
rank: 434
score: 98.552978515625
patch: ++ iter ; if ; }
rank: 434
score: 98.53790838068181
patch: ++ iter ; if ( ! iter . ; }
rank: 435
score: 99.08284859035327
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = < Point CaMeL Vector CaMeL Value CaMeL Pair > checker ;
rank: 435
score: 99.07005004882812
patch: current CaMeL Point = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Residuals ) ;
rank: 435
score: 98.95193045479911
patch: ( final Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 435
score: 98.8522720336914
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , ; }
rank: 435
score: 98.5864013671875
patch: ++ iter ; ; if iter / / /
rank: 435
score: 98.55231323242188
patch: if ( iter == null ; return ; }
rank: 435
score: 98.53688401442308
patch: ++ iter ; Thread . current CaMeL Thread ( ) ; }
rank: 436
score: 99.08275349934895
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > = current ;
rank: 436
score: 99.0699398643092
patch: qtf = weighted CaMeL Residual [ compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 436
score: 99.02620014391448
patch: checker ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ) ;
rank: 436
score: 98.99429524739584
patch: int [ ] current CaMeL Objective = current CaMeL Residuals [ 0 ] ;
rank: 436
score: 98.95185779389881
patch: rs = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Objective ) ;
rank: 436
score: 98.85186004638672
patch: ++ iter ; if ( iter ;
rank: 436
score: 98.6737060546875
patch: ++ iter ; while iter + 0 ;
rank: 436
score: 98.55204554966518
patch: else { ++ iter ; ;
rank: 436
score: 98.53636756310097
patch: ++ iter ; hash CaMeL Code [ 0 ] = iter ;
rank: 437
score: 99.08244243421052
patch: / * Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = null ;
rank: 437
score: 99.02602914663461
patch: int iter = checker . operate ( current CaMeL Objective ) ;
rank: 437
score: 98.9941635131836
patch: boolean first CaMeL Iteration ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 437
score: 98.95182719983552
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , n CaMeL R ) ;
rank: 437
score: 98.85172765395221
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ current CaMeL Point ; }
rank: 437
score: 98.58568226207386
patch: ++ iter ; ; if iter ; ++ iter ;
rank: 437
score: 98.55162353515625
patch: ++ iter ; if ++ iter < iter ;
rank: 437
score: 98.53497869318181
patch: if ( ++ n CaMeL C == 0 ) {
rank: 438
score: 99.08167521158855
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = ( Point CaMeL Vector CaMeL Value CaMeL Pair > ) get ;
rank: 438
score: 99.06840245863971
patch: it = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Residuals ) ;
rank: 438
score: 98.99416097005208
patch: double [ ] current CaMeL Objective = current CaMeL Objective ;
rank: 438
score: 98.95177612304687
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Residuals ) ;
rank: 438
score: 98.85169135199652
patch: ++ iter ; final ; ++ iter ;
rank: 438
score: 98.67332628038194
patch: ++ iter ; iter ; int 1 ;
rank: 438
score: 98.55139838324652
patch: else { if ++ iter > iter ;
rank: 438
score: 98.53464084201389
patch: final int iter = iter - 1 ;
rank: 439
score: 99.08118785511364
patch: weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Objective , current CaMeL Residuals ) ;
rank: 439
score: 99.06821017795139
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair current = current CaMeL Point ;
rank: 439
score: 99.025634765625
patch: double [ ] current CaMeL Residuals = get CaMeL Weight CaMeL Square CaMeL Root ( ) ;
rank: 439
score: 98.99374186197916
patch: boolean first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt [ iter ] ;
rank: 439
score: 98.95170084635417
patch: < Point CaMeL Vector CaMeL Value CaMeL Pair > checker =
rank: 439
score: 98.85120307074652
patch: ++ iter * / * * / ;
rank: 439
score: 98.67286265980114
patch: ++ iter ; ++ iter ; / * * /
rank: 439
score: 98.58432345920139
patch: ++ iter ; iter ; ; / /
rank: 439
score: 98.55078125
patch: else { throw new Runtime CaMeL Exception ++ ;
rank: 439
score: 98.53448486328125
patch: if ( ! iter != null ) {
rank: 440
score: 99.08034349524456
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) 0 ;
rank: 440
score: 99.02513122558594
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair reverse = current ;
rank: 440
score: 98.99371337890625
patch: boolean first CaMeL Iteration = n CaMeL C < n CaMeL R ;
rank: 440
score: 98.95160784040179
patch: check CaMeL Parameters ( current CaMeL Objective , current CaMeL Objective ) ;
rank: 440
score: 98.8498046875
patch: ++ iter ; this . ++ iter ++ ;
rank: 440
score: 98.6724853515625
patch: ++ iter ; ++ iter ; / * * / /
rank: 440
score: 98.58344116210938
patch: / ; ++ iter ; ; ++ iter ;
rank: 440
score: 98.55021837022569
patch: ++ iter ; if ++ * iter ;
rank: 440
score: 98.53444417317708
patch: ++ iter ; ++ iter ; try {
rank: 441
score: 99.0802510579427
patch: Point CaMeL Vector CaMeL Value CaMeL Pair checker = ( Point CaMeL Vector CaMeL Value CaMeL Pair , current CaMeL Point ) ;
rank: 441
score: 99.068115234375
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair final = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ;
rank: 441
score: 98.993505859375
patch: Map < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = false ;
rank: 441
score: 98.95140883501838
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ; break ;
rank: 441
score: 98.84941101074219
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ iter , iter , ;
rank: 441
score: 98.67207166883681
patch: ++ iter ; else * int iter ;
rank: 441
score: 98.58299671519886
patch: ++ iter ; ++ iter ; else throw iter ;
rank: 441
score: 98.54989963107639
patch: if ( iter < 0 ; break ;
rank: 441
score: 98.5332364169034
patch: ++ iter ; ++ n CaMeL R ; break ;
rank: 442
score: 99.07996961805556
patch: Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current CaMeL Point [ iter ] ;
rank: 442
score: 99.06805419921875
patch: Point CaMeL Vector CaMeL Value CaMeL Pair current = current CaMeL Point ;
rank: 442
score: 98.99319893973214
patch: name = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 442
score: 98.95091663707386
patch: this . weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , true ) ;
rank: 442
score: 98.67117648654514
patch: ++ iter ; ++ iter ; - ;
rank: 442
score: 98.58258056640625
patch: ++ iter ; ; if iter ; / /
rank: 442
score: 98.54957411024306
patch: ++ iter ; ++ iter ; if ;
rank: 442
score: 98.53236389160156
patch: if ( iter < 1 ) {
rank: 443
score: 99.02392578125
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair clone = current ;
rank: 443
score: 98.95038132440476
patch: this . weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , ) ;
rank: 443
score: 98.84897189670139
patch: if ( iter < iter ) break ;
rank: 443
score: 98.58131917317708
patch: ++ iter ; ++ ;
rank: 443
score: 98.54871283637152
patch: if ( iter < 0 ; return ;
rank: 443
score: 98.53164438100961
patch: ++ iter ; while ( n CaMeL C > 0 ) {
rank: 444
score: 99.07950846354167
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current CaMeL Point . length ;
rank: 444
score: 99.0676502046131
patch: ++ iter ; final Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current ;
rank: 444
score: 98.99152483258929
patch: int CaMeL Value = checker . operate ( current CaMeL Point ) ;
rank: 444
score: 98.95029296875
patch: rs = get CaMeL Weight CaMeL Square CaMeL Root ( current CaMeL Point , current CaMeL Objective ) ;
rank: 444
score: 98.84890747070312
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , ++ ++ iter ;
rank: 444
score: 98.6704345703125
patch: ++ iter ; ++ iter ; int value ;
rank: 444
score: 98.58103637695312
patch: ++ iter ; ; if iter / ++ ;
rank: 444
score: 98.54849679129464
patch: if ( . is CaMeL Empty ( ) ) { continue ; }
rank: 444
score: 98.53038024902344
patch: ++ iter ; switch ( iter )
rank: 445
score: 99.07932447350544
patch: double current CaMeL Objective = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 445
score: 99.06755913628473
patch: ++ iter = solved CaMeL Cols < Point CaMeL Vector CaMeL Value CaMeL Pair > checker ;
rank: 445
score: 99.02381184895833
patch: Iterator iter = checker . do CaMeL Optimize ( current CaMeL Point ) ;
rank: 445
score: 98.99071393694196
patch: key = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 445
score: 98.9491656759511
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ; }
rank: 445
score: 98.84822082519531
patch: ++ iter * / * iter ;
rank: 445
score: 98.58088989257813
patch: ++ iter ; ++ iter ; / iter ;
rank: 446
score: 99.06744063527961
patch: ( ( Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > ) checker ) ;
rank: 446
score: 99.02329915364584
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair ++ ; {
rank: 446
score: 98.99053955078125
patch: double [ ] current CaMeL Objective = current CaMeL Residuals ;
rank: 446
score: 98.94899338942308
patch: protected Point CaMeL Vector CaMeL Value CaMeL Pair current = null ;
rank: 446
score: 98.6691162109375
patch: ++ iter ; iter ; * - * /
rank: 446
score: 98.58011203342014
patch: ++ iter ; } ++ iter ; }
rank: 446
score: 98.54744175502232
patch: if ( ! 0 . is CaMeL Empty ( ) ; return ;
rank: 446
score: 98.52909545898437
patch: ++ iter ++ ;
rank: 447
score: 99.07927703857422
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current CaMeL Residuals ;
rank: 447
score: 98.98976643880208
patch: if ( n CaMeL C <= n CaMeL C ) {
rank: 447
score: 98.94819972826087
patch: Iterator < Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > iter = iter ;
rank: 447
score: 98.84441266741071
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , current ;
rank: 447
score: 98.66863335503473
patch: int iter + 0 ; ++ iter ;
rank: 447
score: 98.57991166548295
patch: ++ iter ; ; ++ iter ; while iter ;
rank: 447
score: 98.54609818892045
patch: else { ++ iter ; } return false ; }
rank: 447
score: 98.52887517755681
patch: final int iter = iter - n CaMeL C ;
rank: 448
score: 99.07849839154412
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current CaMeL Point = current ; / *
rank: 448
score: 99.06707208806819
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair ( ;
rank: 448
score: 99.02268981933594
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair remove = current ;
rank: 448
score: 98.98974609375
patch: r = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 448
score: 98.94818115234375
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point . 0 ) ;
rank: 448
score: 98.844287109375
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , ;
rank: 448
score: 98.57963731553819
patch: ++ ++ iter ; ; ++ iter ;
rank: 448
score: 98.54585484095982
patch: return iter [ 0 ] ;
rank: 448
score: 98.52846457741477
patch: ++ iter ; if ( iter > 0 ) {
rank: 449
score: 99.06679077148438
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair final = current CaMeL Point [ current CaMeL Point ) ;
rank: 449
score: 98.98779296875
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair iterator = current ;
rank: 449
score: 98.9481201171875
patch: tmp = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Residuals ) ;
rank: 449
score: 98.84417046440973
patch: Iterator iter = iter . iterator ( ;
rank: 449
score: 98.66813151041667
patch: ++ iter ; iter * - iter ;
rank: 449
score: 98.57914595170455
patch: ++ 1 ; ++ iter ; } ++ iter ;
rank: 449
score: 98.54573277064732
patch: if ( . is CaMeL Empty ( ) ; return iter ; }
rank: 450
score: 99.07805926983173
patch: Point CaMeL Vector CaMeL Value CaMeL Pair > checker = null ;
rank: 450
score: 99.02233123779297
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair void = current ;
rank: 450
score: 98.986083984375
patch: boolean < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current ;
rank: 450
score: 98.9478759765625
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , ) ;
rank: 450
score: 98.84396362304688
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current . ++ , ; }
rank: 450
score: 98.66755981445313
patch: ++ iter ; ++ iter ; * * ;
rank: 450
score: 98.57872425426136
patch: ++ iter ; ; ++ iter ; ++ ; /
rank: 450
score: 98.54550606863839
patch: throw new Runtime CaMeL Exception ( $STRING$ + iter + $STRING$ ; }
rank: 450
score: 98.5274887084961
patch: try { ++ iter ; else {
rank: 451
score: 99.06668526785714
patch: i = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Objective ) ;
rank: 451
score: 99.02089556525735
patch: iter = final Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Objective ) ;
rank: 451
score: 98.98606520432692
patch: double [ ] qr CaMeL Decomposition ( current CaMeL Point ) ;
rank: 451
score: 98.94759792751736
patch: list = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point . length ) ;
rank: 451
score: 98.6670430501302
patch: ++ iter ; ++ iter ; ++ * - iter ;
rank: 451
score: 98.57793579101562
patch: ++ iter ; ++ iter ; iter ; start
rank: 451
score: 98.54545084635417
patch: else { ++ * iter ; } }
rank: 451
score: 98.52729936079545
patch: if ( iter == 0 ) { break ; }
rank: 452
score: 99.07780376233552
patch: ++ n CaMeL C ; final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current ;
rank: 452
score: 99.06643240792411
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair qtf = current ;
rank: 452
score: 99.02015686035156
patch: / * compute CaMeL Cost ( n CaMeL R , current CaMeL Objective ) ;
rank: 452
score: 98.947119140625
patch: tmp = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , n CaMeL C ) ;
rank: 452
score: 98.84327697753906
patch: ++ iter ; return new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter ;
rank: 452
score: 98.66689231178977
patch: ++ iter ; ++ iter ; ; int iter ;
rank: 452
score: 98.5775146484375
patch: ++ iter ; iter = ++ iter ;
rank: 452
score: 98.54493001302083
patch: if ( . is CaMeL Empty ( ) ) { return iter ; }
rank: 452
score: 98.52713012695312
patch: while ( true ) { ++ iter ++ ;
rank: 453
score: 99.06629854090073
patch: i = final Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Residuals ) ;
rank: 453
score: 99.01924272017045
patch: return checker . operate ( current CaMeL Residuals ) ;
rank: 453
score: 98.98487200055804
patch: int CaMeL Value = compute CaMeL Cost ( current CaMeL Point ) ;
rank: 453
score: 98.9469985961914
patch: res = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Objective ) ;
rank: 453
score: 98.66664428710938
patch: ++ iter ; ++ iter ; int * ;
rank: 453
score: 98.57675170898438
patch: ++ iter ; iter throw iter ;
rank: 453
score: 98.54462139423077
patch: if ( ! 0 . is CaMeL Empty ( && ) ;
rank: 453
score: 98.52708082932692
patch: ++ iter = Arrays . as CaMeL List ( current ) ;
rank: 454
score: 99.06624109604779
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = current . current CaMeL Point ;
rank: 454
score: 99.0190658569336
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair do = current ;
rank: 454
score: 98.98470052083333
patch: if ( current CaMeL Cost < n CaMeL C ) {
rank: 454
score: 98.94693603515626
patch: n CaMeL R = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , iter ) ;
rank: 454
score: 98.84189453125
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( ; ;
rank: 454
score: 98.66647338867188
patch: ++ iter ; ++ iter ; * * ++ iter ;
rank: 454
score: 98.57633972167969
patch: ++ iter ; iter / break ;
rank: 454
score: 98.544287109375
patch: else { / * * / ++ iter ;
rank: 454
score: 98.52628326416016
patch: ++ iter ; ++ iter 1 ;
rank: 455
score: 99.06619966947116
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair permutation = current ;
rank: 455
score: 98.983984375
patch: System . arraycopy ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 455
score: 98.94683074951172
patch: public Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > do {
rank: 455
score: 98.84117838541667
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL
rank: 455
score: 98.66621907552083
patch: int iter ; / ; int iter ;
rank: 455
score: 98.57616577148437
patch: ++ iter ; iter ; / ++ iter ;
rank: 455
score: 98.54411177201705
patch: if ( iter == 0 ; return ++ iter ;
rank: 455
score: 98.52584838867188
patch: ++ iter - n CaMeL C ;
rank: 456
score: 99.0771993001302
patch: weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective . length ) ;
rank: 456
score: 99.06558227539062
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current CaMeL Point = current CaMeL Point [ 0 ] ;
rank: 456
score: 98.98395182291667
patch: int iter = solved CaMeL Cols . operate ( current CaMeL Residuals ) ;
rank: 456
score: 98.94661218979779
patch: ! weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , 0 ) ;
rank: 456
score: 98.84102376302083
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , current ;
rank: 456
score: 98.57587890625
patch: ++ iter ; ++ current ; ++ iter ;
rank: 456
score: 98.52582341974431
patch: ++ iter ; if ( iter >= 0 ) {
rank: 457
score: 99.07707413383152
patch: Point CaMeL Vector CaMeL Value CaMeL Pair > checker = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ,
rank: 457
score: 99.0177978515625
patch: checker ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) .
rank: 457
score: 98.98218645368304
patch: boolean first CaMeL Iteration = n CaMeL R < n CaMeL C ;
rank: 457
score: 98.94661167689732
patch: x CaMeL Norm = compute CaMeL Cost ( current CaMeL Point ) ;
rank: 457
score: 98.84020124162946
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter
rank: 457
score: 98.66543240017361
patch: ++ iter ; ++ iter + 0 ;
rank: 457
score: 98.57577853732639
patch: ++ iter ; } ++ iter ; ;
rank: 457
score: 98.54294996995192
patch: throw new Runtime CaMeL Exception ( $STRING$ ; } ++ iter ;
rank: 457
score: 98.52557983398438
patch: if ( ++ n CaMeL C > 0 ;
rank: 458
score: 99.07626342773438
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current ; / /
rank: 458
score: 99.01777648925781
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair insert = current ;
rank: 458
score: 98.98047892252605
patch: if ( current CaMeL Point < n CaMeL C ) {
rank: 458
score: 98.94658745659723
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals [ 0 ] ) ;
rank: 458
score: 98.66397705078126
patch: / * ++ iter ; ++ iter ; ;
rank: 458
score: 98.57560511997768
patch: ++ Math ; ++ iter ;
rank: 458
score: 98.54222412109375
patch: if ( iter < 0 ; return null ;
rank: 458
score: 98.52491590711806
patch: final int iter = iter + 1 ;
rank: 459
score: 99.07600911458333
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current CaMeL Objective = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Objective ) ;
rank: 459
score: 99.06501116071429
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 459
score: 98.9803975423177
patch: if ( current CaMeL Point < n CaMeL R ) {
rank: 459
score: 98.94639185855263
patch: tmp = qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 459
score: 98.83828938802084
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair ( ) ;
rank: 459
score: 98.66392933238636
patch: ++ iter ; ++ iter ; while iter ; ;
rank: 459
score: 98.57532848011364
patch: ++ iter ; ++ iter ; ; iter -- ;
rank: 459
score: 98.54169256036931
patch: else { ++ iter ; * / = iter ;
rank: 459
score: 98.52479137073864
patch: ++ iter $NUMBER$ [ n CaMeL C ] ; }
rank: 460
score: 99.07560221354167
patch: ++ iter ; Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current ;
rank: 460
score: 99.01719665527344
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) .
rank: 460
score: 98.9803133877841
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair -- ;
rank: 460
score: 98.94627380371094
patch: ! weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ; }
rank: 460
score: 98.83717447916666
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , true ) ;
rank: 460
score: 98.5750732421875
patch: ++ iter ; iter ++ ; ;
rank: 460
score: 98.54127604166666
patch: throw new Illegal CaMeL Argument CaMeL Exception ( new Exception ( ) ) ;
rank: 460
score: 98.52365112304688
patch: ++ iter + iter ;
rank: 461
score: 99.06451056985294
patch: ++ iter < final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current ;
rank: 461
score: 99.01671491350446
patch: compute CaMeL Cost ( current CaMeL Residuals , current CaMeL Objective ) ;
rank: 461
score: 98.94608931107955
patch: n CaMeL R = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , n CaMeL R ) ;
rank: 461
score: 98.835009765625
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ n CaMeL R ;
rank: 461
score: 98.6624247233073
patch: this . ++ iter ; ++ iter ; int iter ;
rank: 461
score: 98.57460715553977
patch: ++ iter ; ++ iter ; = iter ++ ;
rank: 461
score: 98.54127332899306
patch: else ++ iter ; if ++ iter ;
rank: 461
score: 98.52257283528645
patch: ++ iter = Arrays . as CaMeL List ( iter ;
rank: 462
score: 99.01649983723958
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ; else
rank: 462
score: 98.9788818359375
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > ++ ;
rank: 462
score: 98.94601440429688
patch: found = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , n CaMeL C ) ;
rank: 462
score: 98.66208224826389
patch: / ++ ++ iter ; ++ iter ;
rank: 462
score: 98.57460715553977
patch: ++ iter ; ; ++ start ; ++ iter ;
rank: 462
score: 98.54121537642045
patch: if ( iter > 0 ; return ++ iter ;
rank: 462
score: 98.52223899147727
patch: if ( iter == 0 ) { continue ; }
rank: 463
score: 99.0748062133789
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair case = current ;
rank: 463
score: 99.06372833251953
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair current = 0 ;
rank: 463
score: 99.01619037828948
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Objective , current CaMeL Objective ,
rank: 463
score: 98.9786376953125
patch: Object qr CaMeL Decomposition ( current CaMeL Point , current CaMeL Objective ) ;
rank: 463
score: 98.9450927734375
patch: found = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Objective ) ;
rank: 463
score: 98.83435872395833
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ iter , current ;
rank: 463
score: 98.66192072088069
patch: ++ iter ; iter ; * / int iter ;
rank: 463
score: 98.57425362723214
patch: ++ list ; ++ iter ;
rank: 463
score: 98.54078892299107
patch: if ( . is CaMeL Empty ( ) ) return ++ iter ;
rank: 463
score: 98.52174072265625
patch: if ( ++ n CaMeL C >= 0 )
rank: 464
score: 99.07457275390625
patch: int [ ] current CaMeL Objective = null ;
rank: 464
score: 99.06301540798611
patch: d = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Residuals ) ;
rank: 464
score: 99.01592145647321
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair Math ;
rank: 464
score: 98.97849934895834
patch: Map < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = true ;
rank: 464
score: 98.66158447265624
patch: ++ iter ; * / { ++ iter ;
rank: 464
score: 98.5739517211914
patch: ++ ( ++ iter ; / /
rank: 464
score: 98.54042358398438
patch: / * * * * ; ++ iter ;
rank: 464
score: 98.52161865234375
patch: ++ iter ; while ( iter == iter )
rank: 465
score: 99.07342529296875
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = ( Point CaMeL Vector CaMeL Value CaMeL Pair > ) 0 ;
rank: 465
score: 99.01558685302734
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair sort = current ;
rank: 465
score: 98.9783203125
patch: / * boolean first CaMeL Iteration = true ;
rank: 465
score: 98.94503348214286
patch: comparator . qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point . length ) ) ;
rank: 465
score: 98.8337890625
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , 0 , ;
rank: 465
score: 98.66145155164931
patch: ++ iter ; iter ; * 1 ;
rank: 465
score: 98.57387966579861
patch: ++ iter ; iter / ; / }
rank: 465
score: 98.54041205512152
patch: else { / * * ++ iter ;
rank: 465
score: 98.52130889892578
patch: final ; if ( true ) {
rank: 466
score: 98.97676595052083
patch: Iterator ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 466
score: 98.94456263950893
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ,
rank: 466
score: 98.66129150390626
patch: int iter ; * * / ++ iter ;
rank: 466
score: 98.57379760742188
patch: ++ iter ; ++ iter ; ++ min ;
rank: 466
score: 98.53990071614584
patch: if ( ! 0 . is CaMeL Empty ( ) ) ++ iter ;
rank: 466
score: 98.52122192382812
patch: if ( ++ n CaMeL C < iter )
rank: 467
score: 99.07300567626953
patch: if ( Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > )
rank: 467
score: 99.01425170898438
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair this = current ;
rank: 467
score: 98.97633579799107
patch: double [ ] current CaMeL Objective = this . current CaMeL Residuals ;
rank: 467
score: 98.94448617788461
patch: extends Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 467
score: 98.66110229492188
patch: ++ iter ; ++ * * ++ iter ;
rank: 467
score: 98.57363455636161
patch: ++ iter ; ; / ;
rank: 467
score: 98.53854806082589
patch: else { ++ iterator ; }
rank: 467
score: 98.5211181640625
patch: ++ iter ; if ( iter == null ) continue ;
rank: 468
score: 99.07246907552083
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current CaMeL Point ,
rank: 468
score: 99.01425010279605
patch: checker = weight CaMeL Matrix CaMeL Sqrt . operate . operate ( current CaMeL Residuals ) ; }
rank: 468
score: 98.97623697916667
patch: qtf ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ,
rank: 468
score: 98.94434204101563
patch: list = get CaMeL Weight CaMeL Square CaMeL Root ( current CaMeL Point , current CaMeL Objective ) ;
rank: 468
score: 98.83013916015625
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter ;
rank: 468
score: 98.66074044363839
patch: int iter : ++ iter ;
rank: 468
score: 98.57362670898438
patch: ++ iter ; ++ iter ; } / ;
rank: 468
score: 98.53849283854167
patch: if ( ! 0 . is CaMeL Empty ( ) ; return iter ;
rank: 468
score: 98.52081298828125
patch: ++ iter ; while ( iter ++ ;
rank: 469
score: 99.07228597005208
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > current CaMeL Objective = current ;
rank: 469
score: 99.06232010690789
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = current CaMeL Residuals [ qtf ] ;
rank: 469
score: 99.01417943050987
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ; } }
rank: 469
score: 98.9439208984375
patch: protected Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > do CaMeL Optimize ( ) {
rank: 469
score: 98.82925618489584
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair current = ;
rank: 469
score: 98.57319471571181
patch: ++ iter ; iter * - 1 ;
rank: 469
score: 98.53846571180556
patch: if ( iter == null ; return ;
rank: 469
score: 98.52053598257211
patch: ++ iter ; while ( Arrays . is CaMeL Empty ; )
rank: 470
score: 99.07202826605902
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair first CaMeL Iteration = current ;
rank: 470
score: 99.06220703125
patch: i = final Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 470
score: 99.01407877604167
patch: while ( iter < get CaMeL Weight CaMeL Square CaMeL Root ( ) )
rank: 470
score: 98.94383544921875
patch: prev = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 470
score: 98.8291748046875
patch: ++ iter ; break ; } ++ iter ;
rank: 470
score: 98.6602450284091
patch: ++ iter ; ++ - 1 ; ++ iter ;
rank: 470
score: 98.5731201171875
patch: ++ iter ; ++ ; if iter ;
rank: 470
score: 98.53799874441964
patch: / * ++ * * /
rank: 470
score: 98.5188876065341
patch: if ( this . iter == null ) break ;
rank: 471
score: 99.0716552734375
patch: double [ ] current CaMeL Objective = compute CaMeL Residuals ( current CaMeL Objective ) ;
rank: 471
score: 99.06214488636364
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair ] ;
rank: 471
score: 99.01372528076172
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair for = current ;
rank: 471
score: 98.9751220703125
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker [
rank: 471
score: 98.94365098741319
patch: tmp = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , iter ) ;
rank: 471
score: 98.82842610677083
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , this ) ;
rank: 471
score: 98.66021118164062
patch: ++ iter ; try ; } ++ iter ;
rank: 471
score: 98.57270812988281
patch: if ++ iter ; ++ 1 ;
rank: 471
score: 98.53682454427083
patch: if ( ! 0 . is CaMeL Empty ( ) ) . add ;
rank: 471
score: 98.51873224431819
patch: ++ iter - 1 ; ++ iter - 1 ;
rank: 472
score: 99.01365902549342
patch: checker = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Objective ,
rank: 472
score: 98.9432861328125
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point . current CaMeL Objective ) ;
rank: 472
score: 98.66011555989583
patch: ++ iter ; else iter ; * /
rank: 472
score: 98.572021484375
patch: ++ iter ; iter ; / / ;
rank: 472
score: 98.53641764322917
patch: if ( < 0 ) return null ;
rank: 472
score: 98.5185879794034
patch: ++ iter ; ++ n CaMeL C ; break ;
rank: 473
score: 99.06144205729167
patch: ++ iter ; final Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = get ;
rank: 473
score: 99.01335144042969
patch: int iter = get CaMeL Weight CaMeL Square CaMeL Root ( current CaMeL Point ,
rank: 473
score: 98.9427734375
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , 1 ) ;
rank: 473
score: 98.82747395833333
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , ++ ) ;
rank: 473
score: 98.65981716579861
patch: ++ iter ; int iter ; iter ;
rank: 473
score: 98.53553118024554
patch: if ( . is CaMeL Empty ( ; ) ) return iter ;
rank: 473
score: 98.51732381184895
patch: ++ iter 1 [ n CaMeL R ] ; break ;
rank: 474
score: 99.07057787024456
patch: return weighted CaMeL Jacobian = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 474
score: 99.06117942116477
patch: qr CaMeL Decomposition = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Point ) ;
rank: 474
score: 99.01319715711806
patch: if ( checker . get CaMeL Weight CaMeL Square CaMeL Root ( ) == 0 ) {
rank: 474
score: 98.97222900390625
patch: if ( current CaMeL Point . length != n CaMeL R ) {
rank: 474
score: 98.94270629882813
patch: size = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ;
rank: 474
score: 98.6595947265625
patch: if iter ; ++ iter ; ++ iter ;
rank: 474
score: 98.57161712646484
patch: ++ 1 ; ++ iter ; else
rank: 474
score: 98.53485785590277
patch: try { ++ iter ; } finally {
rank: 474
score: 98.51666259765625
patch: ++ iter 1 [ 0 ] ; }
rank: 475
score: 99.07054379111842
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair = current CaMeL Point [ current CaMeL Point ] ;
rank: 475
score: 99.06093186598558
patch: ++ iter * checker . operate ( current CaMeL Residuals ) ;
rank: 475
score: 99.01274762834821
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair final ;
rank: 475
score: 98.97185809795673
patch: double [ ] current CaMeL Objective = current CaMeL Objective ) ;
rank: 475
score: 98.94269670758929
patch: return ( Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Objective ) ) ;
rank: 475
score: 98.82711356026786
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , current ;
rank: 475
score: 98.65874565972223
patch: ++ iter ; ++ / * iter ;
rank: 475
score: 98.57057883522727
patch: ++ iter ; ++ iter ; ; = iter ;
rank: 475
score: 98.53481038411458
patch: else { / * ++ iter ; }
rank: 475
score: 98.5164794921875
patch: synchronized ( this ) { ++ iter ;
rank: 476
score: 99.0695270040761
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = new Point CaMeL Vector CaMeL Value CaMeL Pair ( this ) ;
rank: 476
score: 99.06083848741319
patch: ++ iter ; Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker =
rank: 476
score: 99.01178656684027
patch: while ( true ) { final Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 476
score: 98.97058919270833
patch: check CaMeL Parameters ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 476
score: 98.94247436523438
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , length ) ;
rank: 476
score: 98.82666887555804
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , false ;
rank: 476
score: 98.65848795572917
patch: ++ iter ; if iter ; 0 ;
rank: 476
score: 98.57057020399306
patch: ++ iter ; iter * ; / /
rank: 476
score: 98.5343729654948
patch: else { ++ out ;
rank: 476
score: 98.51579454210069
patch: if ( ++ iter != 0 ) {
rank: 477
score: 99.06939019097223
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current CaMeL Point [ ) ;
rank: 477
score: 98.96979631696429
patch: if ( current CaMeL Residuals . length < n CaMeL R ) {
rank: 477
score: 98.9423828125
patch: state = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , 0 ) ;
rank: 477
score: 98.82603236607143
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair ( current
rank: 477
score: 98.65831502278645
patch: this . ++ iter ; ++ iter ; while iter ;
rank: 477
score: 98.57050115411931
patch: ++ iter ; ++ iter ; ; throw iter ;
rank: 477
score: 98.53432053786058
patch: throw new Runtime CaMeL Exception ( $STRING$ + 0 , null ;
rank: 478
score: 98.96970040457589
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair * /
rank: 478
score: 98.94204872532895
patch: long current CaMeL Cost = get CaMeL Weight CaMeL Square CaMeL Root ( current CaMeL Point ) ;
rank: 478
score: 98.825244140625
patch: inst = new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , ;
rank: 478
score: 98.65719943576389
patch: ++ iter ; int iter * out ;
rank: 478
score: 98.5702792080966
patch: ++ iter ; ++ iter ; if iter ; }
rank: 478
score: 98.53428819444444
patch: ++ iter ; while ++ iter iter ;
rank: 478
score: 98.51453857421875
patch: ++ iter ; if ( is CaMeL Empty )
rank: 479
score: 99.06889011548913
patch: Point CaMeL Vector CaMeL Value CaMeL Pair current = current ; Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 479
score: 99.06023615056819
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair * ;
rank: 479
score: 99.01100667317708
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair double CaMeL Value = current ;
rank: 479
score: 98.9691162109375
patch: int compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 479
score: 98.94189453125
patch: protected Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > current = current ;
rank: 479
score: 98.82509765625
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , ; new ;
rank: 479
score: 98.56981312144886
patch: ++ iter ; ++ ++ iter ; else iter ;
rank: 479
score: 98.53399047851562
patch: try { ++ iter ; } catch ; }
rank: 479
score: 98.514501953125
patch: ++ iter ; if ( iter >= 0 )
rank: 480
score: 99.05960518973214
patch: Convergence CaMeL Checker ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals , current CaMeL Residuals ) ) ;
rank: 480
score: 98.96817016601562
patch: if ( n CaMeL R < n CaMeL R ) {
rank: 480
score: 98.94180297851562
patch: tmp = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Point ) ;
rank: 480
score: 98.82418387276786
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ++ ;
rank: 480
score: 98.65680803571429
patch: / ; ++ ++ iter ;
rank: 480
score: 98.56807861328124
patch: ++ iter ; ++ iter ; catch iter ;
rank: 480
score: 98.53373209635417
patch: ++ ++ iter ; }
rank: 480
score: 98.5135830965909
patch: if ( ! iter . equals ( iter ) ;
rank: 481
score: 99.05947730654762
patch: Point CaMeL Vector CaMeL Value CaMeL Pair current = new Point CaMeL Vector CaMeL Value CaMeL Pair ( ) ;
rank: 481
score: 99.01058959960938
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Objective ) ,
rank: 481
score: 98.9417724609375
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , true ) ;
rank: 481
score: 98.82410481770833
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , iter ; ;
rank: 481
score: 98.65625678168402
patch: int iter ; / * ++ iter ;
rank: 481
score: 98.56783718532986
patch: else ; ++ iter ; ++ iter ;
rank: 481
score: 98.53367919921875
patch: / * ++ * * / ++ iter ;
rank: 481
score: 98.51197398792614
patch: if ( ! iter [ 0 ] . equals ;
rank: 482
score: 99.05911690848214
patch: iter = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ;
rank: 482
score: 98.966796875
patch: int qtf = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 482
score: 98.94114087975544
patch: Iterator < Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > iter = checker ;
rank: 482
score: 98.65518527560764
patch: ++ iter ; int * - iter ;
rank: 482
score: 98.56707763671875
patch: ++ iter ; iter = iter ; }
rank: 482
score: 98.53361002604167
patch: if ( ! iter ; ++ iter ;
rank: 482
score: 98.51195417131696
patch: if ( iter != 0 )
rank: 483
score: 99.06826602711396
patch: int iter = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Objective ) ;
rank: 483
score: 99.01038360595703
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair ( checker ) ;
rank: 483
score: 98.96676432291666
patch: int CaMeL Value = Point CaMeL Vector CaMeL Value CaMeL Pair [ ] ;
rank: 483
score: 98.94085083007812
patch: [ ] current CaMeL Cost = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 483
score: 98.65495954241071
patch: ++ iter ; += iter ;
rank: 483
score: 98.56637137276786
patch: ++ length ; ++ iter ;
rank: 483
score: 98.5333984375
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + 0 ) ; }
rank: 483
score: 98.51194069602273
patch: ++ iter ; if ( ! iter . contains ;
rank: 484
score: 99.05885943244485
patch: ++ qr CaMeL Decomposition = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ;
rank: 484
score: 99.01031494140625
patch: weighted CaMeL Jacobian ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ; }
rank: 484
score: 98.96664428710938
patch: boolean first CaMeL Iteration = 0 ;
rank: 484
score: 98.94082496279762
patch: list = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Objective ) ;
rank: 484
score: 98.65441284179687
patch: ++ iter ; ++ iter ; return false ;
rank: 484
score: 98.53298715444711
patch: if ( ! 0 . is CaMeL Empty ( iter ) ;
rank: 484
score: 98.51173400878906
patch: ++ iter ; if ( true ;
rank: 485
score: 99.06784057617188
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = ( Point CaMeL Vector CaMeL Value CaMeL Pair > ) this ;
rank: 485
score: 99.0587491122159
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair / ;
rank: 485
score: 99.01023512620192
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair add = current ;
rank: 485
score: 98.9649658203125
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair 1 = current CaMeL Point ;
rank: 485
score: 98.9407626065341
patch: x CaMeL Norm += weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , n CaMeL R ) ;
rank: 485
score: 98.82074381510417
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ iter ;
rank: 485
score: 98.65426296657986
patch: ++ * - iter ; ++ iter ;
rank: 485
score: 98.56603325737848
patch: / ; ++ iter ; ++ 1 ;
rank: 485
score: 98.53293678977273
patch: if ( iter > 1 ; return iter ; }
rank: 485
score: 98.51122107872597
patch: ++ iter ; if ( n CaMeL C > 0 ) {
rank: 486
score: 99.06771187160327
patch: weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective , ) ;
rank: 486
score: 99.05862587376645
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = checker . get ;
rank: 486
score: 98.96422526041667
patch: int iter = current CaMeL Objective . operate ( current CaMeL Residuals ) ;
rank: 486
score: 98.94069417317708
patch: res = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , 0 ) ;
rank: 486
score: 98.82015555245536
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair . ;
rank: 486
score: 98.5657071200284
patch: ++ iter ; ++ iter ; return ++ iter ;
rank: 486
score: 98.5326416015625
patch: if ( ! 0 . is CaMeL Empty ( this . iter ) ;
rank: 486
score: 98.51106770833333
patch: if ( ! is CaMeL Empty ) { ++ iter ;
rank: 487
score: 99.06704711914062
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = current ; Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 487
score: 99.05816359747024
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = current . compute CaMeL Weighted CaMeL Jacobian ( current ;
rank: 487
score: 99.00987897600446
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair { {
rank: 487
score: 98.96412760416666
patch: Point CaMeL Vector CaMeL Value CaMeL Pair checker = current CaMeL Point ) ;
rank: 487
score: 98.940673828125
patch: n CaMeL R = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Point ) ;
rank: 487
score: 98.8201016512784
patch: ++ iter * / * * / ++ iter ;
rank: 487
score: 98.65358479817708
patch: int iter + iter ; int iter ;
rank: 487
score: 98.56528727213542
patch: ++ iter ; iter * ; * /
rank: 487
score: 98.51094818115234
patch: ++ iter )
rank: 488
score: 99.06686268682066
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = < Point CaMeL Vector CaMeL Value CaMeL Pair > ) current ;
rank: 488
score: 99.0094223022461
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair int = current ;
rank: 488
score: 98.94004313151042
patch: result = compute CaMeL Residuals ( current CaMeL Point ) ;
rank: 488
score: 98.82009652944711
patch: ++ iter ; this . ++ iter ; this . ++ ;
rank: 488
score: 98.65254516601563
patch: ++ iter ; else { ++ iter ; ;
rank: 488
score: 98.5651522549716
patch: ++ iter ; ++ new ++ ; ++ iter ;
rank: 488
score: 98.53220621744792
patch: throw new Runtime CaMeL Exception ( $STRING$ + $NUMBER$ ) ;
rank: 488
score: 98.51085408528645
patch: ++ iter ; System . exit ( 0 ) ; }
rank: 489
score: 99.00916812294408
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair ++ ;
rank: 489
score: 98.960986328125
patch: int [ ] current CaMeL Objective = current CaMeL Point [ iter ] ;
rank: 489
score: 98.93973581414474
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , 0 ) ; }
rank: 489
score: 98.65242919921874
patch: ++ name ; ++ iter ; ++ iter ;
rank: 489
score: 98.56484153053977
patch: ++ iter ; iter ; / / ++ iter ;
rank: 489
score: 98.53217230902777
patch: Iterator iter = iter . iterator ++ ;
rank: 489
score: 98.50856018066406
patch: if ; while ( true ) {
rank: 490
score: 99.06546823601974
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair > current CaMeL Objective = current ;
rank: 490
score: 99.05769856770833
patch: iter = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Residuals ) ;
rank: 490
score: 98.960546875
patch: int iter = solved CaMeL Cols . operate ( current CaMeL Point ) ;
rank: 490
score: 98.93965229235198
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Cost ) ;
rank: 490
score: 98.81983642578125
patch: ++ iter ; * / * ++ iter ;
rank: 490
score: 98.65232543945312
patch: / * ++ iter ; / / / ;
rank: 490
score: 98.56483043323864
patch: ++ iter ; ++ iter ; ++ ++ 1 ;
rank: 490
score: 98.53209635416667
patch: throw new Runtime CaMeL Exception ( $STRING$ , this . get CaMeL Message ;
rank: 490
score: 98.50847919170673
patch: ++ iter ; if ( Arrays . as CaMeL List ( ;
rank: 491
score: 99.05763596754808
patch: ++ compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 491
score: 99.00713790090461
patch: ++ ( ( Point CaMeL Vector CaMeL Value CaMeL Pair ) checker ) . weighted CaMeL Residual ;
rank: 491
score: 98.96050618489583
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > current ;
rank: 491
score: 98.93946422230114
patch: Iterator Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > current = current ;
rank: 491
score: 98.81943359375
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter , false ) ;
rank: 491
score: 98.65069025213069
patch: ++ iter ; ++ iter ; start - iter ;
rank: 491
score: 98.56368679470486
patch: ++ iter ; ; ++ iter ; /
rank: 491
score: 98.53200954861111
patch: else { if ++ * ++ iter ;
rank: 491
score: 98.50832297585227
patch: ++ iter 1 [ n CaMeL R ] ; }
rank: 492
score: 99.00704193115234
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair else = current ;
rank: 492
score: 98.95995279947917
patch: x CaMeL Norm = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 492
score: 98.9392578125
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( weighted CaMeL Residual ) ;
rank: 492
score: 98.81885528564453
patch: ++ iter ; / * * ;
rank: 492
score: 98.65061442057292
patch: ++ iter ; if iter + 0 ;
rank: 492
score: 98.56334228515625
patch: ++ Math ; ++ iter ; ++ iter ;
rank: 492
score: 98.53181287977431
patch: else { ++ * iter * iter /
rank: 492
score: 98.50818481445313
patch: ++ iter ; while ( iter == 1 )
rank: 493
score: 99.06506878396739
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = new Point CaMeL Vector CaMeL Value CaMeL Pair ( ) ;
rank: 493
score: 98.95948079427083
patch: int iter = Convergence CaMeL Checker . operate ( current CaMeL Residuals ) ;
rank: 493
score: 98.93919836956522
patch: this . weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ; ++ iter ;
rank: 493
score: 98.81867327008929
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current ;
rank: 493
score: 98.65055338541667
patch: ++ iter ; int iter ; try ;
rank: 493
score: 98.56305609809027
patch: ++ iter ; ++ iter ; = iter
rank: 493
score: 98.53142755681819
patch: throw new Runtime CaMeL Exception ( $STRING$ + start ;
rank: 493
score: 98.50796847873264
patch: ++ iter 1 ; ++ iter 1 ;
rank: 494
score: 99.06461588541667
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Point ,
rank: 494
score: 99.05702209472656
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair stream = current ;
rank: 494
score: 98.95933314732143
patch: int name = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 494
score: 98.938720703125
patch: { final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > current = current ;
rank: 494
score: 98.81853841145833
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ ) ; }
rank: 494
score: 98.6504618326823
patch: super . ++ iter ; ++ iter ; ++ iter ;
rank: 494
score: 98.56282182173295
patch: ++ iter ; ; ++ 0 ; ++ iter ;
rank: 494
score: 98.53101399739583
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + 1 + $STRING$ ;
rank: 494
score: 98.50762261284723
patch: if ( iter != - 1 ) {
rank: 495
score: 99.06456647600446
patch: else final Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 495
score: 99.05670166015625
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Residuals ) ;
rank: 495
score: 99.00637582632211
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair arraycopy = current ;
rank: 495
score: 98.95858561197916
patch: boolean first CaMeL Iteration = current CaMeL Point [ n CaMeL C ] ;
rank: 495
score: 98.93861897786458
patch: n CaMeL C < Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ;
rank: 495
score: 98.81641981336806
patch: ++ iter ; / * * * ;
rank: 495
score: 98.65045166015625
patch: / * / ++ iter ;
rank: 495
score: 98.56262817382813
patch: ++ iter ; iter / * = iter ;
rank: 495
score: 98.53099476207386
patch: throw new Runtime CaMeL Exception ( $STRING$ , $STRING$ ;
rank: 495
score: 98.50613403320312
patch: ++ iter ; while ( iter == null )
rank: 496
score: 99.06443189538044
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = new Point CaMeL Vector CaMeL Value CaMeL Pair ( $NUMBER$ ) ;
rank: 496
score: 99.00569661458333
patch: ( ( Point CaMeL Vector CaMeL Value CaMeL Pair ) checker ) . weighted CaMeL Residual (
rank: 496
score: 98.95817057291667
patch: String qr CaMeL Decomposition ( current CaMeL Point , current CaMeL Objective ) ;
rank: 496
score: 98.93831961495536
patch: current CaMeL Cost = compute CaMeL Cost ( current CaMeL Point ) ;
rank: 496
score: 98.65013292100694
patch: ++ iter ; / / * ; /
rank: 496
score: 98.562255859375
patch: iter ; ++ iter ; if ++ ;
rank: 496
score: 98.53097534179688
patch: ++ iter ; * * * ++ iter ;
rank: 496
score: 98.5056903545673
patch: if ( ! iter . compare CaMeL To ( current ) ;
rank: 497
score: 99.0560635653409
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair final = new Point CaMeL Vector CaMeL Value CaMeL Pair ( ) ;
rank: 497
score: 99.00504343133224
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = get CaMeL Weight CaMeL Square CaMeL Root (
rank: 497
score: 98.9573974609375
patch: / * final Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 497
score: 98.93831380208333
patch: current = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Objective ) ;
rank: 497
score: 98.64896647135417
patch: / * ] iter = ++ iter ;
rank: 497
score: 98.56203391335227
patch: ++ iter ; ; ++ iter ; return iter ;
rank: 497
score: 98.53062133789062
patch: ++ iter ; if ++ iter >= iter ;
rank: 497
score: 98.5048828125
patch: ++ iter 1 [ n CaMeL C ] ; break ; }
rank: 498
score: 99.06400730298913
patch: Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current CaMeL Point ,
rank: 498
score: 99.05594308035714
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = compute CaMeL Weighted CaMeL Jacobian (
rank: 498
score: 99.0047607421875
patch: qr CaMeL Decomposition = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Objective ) ; }
rank: 498
score: 98.95705740792411
patch: double [ ] compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 498
score: 98.93812144886364
patch: Iterator < Point CaMeL Vector CaMeL Value CaMeL Pair , Point CaMeL Vector CaMeL Value CaMeL Pair ( checker ) ;
rank: 498
score: 98.81566510881696
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ ++ iter ;
rank: 498
score: 98.64845784505208
patch: ++ iter ; ++ - iter ; ;
rank: 498
score: 98.56197509765624
patch: ++ 1 ; ++ iter ; -- iter ;
rank: 498
score: 98.53042166573661
patch: ++ [ ] iter ++ ;
rank: 498
score: 98.504638671875
patch: Collections . sort ( iter ) ;
rank: 499
score: 99.06384995404412
patch: Iterator iter = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ;
rank: 499
score: 99.05546061197917
patch: it = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Point ) ;
rank: 499
score: 99.0043194110577
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair in = current ;
rank: 499
score: 98.95683070591518
patch: boolean first CaMeL Iteration = compute CaMeL Weighted CaMeL Jacobian ( current ;
rank: 499
score: 98.93799889605978
patch: this . weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ; ++ iter ;
rank: 499
score: 98.81549944196429
patch: ++ iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ; ;
rank: 499
score: 98.64761962890626
patch: / * ; ++ iter ; ++ iter ;
rank: 499
score: 98.56189643012152
patch: iter ; ++ iter ; for ++ ;
rank: 499
score: 98.5041732788086
patch: while ( true ) { try {
rank: 500
score: 99.05531221277573
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Residuals ) ;
rank: 500
score: 99.00398763020833
patch: checker = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ,
rank: 500
score: 98.9567401592548
patch: int [ ] current CaMeL Objective = current CaMeL Residuals ) ;
rank: 500
score: 98.93740844726562
patch: tmp = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , n CaMeL R ) ;
rank: 500
score: 98.81453080610795
patch: ++ iter ; if ( iter < iter ) {
rank: 500
score: 98.64714898003473
patch: ++ iter ; ; * * / /
rank: 500
score: 98.56163441051136
patch: ++ iter ; ++ if iter ; ++ iter ;
rank: 500
score: 98.5299405184659
patch: else { ++ iter ; } } ++ iter ;
rank: 500
score: 98.50392659505208
patch: ++ iter ; while ( ! is CaMeL Empty ) {
rank: 501
score: 99.06306726792279
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = true ;
rank: 501
score: 99.00355440027573
patch: checker = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Objective ) ; }
rank: 501
score: 98.93739149305556
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , 1 ) ;
rank: 501
score: 98.64666193181819
patch: ++ iter ; ++ iter ; out . iter ;
rank: 501
score: 98.5609130859375
patch: ++ iter ; ; iter / ; /
rank: 501
score: 98.5299072265625
patch: / * * * / /
rank: 501
score: 98.50391303168402
patch: ++ iter ; ++ iter - iter ;
rank: 502
score: 99.06296705163044
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = ( Point CaMeL Vector CaMeL Value CaMeL Pair > ) 0 ;
rank: 502
score: 99.00340270996094
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair compare = current ;
rank: 502
score: 98.95541616586539
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair length = current ;
rank: 502
score: 98.93739149305556
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point . length ) ; }
rank: 502
score: 98.81353759765625
patch: ++ iter ] = iter ;
rank: 502
score: 98.52974155970982
patch: else { iter -- ; }
rank: 502
score: 98.50325833834134
patch: if ( ! is CaMeL Empty ( ) ) ++ iter ;
rank: 503
score: 99.06283569335938
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = this . current ;
rank: 503
score: 99.05477142333984
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair current = get ;
rank: 503
score: 99.002685546875
patch: ++ iter ; Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair
rank: 503
score: 98.95310280539773
patch: double qr CaMeL Decomposition ( current CaMeL Point ) ;
rank: 503
score: 98.93733354048295
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( get CaMeL Weight CaMeL Square CaMeL Root ( ) ) ;
rank: 503
score: 98.81127057756696
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = ++ iter ;
rank: 503
score: 98.646484375
patch: ++ iter ; / * ] iter ;
rank: 503
score: 98.5606356534091
patch: ++ iter ; ++ 1 ; } ++ iter ;
rank: 503
score: 98.52968052455357
patch: ++ * ++ * iter ;
rank: 503
score: 98.50260162353516
patch: try { ++ iter = iter ;
rank: 504
score: 99.06261268028847
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair break = current ;
rank: 504
score: 99.05438591452206
patch: e = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Residuals ) ;
rank: 504
score: 99.00247955322266
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair if = current ;
rank: 504
score: 98.95237513950893
patch: if ( current CaMeL Point . length != n CaMeL C ) {
rank: 504
score: 98.93732244318181
patch: n CaMeL C < Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Objective ) ;
rank: 504
score: 98.81123570033482
patch: ++ iter ; throw new Illegal CaMeL Argument CaMeL Exception ( ; }
rank: 504
score: 98.64640299479167
patch: / * ++ iter ; ++ * /
rank: 504
score: 98.56031494140625
patch: ++ iter ; ++ / ; ++ iter ;
rank: 504
score: 98.52877371651786
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ; } finally {
rank: 504
score: 98.50164794921875
patch: ++ iter ; if ( iter > 0 )
rank: 505
score: 99.0625861672794
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair = current CaMeL Point ,
rank: 505
score: 99.05428314208984
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair class = current ;
rank: 505
score: 99.00238396139706
patch: while ( ! weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) )
rank: 505
score: 98.9521993001302
patch: int CaMeL Value = current CaMeL Point [ iter ] ;
rank: 505
score: 98.9373028094952
patch: public Point CaMeL Vector CaMeL Value CaMeL Pair current = null ;
rank: 505
score: 98.81018829345703
patch: ++ iter ; ++ iter * ;
rank: 505
score: 98.64599609375
patch: / * ++ ++ iter ; * /
rank: 505
score: 98.5590576171875
patch: ++ iter ; ++ iter ; notify ++ ;
rank: 505
score: 98.52806507457386
patch: if ( iter == null ; return ++ iter ;
rank: 505
score: 98.50162760416667
patch: ++ iter ; if ( ! is CaMeL Empty ( ;
rank: 506
score: 99.06227329799107
patch: Point CaMeL Vector CaMeL Value CaMeL Pair current = current ; / /
rank: 506
score: 99.00224034926471
patch: ++ iter ; final Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair >
rank: 506
score: 98.95210774739583
patch: boolean first CaMeL Iteration = current CaMeL Point [ current CaMeL Point ] ;
rank: 506
score: 98.93680245535714
patch: current CaMeL Cost = compute CaMeL Cost ( current CaMeL Residuals ) ;
rank: 506
score: 98.80956420898437
patch: ++ iter ; ++ iter * / * /
rank: 506
score: 98.64573974609375
patch: ++ iter ; ++ * * - iter ;
rank: 506
score: 98.55878240411931
patch: ++ iter ; ; ++ iter ; ++ / /
rank: 506
score: 98.52788837139423
patch: throw new Runtime CaMeL Exception ( $STRING$ , this . iter ;
rank: 506
score: 98.50161743164062
patch: throw new Runtime CaMeL Exception ( $STRING$ + iter ) ;
rank: 507
score: 99.0620647927989
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = new Point CaMeL Vector CaMeL Value CaMeL Pair / current ;
rank: 507
score: 99.05399946732955
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = new Point CaMeL Vector CaMeL Value CaMeL Pair ( ) ;
rank: 507
score: 99.00154331752232
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair * ;
rank: 507
score: 98.9367919921875
patch: tmp = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Objective ) ;
rank: 507
score: 98.64553493923611
patch: ++ iter ; while ; int iter ;
rank: 507
score: 98.55868094308036
patch: iter ; ++ iter ; ;
rank: 507
score: 98.52773611886161
patch: if ( . is CaMeL Empty ( ) ) ; ++ iter ;
rank: 507
score: 98.50160910866477
patch: if ( ! index CaMeL Of ( current ) ;
rank: 508
score: 99.06112007472827
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair ++ ; final Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 508
score: 99.0537341889881
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair qtf = current CaMeL Point [ current CaMeL Objective ] ;
rank: 508
score: 99.00141143798828
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair < qtf ;
rank: 508
score: 98.95106724330357
patch: if ( compute CaMeL Weighted CaMeL Jacobian [ current CaMeL Point ) {
rank: 508
score: 98.9365593405331
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Cost , 0 ) ;
rank: 508
score: 98.80451311383929
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current , ++ ;
rank: 508
score: 98.64523654513889
patch: ++ iter ; ++ iter ; $NUMBER$ ;
rank: 508
score: 98.55832926432292
patch: ++ iter ; iter / = iter ;
rank: 508
score: 98.52743869357639
patch: if ( iter == null ) return ;
rank: 508
score: 98.50140380859375
patch: ++ iter ; while ( iter >= 0 )
rank: 509
score: 99.06104454627403
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = false ;
rank: 509
score: 99.05343627929688
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair package = current ;
rank: 509
score: 99.00127852590461
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , n CaMeL C ,
rank: 509
score: 98.95061786358173
patch: int CaMeL Value = Point CaMeL Vector CaMeL Value CaMeL Pair ;
rank: 509
score: 98.93637917258523
patch: x CaMeL Norm = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Residuals ) ;
rank: 509
score: 98.64515991210938
patch: ++ iter ; iter ; * * * /
rank: 509
score: 98.55780584161931
patch: ++ iter ; ++ iter ; / throw iter ;
rank: 509
score: 98.52730887276786
patch: ++ * 0 * iter ;
rank: 509
score: 98.50135633680556
patch: ++ iter ; synchronized ( this ) {
rank: 510
score: 99.05226135253906
patch: final qtf = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 510
score: 98.95038396661931
patch: int iter = current CaMeL Point [ iter ] ;
rank: 510
score: 98.93620954241071
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ,
rank: 510
score: 98.80399867466518
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( ) ;
rank: 510
score: 98.64508056640625
patch: ++ iter ; while iter ; break ;
rank: 510
score: 98.5574618252841
patch: ++ iter ; ++ start ; } ++ iter ;
rank: 510
score: 98.52637532552083
patch: throw new Runtime CaMeL Exception ( $STRING$ + this . get CaMeL Message ;
rank: 510
score: 98.50121307373047
patch: if ( true ) ++ iter ;
rank: 511
score: 99.05218864889706
patch: t = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ;
rank: 511
score: 98.99972534179688
patch: if ( checker . compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) )
rank: 511
score: 98.95003255208333
patch: int iter = current CaMeL Residuals . operate ( current CaMeL Point ) ;
rank: 511
score: 98.93605638586956
patch: if ( weight CaMeL Matrix CaMeL Sqrt . weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Objective ) ) {
rank: 511
score: 98.80367606026786
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( ; }
rank: 511
score: 98.64458673650569
patch: this . iter ; ++ iter ; int iter ;
rank: 511
score: 98.5570068359375
patch: ++ iter ; ; ++ max ; ++ iter ;
rank: 511
score: 98.52633666992188
patch: / * * ++ * / ++ iter ;
rank: 511
score: 98.50099690755208
patch: final int iter = n CaMeL C ;
rank: 512
score: 99.06061150045956
patch: double iter = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 512
score: 99.05171034071181
patch: else qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ) ;
rank: 512
score: 98.94927978515625
patch: / / Point CaMeL Vector CaMeL Value CaMeL Pair checker = current ;
rank: 512
score: 98.93597412109375
patch: found = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , n CaMeL R ) ;
rank: 512
score: 98.80149623325893
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ 1 ;
rank: 512
score: 98.64456515842014
patch: ++ iter ; ++ value ; iter ;
rank: 512
score: 98.55647416548295
patch: / ; ++ iter ; ++ iter ; ++ ;
rank: 512
score: 98.52632649739583
patch: else { / * ++ ++ iter ;
rank: 512
score: 98.50093900240384
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( iter )
rank: 513
score: 99.06021781589673
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = ( Point CaMeL Vector CaMeL Value CaMeL Pair > ) null ;
rank: 513
score: 99.05160701976104
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair > ( current CaMeL Residuals ) ;
rank: 513
score: 98.99900907628677
patch: iter = final Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Residuals ) ;
rank: 513
score: 98.94896647135417
patch: int CaMeL Value = ( Point CaMeL Vector CaMeL Value CaMeL Pair > )
rank: 513
score: 98.9359489889706
patch: retval = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ; }
rank: 513
score: 98.79634399414063
patch: ++ iter ; ; this . ++ iter ;
rank: 513
score: 98.64434136284723
patch: / * ] iter ; ++ * /
rank: 513
score: 98.55621337890625
patch: ++ iter ; ++ iter ; = 1 ;
rank: 513
score: 98.52627563476562
patch: else { ++ iter ; } / * /
rank: 513
score: 98.50022583007812
patch: ++ iter ; if ( is CaMeL Empty ;
rank: 514
score: 99.06019502527573
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current CaMeL Point ) ;
rank: 514
score: 99.05154579564145
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = current CaMeL Point [ qtf ] ;
rank: 514
score: 98.99894205729167
patch: iter = current CaMeL Point [ n CaMeL C ] ;
rank: 514
score: 98.9482421875
patch: Map < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = this ;
rank: 514
score: 98.79354858398438
patch: ++ iter ; if ( iter < iter ) break ;
rank: 514
score: 98.64425659179688
patch: / * ++ iter ; / int iter ;
rank: 514
score: 98.5261474609375
patch: if ( iter == iter ; ++ iter ;
rank: 515
score: 99.05999755859375
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > current CaMeL Objective = current CaMeL Point ;
rank: 515
score: 99.0513916015625
patch: qtf = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , n CaMeL C ) ;
rank: 515
score: 98.99888392857143
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair name ;
rank: 515
score: 98.94815063476562
patch: if ( current CaMeL Objective == n CaMeL C ) {
rank: 515
score: 98.93577938988095
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) . do CaMeL Optimize ( ) ;
rank: 515
score: 98.64417860243056
patch: ++ iter ; iter ; String iter ;
rank: 515
score: 98.55564575195312
patch: ++ iter ; ++ iter ; else start ;
rank: 515
score: 98.52586263020834
patch: throw new Runtime CaMeL Exception ( $STRING$ + this . iter . length ;
rank: 515
score: 98.4997787475586
patch: ++ iter 1 = iter 1 ;
rank: 516
score: 99.05999755859375
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ,
rank: 516
score: 99.05134133731617
patch: result = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Residuals ) ;
rank: 516
score: 98.99852797564338
patch: try { qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 516
score: 98.94775390625
patch: double first CaMeL Iteration = current CaMeL Point [ iter ] ;
rank: 516
score: 98.93564675071023
patch: x CaMeL Norm = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , n CaMeL C ) ;
rank: 516
score: 98.79151500355114
patch: ++ iter ; * / * ++ iter * /
rank: 516
score: 98.64381103515625
patch: int iter ; ++ iter ; while iter ;
rank: 516
score: 98.55557861328126
patch: ++ iter ; ++ iter ; ; iter ;
rank: 516
score: 98.49962439903847
patch: ++ iter ; if ( this . iter != null ) {
rank: 517
score: 99.05965169270833
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair list = current CaMeL Point ;
rank: 517
score: 99.05101667131696
patch: t = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 517
score: 98.99822998046875
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair split = current ;
rank: 517
score: 98.94756673177083
patch: boolean first CaMeL Iteration = this . current CaMeL Point [ iter ] ;
rank: 517
score: 98.93521457248264
patch: v = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point . length ) ;
rank: 517
score: 98.7889404296875
patch: ++ iter ; iter = iter . iterator ( ;
rank: 517
score: 98.64379204644098
patch: ++ iter ; ; ; if iter ;
rank: 517
score: 98.52518717447917
patch: if ( iter < iter ) return ;
rank: 517
score: 98.49942720853366
patch: if ( ! iter . is CaMeL Empty ( ) && ;
rank: 518
score: 99.05916341145833
patch: int qtf [ ] = current ;
rank: 518
score: 99.05050998263889
patch: i = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Point ) ;
rank: 518
score: 98.99766540527344
patch: Convergence CaMeL Checker ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ,
rank: 518
score: 98.94701276506696
patch: boolean first CaMeL Iteration = checker . operate ( current CaMeL Point ,
rank: 518
score: 98.93470458984375
patch: < Point CaMeL Vector CaMeL Value CaMeL Pair <= Point CaMeL Vector CaMeL Value CaMeL Pair > checker ;
rank: 518
score: 98.78803846571181
patch: ++ iter * / ; ++ iter ;
rank: 518
score: 98.64378138950893
patch: ++ iter ; -- iter ;
rank: 518
score: 98.55463201349431
patch: ++ iter ; ++ start ; ++ iter ; }
rank: 518
score: 98.52512613932292
patch: / * * * /
rank: 518
score: 98.49938286675348
patch: ++ iter ; ++ iter + 1 ;
rank: 519
score: 99.05029296875
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current CaMeL Residuals [ iter ] ;
rank: 519
score: 98.99747507195724
patch: ++ ( ( Point CaMeL Vector CaMeL Value CaMeL Pair ) checker ) . current CaMeL Residuals ;
rank: 519
score: 98.94667405348558
patch: double [ ] current CaMeL Objective ( current CaMeL Point ) ;
rank: 519
score: 98.93467494419643
patch: group = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 519
score: 98.78645833333333
patch: ++ iter ; while ( iter ; )
rank: 519
score: 98.64344482421875
patch: ++ iter ; int iter ; while iter ;
rank: 519
score: 98.554345703125
patch: ++ iter ; ++ iter ; iter -- ;
rank: 519
score: 98.52396850585937
patch: if ( iter > 1 ; return null ;
rank: 519
score: 98.49874877929688
patch: ++ iter ; while ( ! ;
rank: 520
score: 99.05853271484375
patch: int [ ] current CaMeL Objective = weight CaMeL Matrix CaMeL Sqrt . length ;
rank: 520
score: 99.050048828125
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = new ;
rank: 520
score: 98.99742542613636
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair ++ ;
rank: 520
score: 98.93467203776042
patch: r = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , 0 ) ;
rank: 520
score: 98.78521728515625
patch: ++ iter - 1 ; ;
rank: 520
score: 98.64303588867188
patch: int iter = iter ;
rank: 520
score: 98.55408393012152
patch: ++ iter ; ++ -- iter ; ;
rank: 520
score: 98.52370981069711
patch: throw new Runtime CaMeL Exception ( $STRING$ + 1 ) ; }
rank: 520
score: 98.4982177734375
patch: if ( ! iter . is CaMeL Empty ;
rank: 521
score: 99.04998458059211
patch: ++ iter ; Point CaMeL Vector CaMeL Value CaMeL Pair current CaMeL Point = current CaMeL Point ;
rank: 521
score: 98.99697536892361
patch: weighted CaMeL Residual = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Residuals ,
rank: 521
score: 98.94480678013393
patch: double qr CaMeL Decomposition ( current CaMeL Point , current CaMeL Objective ,
rank: 521
score: 98.93452592329545
patch: this . weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , true ) ;
rank: 521
score: 98.78045654296875
patch: ++ iter ; if ( iter < iter )
rank: 521
score: 98.5537841796875
patch: ++ iter ; iter ; / -- iter ;
rank: 521
score: 98.52354736328125
patch: if ( iter == iter ; break ; }
rank: 521
score: 98.49558512369792
patch: ++ iter Math . max ( 0 , iter ) ;
rank: 522
score: 99.05811264935662
patch: double [ ] current CaMeL Objective = compute CaMeL Residuals ( current CaMeL Point ) ;
rank: 522
score: 98.99684544613487
patch: weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , ) ;
rank: 522
score: 98.944580078125
patch: if ( current CaMeL Objective . length < n CaMeL R ) {
rank: 522
score: 98.93447043678977
patch: n CaMeL C = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , n CaMeL C ) ;
rank: 522
score: 98.77992942116477
patch: throw new Illegal CaMeL Argument CaMeL Exception ( ; }
rank: 522
score: 98.64269002278645
patch: ++ iter ; / * * / / ++ iter ;
rank: 522
score: 98.55329047309027
patch: iter ; ++ iter ; while ++ ;
rank: 522
score: 98.52345377604166
patch: throw new Runtime CaMeL Exception ( $STRING$ + iter + $STRING$ + iter ;
rank: 522
score: 98.49512736002605
patch: if ( ! is CaMeL Empty ) { break ; }
rank: 523
score: 98.99671766493056
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ; {
rank: 523
score: 98.944140625
patch: try { final Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 523
score: 98.9344123391544
patch: res = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ; }
rank: 523
score: 98.64111328125
patch: ++ iter ; try ; ; ++ iter ;
rank: 523
score: 98.55278986150569
patch: ++ ++ iter ; ++ 1 ; ++ iter ;
rank: 523
score: 98.52340494791666
patch: throw new Runtime CaMeL Exception ( $STRING$ + this . to CaMeL String ;
rank: 523
score: 98.4950284090909
patch: if ( ! iter . equals ( current ) )
rank: 524
score: 99.05697866586539
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair int = current ;
rank: 524
score: 98.9966681985294
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Objective ) ;
rank: 524
score: 98.94399789663461
patch: String compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 524
score: 98.93436686197917
patch: this . weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( operate ) ;
rank: 524
score: 98.64080200195312
patch: ++ iter ; ++ iter ; ++ value ;
rank: 524
score: 98.55226828835227
patch: ++ -- iter ; ++ iter ; ++ iter ;
rank: 524
score: 98.52266068892045
patch: else { if ++ iter > 0 . length ;
rank: 524
score: 98.49485778808594
patch: int iter = iter + 1 ;
rank: 525
score: 99.05670166015625
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair ! checker = current ;
rank: 525
score: 98.99546595982143
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair start ;
rank: 525
score: 98.94346516927084
patch: double qr CaMeL Decomposition ( current CaMeL Point , current CaMeL Point ) ;
rank: 525
score: 98.9341796875
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point . 0 ) ;
rank: 525
score: 98.77690972222223
patch: ++ iter ; iter = iter . ;
rank: 525
score: 98.64079145951705
patch: ++ iter ; ++ iter ; ++ * 1 ;
rank: 525
score: 98.55199085582386
patch: ++ iter ; ; ++ iter ; ; / /
rank: 525
score: 98.52187875600961
patch: else { throw new Runtime CaMeL Exception ( $STRING$ ; ; }
rank: 525
score: 98.49485560825893
patch: while ( true ) { ;
rank: 526
score: 99.05647277832031
patch: ++ * final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current ;
rank: 526
score: 99.0483627319336
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair substring = current ;
rank: 526
score: 98.9953104654948
patch: iter = current CaMeL Point [ n CaMeL R ] ;
rank: 526
score: 98.93389601934524
patch: Iterator < Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > iter ;
rank: 526
score: 98.7767578125
patch: final ; ++ iter = iter . iter ;
rank: 526
score: 98.64058061079545
patch: ++ iter ; try ; int iter = iter ;
rank: 526
score: 98.55175103081598
patch: ++ iter ; ++ $STRING$ + iter ;
rank: 526
score: 98.52176920572917
patch: else { throw new Runtime CaMeL Exception ++ ; } }
rank: 526
score: 98.4948397549716
patch: if ( iter < n CaMeL C ) break ;
rank: 527
score: 98.99503784179687
patch: while ( true ) { Convergence CaMeL Checker ;
rank: 527
score: 98.9432861328125
patch: Iterator ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) .
rank: 527
score: 98.93330078125
patch: n CaMeL C < Point CaMeL Vector CaMeL Value CaMeL Pair > checker ;
rank: 527
score: 98.64034423828124
patch: ++ iter ; / * ; ++ iter ;
rank: 527
score: 98.55159135298295
patch: ++ iter ; ++ iter ; } iter ++ ;
rank: 527
score: 98.52168782552083
patch: if ( . is CaMeL Empty ( ; ) ; return iter ; }
rank: 527
score: 98.49456232244319
patch: ++ iter ; while ( iter >= 0 ) {
rank: 528
score: 99.0560302734375
patch: double [ ] current CaMeL Objective = current CaMeL Point ,
rank: 528
score: 99.04789225260417
patch: final Convergence CaMeL Checker ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ) ;
rank: 528
score: 98.99444580078125
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair arraycopy ;
rank: 528
score: 98.9429180438702
patch: double qr CaMeL Decomposition = current CaMeL Point [ iter ] ;
rank: 528
score: 98.93250450721153
patch: ? Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 528
score: 98.77340698242188
patch: ++ iter ; iter = iter . ; }
rank: 528
score: 98.64000854492187
patch: ++ iter ; ++ iter ; - 1 ;
rank: 528
score: 98.55031516335227
patch: ++ iter ; ; ++ iter ; else iter ;
rank: 528
score: 98.52165391710069
patch: } if ( iter > 0 ) {
rank: 528
score: 98.49387613932292
patch: if ( iter < 0 ) break ;
rank: 529
score: 99.05599814967105
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair $NUMBER$ ;
rank: 529
score: 99.04775103400735
patch: qtf = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ,
rank: 529
score: 98.99275476792279
patch: ++ iter ; final Convergence CaMeL Checker = weight CaMeL Matrix CaMeL Sqrt . operate (
rank: 529
score: 98.94242350260417
patch: if ( n CaMeL C != n CaMeL C ) {
rank: 529
score: 98.93225969587054
patch: < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current ;
rank: 529
score: 98.77309348366477
patch: ++ iter ; this . ++ iter = iter ;
rank: 529
score: 98.63955688476562
patch: ++ iter ; ++ iter ; out ; int iter ;
rank: 529
score: 98.55020751953126
patch: / ; ++ iter ; ++ ++ iter ;
rank: 529
score: 98.52134195963542
patch: else { ++ * * ++ iter ;
rank: 529
score: 98.4927090731534
patch: ++ iter ; while ( true ) { try {
rank: 530
score: 99.05594576322116
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair out = current ;
rank: 530
score: 98.99061802455357
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair min ;
rank: 530
score: 98.93212890625
patch: < Point CaMeL Vector CaMeL Value CaMeL Pair > weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 530
score: 98.6387939453125
patch: ++ iter ; ++ iter ; * * iter ;
rank: 530
score: 98.52077811104911
patch: if ( . is CaMeL Empty ( ; ) ; ++ iter ;
rank: 530
score: 98.49233669704861
patch: ++ iter ; System . out . ;
rank: 531
score: 98.98964146205357
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair for ;
rank: 531
score: 98.941796875
patch: int current CaMeL Objective = compute CaMeL Cost ( current CaMeL Point ) ;
rank: 531
score: 98.93211669921875
patch: < Point CaMeL Vector CaMeL Value CaMeL Pair , Point CaMeL Vector CaMeL Value CaMeL Pair > checker ;
rank: 531
score: 98.77142803485577
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = new ;
rank: 531
score: 98.63869803292411
patch: ++ iter ; else continue ;
rank: 531
score: 98.549755859375
patch: ++ iter ; ++ iter ; ++ name ;
rank: 531
score: 98.52074517144098
patch: else { / * * ++ iter /
rank: 531
score: 98.49230194091797
patch: if ( ! is CaMeL Empty ;
rank: 532
score: 99.04584099264706
patch: ++ iter = checker . compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 532
score: 98.9894775390625
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair < current ;
rank: 532
score: 98.9407470703125
patch: boolean first CaMeL Iteration = true ; boolean first CaMeL Iteration = true ;
rank: 532
score: 98.93206232244319
patch: private Point CaMeL Vector CaMeL Value CaMeL Pair ( Point CaMeL Vector CaMeL Value CaMeL Pair current CaMeL Cost ) {
rank: 532
score: 98.63651733398437
patch: ++ iter ; ++ * - iter ; ;
rank: 532
score: 98.54970092773438
patch: ++ super ; ++ iter ; ++ iter ;
rank: 532
score: 98.52056884765625
patch: else { if ( iter == null ;
rank: 532
score: 98.49195353190105
patch: final int iter = Arrays . as CaMeL List ( ;
rank: 533
score: 99.05478244357639
patch: ++ n CaMeL C ; final Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 533
score: 99.04566539417614
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair 0 ;
rank: 533
score: 98.98922025240384
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair min = current ;
rank: 533
score: 98.94044846754808
patch: int iter = compute CaMeL Cost ( current CaMeL Point ) ;
rank: 533
score: 98.93203125
patch: public Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > do CaMeL Optimize ( ) {
rank: 533
score: 98.77011108398438
patch: ++ iter * / * * * * /
rank: 533
score: 98.63533158735795
patch: ++ iter ; ++ iter ; } int iter ;
rank: 533
score: 98.54916720920139
patch: iter ++ ; ++ iter ; ++ ;
rank: 533
score: 98.51909528459821
patch: ++ * * * iter /
rank: 533
score: 98.49191623263889
patch: System . arraycopy ( iter , 0 ,
rank: 534
score: 99.04560289884868
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = this . null ;
rank: 534
score: 98.98769705636161
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < double [ ] ;
rank: 534
score: 98.93192722486413
patch: < Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > > current = current ;
rank: 534
score: 98.76873779296875
patch: ++ iter = iter . iter ;
rank: 534
score: 98.63478393554688
patch: ++ iter ; int iter ; int iter ;
rank: 534
score: 98.54915364583333
patch: ++ ( ++ iter ; / / /
rank: 534
score: 98.5185546875
patch: / * * * ++ /
rank: 534
score: 98.491455078125
patch: try { while ( true ) {
rank: 535
score: 99.05369059244792
patch: Point CaMeL Vector CaMeL Value CaMeL Pair > checker = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ,
rank: 535
score: 98.98707682291666
patch: while ( ! compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) )
rank: 535
score: 98.93923715444711
patch: boolean first CaMeL Iteration = current CaMeL Point [ 0 ] ;
rank: 535
score: 98.93117804276316
patch: synchronized ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ) {
rank: 535
score: 98.7684326171875
patch: ++ iter ; current = iter ;
rank: 535
score: 98.54865180121527
patch: ++ 1 ; ++ iter ; / /
rank: 535
score: 98.51837158203125
patch: ++ * ; ++ iter ;
rank: 535
score: 98.49127960205078
patch: final ; final ; ++ iter ;
rank: 536
score: 98.98672688802084
patch: ++ true ; compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 536
score: 98.93892124720982
patch: boolean first CaMeL Iteration = n CaMeL R < n CaMeL R ;
rank: 536
score: 98.93104619565217
patch: current CaMeL Point = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Objective ) ;
rank: 536
score: 98.76725260416667
patch: int iter = current . index CaMeL Of ( $STRING$ ;
rank: 536
score: 98.63270152698864
patch: ++ iter ; try ; ++ iter ; iter ;
rank: 536
score: 98.54850463867187
patch: ++ iter ; iter = iter + iter ;
rank: 536
score: 98.51817103794643
patch: return iter + iter ; }
rank: 536
score: 98.48992047991071
patch: ++ iter - iter ; ;
rank: 537
score: 99.05241956208882
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current CaMeL Point ,
rank: 537
score: 98.986572265625
patch: qr CaMeL Decomposition ( current CaMeL Point , current CaMeL Objective ) ; }
rank: 537
score: 98.93882399338942
patch: int first CaMeL Iteration = current CaMeL Point [ 0 ] ;
rank: 537
score: 98.76676025390626
patch: ++ iter ; while ( iter ; ) {
rank: 537
score: 98.63245849609375
patch: ++ iter ; / ; if ++ iter ;
rank: 537
score: 98.54802911931819
patch: ++ iter ; ++ iter ; if iter -- ;
rank: 537
score: 98.51816030649039
patch: if ( . is CaMeL Empty ( ) ; return false ;
rank: 537
score: 98.48979356553819
patch: ++ iter ; if ( ! iter ;
rank: 538
score: 98.98583306206598
patch: qtf [ iter ] = current ;
rank: 538
score: 98.9384765625
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = 1 ;
rank: 538
score: 98.93075706845238
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , 0 ) ; }
rank: 538
score: 98.76646118164062
patch: ++ iter * /
rank: 538
score: 98.63188032670455
patch: ++ iter ; ++ iter ; out ; ++ ;
rank: 538
score: 98.5478515625
patch: ++ iter ; ; ;
rank: 538
score: 98.51811000279018
patch: else { / * ++ ;
rank: 539
score: 99.04407848011364
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair final = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current ;
rank: 539
score: 98.98582356770834
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair ( current ;
rank: 539
score: 98.93844604492188
patch: boolean first CaMeL Iteration = null ;
rank: 539
score: 98.93075358072916
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( checker ) ; }
rank: 539
score: 98.76627894810268
patch: ++ iter ; final double ;
rank: 539
score: 98.63120727539062
patch: ++ iter ; iter ; * ; * /
rank: 539
score: 98.54754083806819
patch: ++ iter ; ++ iter ; catch ++ iter ;
rank: 539
score: 98.51791381835938
patch: else throw new Runtime CaMeL Exception ( $STRING$ ;
rank: 539
score: 98.48924424913194
patch: if ( iter < 0 ) continue ;
rank: 540
score: 99.04376541940789
patch: qtf = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Objective , current CaMeL Objective ) ;
rank: 540
score: 98.98286946614583
patch: if ( first CaMeL Iteration && first CaMeL Iteration ) {
rank: 540
score: 98.9306640625
patch: private Point CaMeL Vector CaMeL Value CaMeL Pair ( Point CaMeL Vector CaMeL Value CaMeL Pair current CaMeL Point ,
rank: 540
score: 98.63037719726563
patch: ++ iter ; int iter ; ++ iter ;
rank: 540
score: 98.54746500651042
patch: ++ iter ; iter / iter ; }
rank: 540
score: 98.51755196707589
patch: break ; } ++ iter ;
rank: 540
score: 98.48777770996094
patch: ++ iter - 1 ; break ;
rank: 541
score: 99.05129107306985
patch: ++ n CaMeL C ; Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 541
score: 99.04364420572917
patch: ++ iter = jac CaMeL Norm . operate ( current CaMeL Residuals ) ;
rank: 541
score: 98.97976888020834
patch: ++ n CaMeL C ; compute CaMeL Cost ( current CaMeL Objective ) ;
rank: 541
score: 98.9368896484375
patch: if ( current CaMeL Cost < n CaMeL R ) {
rank: 541
score: 98.9303466796875
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Point ) ;
rank: 541
score: 98.63014914772727
patch: ++ iter ; ++ iter ; synchronized ++ iter ;
rank: 541
score: 98.54736328125
patch: ++ iter ; ++ iter ; else / iter ;
rank: 541
score: 98.51749965122768
patch: / * * * * /
rank: 541
score: 98.4874979654948
patch: ++ iter $NUMBER$ [ n CaMeL C ] ; break ;
rank: 542
score: 99.05084549753289
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = current CaMeL Point [ qtf ] ;
rank: 542
score: 99.04343775699013
patch: qtf = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Objective , current CaMeL Residuals ) ;
rank: 542
score: 98.97945149739583
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point )
rank: 542
score: 98.93559919084821
patch: double [ ] current CaMeL Objective = this . current CaMeL Objective ;
rank: 542
score: 98.93027630974265
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ) ;
rank: 542
score: 98.62985229492188
patch: ++ iter ; ++ - * - iter ;
rank: 542
score: 98.54704145951705
patch: ++ iter ; iter ; / / = iter ;
rank: 542
score: 98.51705729166666
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + $NUMBER$ , ) ;
rank: 543
score: 99.05083465576172
patch: ++ Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker ;
rank: 543
score: 99.04342215401786
patch: i = final Point CaMeL Vector CaMeL Value CaMeL Pair > checker ;
rank: 543
score: 98.97843424479167
patch: iter = final Point CaMeL Vector CaMeL Value CaMeL Pair ( checker ) ;
rank: 543
score: 98.93526785714286
patch: boolean iter = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 543
score: 98.9299083891369
patch: this . weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , ) ;
rank: 543
score: 98.76450602213542
patch: ++ iter * / * * * ;
rank: 543
score: 98.62877807617187
patch: ++ iter ; ; * * ++ iter ;
rank: 543
score: 98.54688609730114
patch: ++ 0 ; ++ iter ; } ++ iter ;
rank: 543
score: 98.51674194335938
patch: if ( iter > 0 ) return null ;
rank: 543
score: 98.48497178819444
patch: while ( iter ++ >= 0 ) {
rank: 544
score: 99.04308268229167
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair iter = current CaMeL Point ;
rank: 544
score: 98.97665201822916
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair -- ; {
rank: 544
score: 98.933837890625
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair char = current ;
rank: 544
score: 98.92960611979167
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point . length ) ; }
rank: 544
score: 98.7641132061298
patch: ++ iter ; Point CaMeL Vector CaMeL Value CaMeL Pair ++ ;
rank: 544
score: 98.628173828125
patch: ++ iter ; if iter ; while iter ;
rank: 544
score: 98.54680841619319
patch: ++ 1 ; ++ iter ; ++ iter ; }
rank: 544
score: 98.51605224609375
patch: if ++ iter ;
rank: 544
score: 98.48477935791016
patch: ++ iter - 1 ; try {
rank: 545
score: 99.0498046875
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair current = current ; / *
rank: 545
score: 99.04297984730114
patch: int iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Objective ) ;
rank: 545
score: 98.97623697916667
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair < int ==
rank: 545
score: 98.92939897017045
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Point ) ;
rank: 545
score: 98.62764115767045
patch: / * ] iter ; * / int iter ;
rank: 545
score: 98.54524369673295
patch: ++ iter ; ++ iter ; ++ 1 ; }
rank: 545
score: 98.51602608816964
patch: ++ < $NUMBER$ > iter ;
rank: 545
score: 98.48473358154297
patch: result [ 0 ] = iter ;
rank: 546
score: 98.97324782151442
patch: checker = get CaMeL Weight CaMeL Square CaMeL Root ( ) ;
rank: 546
score: 98.93357496995192
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair [ ] current ;
rank: 546
score: 98.9290771484375
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , ) ;
rank: 546
score: 98.76277982271634
patch: int iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ;
rank: 546
score: 98.6276143391927
patch: ++ iter ; ++ iter ; / * / / /
rank: 546
score: 98.54502360026042
patch: iter ; ++ ; ++ iter ; }
rank: 546
score: 98.51493326822917
patch: if ( . is CaMeL Empty ( ) ; / ;
rank: 546
score: 98.48351440429687
patch: if ( iter == - 1 ) break ;
rank: 547
score: 98.9727783203125
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair
rank: 547
score: 98.93201904296875
patch: / * boolean first CaMeL Iteration = false ;
rank: 547
score: 98.9290771484375
patch: x CaMeL Norm += weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Objective ) ;
rank: 547
score: 98.62748579545455
patch: ++ iter ; try ; if iter ; iter ;
rank: 547
score: 98.54490831163194
patch: ++ iter ; iter ; = iter ;
rank: 547
score: 98.48343658447266
patch: final ; while ( true ) {
rank: 548
score: 99.04920305524554
patch: if ( current CaMeL Point . length <= n CaMeL C ) {
rank: 548
score: 98.96971717247597
patch: Iterator iter = current CaMeL Point [ n CaMeL C ] ;
rank: 548
score: 98.93126502403847
patch: double compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 548
score: 98.92866654829545
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , 0 , 0 ) ;
rank: 548
score: 98.6271240234375
patch: ++ iter ; / * / int iter ;
rank: 548
score: 98.54448106553819
patch: ++ iter ; ++ max ; iter ;
rank: 548
score: 98.51416015625
patch: else { ++ * * ++ iter ; }
rank: 548
score: 98.48299407958984
patch: ++ iter ; while ( false ;
rank: 549
score: 99.04058430989583
patch: ++ iter = current CaMeL Residuals . operate ( current CaMeL Residuals ) ;
rank: 549
score: 98.92860630580357
patch: n CaMeL R = compute CaMeL Cost ( current CaMeL Point ) ;
rank: 549
score: 98.7613754272461
patch: ++ iter ; * / ; ;
rank: 549
score: 98.54378255208333
patch: ++ iter ; iter / * ; /
rank: 550
score: 99.03980364118304
patch: i = final Point CaMeL Vector CaMeL Value CaMeL Pair > 0 ;
rank: 550
score: 98.93062046595982
patch: if ( current CaMeL Residuals . length < n CaMeL C ) {
rank: 550
score: 98.92810997596153
patch: case Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 550
score: 98.7604248046875
patch: ++ iter ; * / * * * /
rank: 550
score: 98.62685324928977
patch: ++ iter ; ++ iter ; int * * /
rank: 550
score: 98.54368760850694
patch: } ++ iter ; ++ ++ iter ;
rank: 550
score: 98.51337076822917
patch: if ( . is CaMeL Empty ( ) ) . ; ++ iter ;
rank: 550
score: 98.48271179199219
patch: ++ iter ; this . ++ ;
rank: 551
score: 99.04840446920956
patch: ++ iter ; final final Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 551
score: 99.03933279854911
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair $NUMBER$ current = current ;
rank: 551
score: 98.93045748197116
patch: qtf ( current CaMeL Point , current CaMeL Objective ) ;
rank: 551
score: 98.92780095880681
patch: n CaMeL C = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Residuals ) ;
rank: 551
score: 98.758544921875
patch: ++ iter ; ; ++ iter * /
rank: 551
score: 98.62664184570312
patch: ++ iter ; * * ; ++ iter ;
rank: 551
score: 98.54365234375
patch: ++ iter ; iter / ; return iter ;
rank: 551
score: 98.51309640066964
patch: else { iter ++ ; }
rank: 551
score: 98.48136393229167
patch: if ( ! is CaMeL Empty ( ) ) continue ;
rank: 552
score: 99.04722836143092
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = weight CaMeL Matrix CaMeL Sqrt . operate (
rank: 552
score: 99.0392707375919
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair 1 checker = current ;
rank: 552
score: 98.95071411132812
patch: return checker . operate ( current CaMeL Residuals ) ; }
rank: 552
score: 98.92991129557292
patch: int [ ] current CaMeL Objective = current CaMeL Objective ;
rank: 552
score: 98.927734375
patch: n CaMeL R = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Objective ) ;
rank: 552
score: 98.75799560546875
patch: if ( ++ iter < n CaMeL R ) break ;
rank: 552
score: 98.62623180042614
patch: if ++ iter ; ++ iter ; ++ iter ;
rank: 552
score: 98.51293131510417
patch: if ( . is CaMeL Empty ( ) ) { break ; } }
rank: 552
score: 98.4803466796875
patch: ++ iter ; while ( iter ++ >= 0 ) {
rank: 553
score: 99.04718017578125
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , 0 ) ;
rank: 553
score: 99.03754739200367
patch: d = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Residuals ) ;
rank: 553
score: 98.94788614908855
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair += current ;
rank: 553
score: 98.9297344501202
patch: pk = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 553
score: 98.92769582648026
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , qtf ) ;
rank: 553
score: 98.75645094651442
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ ) ;
rank: 553
score: 98.62603204900569
patch: ++ iter ; ++ iter ; ; if iter ;
rank: 553
score: 98.54243977864583
patch: ++ iter ; iter / max ++ ;
rank: 553
score: 98.51278250558036
patch: else { / * * /
rank: 553
score: 98.47952609592014
patch: ++ iter = iter ; ++ iter ;
rank: 554
score: 99.04686781939338
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current CaMeL Objective = current CaMeL Point ;
rank: 554
score: 98.92727225167411
patch: Point CaMeL Vector CaMeL Value CaMeL Pair final = current CaMeL Point ;
rank: 554
score: 98.62547718394886
patch: ++ iter ; try { iter ; break ; }
rank: 554
score: 98.5421142578125
patch: ++ iter ; ++ iter ; ; try
rank: 554
score: 98.51262872869319
patch: else { ++ iter ; * / break ; }
rank: 554
score: 98.47906494140625
patch: ++ iter ; Thread . sleep ( iter ) ; }
rank: 555
score: 99.03645833333333
patch: ++ iter = < Point CaMeL Vector CaMeL Value CaMeL Pair > checker ;
rank: 555
score: 98.94603474934895
patch: / * compute CaMeL Residuals ( current CaMeL Point ) ;
rank: 555
score: 98.92653198242188
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , weighted CaMeL Residual ) ;
rank: 555
score: 98.92580740792411
patch: final int CaMeL Value = Point CaMeL Vector CaMeL Value CaMeL Pair ;
rank: 555
score: 98.62544555664063
patch: ++ iter ; try { if ++ iter ;
rank: 555
score: 98.54210747612848
patch: ++ iter ; iter / ++ ; /
rank: 555
score: 98.51188354492187
patch: else { / * * ; ++ iter ;
rank: 555
score: 98.4786376953125
patch: if ( iter == null ) continue ; ++ iter ;
rank: 556
score: 99.0462137858073
patch: weighted CaMeL Jacobian = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective , 0 ) ;
rank: 556
score: 99.03644205729167
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair start = current CaMeL Point ;
rank: 556
score: 98.92603149414063
patch: p = get CaMeL Weight CaMeL Square CaMeL Root ( current CaMeL Point , current CaMeL Objective ) ;
rank: 556
score: 98.92544991629464
patch: if ( Point CaMeL Vector CaMeL Value CaMeL Pair > 0 ) {
rank: 556
score: 98.54206000434027
patch: } ++ iter ; ++ iter ; ;
rank: 556
score: 98.51027610085227
patch: if ( iter > $NUMBER$ ; return iter ; }
rank: 556
score: 98.47744411892361
patch: if ( iter <= 0 ) continue ;
rank: 557
score: 99.04595947265625
patch: int [ ] current CaMeL Objective = weight CaMeL Matrix CaMeL Sqrt . operate ( ) ;
rank: 557
score: 99.03611403245192
patch: ++ iter = checker . operate ( current CaMeL Point ) ;
rank: 557
score: 98.94536884014423
patch: Iterator iter = current CaMeL Point [ n CaMeL R ] ;
rank: 557
score: 98.9258700284091
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) . operate ( current CaMeL Objective ) ;
rank: 557
score: 98.92421177455357
patch: int iter = ( Point CaMeL Vector CaMeL Value CaMeL Pair > )
rank: 557
score: 98.75375366210938
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ ;
rank: 557
score: 98.54198109019886
patch: ++ iter ; ++ iter ; throw iter ; }
rank: 557
score: 98.51016438802084
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + 1 . $STRING$ ;
rank: 557
score: 98.47742377387152
patch: if ( this . iter != null )
rank: 558
score: 99.03586251395089
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair $NUMBER$ ;
rank: 558
score: 98.94529030539773
patch: while ( true ) { while ( true ) {
rank: 558
score: 98.925439453125
patch: check CaMeL Parameters ( current CaMeL Objective ) ;
rank: 558
score: 98.92378743489583
patch: if ( current CaMeL Point , current CaMeL Objective ) {
rank: 558
score: 98.54126848493304
patch: if iter ; ++ iter ;
rank: 558
score: 98.50996616908482
patch: return iter * 0 ; }
rank: 558
score: 98.47674560546875
patch: if ( ! iter != null )
rank: 559
score: 99.04564208984375
patch: double [ ] current CaMeL Point = current ;
rank: 559
score: 99.03289435891544
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair current = current ; {
rank: 559
score: 98.9451434795673
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair <
rank: 559
score: 98.92537649054276
patch: current CaMeL Point = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point ) ;
rank: 559
score: 98.75237358940973
patch: ++ iter ; * / * / ;
rank: 559
score: 98.62422688802083
patch: / * ++ iter ; ++ iter ; ++ iter ;
rank: 559
score: 98.54114641462054
patch: ++ iter ; ++ current ;
rank: 559
score: 98.50993129185268
patch: ++ iter ; while ; }
rank: 559
score: 98.47621848366477
patch: ++ iter ; if ( true ) ++ iter ;
rank: 560
score: 98.94318389892578
patch: if ( first CaMeL Iteration ) {
rank: 560
score: 98.92528076171875
patch: ret = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Objective ) ;
rank: 560
score: 98.92323655348558
patch: double [ ] current CaMeL Objective = current CaMeL Point ) ;
rank: 560
score: 98.75052897135417
patch: ++ iter ; ++ iter * / ;
rank: 560
score: 98.62340436662946
patch: / ; ++ iter ; ;
rank: 560
score: 98.54099527994792
patch: ++ iter ; ++ this + iter ;
rank: 560
score: 98.50954182942708
patch: ++ iter ; for iter = iter . iterator ++ ;
rank: 561
score: 99.0446548461914
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair > = current ;
rank: 561
score: 98.94289926382211
patch: weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate (
rank: 561
score: 98.92519309303977
patch: x CaMeL Norm = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Point ) ;
rank: 561
score: 98.74970838758681
patch: ++ iter ; do { ++ iter ;
rank: 561
score: 98.62269287109375
patch: / * ++ iter ; / / / /
rank: 561
score: 98.540673828125
patch: ++ iter ; ++ iter ; ; break ;
rank: 561
score: 98.509521484375
patch: ++ iter ; if ++ iter * iter ;
rank: 561
score: 98.47490098741319
patch: ++ iter ; if ( iter == ;
rank: 562
score: 99.04441431949013
patch: double [ ] current CaMeL Objective = weight CaMeL Matrix CaMeL Sqrt . operate ( 0 ) ;
rank: 562
score: 99.03193010602679
patch: d = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ;
rank: 562
score: 98.94273071289062
patch: ++ iter ; final Convergence CaMeL Checker ++ ;
rank: 562
score: 98.74942720853366
patch: ++ iter ; int iter = current CaMeL Point . length ;
rank: 562
score: 98.62254028320312
patch: ++ iter ; ++ * ; int iter ;
rank: 562
score: 98.54043240017361
patch: ++ iter ; iter / 1 ; /
rank: 562
score: 98.50927734375
patch: if ( iter > 0 ; return . $NUMBER$ ;
rank: 562
score: 98.47486029730902
patch: final int iter = iter + iter ;
rank: 563
score: 99.04434204101562
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = new Point CaMeL Vector CaMeL Value CaMeL Pair ( this ) ;
rank: 563
score: 98.92470877511161
patch: tmp = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) current ;
rank: 563
score: 98.92027791341145
patch: int [ ] current CaMeL Objective = current CaMeL Residuals ;
rank: 563
score: 98.6224609375
patch: / * ++ iter ; ; ++ iter ;
rank: 563
score: 98.50901489257812
patch: else { if ( iter > $NUMBER$ ) {
rank: 564
score: 99.04411097935268
patch: double [ ] current CaMeL Objective = weight CaMeL Matrix CaMeL Sqrt ;
rank: 564
score: 98.92465645926339
patch: first CaMeL Iteration = compute CaMeL Cost ( current CaMeL Objective ) ;
rank: 564
score: 98.91910494290866
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = 0 ;
rank: 564
score: 98.62119140625
patch: ++ iter ; iter ; * / * /
rank: 564
score: 98.50875244140624
patch: ++ iter ; if ++ iter < 0 ;
rank: 564
score: 98.47454071044922
patch: int iter = iter - 1 ;
rank: 565
score: 99.04360961914062
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > checker [ ] = current ;
rank: 565
score: 99.03052629743304
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair 1 ;
rank: 565
score: 98.93616739908855
patch: / / compute CaMeL Residuals ( current CaMeL Point ) ;
rank: 565
score: 98.924560546875
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , n CaMeL C ) ;
rank: 565
score: 98.91868239182692
patch: boolean compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 565
score: 98.74750310724431
patch: ++ iter ; while ( iter == iter ) {
rank: 565
score: 98.62109375
patch: ++ iter ; ++ iter ; / * * ; /
rank: 565
score: 98.53818359375
patch: / ; ++ ++ iter ; ++ iter ;
rank: 565
score: 98.50865071614584
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ; } return iter ;
rank: 565
score: 98.47447620738636
patch: ++ iter ; System . arraycopy ( iter ) ;
rank: 566
score: 99.0432637532552
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = current ; Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 566
score: 99.03038736979167
patch: e ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 566
score: 98.93549053485577
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair ++ = current ;
rank: 566
score: 98.91517857142857
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair [ ;
rank: 566
score: 98.7442626953125
patch: ++ iter ; * ++ iter * /
rank: 566
score: 98.53766479492188
patch: ++ iter ; ++ iter ; try / /
rank: 566
score: 98.50852614182692
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ; } else
rank: 566
score: 98.47373453776042
patch: if ( ++ n CaMeL C < 0 ) continue ;
rank: 567
score: 99.04302509014423
patch: int Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 567
score: 99.02968924386161
patch: ++ iter = final Point CaMeL Vector CaMeL Value CaMeL Pair > ;
rank: 567
score: 98.9338134765625
patch: qr CaMeL Decomposition ( current CaMeL Point ) ;
rank: 567
score: 98.9231689453125
patch: ret = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Residuals ) ;
rank: 567
score: 98.91458565848214
patch: double [ ] current CaMeL Objective = current CaMeL Residuals ( ) ;
rank: 567
score: 98.74420844184027
patch: ++ iter * / * iter * /
rank: 567
score: 98.53749389648438
patch: ++ iter ; ++ * / ++ iter ;
rank: 567
score: 98.50799005681819
patch: if ( ! iter == null ; ++ iter ;
rank: 567
score: 98.47272338867188
patch: if ( ++ n CaMeL C < 0 ;
rank: 568
score: 99.04282740542763
patch: double [ ] current CaMeL Objective = weight CaMeL Matrix CaMeL Sqrt . operate ( this ) ;
rank: 568
score: 99.02900390625
patch: ++ iter = checker . operate . operate ( current CaMeL Residuals ) ;
rank: 568
score: 98.93280029296875
patch: while ( true ) { { {
rank: 568
score: 98.92279343377976
patch: check CaMeL Parameters ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , current CaMeL Objective ) ) ;
rank: 568
score: 98.91420200892857
patch: double [ ] current CaMeL Objective = compute CaMeL Weighted CaMeL Jacobian (
rank: 568
score: 98.74343872070312
patch: for ( ; ; ; ) {
rank: 568
score: 98.5361083984375
patch: ++ iter ; ; if iter = 1 ;
rank: 568
score: 98.50790841238839
patch: / * * ++ iter /
rank: 568
score: 98.4726333618164
patch: ++ iter ; if ( current ;
rank: 569
score: 99.04280598958333
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker =
rank: 569
score: 99.02873011997768
patch: compute CaMeL Residuals ( current CaMeL Point , current CaMeL Objective ) ;
rank: 569
score: 98.93190696022727
patch: ++ iter ; final Convergence CaMeL Checker ( ) ;
rank: 569
score: 98.9226009971217
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) [ iter ] ;
rank: 569
score: 98.91086989182692
patch: iter = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 569
score: 98.74284224076705
patch: ++ iter ; if ( iter == - 1 )
rank: 569
score: 98.62043900923295
patch: ++ iter ; / * * / int iter ;
rank: 569
score: 98.53511962890624
patch: ++ iter ; ; if iter * ; /
rank: 569
score: 98.50739397321429
patch: throw new Runtime CaMeL Exception ( $STRING$ ) ; } ++ iter ;
rank: 569
score: 98.47250366210938
patch: ++ iter ] ; break ; }
rank: 570
score: 99.04251098632812
patch: Point CaMeL Vector CaMeL Value CaMeL Pair checker = current ; final Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 570
score: 99.02805001395089
patch: / / Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 570
score: 98.93020629882812
patch: while ( iter ; final Convergence CaMeL Checker ;
rank: 570
score: 98.92249755859375
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , 0 , 0 ) ;
rank: 570
score: 98.91081019810268
patch: if ( current CaMeL Objective . length < n CaMeL C ) {
rank: 570
score: 98.74142690805289
patch: if ( ++ iter < n CaMeL R ) ++ iter ;
rank: 570
score: 98.61946411132813
patch: if 0 ; ++ iter ; ++ iter ;
rank: 570
score: 98.534765625
patch: ++ iter ; ; / if ++ iter ;
rank: 570
score: 98.50725708007812
patch: / * * /
rank: 570
score: 98.47248979048295
patch: if ( ! iter . equals ( current ) ;
rank: 571
score: 99.04245174632354
patch: Iterator iter = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ;
rank: 571
score: 99.02717808314732
patch: list = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ;
rank: 571
score: 98.92833533653847
patch: if ( checker . operate ( current CaMeL Residuals ) ) {
rank: 571
score: 98.92237200055804
patch: < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = false ;
rank: 571
score: 98.91078538161058
patch: if ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point )
rank: 571
score: 98.74125532670455
patch: if ( iter > 0 ) { ++ iter ;
rank: 571
score: 98.61924050071023
patch: ++ iter ; ++ iter ; out ; break ;
rank: 571
score: 98.53439331054688
patch: ++ iter ; ; = iter / iter ;
rank: 571
score: 98.50701497395833
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + 1 + 0 ;
rank: 571
score: 98.4721923828125
patch: ++ iter ; if ( true ) break ;
rank: 572
score: 98.92757474459134
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair -- = current ;
rank: 572
score: 98.92154366629464
patch: ( ( Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 572
score: 98.91032191685268
patch: if ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 572
score: 98.7408780184659
patch: ++ iter * / * / ++ iter * /
rank: 572
score: 98.61675415039062
patch: ++ iter ; else { iter ; * /
rank: 572
score: 98.53384399414062
patch: ++ iter ; iter ++ ; -- iter ;
rank: 572
score: 98.50679524739583
patch: throw new Runtime CaMeL Exception ( $STRING$ + ++ iter ;
rank: 572
score: 98.47162420099431
patch: if ( ! name . equals ( iter ) )
rank: 573
score: 99.02461460658482
patch: it = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Objective ) ;
rank: 573
score: 98.92654184194711
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < double ) {
rank: 573
score: 98.92116827713816
patch: x CaMeL Norm += weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , ) ;
rank: 573
score: 98.74087289663461
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( this , ;
rank: 573
score: 98.53280029296874
patch: ++ iter ; ++ iter ; ; / }
rank: 573
score: 98.50640258789062
patch: else { ++ iter ; } = iter ;
rank: 573
score: 98.47130584716797
patch: ++ iter ; while ( break ;
rank: 574
score: 99.04002888997395
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = new Point CaMeL Vector CaMeL Value CaMeL Pair ( $NUMBER$ ) ;
rank: 574
score: 99.02274263822116
patch: return weighted CaMeL Residual . operate ( current CaMeL Residuals ) ;
rank: 574
score: 98.92112038352273
patch: x CaMeL Norm = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , n CaMeL R ) ;
rank: 574
score: 98.9196268717448
patch: / / compute CaMeL Cost ( n CaMeL C ) ;
rank: 574
score: 98.90988393930289
patch: final int CaMeL Value = current CaMeL Point [ 0 ] ;
rank: 574
score: 98.73946804470486
patch: ++ iter ; / * * * /
rank: 574
score: 98.61574009486607
patch: ++ iter ; ++ out ;
rank: 574
score: 98.53274972098214
patch: ++ iter ; iter * ;
rank: 574
score: 98.47091238839286
patch: ++ iter - iter 1 ;
rank: 575
score: 99.03975736177884
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > = current ;
rank: 575
score: 99.02089146205357
patch: pos = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ;
rank: 575
score: 98.92075417258523
patch: protected Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair >> current = current ;
rank: 575
score: 98.91907848011364
patch: qtf [ iter ] = weighted CaMeL Residual ;
rank: 575
score: 98.90986851283482
patch: if ( current CaMeL Point . length <= n CaMeL R ) {
rank: 575
score: 98.61501242897727
patch: ++ iter ; / * * ; ++ iter ;
rank: 575
score: 98.53265380859375
patch: ++ iter ; iter ; / = iter ;
rank: 575
score: 98.50615985576923
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ iter ; }
rank: 575
score: 98.47071422230114
patch: while ( true ) { if ( true ) {
rank: 576
score: 99.03951009114583
patch: weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective , true ) ;
rank: 576
score: 98.92061574835526
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point . length ;
rank: 576
score: 98.9154522235577
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair continue = current ;
rank: 576
score: 98.90802471454327
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair $NUMBER$ = current ;
rank: 576
score: 98.53261108398438
patch: ++ iter ; iter / ; / / /
rank: 576
score: 98.50609537760417
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + 0 . $STRING$ ;
rank: 576
score: 98.470703125
patch: final ; if ( iter != null )
rank: 577
score: 98.920361328125
patch: ret = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Point ) ;
rank: 577
score: 98.9150899251302
patch: checker = current CaMeL Point [ n CaMeL C ] ;
rank: 577
score: 98.73819580078126
patch: ++ iter ; ; ++ iter - 1 ;
rank: 577
score: 98.61406915838069
patch: ++ iter ; ++ iter ; out ; iter ;
rank: 577
score: 98.5317626953125
patch: ++ ( ++ ++ iter ; ++ iter ;
rank: 577
score: 98.50602504185268
patch: if ( . is CaMeL Empty ( ) ) ++ iter ; }
rank: 577
score: 98.47054036458333
patch: final int iter = iter / iter ;
rank: 578
score: 99.03897094726562
patch: double [ ] current CaMeL Residuals = current ;
rank: 578
score: 99.01896158854167
patch: if ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ) {
rank: 578
score: 98.9202816611842
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , 0 , 0 ) ;
rank: 578
score: 98.90629438920455
patch: int iter = current CaMeL Point [ 0 ] ;
rank: 578
score: 98.73806326729911
patch: ++ iter ; int ++ ;
rank: 578
score: 98.61395818536931
patch: / * ++ iter ; / ; ++ iter ;
rank: 578
score: 98.53150024414063
patch: ++ iter ; ; ; if ++ iter ;
rank: 578
score: 98.50450642903645
patch: else ++ ++ iter ;
rank: 578
score: 98.46959431966145
patch: if ( ! is CaMeL Empty ( ) ) break ;
rank: 579
score: 99.038818359375
patch: ++ ( final Point CaMeL Vector CaMeL Value CaMeL Pair > checker ;
rank: 579
score: 99.01879010881696
patch: i = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Objective ) ;
rank: 579
score: 98.920166015625
patch: < Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > > checker ;
rank: 579
score: 98.90986772017045
patch: qr CaMeL Decomposition ( current CaMeL Point ) ; }
rank: 579
score: 98.90565074573864
patch: if ( n CaMeL C < n CaMeL C )
rank: 579
score: 98.73781516335227
patch: ++ iter ; ++ iter = iter . iter ;
rank: 579
score: 98.5308349609375
patch: ++ iter ; ; if ; ++ iter ;
rank: 579
score: 98.5043436686198
patch: if ( . is CaMeL Empty ( ) ) { ;
rank: 579
score: 98.46901245117188
patch: if ( ++ iter == 0 ) break ;
rank: 580
score: 98.90982055664062
patch: / / compute CaMeL Residuals ( current CaMeL Objective ) ;
rank: 580
score: 98.90497295673077
patch: int [ ] current CaMeL Objective = current CaMeL Objective ) ;
rank: 580
score: 98.73756626674107
patch: ++ iter * / ; ;
rank: 580
score: 98.61332194010417
patch: ++ iter ; else ;
rank: 580
score: 98.53074428013393
patch: } iter ; ++ iter ;
rank: 580
score: 98.50428185096153
patch: if ( . is CaMeL Empty ( ; ) ) continue ;
rank: 580
score: 98.46856079101562
patch: if ( ++ n CaMeL R > 0 )
rank: 581
score: 98.919873046875
patch: x CaMeL Norm += weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , 0 ) ;
rank: 581
score: 98.90780639648438
patch: / / compute CaMeL Residuals ( current CaMeL Residuals ) ;
rank: 581
score: 98.90464274088542
patch: if ( n CaMeL R <= n CaMeL C ) {
rank: 581
score: 98.7368633563702
patch: int iter = current . index CaMeL Of ( $STRING$ ) ;
rank: 581
score: 98.530224609375
patch: ++ 1 ; ++ iter ; ++ 1 ;
rank: 581
score: 98.50401000976562
patch: / * * * / ++ ++ iter ;
rank: 581
score: 98.46846147017045
patch: ++ iter ; if ( iterator != null ) {
rank: 582
score: 99.03854166666666
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair max = current CaMeL Point ;
rank: 582
score: 98.91941139914773
patch: CaMeL Point CaMeL Vector CaMeL Value CaMeL Pair current = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current ;
rank: 582
score: 98.90738619290866
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair Math = current ;
rank: 582
score: 98.7354227701823
patch: ++ iter ; while ( iter . iter < iter )
rank: 582
score: 98.61270751953126
patch: try { ++ iter ; ++ iter ; ;
rank: 582
score: 98.53008422851562
patch: ++ length ; ++ iter ; ++ iter ;
rank: 582
score: 98.50377197265625
patch: else { ++ iter ; * * / }
rank: 582
score: 98.46763305664062
patch: ++ iter == 0 ? 0 : iter ;
rank: 583
score: 99.03833946814903
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair ( checker ) ;
rank: 583
score: 99.01603190104167
patch: ++ iter = solved CaMeL Cols . operate ( current CaMeL Residuals ) ;
rank: 583
score: 98.91936292146382
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , n CaMeL C ) ;
rank: 583
score: 98.90419514973958
patch: Iterator iter = checker . operate ( current CaMeL Point ,
rank: 583
score: 98.90335787259616
patch: boolean first CaMeL Iteration = true ; int iter = 0 ;
rank: 583
score: 98.6125155362216
patch: ++ iter ; ++ iter ; for ++ iter ;
rank: 583
score: 98.5285400390625
patch: ++ iter ; ++ iter ; ; * /
rank: 583
score: 98.50370279947917
patch: if ( ! 0 . is CaMeL Empty ( ) ) throw null ;
rank: 583
score: 98.46721733940973
patch: ++ iter ; ++ iter ; else {
rank: 584
score: 99.03797403971355
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current CaMeL Point = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) null ;
rank: 584
score: 98.9192531419837
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) . operate ( current CaMeL Residuals ) ; }
rank: 584
score: 98.90386962890625
patch: / * compute CaMeL Residuals ( current CaMeL Objective ) ;
rank: 584
score: 98.90248460036058
patch: double first CaMeL Iteration = current CaMeL Point [ 0 ] ;
rank: 584
score: 98.73487548828125
patch: ++ iter * / * ++ iter * ;
rank: 584
score: 98.61182657877605
patch: ++ 1 ++ iter ;
rank: 584
score: 98.52803344726563
patch: ++ iter ; ++ iter ; = start ;
rank: 584
score: 98.50315163352273
patch: if ( iter > 0 ; return . 1 ;
rank: 584
score: 98.46721055772569
patch: if ( iter == - 1 ) {
rank: 585
score: 99.03767395019531
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = jac CaMeL Norm ;
rank: 585
score: 98.9192127046131
patch: this . qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point . length ) ) ;
rank: 585
score: 98.90360884232955
patch: while ( ! weight CaMeL Matrix CaMeL Sqrt ) {
rank: 585
score: 98.73482937282986
patch: if ( iter < iter ) continue ;
rank: 585
score: 98.61128373579545
patch: int iter ; ++ iter ; while ++ iter ;
rank: 585
score: 98.527978515625
patch: ++ iter ; ++ ; ++ iter ; ;
rank: 585
score: 98.5030517578125
patch: if ( ! 0 . is CaMeL Empty ( ) ; break ;
rank: 585
score: 98.46675109863281
patch: final int iter = iter ) ;
rank: 586
score: 99.03748575846355
patch: Point CaMeL Vector CaMeL Value CaMeL Pair current = new Point CaMeL Vector CaMeL Value CaMeL Pair ( n CaMeL C ) ;
rank: 586
score: 98.91898970170455
patch: x CaMeL Norm += weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Cost ) ;
rank: 586
score: 98.90283203125
patch: / * compute CaMeL Cost ( n CaMeL C ) ;
rank: 586
score: 98.90077427455357
patch: boolean checker = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 586
score: 98.73444366455078
patch: ++ iter ] = iter ; }
rank: 586
score: 98.52797241210938
patch: ++ 0 ; ++ iter ; -- iter ;
rank: 586
score: 98.50205078125
patch: else { ++ iter ; * / * /
rank: 586
score: 98.466552734375
patch: ++ iter ; if ( iter == 0 ) {
rank: 587
score: 99.03731282552083
patch: Point CaMeL Vector CaMeL Value CaMeL Pair current = new Point CaMeL Vector CaMeL Value CaMeL Pair ( n CaMeL R ) ;
rank: 587
score: 98.91888982599431
patch: public Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair >> current = current ;
rank: 587
score: 98.89968436104911
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair = current CaMeL Point ;
rank: 587
score: 98.73284442608173
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current ; ++ ;
rank: 587
score: 98.61092529296874
patch: ++ iter ; ; * / ++ iter ;
rank: 587
score: 98.50183977399554
patch: else { ++ max ; }
rank: 587
score: 98.46644083658855
patch: ++ iter ; if ( Arrays . as CaMeL List ;
rank: 588
score: 99.0372314453125
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , $NUMBER$ ) ;
rank: 588
score: 99.01041957310268
patch: k = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ;
rank: 588
score: 98.91881742931548
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , qtf ) ;
rank: 588
score: 98.89944458007812
patch: Point CaMeL Vector CaMeL Value CaMeL Pair start = current ;
rank: 588
score: 98.89752197265625
patch: while ( iter ; true ) {
rank: 588
score: 98.73223407451923
patch: ++ iter ; if ( iter == - 1 ) break ;
rank: 588
score: 98.61070556640625
patch: ++ iter ; ++ 1 ; int iter ;
rank: 588
score: 98.52716936383929
patch: ++ super ; ++ iter ;
rank: 588
score: 98.50156656901042
patch: else throw new Runtime CaMeL Exception ( $STRING$ + iter ;
rank: 588
score: 98.4664306640625
patch: ++ iter ; if ( true ) { ++ iter ;
rank: 589
score: 99.03704833984375
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair checker = this ;
rank: 589
score: 98.91871995192308
patch: < Point CaMeL Vector CaMeL Value CaMeL Pair ( checker ) ;
rank: 589
score: 98.89930138221153
patch: int first CaMeL Iteration = current CaMeL Point [ iter ] ;
rank: 589
score: 98.89742337740384
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair for = current ;
rank: 589
score: 98.61055131392045
patch: int iter ; ++ iter ; / * / /
rank: 589
score: 98.5269775390625
patch: ++ iter ; iter ; if iter ++ ;
rank: 589
score: 98.50124289772727
patch: throw new Runtime CaMeL Exception ( $STRING$ , null ;
rank: 589
score: 98.46576605902777
patch: if ( iter <= 0 ) break ;
rank: 590
score: 99.03704833984375
patch: weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective , false ) ;
rank: 590
score: 99.01028645833334
patch: ++ iter = current CaMeL Objective . operate ( current CaMeL Residuals ) ;
rank: 590
score: 98.9185302734375
patch: private Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > current ;
rank: 590
score: 98.89854939778645
patch: if ( current CaMeL Cost != n CaMeL C ) {
rank: 590
score: 98.89552659254808
patch: while ( iter < solved CaMeL Cols ; iter ++ ) {
rank: 590
score: 98.72846221923828
patch: ++ iter ; if ( ; ;
rank: 590
score: 98.61028180803571
patch: i ++ ; ++ iter ;
rank: 590
score: 98.52599487304687
patch: ++ iter ; ++ iter ; return 1 ;
rank: 590
score: 98.46421983506944
patch: if ( ++ iter > 0 ) {
rank: 591
score: 98.9183349609375
patch: n CaMeL C = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , n CaMeL R ) ;
rank: 591
score: 98.89841715494792
patch: if ( current CaMeL Residuals == n CaMeL C ) {
rank: 591
score: 98.8953145345052
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < int ;
rank: 591
score: 98.72803412543402
patch: ++ iter ] = ++ iter ; }
rank: 591
score: 98.61021931966145
patch: ++ iter ; ++ iter ; int * - iter ;
rank: 591
score: 98.52593383789062
patch: ++ iter ; iter / - ++ iter ;
rank: 591
score: 98.50076293945312
patch: if ( iter > 0 ; return ++ iter ; }
rank: 592
score: 98.89487868088942
patch: compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ; }
rank: 592
score: 98.72760479266827
patch: Point CaMeL Vector CaMeL Value CaMeL Pair current = ++ iter ;
rank: 592
score: 98.61016290838069
patch: ++ iter ; for iter + iter : iter ;
rank: 592
score: 98.52589111328125
patch: } iter ; ++ iter ; ++ iter ;
rank: 592
score: 98.50062913161058
patch: else { if ( iter > 0 ; return null ; }
rank: 592
score: 98.46310860770089
patch: ++ iter ] ; break ;
rank: 593
score: 98.91804584703948
patch: Iterator < Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > iter = true ;
rank: 593
score: 98.89287860576923
patch: / / * compute CaMeL Cost ( current CaMeL Objective ) ;
rank: 593
score: 98.72646859975961
patch: int current = current CaMeL Point . length ; ++ current ;
rank: 593
score: 98.60986328125
patch: / * ] iter ; / / int iter ;
rank: 593
score: 98.50054931640625
patch: else { if ( iter > 0 ; break ; }
rank: 593
score: 98.4627685546875
patch: if ( ++ n CaMeL C < 0 ) break ;
rank: 594
score: 99.03548177083333
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < double , Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current ;
rank: 594
score: 98.91778564453125
patch: n CaMeL C = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , iter ) ;
rank: 594
score: 98.8927753155048
patch: Iterator true = checker . operate ( current CaMeL Residuals ) ;
rank: 594
score: 98.72466571514423
patch: throw new Unsupported CaMeL Operation CaMeL Exception ( $STRING$ + iter ;
rank: 594
score: 98.6092529296875
patch: ++ iter ; ++ 1 ; if iter ;
rank: 594
score: 98.525
patch: ++ iter ; ++ iter ; ++ this ;
rank: 594
score: 98.5002197265625
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + 0 + $STRING$ ;
rank: 594
score: 98.46230061848958
patch: ++ iter Math . max ( iter , iter ) ;
rank: 595
score: 99.0350341796875
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current CaMeL Point = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) 0 ;
rank: 595
score: 98.91776733398437
patch: < Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > > {
rank: 595
score: 98.89334810697116
patch: Point CaMeL Vector CaMeL Value CaMeL Pair 1 checker = current ;
rank: 595
score: 98.7242764559659
patch: ++ iter ; * / * * * * /
rank: 595
score: 98.60872802734374
patch: ++ iter ; * ; if ++ iter ;
rank: 595
score: 98.50001220703125
patch: / * * * / / ++ iter ;
rank: 595
score: 98.46194458007812
patch: ++ iter ; while ( iter . ; ++ iter )
rank: 596
score: 99.03475952148438
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = new Point CaMeL Vector CaMeL Value CaMeL Pair ( qtf ) ;
rank: 596
score: 99.00412222055289
patch: return compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ;
rank: 596
score: 98.91764322916667
patch: result = compute CaMeL Cost ( current CaMeL Objective ) ;
rank: 596
score: 98.89231520432692
patch: Map < Point CaMeL Vector CaMeL Value CaMeL Pair > checker =
rank: 596
score: 98.8912353515625
patch: ++ iter ; final final Convergence CaMeL Checker ;
rank: 596
score: 98.72368706597223
patch: ++ iter ; ++ iter * iter ;
rank: 596
score: 98.60859985351563
patch: ++ iter ; else ; if ++ iter ;
rank: 596
score: 98.523828125
patch: ++ iter ; iter ++ ; if ++ ;
rank: 596
score: 98.49930419921876
patch: else { ++ iter ; * / } }
rank: 596
score: 98.46119689941406
patch: ++ iter = iter - iter ;
rank: 597
score: 98.91738455636161
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 597
score: 98.8904317220052
patch: if ( current CaMeL Objective == n CaMeL R ) {
rank: 597
score: 98.8896240234375
patch: if ( current CaMeL Residuals == 0 ) {
rank: 597
score: 98.72344501201923
patch: if ( ++ iter < n CaMeL C ) ++ iter ;
rank: 597
score: 98.6084872159091
patch: ++ iter ; ++ iter ; System . max ;
rank: 597
score: 98.5230712890625
patch: ++ iter ; iter = iter = iter ;
rank: 597
score: 98.49922318892045
patch: if ( iter > 0 ; return iter * ;
rank: 598
score: 98.99683556189903
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair * = current ;
rank: 598
score: 98.9171726392663
patch: iter = get CaMeL Weight CaMeL Square CaMeL Root ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ;
rank: 598
score: 98.88802083333333
patch: while ( iter < solved CaMeL Cols ; true ) {
rank: 598
score: 98.72240101207386
patch: ++ iter ; iter = iter . iter ; ;
rank: 598
score: 98.608154296875
patch: ++ iter ; ++ iter ; ; * ;
rank: 598
score: 98.523046875
patch: ++ iter ; ++ iter ; * iter ;
rank: 598
score: 98.49888392857143
patch: return iter + 0 ; }
rank: 598
score: 98.45942034040179
patch: ++ iter [ 0 ] ;
rank: 599
score: 98.91706194196429
patch: state = ( Point CaMeL Vector CaMeL Value CaMeL Pair ) current ;
rank: 599
score: 98.88705105251736
patch: if ( ! first CaMeL Iteration ) {
rank: 599
score: 98.72227783203125
patch: while ( iter < n CaMeL C ) {
rank: 599
score: 98.608154296875
patch: int iter ; ++ iter ; * * /
rank: 599
score: 98.52265014648438
patch: / ; ++ iter ; while ++ iter ;
rank: 599
score: 98.49854625355114
patch: throw new Runtime CaMeL Exception ( $STRING$ + ; }
rank: 599
score: 98.45928955078125
patch: ++ iter + 1 ; break ;
rank: 600
score: 98.91680908203125
patch: entry = < Point CaMeL Vector CaMeL Value CaMeL Pair > ) {
rank: 600
score: 98.88511352539062
patch: if ( current CaMeL Residuals != 0 ) {
rank: 600
score: 98.88424917367789
patch: double [ ] current CaMeL Objective ( current CaMeL Residuals ) ;
rank: 600
score: 98.60805053710938
patch: ++ iter ; try { iter ; * ;
rank: 600
score: 98.52208600725446
patch: ++ iter ; ++ length ;
rank: 600
score: 98.49854454627403
patch: if ( ! 0 . is CaMeL Empty ( ; ) )
rank: 600
score: 98.45926666259766
patch: if ( ++ iter >= 0 )
rank: 601
score: 98.91593070652173
patch: if ( weight CaMeL Matrix CaMeL Sqrt . weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Cost ) ) {
rank: 601
score: 98.88412475585938
patch: while ( iter < n CaMeL C ; true ) {
rank: 601
score: 98.60798863002232
patch: -- iter ; ++ iter ;
rank: 601
score: 98.52103678385417
patch: ++ ++ ++ iter ;
rank: 601
score: 98.49836077008929
patch: if ( . is CaMeL Empty ( ) ) return null ; }
rank: 601
score: 98.45894368489583
patch: synchronized ( this ) { ++ iter ; break ; }
rank: 602
score: 98.91588774181548
patch: protected Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > ( ) {
rank: 602
score: 98.88260904947917
patch: int [ ] current CaMeL Objective = jac CaMeL Norm ;
rank: 602
score: 98.87823486328125
patch: / * compute CaMeL Residuals ( current CaMeL Residuals ) ;
rank: 602
score: 98.72041015625
patch: synchronized ( this ) { ++ iter ; }
rank: 602
score: 98.60789905894886
patch: int iter ; / * * / ++ iter ;
rank: 602
score: 98.52068481445312
patch: ++ iter ; ++ iter ; else / }
rank: 602
score: 98.49827880859375
patch: if ( iter != null ; ++ iter ;
rank: 602
score: 98.45881652832031
patch: ++ iter ) { ++ iter ;
rank: 603
score: 98.91583862304688
patch: n CaMeL R = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , 0 ) ;
rank: 603
score: 98.88255896935097
patch: boolean first CaMeL Iteration = false ; int iter = 0 ;
rank: 603
score: 98.87223677201705
patch: while ( true ) { ++ n CaMeL R ;
rank: 603
score: 98.71886097301136
patch: ++ iter * / * ++ iter ; * /
rank: 603
score: 98.60722212357955
patch: i * ++ ; ++ iter ; ++ iter ;
rank: 603
score: 98.5202880859375
patch: ++ iter ; ++ 1 ; ++ 1 ;
rank: 603
score: 98.45834350585938
patch: ++ iter ; return null ; }
rank: 604
score: 99.03310259650735
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = compute CaMeL Weighted CaMeL Jacobian (
rank: 604
score: 98.9156982421875
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Objective ) ; }
rank: 604
score: 98.88228352864583
patch: Point CaMeL Vector CaMeL Value CaMeL Pair 1 = current ;
rank: 604
score: 98.87147216796875
patch: int iter = current CaMeL Point . length ;
rank: 604
score: 98.60666725852273
patch: ++ iter ; ++ iter ; int iter ++ ;
rank: 604
score: 98.52025756835937
patch: ++ iter ; iter * ; -- iter ;
rank: 604
score: 98.49755859375
patch: ++ ++ [ 0 ] ;
rank: 605
score: 99.03288130326705
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker ;
rank: 605
score: 98.98324819711539
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair this = current ;
rank: 605
score: 98.91556980298913
patch: Iterator < Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > iter = 0 ;
rank: 605
score: 98.87070922851562
patch: while ( true ) { Convergence CaMeL Checker .
rank: 605
score: 98.71710205078125
patch: ++ iter * / / * /
rank: 605
score: 98.60615678267045
patch: / * ++ iter ; / * ++ iter ;
rank: 605
score: 98.52015380859375
patch: ++ iter ; ++ iter ; ; } iter
rank: 605
score: 98.49720110212054
patch: / * / * * /
rank: 605
score: 98.4578524502841
patch: if ( ! index CaMeL Of ( iter ) )
rank: 606
score: 99.031494140625
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair set = current ;
rank: 606
score: 98.91549072265624
patch: Iterator <= Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Objective ) ;
rank: 606
score: 98.8783428485577
patch: Point CaMeL Vector CaMeL Value CaMeL Pair $NUMBER$ checker = current ;
rank: 606
score: 98.86939697265625
patch: ++ iter ; final Convergence CaMeL Checker ; {
rank: 606
score: 98.71602172851563
patch: if ( iter < iter ) ++ iter ;
rank: 606
score: 98.60530229048295
patch: ++ iter ; ++ iter ; int - 1 ;
rank: 606
score: 98.5196533203125
patch: ++ iter ; ; ++ ; ++ iter ;
rank: 606
score: 98.49718299278847
patch: else { throw new Runtime CaMeL Exception ( $STRING$ ; } }
rank: 606
score: 98.45771928267045
patch: ++ iter ; while ( iter ++ >= 0 )
rank: 607
score: 99.0313720703125
patch: ++ 1 ; final Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 607
score: 98.91542358398438
patch: for ( Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker : checker ) {
rank: 607
score: 98.87795785757211
patch: int qr CaMeL Decomposition = current CaMeL Point [ iter ] ;
rank: 607
score: 98.86734008789062
patch: while ( iter < n CaMeL R ; true ) {
rank: 607
score: 98.60519409179688
patch: this . ++ iter ; ++ iter ; if iter ;
rank: 607
score: 98.5194580078125
patch: / ; ++ iter ; ++ iter ; ;
rank: 607
score: 98.49697641225961
patch: if ( . is CaMeL Empty ( ; ) ) break ;
rank: 607
score: 98.45574951171875
patch: if ( iter < 0 )
rank: 608
score: 98.91494605654762
patch: found = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ; }
rank: 608
score: 98.86633911132813
patch: while ( true ) { ++ iter ; {
rank: 608
score: 98.71537272135417
patch: ++ iter ; new Point CaMeL Vector CaMeL Value CaMeL Pair
rank: 608
score: 98.60441450639205
patch: ++ iter ; ++ iter ; / / / ;
rank: 608
score: 98.49673897879464
patch: ++ [ * 0 ] ;
rank: 608
score: 98.45475769042969
patch: final ; ++ iter - 1 ;
rank: 609
score: 99.03111921037946
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair checker =
rank: 609
score: 98.91480654761905
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) . do CaMeL Optimize ( ) ;
rank: 609
score: 98.8730977376302
patch: Point CaMeL Vector CaMeL Value CaMeL Pair new = current ;
rank: 609
score: 98.86286078559027
patch: while ( true ) { qtf .
rank: 609
score: 98.71448364257813
patch: if ( iter > 0 ) ++ iter ;
rank: 609
score: 98.51699829101562
patch: ++ iter ; ++ iter ; ++ / /
rank: 609
score: 98.49662272135417
patch: throw new Runtime CaMeL Exception ( $STRING$ , this ) ;
rank: 609
score: 98.45467122395833
patch: int iter = iter ; while ( iter != null )
rank: 610
score: 98.91471557617187
patch: ret = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , n CaMeL C ) ;
rank: 610
score: 98.87279256184895
patch: if ( current CaMeL Cost <= n CaMeL C ) {
rank: 610
score: 98.86216430664062
patch: if ( first CaMeL Iteration && true ) {
rank: 610
score: 98.71441180889423
patch: ++ iter ; throw new Runtime CaMeL Exception ( $STRING$ ) ;
rank: 610
score: 98.6034823330966
patch: ++ iter ; / * * / / iter ;
rank: 610
score: 98.49656575520834
patch: if ( ! 0 . is CaMeL Empty ( ) ) return iter ;
rank: 610
score: 98.454345703125
patch: ++ iter ; while ( this . iter != null )
rank: 611
score: 98.973876953125
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair stream = current ;
rank: 611
score: 98.8704833984375
patch: int iter = jac CaMeL Norm [ iter ] ;
rank: 611
score: 98.86019897460938
patch: while ( iter <= n CaMeL C ; true ) {
rank: 611
score: 98.71339768629808
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + $STRING$ ;
rank: 611
score: 98.60313924153645
patch: int iter ; ++ iter ; * / ++ iter ;
rank: 611
score: 98.51586303710937
patch: ++ iter ; ++ 1 ; -- iter ;
rank: 611
score: 98.49568684895833
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + 1 + 1 ;
rank: 611
score: 98.45384632457386
patch: if ( ! iter . is CaMeL Empty ; ;
rank: 612
score: 99.03021240234375
patch: int Point CaMeL Vector CaMeL Value CaMeL Pair > checker = null ;
rank: 612
score: 98.97337928185097
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = get ;
rank: 612
score: 98.91443980823864
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , weight CaMeL Matrix CaMeL Sqrt ) ;
rank: 612
score: 98.870361328125
patch: if ( current CaMeL Objective < n CaMeL C ) {
rank: 612
score: 98.85760498046875
patch: / / compute CaMeL Cost ( n CaMeL R ) ;
rank: 612
score: 98.71246807391827
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ ; }
rank: 612
score: 98.60301717122395
patch: ++ iter ; ++ iter ; / * int iter ;
rank: 612
score: 98.51576538085938
patch: iter ; ++ iter ; ++ iter ; }
rank: 612
score: 98.49562377929688
patch: else { ++ iter ; = iter ; }
rank: 612
score: 98.45334201388889
patch: if ( ++ iter == 0 ) {
rank: 613
score: 98.97298490084134
patch: e = compute CaMeL Weighted CaMeL Jacobian ( qtf ) ;
rank: 613
score: 98.91437639508929
patch: boolean first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , 0 ) ;
rank: 613
score: 98.87011108398437
patch: byte [ ] current CaMeL Objective = current ;
rank: 613
score: 98.85619506835937
patch: ++ iter ; final Convergence CaMeL Checker iter ;
rank: 613
score: 98.71230246803977
patch: ++ iter ; iter = iter . iter ( ;
rank: 613
score: 98.60263061523438
patch: this . ++ iter ; ++ iter ; for iter ;
rank: 613
score: 98.51551164899554
patch: iter ; iter if ++ ;
rank: 613
score: 98.49513596754808
patch: if ( iter > 0 ; return . [ 0 ] ;
rank: 613
score: 98.45309448242188
patch: if ( iter >= 0 ) { ++ iter ; }
rank: 614
score: 98.96926645132211
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = $STRING$ ;
rank: 614
score: 98.91338556463069
patch: n CaMeL C = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Point ) ;
rank: 614
score: 98.86746215820312
patch: double [ ] current CaMeL Objective = qtf ) ;
rank: 614
score: 98.85613403320312
patch: qtf [ iter ] = current ; }
rank: 614
score: 98.71160419170673
patch: throw new Runtime CaMeL Exception ( $STRING$ + n CaMeL C ;
rank: 614
score: 98.60231711647727
patch: ++ iter ; while iter ; current . iter ;
rank: 614
score: 98.5150146484375
patch: ++ iter ; ++ length ; ++ iter ;
rank: 614
score: 98.49482421875
patch: try { ++ iter ; while ++ iter ;
rank: 614
score: 98.45283508300781
patch: if ( ++ iter != 0 )
rank: 615
score: 98.91334117542614
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( weight CaMeL Matrix CaMeL Sqrt . operate ( ) ) ; }
rank: 615
score: 98.86611938476562
patch: if ( 0 < n CaMeL C ) {
rank: 615
score: 98.85562133789062
patch: ++ iter ; final Convergence CaMeL Checker ) {
rank: 615
score: 98.71075439453125
patch: if ( ++ iter < n CaMeL C ) break ;
rank: 615
score: 98.60225830078124
patch: ++ iter ; ++ iter ; Integer iter ;
rank: 615
score: 98.51468505859376
patch: ++ iter ; ++ max ; -- iter ;
rank: 615
score: 98.4947509765625
patch: else { if ( ! iter == null ;
rank: 616
score: 98.96814903846153
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair class = current ;
rank: 616
score: 98.91303045099431
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point . length ( ) ) ;
rank: 616
score: 98.86474609375
patch: int [ ] current CaMeL Residuals = current ;
rank: 616
score: 98.85513305664062
patch: compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ;
rank: 616
score: 98.71050555889423
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( ++ 1 ;
rank: 616
score: 98.6021728515625
patch: ++ iter ; ++ iter ; * / ;
rank: 616
score: 98.51458740234375
patch: ++ iter ; iter * /
rank: 616
score: 98.49432779947917
patch: if ( . is CaMeL Empty ( ) ) return ++ iter ; }
rank: 616
score: 98.45257568359375
patch: ++ iter ; if ( this . iter == 0 )
rank: 617
score: 98.91255326704545
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , weighted CaMeL Jacobian ) ;
rank: 617
score: 98.8636474609375
patch: if ( current CaMeL Cost != 0 ) {
rank: 617
score: 98.85472523082386
patch: while ( ! checker . first CaMeL Iteration ) {
rank: 617
score: 98.60200805664063
patch: try { ++ iter ; ++ iter ; }
rank: 617
score: 98.51414794921875
patch: ++ iter ; iter / 1 = iter ;
rank: 617
score: 98.494140625
patch: Iterator iter = iter . iterator ++ ; else {
rank: 617
score: 98.45179966517857
patch: synchronized ( ++ iter ) {
rank: 618
score: 99.02801513671875
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair current =
rank: 618
score: 98.96578275240384
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair package = current ;
rank: 618
score: 98.91234130859375
patch: n CaMeL R = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , true ) ;
rank: 618
score: 98.86197603665866
patch: i = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 618
score: 98.85020955403645
patch: Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair
rank: 618
score: 98.71025933159723
patch: ++ iter - 1 ; break ; }
rank: 618
score: 98.50595092773438
patch: ++ ( ++ iter ;
rank: 618
score: 98.49396306818181
patch: if ( iter < iter ) { continue ; }
rank: 618
score: 98.45090738932292
patch: if ( ++ iter - iter ) {
rank: 619
score: 99.02785818917411
patch: ++ Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current ;
rank: 619
score: 98.96436485877403
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair substring = current ;
rank: 619
score: 98.91215587797619
patch: comparator . qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , 0 ) ) ;
rank: 619
score: 98.8609619140625
patch: int n CaMeL R = current CaMeL Point [ iter ] ;
rank: 619
score: 98.71010335286458
patch: ++ iter ; while ( ; ) {
rank: 619
score: 98.601806640625
patch: ++ iter ; ++ iter ; int * /
rank: 619
score: 98.50099400111607
patch: ++ iter ; ++ list ;
rank: 619
score: 98.49388020833334
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + $NUMBER$ , null ;
rank: 619
score: 98.44992065429688
patch: ++ iter ; if ( iter < 0 )
rank: 620
score: 98.91176535866477
patch: private Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > current = null ;
rank: 620
score: 98.86070838341347
patch: int iter = compute CaMeL Residuals ( current CaMeL Point ) ;
rank: 620
score: 98.84654541015625
patch: boolean first CaMeL Iteration = first CaMeL Iteration ;
rank: 620
score: 98.60153198242188
patch: ++ iter ; ++ iter ; ; * ++ iter ;
rank: 620
score: 98.49384014423077
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ; iter ;
rank: 620
score: 98.4498799641927
patch: if ( iter == null ) break ; ++ iter ;
rank: 621
score: 99.02752326516544
patch: weighted CaMeL Jacobian = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ,
rank: 621
score: 98.9107998934659
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) . operate ( current CaMeL Cost ) ;
rank: 621
score: 98.85953776041667
patch: boolean first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt ;
rank: 621
score: 98.70817427201705
patch: ++ iter * / * * * * * /
rank: 621
score: 98.601513671875
patch: ++ iter ; iter ; * / break ;
rank: 621
score: 98.4932861328125
patch: if ( . is CaMeL Empty ( ) ) . add ;
rank: 621
score: 98.48902239118304
patch: iter iter ++ ; ++ ;
rank: 621
score: 98.44943576388889
patch: if ( this . iter == null )
rank: 622
score: 99.0274658203125
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = true ;
rank: 622
score: 98.91044284986413
patch: this . weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) [ iter ] ;
rank: 622
score: 98.85854270241477
patch: Object qr CaMeL Decomposition ( current CaMeL Point ) ;
rank: 622
score: 98.8436508178711
patch: if ( true && true ) {
rank: 622
score: 98.70805358886719
patch: ++ iter = iter + 1 ;
rank: 622
score: 98.60139604048295
patch: ++ iter ; ++ iter ; final ++ iter ;
rank: 622
score: 98.48782784598214
patch: iter ; ++ iter ; }
rank: 623
score: 99.02731119791666
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker [ ] = current ;
rank: 623
score: 98.96090932992789
patch: ++ compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Residuals ) ;
rank: 623
score: 98.91036551339286
patch: this . weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ) ;
rank: 623
score: 98.8582763671875
patch: k = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 623
score: 98.8422607421875
patch: while ( true ) { while ( true )
rank: 623
score: 98.70779184194711
patch: ++ iter ; if ( iter < iter ) ++ iter ;
rank: 623
score: 98.4930908203125
patch: / * / * * / ++ iter ;
rank: 623
score: 98.48259626116071
patch: ++ iter ; ++ / ;
rank: 623
score: 98.44922485351563
patch: ++ iter ; if ( iter == 0 ;
rank: 624
score: 98.95803833007812
patch: while ( n CaMeL C < n CaMeL C ) {
rank: 624
score: 98.91032270951705
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , n CaMeL R ) ;
rank: 624
score: 98.85794067382812
patch: double [ ] current CaMeL Residuals = current CaMeL Point ;
rank: 624
score: 98.84066772460938
patch: while ( true ) { ) {
rank: 624
score: 98.70761108398438
patch: ++ iter ; this . ++ iter ; }
rank: 624
score: 98.60121848366477
patch: ++ iter ; ++ iter ; if iter ; ;
rank: 624
score: 98.49294211647727
patch: throw new Runtime CaMeL Exception ( $STRING$ ) ; ;
rank: 624
score: 98.4808349609375
patch: ++ iter ; ; iter
rank: 625
score: 99.02635846819196
patch: int [ ] current CaMeL Objective = current CaMeL Point . length ;
rank: 625
score: 98.9572245279948
patch: iter = compute CaMeL Cost ( current CaMeL Residuals ) ;
rank: 625
score: 98.909521484375
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , $NUMBER$ ) ;
rank: 625
score: 98.85784912109375
patch: double [ ] current CaMeL Objective ( qtf ) ;
rank: 625
score: 98.83922322591145
patch: / * compute CaMeL Cost ( n CaMeL R ) ;
rank: 625
score: 98.7071200284091
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current ;
rank: 625
score: 98.60118519176136
patch: ++ iter ; ++ iter ; int * iter ;
rank: 625
score: 98.4927978515625
patch: return ++ [ 1 ] ;
rank: 625
score: 98.47933523995536
patch: ++ current ; ++ iter ;
rank: 625
score: 98.44903564453125
patch: ++ iter ; if ( iterator != null )
rank: 626
score: 99.02569221047794
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair [ ] current = current CaMeL Point ;
rank: 626
score: 98.95554762620192
patch: ++ iter ; final int CaMeL Value = n CaMeL C ;
rank: 626
score: 98.90887741815476
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point [ 0 ] ) ;
rank: 626
score: 98.85721842447917
patch: if ( n CaMeL C <= n CaMeL R ) {
rank: 626
score: 98.83800252278645
patch: while ( iter <= n CaMeL R ; true ) {
rank: 626
score: 98.47562408447266
patch: ++ 0 ;
rank: 626
score: 98.44867498224431
patch: while ( iter != null ) { ++ iter ;
rank: 627
score: 99.02532087053571
patch: int CaMeL Value = current CaMeL Point [ n CaMeL R ] ;
rank: 627
score: 98.95552884615384
patch: ++ iter ; final Point CaMeL Vector CaMeL Value CaMeL Pair [
rank: 627
score: 98.9088134765625
patch: result = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Objective ) ;
rank: 627
score: 98.85691139914773
patch: Point CaMeL Vector CaMeL Value CaMeL Pair = current ;
rank: 627
score: 98.83756103515626
patch: while ( ! first CaMeL Iteration ) { {
rank: 627
score: 98.59975179036458
patch: ++ iter ; ++ * - iter ; ++ iter ;
rank: 627
score: 98.46972045898437
patch: ++ iter ; iter
rank: 628
score: 99.02522547104779
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current CaMeL Point = current CaMeL Point ,
rank: 628
score: 98.95459923377403
patch: ++ iter = compute CaMeL Cost ( current CaMeL Residuals ) ;
rank: 628
score: 98.90859587296195
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point . current CaMeL Point . current CaMeL Point .
rank: 628
score: 98.83754475911458
patch: ++ iter ; final boolean first CaMeL Iteration = true ;
rank: 628
score: 98.70442708333333
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + ;
rank: 628
score: 98.5996981534091
patch: / * ] iter ; ++ ; ++ iter ;
rank: 628
score: 98.49165482954545
patch: if ( iter < 0 ) { continue ; }
rank: 628
score: 98.44841851128473
patch: ++ iter $NUMBER$ [ iter 1 ] ;
rank: 629
score: 98.95273061899039
patch: ++ iter = final Point CaMeL Vector CaMeL Value CaMeL Pair ;
rank: 629
score: 98.90762094350961
patch: iter = < Point CaMeL Vector CaMeL Value CaMeL Pair > ;
rank: 629
score: 98.836181640625
patch: return checker . operate ( current CaMeL Objective ) ;
rank: 629
score: 98.70375061035156
patch: ++ iter ; ; if ( ;
rank: 629
score: 98.5988037109375
patch: / * ++ ++ iter ; int iter ;
rank: 629
score: 98.49139959161931
patch: ++ iter ; * * * / ++ iter ;
rank: 629
score: 98.45762416294643
patch: / iter ; ++ iter ;
rank: 629
score: 98.44807572798295
patch: if ( ! index CaMeL Of ( current ) )
rank: 630
score: 98.90757057883523
patch: public Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > current = null ;
rank: 630
score: 98.85507202148438
patch: Point CaMeL Vector CaMeL Value CaMeL Pair list = current ;
rank: 630
score: 98.70343017578125
patch: ++ iter ] = iter ; break ; }
rank: 630
score: 98.49116821289063
patch: return new Object [ ] = ++ iter ;
rank: 630
score: 98.45710100446429
patch: ++ iter ; iter / *
rank: 630
score: 98.447412109375
patch: final int iter = iter ; ++ iter ;
rank: 631
score: 99.02462768554688
patch: double [ ] current CaMeL Objective = false ;
rank: 631
score: 98.90740094866071
patch: public Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > ( ) {
rank: 631
score: 98.85408528645833
patch: boolean first CaMeL Iteration = ( current CaMeL Point ) ;
rank: 631
score: 98.83185424804688
patch: while ( iter <= n CaMeL R ) {
rank: 631
score: 98.7034024325284
patch: ++ iter ; iter = iter . iter ; }
rank: 631
score: 98.59717407226563
patch: try { ++ iter ; } int iter ;
rank: 632
score: 98.94704026442308
patch: i = compute CaMeL Weighted CaMeL Jacobian ( qtf ) ;
rank: 632
score: 98.90730086616848
patch: x CaMeL Norm += weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Objective ) ; }
rank: 632
score: 98.85365804036458
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair = checker ;
rank: 632
score: 98.83074951171875
patch: ++ n CaMeL C ; } if ( true ) {
rank: 632
score: 98.70315551757812
patch: ++ iter ; iter = iter . iter . iter ;
rank: 632
score: 98.59712727864583
patch: ++ iter ; ++ iter ; * / int iter ;
rank: 632
score: 98.490185546875
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + 0 , null ;
rank: 632
score: 98.44692993164062
patch: if ( iter == 0 ) continue ; ++ iter ;
rank: 633
score: 99.0242919921875
patch: int [ ] current CaMeL Objective = compute CaMeL Residuals ( current CaMeL Objective ) ;
rank: 633
score: 98.90637788318452
patch: < Point CaMeL Vector CaMeL Value CaMeL Pair <= Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 633
score: 98.853271484375
patch: if ( current CaMeL Objective == 0 ) {
rank: 633
score: 98.8292744954427
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair < double )
rank: 633
score: 98.59679565429687
patch: ++ iter ; ++ iter ; int start ;
rank: 633
score: 98.48992047991071
patch: * * * ++ iter ;
rank: 633
score: 98.44753592354911
patch: ++ iter ; ; iter ;
rank: 633
score: 98.44670104980469
patch: ++ iter ; hash CaMeL Code ;
rank: 634
score: 99.024169921875
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current CaMeL Point = current ; / /
rank: 634
score: 98.94649564302884
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair delta = current ;
rank: 634
score: 98.90630812872024
patch: entry = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Objective ) ;
rank: 634
score: 98.8523661295573
patch: if ( n CaMeL R != n CaMeL C ) {
rank: 634
score: 98.82305230034723
patch: ++ iter ; final Convergence CaMeL Checker .
rank: 634
score: 98.70222981770833
patch: ++ iter ; while ( iter < n CaMeL C )
rank: 634
score: 98.489697265625
patch: return ++ iter ;
rank: 634
score: 98.445556640625
patch: ++ iter ; if ( this . iter != null )
rank: 635
score: 99.02325908954327
patch: Point CaMeL Vector CaMeL Value CaMeL Pair > current = current ;
rank: 635
score: 98.94075833834134
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair default = current ;
rank: 635
score: 98.85235040838069
patch: String qr CaMeL Decomposition ( current CaMeL Point ) ;
rank: 635
score: 98.59616921164773
patch: ++ iter ; ++ iter ; start * iter ;
rank: 635
score: 98.48956768329327
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ; else {
rank: 635
score: 98.44456481933594
patch: int iter = iter + iter ;
rank: 635
score: 98.44408307756696
patch: ++ 1 ; ++ 1 ;
rank: 636
score: 98.9393780048077
patch: ++ iter = compute CaMeL Cost ( current CaMeL Point ) ;
rank: 636
score: 98.90447443181819
patch: iter = < Point CaMeL Vector CaMeL Value CaMeL Pair > ( current CaMeL Point , current CaMeL Objective ) ;
rank: 636
score: 98.85021362304687
patch: double [ ] qr CaMeL Decomposition = current ;
rank: 636
score: 98.816357421875
patch: if ( n CaMeL C < 0 ) {
rank: 636
score: 98.7014911358173
patch: new Point CaMeL Vector CaMeL Value CaMeL Pair ( current . ;
rank: 636
score: 98.59614701704545
patch: ++ iter ; ++ iter ; ++ ( iter ;
rank: 636
score: 98.48926595052083
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + 1 , iter ;
rank: 636
score: 98.44445037841797
patch: ++ iter - n CaMeL R ;
rank: 636
score: 98.44284493582589
patch: ++ out ; ++ iter ;
rank: 637
score: 99.02095249720982
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = $STRING$ ;
rank: 637
score: 98.93918081430289
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair chars = current ;
rank: 637
score: 98.90418590198864
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ; ++ iter ++ ;
rank: 637
score: 98.81479714133523
patch: qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian (
rank: 637
score: 98.70135028545673
patch: ++ iter ; while ( iter < n CaMeL C ) {
rank: 637
score: 98.59551447088069
patch: ++ iter ; int iter ; / * / /
rank: 637
score: 98.48920288085938
patch: else { if ( iter > 1 ) {
rank: 637
score: 98.43402971540179
patch: ++ iter ; iter ; /
rank: 638
score: 98.90373091264205
patch: x CaMeL Norm = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Objective ) ;
rank: 638
score: 98.84953169389205
patch: boolean first CaMeL Iteration ( current CaMeL Point ) ;
rank: 638
score: 98.81201171875
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair new ;
rank: 638
score: 98.69984944661458
patch: ++ iter ; while ( iter . iter != null )
rank: 638
score: 98.5953369140625
patch: int iter + iter ;
rank: 638
score: 98.48859252929688
patch: ++ iter ; while ; { ++ iter ;
rank: 638
score: 98.44189453125
patch: while ( iter >= 0 ) {
rank: 638
score: 98.43089076450893
patch: ++ iter ; ; else ;
rank: 639
score: 98.937744140625
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair diag = current ;
rank: 639
score: 98.84913126627605
patch: Point CaMeL Vector CaMeL Value CaMeL Pair iter = current ;
rank: 639
score: 98.80883178710937
patch: qr CaMeL Decomposition ( current CaMeL Residuals ) ;
rank: 639
score: 98.69977416992188
patch: ++ iter * / * * * * ;
rank: 639
score: 98.59487915039062
patch: ++ iter ; ++ iter ; int iter {
rank: 639
score: 98.488037109375
patch: if ( iter == iter ; return null ;
rank: 639
score: 98.44045681423611
patch: if ( ++ iter & 1 ) {
rank: 639
score: 98.41649518694196
patch: ++ iter ; iter break ;
rank: 640
score: 98.90261008522727
patch: n CaMeL R = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Cost ) ;
rank: 640
score: 98.8479512532552
patch: if ( current CaMeL Objective < n CaMeL R ) {
rank: 640
score: 98.80733032226563
patch: qr CaMeL Decomposition [ iter ] = current ;
rank: 640
score: 98.69938520951705
patch: ++ iter ; ++ iter * / ++ iter ;
rank: 640
score: 98.59427897135417
patch: ++ iter ; try ; if iter ; ++ iter ;
rank: 640
score: 98.487353515625
patch: if ( . is CaMeL Empty ( ) ) continue ; ++ iter ;
rank: 640
score: 98.44010620117187
patch: try { Thread . sleep ( iter ) ;
rank: 640
score: 98.41644287109375
patch: ++ iter ; ++ / /
rank: 641
score: 98.93223219651442
patch: ++ iter = current CaMeL Point [ current CaMeL Objective ] ;
rank: 641
score: 98.90214399857955
patch: this . weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , 1 ) ;
rank: 641
score: 98.84708251953126
patch: if ( n CaMeL R != 0 ) {
rank: 641
score: 98.80657404119319
patch: / * compute CaMeL Cost ( current CaMeL Point ,
rank: 641
score: 98.69805908203125
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current
rank: 641
score: 98.43955993652344
patch: ++ n CaMeL R ; break ;
rank: 641
score: 98.41455078125
patch: ++ iter ; ++ stop ;
rank: 642
score: 99.01686789772727
patch: double [ ] current CaMeL Objective = qtf ;
rank: 642
score: 98.92850748697917
patch: i = compute CaMeL Cost ( current CaMeL Residuals ) ;
rank: 642
score: 98.90191359747024
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ; ++ iter ;
rank: 642
score: 98.84323952414773
patch: int qr CaMeL Decomposition ( current CaMeL Point ) ;
rank: 642
score: 98.80610961914063
patch: Iterator iter = checker . iter ( ) ;
rank: 642
score: 98.59344482421875
patch: int 0 ; ++ iter ;
rank: 642
score: 98.48726981026786
patch: if ( . is CaMeL Empty ( ) ) return iter ; }
rank: 642
score: 98.43800354003906
patch: if ( iter != - 1 )
rank: 642
score: 98.41361781529018
patch: ++ iter ; iter ; }
rank: 643
score: 99.01571219308036
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair Math checker = current ;
rank: 643
score: 98.92786583533653
patch: ++ iter = checker . operate ( current CaMeL Objective ) ;
rank: 643
score: 98.90172230113636
patch: n CaMeL C = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Objective ) ;
rank: 643
score: 98.84213256835938
patch: if ( current CaMeL Residuals == n CaMeL R ) {
rank: 643
score: 98.80020751953126
patch: while ( true ) { { ++ iter ;
rank: 643
score: 98.59325062144886
patch: ++ iter ; ++ iter ; * * 1 ;
rank: 643
score: 98.48699951171875
patch: if ( iter == 0 ; throw null ;
rank: 643
score: 98.43796608664773
patch: ++ iter ; if ( iter != - 1 )
rank: 643
score: 98.41250174386161
patch: ++ iter ; ; ++ ;
rank: 644
score: 98.90107865767045
patch: this . weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , length ) ;
rank: 644
score: 98.84194946289062
patch: int iter = Point CaMeL Vector CaMeL Value CaMeL Pair ;
rank: 644
score: 98.79692077636719
patch: while ( true || true ) {
rank: 644
score: 98.59322102864583
patch: ++ iter ; ++ iter ; / * / iter ;
rank: 644
score: 98.43790893554687
patch: ++ iter ; ; while ( true ) {
rank: 645
score: 98.89951393821023
patch: <= Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > current = current ;
rank: 645
score: 98.84127807617188
patch: if ( current CaMeL Residuals < n CaMeL C ) {
rank: 645
score: 98.79632568359375
patch: while ( true && true ) { {
rank: 645
score: 98.69644165039062
patch: int iter = current CaMeL Point . length - iter ;
rank: 645
score: 98.59257202148437
patch: ++ iter ; ; * ; ++ iter ;
rank: 645
score: 98.48671177455357
patch: / * ++ iter * /
rank: 645
score: 98.43703391335227
patch: if ( iter >= 0 ) { ++ iter ;
rank: 645
score: 98.40745326450893
patch: ++ iter ; ++ super ;
rank: 646
score: 99.01443045479911
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = 1 ;
rank: 646
score: 98.92667643229167
patch: iter = compute CaMeL Cost ( current CaMeL Objective ) ;
rank: 646
score: 98.89943625710227
patch: < Point CaMeL Vector CaMeL Value CaMeL Pair <= Point CaMeL Vector CaMeL Value CaMeL Pair > current = current ;
rank: 646
score: 98.8390401204427
patch: return compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 646
score: 98.79334716796875
patch: if ( checker . first CaMeL Iteration ) {
rank: 646
score: 98.69536743164062
patch: ++ iter * / * ++ iter ; ;
rank: 646
score: 98.59225463867188
patch: ++ iter ; try { ++ iter ; *
rank: 646
score: 98.4866610440341
patch: } if ( iter == null ; return iter ;
rank: 646
score: 98.43673095703124
patch: if ( get CaMeL Context ( ) . ;
rank: 646
score: 98.40629359654018
patch: iter / ; ++ iter ;
rank: 647
score: 99.01425170898438
patch: int [ ] current CaMeL Point = current ;
rank: 647
score: 98.92252291165866
patch: i = final Point CaMeL Vector CaMeL Value CaMeL Pair > ;
rank: 647
score: 98.89840932992789
patch: ( iter < Point CaMeL Vector CaMeL Value CaMeL Pair > )
rank: 647
score: 98.79283558238636
patch: while ( true ) { Convergence CaMeL Checker . {
rank: 647
score: 98.6951192220052
patch: iter = new Point CaMeL Vector CaMeL Value CaMeL Pair ;
rank: 647
score: 98.59197387695312
patch: ++ iter ; ; / * ++ iter ;
rank: 647
score: 98.4864501953125
patch: if ( . is CaMeL Empty ( ; ) ) return null ;
rank: 647
score: 98.43654378255208
patch: if ( ++ iter >= 1 ) {
rank: 648
score: 98.92056274414062
patch: i = final Point CaMeL Vector CaMeL Value CaMeL Pair ;
rank: 648
score: 98.89747203480114
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Cost ) ;
rank: 648
score: 98.83841959635417
patch: boolean first CaMeL Iteration = checker . operate ( ) ;
rank: 648
score: 98.5919189453125
patch: ++ iter ; ++ iter ; int iter = iter ;
rank: 648
score: 98.48631940569196
patch: return super . ++ ; }
rank: 648
score: 98.43611907958984
patch: if ( iter != this ) {
rank: 648
score: 98.40519496372768
patch: ++ 1 ; ++ start ;
rank: 649
score: 99.01365152994792
patch: if ( true ) { ++ iter ;
rank: 649
score: 98.89734468005952
patch: < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = get CaMeL Point ( current CaMeL Point ) ;
rank: 649
score: 98.8380878155048
patch: int current CaMeL Objective = current CaMeL Point [ iter ] ;
rank: 649
score: 98.78937639508929
patch: ++ n CaMeL C ; }
rank: 649
score: 98.59051513671875
patch: / * ++ iter ; * / / ++ iter ;
rank: 649
score: 98.48626154119319
patch: else { ++ iter ; } return true ; }
rank: 649
score: 98.43589782714844
patch: while ( true ) { final ;
rank: 650
score: 99.01349748883929
patch: Point CaMeL Vector CaMeL Value CaMeL Pair checker = current ; / *
rank: 650
score: 98.89734417459239
patch: this . weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , qtf ) ;
rank: 650
score: 98.69446818033855
patch: int iter = current . index CaMeL Of ( iter ;
rank: 650
score: 98.5904541015625
patch: ++ iter ; ++ iter ; ++ * ++ iter ;
rank: 650
score: 98.48621215820313
patch: if ( iter < iter ) return iter ;
rank: 650
score: 98.43560791015625
patch: if ( iter == 0 ) ++ iter ;
rank: 650
score: 98.39289202008929
patch: if iter ] = iter ;
rank: 651
score: 98.89613560267857
patch: ret = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Objective ) ;
rank: 651
score: 98.83692345252403
patch: int [ ] current CaMeL Objective ( current CaMeL Point ) ;
rank: 651
score: 98.7860440340909
patch: qr CaMeL Decomposition ( current CaMeL Residuals ) ; }
rank: 651
score: 98.69439697265625
patch: while ( iter < iter )
rank: 651
score: 98.59044300426136
patch: ++ iter ; ++ iter ; * * * /
rank: 651
score: 98.48617989676339
patch: else ++ iter ; * /
rank: 651
score: 98.43538411458333
patch: ++ iter 1 ; while ( true )
rank: 651
score: 98.39176722935268
patch: ++ iter ; ++ ++ ;
rank: 652
score: 98.8957287016369
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , qtf ) ;
rank: 652
score: 98.8362325032552
patch: if ( n CaMeL C >= n CaMeL C ) {
rank: 652
score: 98.69377790178571
patch: ++ iter = ++ iter ;
rank: 652
score: 98.59033203125
patch: ++ iter ; iter ; * ++ iter ;
rank: 652
score: 98.48600463867187
patch: if ( iter > 0 ; * / ;
rank: 652
score: 98.43522813585069
patch: ++ iter ; while ( iter ++ )
rank: 652
score: 98.39096505301339
patch: ++ iter ; ++ in ;
rank: 653
score: 98.90611775716145
patch: ++ iter = current CaMeL Residuals [ qtf ] ;
rank: 653
score: 98.89536830357143
patch: Iterator < Point CaMeL Vector CaMeL Value CaMeL Pair , Point CaMeL Vector CaMeL Value CaMeL Pair > checker ;
rank: 653
score: 98.69306776258681
patch: ++ iter * / / ++ iter ;
rank: 653
score: 98.5894775390625
patch: ++ iter ; ++ * - iter ; break ;
rank: 653
score: 98.48572887073864
patch: throw new Runtime CaMeL Exception ( $STRING$ ; } ;
rank: 653
score: 98.43479919433594
patch: int iter = iter / iter ;
rank: 653
score: 98.38841901506696
patch: ++ iter ; ; * /
rank: 654
score: 98.89527529761905
patch: r = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Objective ) ;
rank: 654
score: 98.83233173076923
patch: int [ ] current CaMeL Objective = current CaMeL Point ) ;
rank: 654
score: 98.78243001302083
patch: while ( true ) { ++ true ;
rank: 654
score: 98.69229465060764
patch: ++ iter * / ++ iter * /
rank: 654
score: 98.58875621448864
patch: ++ iter ; ++ iter ; throw ( iter ;
rank: 654
score: 98.48565673828125
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ; else
rank: 654
score: 98.43471457741477
patch: ++ iter ; if ( ! iter . equals ;
rank: 654
score: 98.38833182198661
patch: ++ iter ; ++ delta ;
rank: 655
score: 99.01263427734375
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > current = null ;
rank: 655
score: 98.89750532670455
patch: ++ iter ; boolean first CaMeL Iteration = 0 ;
rank: 655
score: 98.89515752377717
patch: this . weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , qtf ) ;
rank: 655
score: 98.83223470052083
patch: if ( current CaMeL Cost != n CaMeL R ) {
rank: 655
score: 98.77945556640626
patch: weighted CaMeL Residual ( current CaMeL Residuals ) ;
rank: 655
score: 98.69215698242188
patch: ++ iter * / * * * / ;
rank: 655
score: 98.58871459960938
patch: ++ 1 ; ++ iter ; int iter ;
rank: 655
score: 98.48543875558036
patch: if ( . is CaMeL Empty ( ; ) ) ++ iter ;
rank: 655
score: 98.38680594308036
patch: ++ iter ; iter ; iter
rank: 656
score: 99.0126201923077
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current CaMeL Point ;
rank: 656
score: 98.89727783203125
patch: i = compute CaMeL Cost ( current CaMeL Objective ) ;
rank: 656
score: 98.89484969429348
patch: ? final Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > current = current ;
rank: 656
score: 98.83189039963942
patch: i = ( Point CaMeL Vector CaMeL Value CaMeL Pair > )
rank: 656
score: 98.77431640625
patch: compute CaMeL Cost ( current CaMeL Residuals ) ;
rank: 656
score: 98.69190562855114
patch: ++ iter ; if ( iter == - 1 ;
rank: 656
score: 98.58854370117187
patch: ++ iter ; * ; { ++ iter ;
rank: 656
score: 98.48540387834821
patch: if ( . is CaMeL Empty ( ) ; ++ ++ iter ;
rank: 656
score: 98.43277740478516
patch: ++ iter ; case - 1 :
rank: 656
score: 98.38670131138393
patch: ++ iterator ; ++ iter ;
rank: 657
score: 98.89460555366848
patch: CaMeL Point CaMeL Vector CaMeL Value CaMeL Pair current = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current ) ;
rank: 657
score: 98.831640625
patch: Object current CaMeL Point = current CaMeL Point ;
rank: 657
score: 98.77393188476563
patch: ++ iter ; final Convergence CaMeL Checker . {
rank: 657
score: 98.58847878196023
patch: ++ iter ; iter ; / * * / /
rank: 657
score: 98.48479352678571
patch: ++ += iter * iter ;
rank: 657
score: 98.43254743303571
patch: ++ iter [ iter ] ;
rank: 657
score: 98.38521902901786
patch: ++ ++ ++ ++ iter ;
rank: 658
score: 98.89447312127976
patch: ( iter Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Objective ) ) ;
rank: 658
score: 98.89380900065105
patch: ++ iter = checker . operate ( qtf ) ;
rank: 658
score: 98.83128943810097
patch: final int CaMeL Value = current CaMeL Point [ iter ] ;
rank: 658
score: 98.76619096235795
patch: int iter = current CaMeL Objective [ iter ] ;
rank: 658
score: 98.5883076985677
patch: ++ iter ; ++ iter ; System . iter ++ ;
rank: 658
score: 98.48470633370536
patch: if ( ! 0 . is CaMeL Empty ( ) ) throw ;
rank: 658
score: 98.43240356445312
patch: if ( iter == - 1 ) continue ;
rank: 658
score: 98.3829345703125
patch: ++ 0 ; ++ 1 ;
rank: 659
score: 99.00894601004464
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = $NUMBER$ ;
rank: 659
score: 98.89446466619319
patch: < Point CaMeL Vector CaMeL Value CaMeL Pair > < Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 659
score: 98.7660140991211
patch: while ( iter > 0 ) {
rank: 659
score: 98.69021606445312
patch: ++ iter ; throw new Runtime CaMeL Exception ( ; }
rank: 659
score: 98.5879794034091
patch: ++ iter ; ++ iter ; for iter ; ;
rank: 659
score: 98.48401489257813
patch: ++ iter ; if ++ iter < $NUMBER$ ;
rank: 659
score: 98.4318115234375
patch: try { Thread . sleep ( $NUMBER$ ) ;
rank: 659
score: 98.38144356863839
patch: ++ copy ; ++ iter ;
rank: 660
score: 99.00885881696429
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair * checker = current ;
rank: 660
score: 98.8942234205163
patch: Iterator <= Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > iter = current ;
rank: 660
score: 98.88995361328125
patch: if ( n CaMeL C < current CaMeL Residuals ) {
rank: 660
score: 98.83049926757812
patch: double [ ] current CaMeL Objective = this ;
rank: 660
score: 98.75970458984375
patch: if ( current CaMeL Point != 0 ) {
rank: 660
score: 98.5868896484375
patch: / * ++ iter ; / * / /
rank: 660
score: 98.48349434988839
patch: if ( iter < iter )
rank: 660
score: 98.43145751953125
patch: ++ iter ; if ( iter == 1 )
rank: 661
score: 99.00843912760416
patch: / * Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current ;
rank: 661
score: 98.89398193359375
patch: synchronized ( weighted CaMeL Residual ) {
rank: 661
score: 98.88927205403645
patch: return compute CaMeL Weighted CaMeL Jacobian ( qtf ) ;
rank: 661
score: 98.82656860351562
patch: boolean first CaMeL Iteration = n CaMeL C < 0 ;
rank: 661
score: 98.58687337239583
patch: ++ iter ; ++ iter ; int * ++ iter ;
rank: 661
score: 98.48348388671874
patch: if ( iter > 1 ; return iter ;
rank: 661
score: 98.43145141601562
patch: if ( iter >= 0 ) ++ iter ;
rank: 661
score: 98.37870570591518
patch: ++ iter ; ++ ; /
rank: 662
score: 98.89346976902173
patch: Iterator < Point CaMeL Vector CaMeL Value CaMeL Pair <= Point CaMeL Vector CaMeL Value CaMeL Pair > iter = current ;
rank: 662
score: 98.82437133789062
patch: if ( current CaMeL Residuals < n CaMeL R ) {
rank: 662
score: 98.75743519176136
patch: / / compute CaMeL Cost ( current CaMeL Point ,
rank: 662
score: 98.5865145596591
patch: ++ iter ; ++ iter ; System . ; ;
rank: 662
score: 98.48340782752403
patch: throw new Runtime CaMeL Exception ( $STRING$ + 0 , $STRING$ ;
rank: 662
score: 98.43049760298295
patch: if ( ! index CaMeL Of ( iter ) ;
rank: 662
score: 98.37832205636161
patch: ++ min ; ++ iter ;
rank: 663
score: 99.006591796875
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair [ ] checker = null ;
rank: 663
score: 98.89299982244319
patch: private Point CaMeL Vector CaMeL Value CaMeL Pair ( Point CaMeL Vector CaMeL Value CaMeL Pair current CaMeL Point ) ;
rank: 663
score: 98.88522338867188
patch: it = compute CaMeL Cost ( current CaMeL Residuals ) ;
rank: 663
score: 98.82352294921876
patch: boolean [ ] current CaMeL Objective = current ;
rank: 663
score: 98.75655517578124
patch: ++ iter ; final Convergence CaMeL Checker true ;
rank: 663
score: 98.58559163411458
patch: / * ++ iter ; / * / ++ iter ;
rank: 663
score: 98.4832763671875
patch: throw new Illegal CaMeL Argument CaMeL Exception ( new Exception ( ) ; }
rank: 663
score: 98.3765380859375
patch: ++ new ++ ;
rank: 664
score: 98.89255593039773
patch: x CaMeL Norm = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Cost ) ;
rank: 664
score: 98.88494873046875
patch: i = compute CaMeL Cost ( current CaMeL Point ) ;
rank: 664
score: 98.75602583451705
patch: while ( ! first CaMeL Iteration && true ) {
rank: 664
score: 98.68755340576172
patch: ++ iter ; current . ++ ;
rank: 664
score: 98.58528275923295
patch: ++ iter ; iter ; * - * 1 ;
rank: 664
score: 98.48310198102679
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + iter ; }
rank: 664
score: 98.42990944602273
patch: if ( ! name . equals ( iter ) ;
rank: 664
score: 98.37465994698661
patch: / ; ; ++ iter ;
rank: 665
score: 99.00620930989584
patch: else final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = current ;
rank: 665
score: 98.8916652513587
patch: < Point CaMeL Vector CaMeL Value CaMeL Pair > < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = null ;
rank: 665
score: 98.88387044270833
patch: int [ ] current CaMeL Objective ( qtf ) ;
rank: 665
score: 98.82188720703125
patch: if ( current CaMeL Objective != 0 ) {
rank: 665
score: 98.75559303977273
patch: ++ solved CaMeL Cols [ iter ] = current ;
rank: 665
score: 98.585205078125
patch: ++ iter ; try ; int iter ; ++ iter ;
rank: 665
score: 98.48299560546874
patch: throw new Runtime CaMeL Exception ( $STRING$ + ;
rank: 665
score: 98.42969428168402
patch: final ; if ( iter == null )
rank: 665
score: 98.37118966238839
patch: iter ; ++ ; / /
rank: 666
score: 99.00542805989583
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = current CaMeL Point ,
rank: 666
score: 98.89154607599431
patch: x CaMeL Norm += weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Residuals ) ;
rank: 666
score: 98.82187721946023
patch: if ( n CaMeL R < n CaMeL C )
rank: 666
score: 98.75145374644886
patch: ++ n CaMeL C ; if ( true ) {
rank: 666
score: 98.68507385253906
patch: ++ iter * / iter * /
rank: 666
score: 98.58487548828126
patch: ++ iter ; iter ; System . out ;
rank: 666
score: 98.48290076622597
patch: throw new Runtime CaMeL Exception ( $STRING$ + this . current ;
rank: 666
score: 98.37063598632812
patch: ++ $NUMBER$ ;
rank: 667
score: 99.00321138822116
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker = 0 ;
rank: 667
score: 98.890625
patch: Iterator < Point CaMeL Vector CaMeL Value CaMeL Pair > checker =
rank: 667
score: 98.81827799479167
patch: if ( n CaMeL C > n CaMeL C ) {
rank: 667
score: 98.7510757446289
patch: while ( ! first CaMeL Iteration )
rank: 667
score: 98.68424849076705
patch: ++ iter ; while ( iter == null ) {
rank: 667
score: 98.5841064453125
patch: ++ iter ; int iter ; while ++ iter ;
rank: 667
score: 98.48231858473558
patch: ++ iter ; for iter = iter . iterator ++ ; }
rank: 667
score: 98.36778767903645
patch: ++ iter ; ; /
rank: 668
score: 99.00179617745536
patch: if ( current CaMeL Point . length >= n CaMeL C ) {
rank: 668
score: 98.89020647321429
patch: temp = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Objective ) ;
rank: 668
score: 98.87405395507812
patch: Point CaMeL Vector CaMeL Value CaMeL Pair current = null ;
rank: 668
score: 98.81392415364583
patch: int iter = compute CaMeL Cost ( current CaMeL Point ,
rank: 668
score: 98.75064697265626
patch: iter = current CaMeL Point [ 0 ] ;
rank: 668
score: 98.58354048295455
patch: ++ iter ; ++ iter ; out = iter ;
rank: 668
score: 98.48178335336539
patch: else { throw new Runtime CaMeL Exception ++ iter ; } }
rank: 668
score: 98.4285000887784
patch: ++ iter ; while ( iter ++ != 0 )
rank: 668
score: 98.3669942220052
patch: iter ; ++ 0 ;
rank: 669
score: 98.88953218005952
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point ) ; if ( true ) {
rank: 669
score: 98.8693135579427
patch: qtf . qr CaMeL Decomposition ( qtf ) ;
rank: 669
score: 98.8136494954427
patch: if ( n CaMeL R < current CaMeL Objective ) {
rank: 669
score: 98.74968927556819
patch: weighted CaMeL Residual ( current CaMeL Residuals ) ; }
rank: 669
score: 98.58352661132812
patch: ++ iter ; ++ iter ; int * / iter ;
rank: 669
score: 98.48152299360795
patch: if ( iter == 0 ) return null ; else
rank: 669
score: 98.36431884765625
patch: iter ; ; ++ iter ;
rank: 670
score: 99.0004549893466
patch: final double [ ] current CaMeL Objective = current ;
rank: 670
score: 98.88934616815476
patch: this . qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point , 0 ) ) ;
rank: 670
score: 98.8688252766927
patch: iter = compute CaMeL Residuals ( current CaMeL Residuals ) ;
rank: 670
score: 98.8136494954427
patch: double [ ] qr CaMeL Decomposition = current CaMeL Point ;
rank: 670
score: 98.74968872070312
patch: ++ iter ; final if ( true ) {
rank: 670
score: 98.68417358398438
patch: ++ iter ? $NUMBER$ : $NUMBER$ ;
rank: 670
score: 98.5833251953125
patch: ++ iter ; / * * ++ * /
rank: 670
score: 98.48114568536931
patch: else { / * * * / ++ iter ;
rank: 670
score: 98.42808227539062
patch: ++ iter ; ; if ( true ) {
rank: 670
score: 98.36380440848214
patch: iter ; iter } ++ ;
rank: 671
score: 98.88795055042614
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , weight CaMeL Matrix CaMeL Sqrt ) ;
rank: 671
score: 98.8671875
patch: int iter = n CaMeL C ;
rank: 671
score: 98.81092529296875
patch: double [ ] current = current CaMeL Point ;
rank: 671
score: 98.74884643554688
patch: weighted CaMeL Residual [ iter ] = current ;
rank: 671
score: 98.68339029947917
patch: ++ iter ; while ( iter < iter ) { ;
rank: 671
score: 98.5830586751302
patch: ++ iter ; ++ iter ; ++ iter ; break ;
rank: 671
score: 98.47999156605114
patch: if ( iter == 0 ; / * * /
rank: 671
score: 98.42787475585938
patch: ++ iter ; while ( false ) { ;
rank: 671
score: 98.36174665178571
patch: ++ iter ; ; iter }
rank: 672
score: 98.99941580636161
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair , checker = current ;
rank: 672
score: 98.88792835582386
patch: Point CaMeL Vector CaMeL Value CaMeL Pair current = new Point CaMeL Vector CaMeL Value CaMeL Pair ( checker ) ;
rank: 672
score: 98.8645731608073
patch: if ( n CaMeL C < current CaMeL Objective ) {
rank: 672
score: 98.8107401529948
patch: if ( n CaMeL C == n CaMeL C ) {
rank: 672
score: 98.745361328125
patch: / / compute CaMeL Cost ( current CaMeL Residuals ,
rank: 672
score: 98.68210671164773
patch: ++ iter ; while ( iter <= iter ) {
rank: 672
score: 98.58283025568181
patch: ++ iter ; ++ * - iter ; iter ;
rank: 672
score: 98.47967936197917
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + [ 1 ] ;
rank: 672
score: 98.42780095880681
patch: ++ iter ; while ( iter ++ == 0 )
rank: 672
score: 98.36160714285714
patch: ++ iter ; ++ Arrays ;
rank: 673
score: 98.99929574819711
patch: int Point CaMeL Vector CaMeL Value CaMeL Pair checker = current ;
rank: 673
score: 98.88743954613095
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , weight CaMeL Matrix CaMeL Sqrt ) ;
rank: 673
score: 98.8092753092448
patch: if ( current CaMeL Cost <= n CaMeL R ) {
rank: 673
score: 98.74360795454545
patch: / / compute CaMeL Cost ( n CaMeL R ,
rank: 673
score: 98.68138631184895
patch: ++ iter ; if ( iter < $NUMBER$ ) break ;
rank: 673
score: 98.4796630859375
patch: if ( ! 0 . is CaMeL Empty ( ) ) . remove ;
rank: 673
score: 98.42763061523438
patch: if ( iter < 0 ) ++ iter ;
rank: 673
score: 98.35520935058594
patch: ++ start ;
rank: 674
score: 98.8080546061198
patch: if ( n CaMeL R != n CaMeL R ) {
rank: 674
score: 98.68137817382812
patch: ++ iter ; / * ++ iter * /
rank: 674
score: 98.58239135742187
patch: ++ 0 ; ++ iter ; while iter ;
rank: 674
score: 98.42756791548295
patch: ++ iter ; while ( iter != - 1 )
rank: 674
score: 98.35223999023438
patch: ++ ++ 1 ;
rank: 675
score: 98.86166381835938
patch: int iter = current CaMeL Residuals [ qtf ] ;
rank: 675
score: 98.80722045898438
patch: int [ ] current CaMeL Residuals = current CaMeL Point ;
rank: 675
score: 98.7422762784091
patch: Iterator iter = current CaMeL Point [ 0 ] ;
rank: 675
score: 98.68133544921875
patch: ++ iter ; ; ++ iter - iter ;
rank: 675
score: 98.58223266601563
patch: ++ iter ; ++ iter ; int break ;
rank: 675
score: 98.47923990885417
patch: if ( . is CaMeL Empty ( ) ) ; ++ iter ; }
rank: 675
score: 98.42695922851563
patch: while ( true ) { if ( true )
rank: 676
score: 98.9958965594952
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair read = current ;
rank: 676
score: 98.8855313387784
patch: protected Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair > current = null ;
rank: 676
score: 98.8069559733073
patch: if ( n CaMeL R <= n CaMeL R ) {
rank: 676
score: 98.7420425415039
patch: / / if ( true ) {
rank: 676
score: 98.68033854166667
patch: ++ iter ; ++ iter * ++ ;
rank: 676
score: 98.58106578480114
patch: ++ iter ; ++ iter ; * * / /
rank: 676
score: 98.4791729266827
patch: if ( ! 0 . is CaMeL Empty ( ) ) ;
rank: 676
score: 98.30826822916667
patch: iter ++ ; ++ ;
rank: 677
score: 98.9947979266827
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = false ;
rank: 677
score: 98.88544256036931
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , weighted CaMeL Residual ) ;
rank: 677
score: 98.80397338867188
patch: i = current CaMeL Point [ iter ] ;
rank: 677
score: 98.74140276227679
patch: while ( true && true )
rank: 677
score: 98.58045543323864
patch: ++ iter ; ++ iter ; ++ * false ;
rank: 677
score: 98.47867431640626
patch: else { ++ iter ; } / * ;
rank: 677
score: 98.42625732421875
patch: ++ iter ; if ( iter <= 0 )
rank: 677
score: 98.290771484375
patch: ++ iter ; ; else
rank: 678
score: 98.99160531850961
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair do = current ;
rank: 678
score: 98.88465465198864
patch: ! weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) . operate ( current CaMeL Residuals ) ;
rank: 678
score: 98.80369262695312
patch: int current CaMeL Point = current CaMeL Point ;
rank: 678
score: 98.73919122869319
patch: int iter = current CaMeL Objective [ true ] ;
rank: 678
score: 98.67899576822917
patch: ++ iter * / * * ; ;
rank: 678
score: 98.58001098632812
patch: ++ iter ; else * ; ++ iter ;
rank: 678
score: 98.47862141927084
patch: throw new Runtime CaMeL Exception ( $STRING$ + this . get CaMeL Name ;
rank: 678
score: 98.42503662109375
patch: ++ iter ; System . arraycopy ( iter ;
rank: 678
score: 98.28467814127605
patch: ++ iter ; iter }
rank: 679
score: 98.99123128255208
patch: int [ ] current CaMeL Objective = current CaMeL Point ,
rank: 679
score: 98.88444380326705
patch: Point CaMeL Vector CaMeL Value CaMeL Pair current = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current ) ;
rank: 679
score: 98.7998934659091
patch: double iter = current CaMeL Point [ 0 ] ;
rank: 679
score: 98.73551940917969
patch: while ( ( true ) ) {
rank: 679
score: 98.67832641601562
patch: ++ iter ; * / * * / ;
rank: 679
score: 98.57909284319196
patch: finally { ++ iter ; ;
rank: 679
score: 98.47797502790179
patch: else { ++ break ; }
rank: 679
score: 98.42396240234375
patch: if ( ! iter [ 0 ] . ;
rank: 679
score: 98.28224182128906
patch: iter ; iter
rank: 680
score: 98.98923903245192
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair trim = current ;
rank: 680
score: 98.8832674893466
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ; ++ iter ++ ;
rank: 680
score: 98.79959106445312
patch: Point CaMeL Vector CaMeL Value CaMeL Pair checker = this ;
rank: 680
score: 98.73529663085938
patch: compute CaMeL Cost ( current CaMeL Objective ) ;
rank: 680
score: 98.6783114346591
patch: ++ iter * / * * ++ iter * /
rank: 680
score: 98.57887961647727
patch: / * ++ iter ; / / / / /
rank: 680
score: 98.47764369419643
patch: ++ < 0 : iter ;
rank: 680
score: 98.42328752790179
patch: ++ iter ; } else {
rank: 680
score: 98.27189127604167
patch: long iter = iter ;
rank: 681
score: 98.8831454190341
patch: private Point CaMeL Vector CaMeL Value CaMeL Pair < Point CaMeL Vector CaMeL Value CaMeL Pair >> current = current ;
rank: 681
score: 98.85591430664063
patch: if ( x CaMeL Norm == 0 ) {
rank: 681
score: 98.73518510298295
patch: / / compute CaMeL Cost ( current CaMeL Objective ,
rank: 681
score: 98.67723999023437
patch: ++ iter ; while ( iter ; break ;
rank: 681
score: 98.47761753627232
patch: if ( ! 0 . is CaMeL Empty ( ) ; continue ;
rank: 681
score: 98.42320667613636
patch: ++ iter 1 [ iter 1 ] ; break ;
rank: 681
score: 98.26884765625
patch: ++ -- iter ;
rank: 682
score: 98.98561448317308
patch: Point CaMeL Vector CaMeL Value CaMeL Pair > checker = get ;
rank: 682
score: 98.88048206676136
patch: n CaMeL C = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , current CaMeL Cost ) ;
rank: 682
score: 98.73466352982955
patch: / * compute CaMeL Cost ( current CaMeL Objective ,
rank: 682
score: 98.67711292613636
patch: while ( iter < iter ) { ++ iter ;
rank: 682
score: 98.57837931315105
patch: int iter ; ++ iter ; / * ++ iter ;
rank: 682
score: 98.477490234375
patch: ++ iter ; for ; ; ; ; ;
rank: 682
score: 98.42242431640625
patch: while ( iter == 0 ) {
rank: 682
score: 98.26358032226562
patch: iter ; iter -- ;
rank: 683
score: 98.87873979048295
patch: this . weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , $NUMBER$ ) ;
rank: 683
score: 98.84315185546875
patch: ++ iter ; ++ n CaMeL C ; {
rank: 683
score: 98.7331314086914
patch: while ( iter <= true ) {
rank: 683
score: 98.67622884114583
patch: if ( iter > 0 ) break ;
rank: 683
score: 98.47710626775569
patch: if ( iter > 0 ; / / * ;
rank: 683
score: 98.42240142822266
patch: if ( is CaMeL Empty ) {
rank: 683
score: 98.25831095377605
patch: if ++ ++ iter ;
rank: 684
score: 98.98416841947116
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair throws = current ;
rank: 684
score: 98.87807395241477
patch: return new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point . length , current CaMeL Objective ) ;
rank: 684
score: 98.84264526367187
patch: ++ iter ; Convergence CaMeL Checker > 0 ;
rank: 684
score: 98.78924005681819
patch: if ( n CaMeL C < n CaMeL R )
rank: 684
score: 98.73295454545455
patch: compute CaMeL Cost ( current CaMeL Residuals ) ; }
rank: 684
score: 98.6759033203125
patch: ++ iter ; * / * * / ++ iter ;
rank: 684
score: 98.57805841619319
patch: ++ iter ; ++ iter ; ++ * * ;
rank: 684
score: 98.47666015625
patch: ++ iter ; for ; ; ; ; )
rank: 684
score: 98.42221408420139
patch: ++ iter ; if ( iter != ;
rank: 684
score: 98.24579620361328
patch: iter ++ ;
rank: 685
score: 98.87706502278645
patch: first CaMeL Iteration = current CaMeL Point [ 0 ] ;
rank: 685
score: 98.8362704190341
patch: ++ iter = current CaMeL Point [ 0 ] ;
rank: 685
score: 98.78587036132812
patch: List [ ] current CaMeL Objective = current ;
rank: 685
score: 98.73284357244319
patch: iter = checker . operate ( current CaMeL Point ,
rank: 685
score: 98.6754483309659
patch: ++ iter ; / * * ++ iter * /
rank: 685
score: 98.57784016927083
patch: ++ iter ; ++ iter ; int iter + iter ;
rank: 685
score: 98.47646859975961
patch: throw new Runtime CaMeL Exception ( $STRING$ + iter * $STRING$ ;
rank: 685
score: 98.42144220525569
patch: while ( true ) { ++ iter = iter ;
rank: 685
score: 98.244140625
patch: iter ; ++ 1 ;
rank: 686
score: 98.87681995738636
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point . length , 0 ) ;
rank: 686
score: 98.78379516601562
patch: if ( n CaMeL C != 0 ) {
rank: 686
score: 98.73251953125
patch: while ( true ) { qtf . {
rank: 686
score: 98.67406116832386
patch: if ( iter < n CaMeL R ) break ;
rank: 686
score: 98.47645152698864
patch: if ( iter == 0 ; / * * ;
rank: 686
score: 98.242431640625
patch: iter ; iter ++ ;
rank: 687
score: 98.98235529119319
patch: final int [ ] current CaMeL Objective = current ;
rank: 687
score: 98.8762958233173
patch: Iterator < Point CaMeL Vector CaMeL Value CaMeL Pair > iter =
rank: 687
score: 98.73246547154018
patch: ++ n CaMeL R ; }
rank: 687
score: 98.6740234375
patch: ++ iter ; * / * * * ;
rank: 687
score: 98.57771606445313
patch: ++ iter ; / * * ; * /
rank: 687
score: 98.47632649739583
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ; } } else {
rank: 687
score: 98.42103271484375
patch: ++ iter ; if ( true ) continue ;
rank: 687
score: 98.23855590820312
patch: iter ; if ++ ;
rank: 688
score: 98.87619018554688
patch: y = compute CaMeL Cost ( current CaMeL Point ) ;
rank: 688
score: 98.8234530362216
patch: ++ iter ; final int CaMeL Value = 0 ;
rank: 688
score: 98.73186645507812
patch: while ( ! ! first CaMeL Iteration ) {
rank: 688
score: 98.67394409179687
patch: ++ iter ; * / ; ++ iter ;
rank: 688
score: 98.57762562144886
patch: ++ iter ; ++ iter ; / * * ;
rank: 688
score: 98.47395463423295
patch: if ( iter == 0 || is CaMeL Empty ;
rank: 688
score: 98.42090861002605
patch: if ( false ) {
rank: 688
score: 98.23638153076172
patch: ++ true ;
rank: 689
score: 98.9803466796875
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = current ,
rank: 689
score: 98.87486853966347
patch: long current CaMeL Cost = current CaMeL Point [ 0 ] ;
rank: 689
score: 98.73040771484375
patch: ++ iter ; final Convergence CaMeL Checker > ;
rank: 689
score: 98.67345513237848
patch: ++ iter ; * / * ; ;
rank: 689
score: 98.57759602864583
patch: ++ iter ; ++ iter ; System . iter iter ;
rank: 689
score: 98.47317270132211
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; ;
rank: 689
score: 98.42039659288194
patch: ++ iter ; ; while ( true )
rank: 690
score: 98.87380149147727
patch: this . weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , permutation ) ;
rank: 690
score: 98.8197354403409
patch: ++ iter ; boolean first CaMeL Iteration = true ;
rank: 690
score: 98.77427978515625
patch: float [ ] current CaMeL Objective = current ;
rank: 690
score: 98.72854614257812
patch: / * while ( true ) {
rank: 690
score: 98.67322540283203
patch: ++ iter * ; ++ iter ;
rank: 690
score: 98.57674560546874
patch: ++ 0 ; ++ iter ; int iter ;
rank: 690
score: 98.4727313701923
patch: throw new Runtime CaMeL Exception ( $STRING$ + iter ) ; }
rank: 690
score: 98.41985321044922
patch: if ( false ) ++ iter ;
rank: 690
score: 98.21700032552083
patch: ++ $STRING$ ++ iter ;
rank: 691
score: 98.9790771484375
patch: double [ ] current CaMeL Objective = true ;
rank: 691
score: 98.87300248579545
patch: n CaMeL R = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , current CaMeL Residuals ) ;
rank: 691
score: 98.8187255859375
patch: ++ iter ; { ++ n CaMeL C ;
rank: 691
score: 98.6728182705966
patch: ++ iter ; while ( iter ; ) { ;
rank: 691
score: 98.57652587890625
patch: int iter ; / * / ++ iter ;
rank: 691
score: 98.47267503004808
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ , iter ;
rank: 691
score: 98.41945190429688
patch: ++ iter ; if ( iter != null ;
rank: 691
score: 98.21543884277344
patch: ++ $STRING$ ;
rank: 692
score: 98.87261408025569
patch: x CaMeL Norm += weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , weighted CaMeL Jacobian ) ;
rank: 692
score: 98.81723854758523
patch: ++ iter = current CaMeL Point [ iter ] ;
rank: 692
score: 98.76542524857955
patch: if ( first CaMeL Iteration ) { ++ iter ;
rank: 692
score: 98.67227172851562
patch: ++ iter ; / * * * * /
rank: 692
score: 98.57627360026042
patch: ++ iter ; ++ iter ; / * ] iter ;
rank: 692
score: 98.47265625
patch: if ( iter == 0 ) return null ; }
rank: 692
score: 98.41912163628473
patch: ++ iter ; while ( true ) ;
rank: 692
score: 98.21487426757812
patch: ++ ++ ++ 1 ;
rank: 693
score: 98.97681603064903
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair insert = current ;
rank: 693
score: 98.87191772460938
patch: int current CaMeL Cost = current CaMeL Point . length ;
rank: 693
score: 98.81046295166016
patch: ++ iter = n CaMeL C ;
rank: 693
score: 98.72366943359376
patch: while ( iter < n CaMeL R ) {
rank: 693
score: 98.67151489257813
patch: ++ iter * / * / iter * /
rank: 693
score: 98.576123046875
patch: if ++ iter ; / * ++ iter ;
rank: 693
score: 98.47229942908653
patch: throw new Illegal CaMeL Argument CaMeL Exception ( new Exception ; }
rank: 693
score: 98.41893768310547
patch: ++ iter - iter ; try {
rank: 693
score: 98.21295166015625
patch: ++ iter ; / /
rank: 694
score: 98.8713711825284
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , 0 , 1 ) ;
rank: 694
score: 98.80537109375
patch: ++ iter ; ++ n CaMeL R ; {
rank: 694
score: 98.7625399502841
patch: int qtf [ ] = current CaMeL Point ;
rank: 694
score: 98.47203572591145
patch: else { ++ iter ; * / = iter ; }
rank: 694
score: 98.41738891601562
patch: final ; this . ++ iter ;
rank: 694
score: 98.2080322265625
patch: ++ - iter ;
rank: 695
score: 98.9705810546875
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair remove = current ;
rank: 695
score: 98.8706805889423
patch: if ( weight CaMeL Matrix CaMeL Sqrt . operate ( ) )
rank: 695
score: 98.75938720703125
patch: / / boolean first CaMeL Iteration = true ;
rank: 695
score: 98.7210693359375
patch: / / compute CaMeL Cost ( n CaMeL C ,
rank: 695
score: 98.57503255208333
patch: ++ iter ; ++ iter ; iter ; ++ iter ;
rank: 695
score: 98.41731262207031
patch: final ; ++ iter - iter ;
rank: 695
score: 98.20292154947917
patch: } ++ ++ iter ;
rank: 696
score: 98.96883451021634
patch: Point CaMeL Vector CaMeL Value CaMeL Pair > checker = this ;
rank: 696
score: 98.87017267400569
patch: first CaMeL Iteration = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , first CaMeL Iteration ) ;
rank: 696
score: 98.7210360440341
patch: / * compute CaMeL Cost ( current CaMeL Residuals ,
rank: 696
score: 98.66873931884766
patch: ++ iter ; / * ; ;
rank: 696
score: 98.57501220703125
patch: ++ iter ; if iter + iter ; ++ iter ;
rank: 696
score: 98.4714599609375
patch: if ( iter > 0 ; return . ;
rank: 696
score: 98.41632080078125
patch: final int iter = iter * iter ;
rank: 696
score: 98.20277913411458
patch: ++ iter ; ; }
rank: 697
score: 98.96700345552884
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair else = current ;
rank: 697
score: 98.86972878196023
patch: < Point CaMeL Vector CaMeL Value CaMeL Pair > < Point CaMeL Vector CaMeL Value CaMeL Pair ( checker ) ;
rank: 697
score: 98.75792846679687
patch: Point CaMeL Vector CaMeL Value CaMeL Pair -- ;
rank: 697
score: 98.47144571940105
patch: if ; ++ iter ;
rank: 697
score: 98.41595458984375
patch: if ( ++ iter == 0 ) continue ;
rank: 698
score: 98.966552734375
patch: if ( current CaMeL Cost >= n CaMeL C ) {
rank: 698
score: 98.86968439275569
patch: this . weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals , $NUMBER$ ) ;
rank: 698
score: 98.8009033203125
patch: int iter = current CaMeL Residuals [ 0 ] ;
rank: 698
score: 98.756640625
patch: double [ ] jac CaMeL Norm = current ;
rank: 698
score: 98.71873779296875
patch: ++ iter ; final Convergence CaMeL Checker ; }
rank: 698
score: 98.6681620279948
patch: ++ iter ; if ( iter <= 0 ) break ;
rank: 698
score: 98.57464599609375
patch: / * ] iter ; /
rank: 698
score: 98.47140066964286
patch: ++ * * iter ; }
rank: 698
score: 98.41436767578125
patch: result [ iter ] = iter ;
rank: 698
score: 98.1990966796875
patch: ++ iter ; ; try
rank: 699
score: 98.96593299278847
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair if = current ;
rank: 699
score: 98.86949666341145
patch: Iterator < Point CaMeL Vector CaMeL Value CaMeL Pair > checker
rank: 699
score: 98.75562133789063
patch: long [ ] current CaMeL Objective = current ;
rank: 699
score: 98.7181167602539
patch: while ( true ) { iter ;
rank: 699
score: 98.5746358235677
patch: ++ iter ; ++ iter ; break ; ++ iter ;
rank: 699
score: 98.47129603794643
patch: if ( ! 0 . is CaMeL Empty ( ; ) . ;
rank: 699
score: 98.41334533691406
patch: if ( ! iter == null )
rank: 699
score: 98.1989974975586
patch: ++ max ;
rank: 700
score: 98.9625
patch: int [ ] current CaMeL Objective = this ;
rank: 700
score: 98.86845259232955
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point . length , current CaMeL Objective ) ;
rank: 700
score: 98.79563210227273
patch: ++ iter ; final int CaMeL Value = current ;
rank: 700
score: 98.75523792613636
patch: double iter = current CaMeL Point [ iter ] ;
rank: 700
score: 98.71726296164773
patch: ++ iter ; final Convergence CaMeL Checker > 0 ;
rank: 700
score: 98.57457386363636
patch: ++ iter ; ++ iter ; int iter * ;
rank: 700
score: 98.4707364169034
patch: if ( iter > 0 ) { break ; }
rank: 700
score: 98.41334364149306
patch: if ( iter == this ) break ;
rank: 700
score: 98.19423421223958
patch: } ; ++ iter ;
rank: 701
score: 98.96034592848558
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair [ ] checker ;
rank: 701
score: 98.86766468394886
patch: Iterator < Point CaMeL Vector CaMeL Value CaMeL Pair , Point CaMeL Vector CaMeL Value CaMeL Pair current = current ;
rank: 701
score: 98.75442504882812
patch: / * boolean first CaMeL Iteration = 0 ;
rank: 701
score: 98.66719563802083
patch: ++ iter * / * * / ++ iter * /
rank: 701
score: 98.47071940104166
patch: throw new Illegal CaMeL Argument CaMeL Exception ( new Exception iter ) ; }
rank: 701
score: 98.41290283203125
patch: if ( ++ iter - iter )
rank: 701
score: 98.19406127929688
patch: ++ ++ iter ; ;
rank: 702
score: 98.9586181640625
patch: int [ ] current CaMeL Objective = qtf ;
rank: 702
score: 98.86586692116477
patch: return weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) . double CaMeL Value ( ) ; }
rank: 702
score: 98.79471435546876
patch: ++ iter ; { ++ n CaMeL R ;
rank: 702
score: 98.71427778764205
patch: while ( iter < solved CaMeL Cols ; true )
rank: 702
score: 98.5736971768466
patch: ++ iter ; ++ iter ; * * * ;
rank: 702
score: 98.4706561748798
patch: throw new Runtime CaMeL Exception ( $STRING$ + 1 + 0 ;
rank: 702
score: 98.41145833333333
patch: if ( iter == this . ++ )
rank: 702
score: 98.19083862304687
patch: / ++ iter ;
rank: 703
score: 98.95572916666667
patch: double [ ] current CaMeL Objective = 0 . 0 ;
rank: 703
score: 98.86473499644886
patch: < Point CaMeL Vector CaMeL Value CaMeL Pair > checker
rank: 703
score: 98.71389770507812
patch: while ( n CaMeL C < 0 ) {
rank: 703
score: 98.66490173339844
patch: ++ iter * / / * ;
rank: 703
score: 98.57356770833333
patch: ++ iter ; ++ iter ; * * - iter ;
rank: 703
score: 98.40821533203125
patch: ++ iter ; if ( iter == null ;
rank: 703
score: 98.18779296875
patch: ++ ! iter ;
rank: 704
score: 98.86385091145833
patch: iter = compute CaMeL Cost ( current CaMeL Point ) ;
rank: 704
score: 98.78773803710938
patch: if ( current CaMeL Cost < 0 ) {
rank: 704
score: 98.74867942116477
patch: boolean iter = current CaMeL Point [ iter ] ;
rank: 704
score: 98.7108154296875
patch: ++ iter ; { ++ iter ;
rank: 704
score: 98.5732421875
patch: ++ iter ; / * * * * / /
rank: 704
score: 98.47050337357955
patch: if ( iter == 0 ; / / * ;
rank: 704
score: 98.4077880859375
patch: ++ iter ? iter ? iter : iter ;
rank: 704
score: 98.1841328938802
patch: if iter * ++ ;
rank: 705
score: 98.86378062855114
patch: this . weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Point , null ) ;
rank: 705
score: 98.74761962890625
patch: int current CaMeL Objective = current CaMeL Objective ;
rank: 705
score: 98.7081298828125
patch: / * compute CaMeL Cost ( n CaMeL R ,
rank: 705
score: 98.66417236328125
patch: throw new Illegal CaMeL Argument CaMeL Exception ( ;
rank: 705
score: 98.5732421875
patch: ++ iter ; ++ iter ; System ; ++ iter ;
rank: 705
score: 98.47036508413461
patch: if ( . is CaMeL Empty ( ) ) throw iter ;
rank: 705
score: 98.40719604492188
patch: ++ iter $NUMBER$ [ 0 ] ; break ;
rank: 705
score: 98.18128458658855
patch: break ; ++ iter ;
rank: 706
score: 98.94917805989583
patch: Point CaMeL Vector CaMeL Value CaMeL Pair checker = null ;
rank: 706
score: 98.85813395182292
patch: if ( ! weight CaMeL Matrix CaMeL Sqrt . ) {
rank: 706
score: 98.78679865056819
patch: ++ iter = current CaMeL Residuals [ 0 ] ;
rank: 706
score: 98.7066650390625
patch: ++ ++ iter ; final Convergence CaMeL Checker ;
rank: 706
score: 98.66356065538194
patch: final ; ++ iter * / * /
rank: 706
score: 98.57283158735795
patch: ++ iter ; ++ iter ; System . ; *
rank: 706
score: 98.40718841552734
patch: ++ iter ; return new ; }
rank: 706
score: 98.1797587076823
patch: ++ < ++ iter ;
rank: 707
score: 98.94876802884616
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = $NUMBER$ ;
rank: 707
score: 98.85498046875
patch: entry = get CaMeL Point ( current CaMeL Point ) ;
rank: 707
score: 98.78653564453126
patch: return weighted CaMeL Residual [ qtf ] ;
rank: 707
score: 98.7064208984375
patch: while ( true ) { { Convergence CaMeL Checker ;
rank: 707
score: 98.57264927455357
patch: ++ iter ; for ++ ;
rank: 707
score: 98.46961263020833
patch: if ( . is CaMeL Empty ( ) ) { return false ; }
rank: 707
score: 98.40677897135417
patch: ++ iter ; if ( break ) {
rank: 707
score: 98.16642252604167
patch: * ; ++ iter ;
rank: 708
score: 98.94873046875
patch: double [ ] current CaMeL Objective = $NUMBER$ . 0 ;
rank: 708
score: 98.853515625
patch: < Point CaMeL Vector CaMeL Value CaMeL Pair ) {
rank: 708
score: 98.73892974853516
patch: int iter = n CaMeL R ;
rank: 708
score: 98.70635986328125
patch: if ( checker == 0 ) {
rank: 708
score: 98.6630859375
patch: ++ iter ; ; ++ iter * / * /
rank: 708
score: 98.57195490056819
patch: ++ iter ; iter ; * / * / /
rank: 708
score: 98.46949114118304
patch: / * * += iter ;
rank: 708
score: 98.40642547607422
patch: vars [ iter ] = iter ;
rank: 708
score: 98.16636149088542
patch: ++ else ++ iter ;
rank: 709
score: 98.94673978365384
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = true ;
rank: 709
score: 98.85320281982422
patch: long current CaMeL Cost = 0 ;
rank: 709
score: 98.7061767578125
patch: ++ n CaMeL C ; } if ( true )
rank: 709
score: 98.66259765625
patch: ++ iter ; * / * * ++ iter ;
rank: 709
score: 98.5712890625
patch: ++ iter ; ++ iter ; / * / / ;
rank: 709
score: 98.46920340401786
patch: else { throw new Runtime CaMeL Exception ( $STRING$ + iter ; }
rank: 709
score: 98.4063949584961
patch: ++ iter $NUMBER$ [ iter ] ;
rank: 709
score: 98.16465250651042
patch: iter ; ++ ++ ;
rank: 710
score: 98.73466186523437
patch: double [ ] current CaMeL Objective = permutation ;
rank: 710
score: 98.70554421164773
patch: while ( iter < n CaMeL C ; true )
rank: 710
score: 98.66224161783855
patch: ++ iter ; while ( iter < iter ) break ;
rank: 710
score: 98.57045491536458
patch: ++ iter ; ++ iter ; / / * / /
rank: 710
score: 98.46910603841145
patch: throw new Illegal CaMeL Argument CaMeL Exception ( new Exception ;
rank: 710
score: 98.40631975446429
patch: final double iter = iter ;
rank: 710
score: 98.16331990559895
patch: ++ iter ; iter {
rank: 711
score: 98.94423264723558
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair list = null ;
rank: 711
score: 98.85124067826705
patch: if ( weight CaMeL Matrix CaMeL Sqrt . ) {
rank: 711
score: 98.73388671875
patch: final Convergence CaMeL Checker < double [ ] ;
rank: 711
score: 98.70165252685547
patch: / / while ( true ) {
rank: 711
score: 98.57044566761364
patch: ++ iter ; ++ iter ; int ++ iter ;
rank: 711
score: 98.46824428013393
patch: if ( ! 0 . is CaMeL Empty ( ) ++ iter ;
rank: 711
score: 98.406298828125
patch: if ( true ) { ++ iter ; }
rank: 712
score: 98.84902954101562
patch: int iter = 0 ;
rank: 712
score: 98.77891956676136
patch: ++ iter ; int iter = n CaMeL C ;
rank: 712
score: 98.7310791015625
patch: Object [ ] current CaMeL Objective = current ;
rank: 712
score: 98.70018920898437
patch: while ( true ) if ( true ) {
rank: 712
score: 98.57012939453125
patch: ++ iter ; int value ;
rank: 712
score: 98.46774088541666
patch: if ( ! 0 . is CaMeL Empty ( ; ) ++ iter ;
rank: 712
score: 98.40409342447917
patch: ++ iter / iter ;
rank: 712
score: 98.15767415364583
patch: if ++ iter ; /
rank: 713
score: 98.72761674360795
patch: if ( n CaMeL R < n CaMeL R )
rank: 713
score: 98.6968994140625
patch: while ( iter <= Convergence CaMeL Checker ) {
rank: 713
score: 98.467724609375
patch: throw new Runtime CaMeL Exception ( $STRING$ + iter + $STRING$ ) ; }
rank: 713
score: 98.40375518798828
patch: while ( iter == null ) {
rank: 713
score: 98.15512084960938
patch: iter
rank: 714
score: 98.94166259765625
patch: int [ ] current CaMeL Objective = false ;
rank: 714
score: 98.8477783203125
patch: check CaMeL Parameters ( current CaMeL Residuals ) ;
rank: 714
score: 98.72726440429688
patch: if ( current CaMeL Point ) {
rank: 714
score: 98.6943692294034
patch: checker = weight CaMeL Matrix CaMeL Sqrt . operate (
rank: 714
score: 98.65995279947917
patch: ++ iter ; if ( ++ n CaMeL C > ;
rank: 714
score: 98.56851196289062
patch: ++ iter ; ++ iter ; int iter { ++ ;
rank: 714
score: 98.46753946940105
patch: else { ++ iter ; } return new ++ ; }
rank: 714
score: 98.40272521972656
patch: final ; try { ++ iter ;
rank: 714
score: 98.15298461914062
patch: iter ; ++ ;
rank: 715
score: 98.94140625
patch: int iter = current CaMeL Objective ( ) ;
rank: 715
score: 98.83775838216145
patch: end = compute CaMeL Cost ( current CaMeL Point ) ;
rank: 715
score: 98.77419026692708
patch: boolean first CaMeL Iteration = true ; {
rank: 715
score: 98.725
patch: Vector [ ] current CaMeL Objective = current ;
rank: 715
score: 98.69360961914063
patch: ++ ( iter ; final Convergence CaMeL Checker ;
rank: 715
score: 98.56837047230114
patch: / * ++ iter ; * ; ++ iter ;
rank: 715
score: 98.46732954545455
patch: if ( iter > 0 ; return iter / ;
rank: 715
score: 98.4016825358073
patch: ++ iter ( ) ;
rank: 716
score: 98.9404296875
patch: Point CaMeL Vector CaMeL Value CaMeL Pair > checker = false ;
rank: 716
score: 98.81541137695312
patch: result = current CaMeL Point [ 0 ] ;
rank: 716
score: 98.77128462357955
patch: compute CaMeL Weighted CaMeL Jacobian ( qtf ) ;
rank: 716
score: 98.72365500710227
patch: if ( n CaMeL C <= n CaMeL C )
rank: 716
score: 98.69300842285156
patch: while ( iter < true ) {
rank: 716
score: 98.56815592447917
patch: ++ iter ; ++ iter ; for iter { ++ ;
rank: 716
score: 98.46725260416666
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + 1 , 0 ;
rank: 716
score: 98.40069580078125
patch: ++ iter + 1 ; ;
rank: 716
score: 98.15220133463542
patch: ++ } ++ iter ;
rank: 717
score: 98.81410910866477
patch: ! compute CaMeL Residuals ( current CaMeL Point ) ;
rank: 717
score: 98.7226318359375
patch: double [ ] current CaMeL Objective = diag ;
rank: 717
score: 98.69268798828125
patch: ++ iter ; final Convergence CaMeL Checker ; ;
rank: 717
score: 98.56793212890625
patch: ++ iter ; ++ iter ; / * * iter ;
rank: 717
score: 98.46724446614583
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + iter + ; }
rank: 717
score: 98.40044403076172
patch: ++ iter ; else break ; }
rank: 717
score: 98.1521708170573
patch: ++ ! ++ iter ;
rank: 718
score: 98.80537632533482
patch: first CaMeL Iteration = current ;
rank: 718
score: 98.75444946289062
patch: if ( n CaMeL R < 0 ) {
rank: 718
score: 98.72257995605469
patch: int iter = jac CaMeL Norm ;
rank: 718
score: 98.692138671875
patch: compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ,
rank: 718
score: 98.56773792613636
patch: int iter ; ++ iter ; / * / ;
rank: 718
score: 98.4669658954327
patch: throw new Runtime CaMeL Exception ( $STRING$ + iter + ; }
rank: 718
score: 98.14599609375
patch: ++ super = iter ;
rank: 719
score: 98.93072979266827
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair > checker = new
rank: 719
score: 98.80048162286931
patch: < Point CaMeL Vector CaMeL Value CaMeL Pair > {
rank: 719
score: 98.71875
patch: short [ ] current CaMeL Objective = current ;
rank: 719
score: 98.69133966619319
patch: ++ n CaMeL R ; if ( true ) {
rank: 719
score: 98.56676374162946
patch: ++ iter ; else iter ;
rank: 719
score: 98.46680797230114
patch: if ( < 0 ) { return null ; }
rank: 719
score: 98.39891899956598
patch: ++ iter ; while ( true ; ;
rank: 719
score: 98.14036051432292
patch: } ++ iter ; ;
rank: 720
score: 98.7982421875
patch: get CaMeL Point ( current CaMeL Point ) ;
rank: 720
score: 98.718359375
patch: int CaMeL Value ( current CaMeL Point ) ;
rank: 720
score: 98.69121442522321
patch: while ( iter ; true )
rank: 720
score: 98.56670270647321
patch: this . ++ iter ; ;
rank: 720
score: 98.46651204427083
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ; ++ ++ iter ;
rank: 720
score: 98.39795684814453
patch: for ( ; iter ++ ) {
rank: 721
score: 98.7894775390625
patch: if ( true )
rank: 721
score: 98.7505215731534
patch: ++ iter ; int first CaMeL Iteration = 0 ;
rank: 721
score: 98.7148681640625
patch: int [ ] current = current CaMeL Point ;
rank: 721
score: 98.69098455255681
patch: while ( iter < n CaMeL R ; true )
rank: 721
score: 98.56647600446429
patch: return false ; ++ iter ;
rank: 721
score: 98.4664306640625
patch: if ( iter > 0 ; return false ; }
rank: 721
score: 98.12929280598958
patch: iter ;
rank: 722
score: 98.92470139723558
patch: double [ ] current CaMeL Objective ( current CaMeL Objective ) ;
rank: 722
score: 98.77716619318181
patch: result = weight CaMeL Matrix CaMeL Sqrt . operate (
rank: 722
score: 98.75005231584821
patch: ++ n CaMeL C ; {
rank: 722
score: 98.71444091796874
patch: j = current CaMeL Point [ iter ] ;
rank: 722
score: 98.69056532118056
patch: while ( true ) { current ; }
rank: 722
score: 98.65705702039931
patch: ++ iter * / * / * /
rank: 722
score: 98.56598455255681
patch: ++ iter ; ++ iter ; iter ; * /
rank: 722
score: 98.46548227163461
patch: throw new Runtime CaMeL Exception ( $STRING$ + $NUMBER$ , null ;
rank: 722
score: 98.39551653180804
patch: if ( ! ++ iter )
rank: 722
score: 98.12885131835938
patch: iter iter ++ ;
rank: 723
score: 98.713525390625
patch: iter = current CaMeL Point [ iter ] ;
rank: 723
score: 98.65655517578125
patch: ++ iter ; ++ iter ++ ;
rank: 723
score: 98.56575150923295
patch: ++ iter ; iter ; out ; int iter ;
rank: 723
score: 98.465087890625
patch: throw new Runtime CaMeL Exception ( $STRING$ , null ) ;
rank: 723
score: 98.39362250434027
patch: ++ iter ; if ( ! ) {
rank: 724
score: 98.922607421875
patch: final double [ ] current CaMeL Objective = current CaMeL Point ;
rank: 724
score: 98.71165882457386
patch: int iter = solved CaMeL Cols [ iter ] ;
rank: 724
score: 98.69032981178977
patch: while ( true ) { qtf . ++ ;
rank: 724
score: 98.65602620442708
patch: ++ iter ; if ( iter == iter ) break ;
rank: 724
score: 98.56552956321023
patch: ++ iter ; ; * * / ++ iter ;
rank: 724
score: 98.4647216796875
patch: if ( . is CaMeL Empty ( ) ) { return ; }
rank: 724
score: 98.39302571614583
patch: if ( ++ iter >= iter ) {
rank: 724
score: 98.12699381510417
patch: if iter - ++ ;
rank: 725
score: 98.92205810546875
patch: ++ [ ] current CaMeL Objective ( qtf ) ;
rank: 725
score: 98.76991965553977
patch: < Point CaMeL Vector CaMeL Value CaMeL Pair > ;
rank: 725
score: 98.7441650390625
patch: ++ iter ; {
rank: 725
score: 98.69008567116477
patch: ++ iter ; final Convergence CaMeL Checker ++ ; {
rank: 725
score: 98.56490071614583
patch: ++ iter ; while iter ; 0 ; ++ iter ;
rank: 725
score: 98.4646329012784
patch: if ( iter == null ; return null ; }
rank: 725
score: 98.39164515904018
patch: final ; final ++ iter ;
rank: 725
score: 98.1213887532552
patch: iter ; iter / /
rank: 726
score: 98.76742214626736
patch: check CaMeL Parameters ( qtf ) ;
rank: 726
score: 98.71033935546875
patch: / / boolean first CaMeL Iteration = false ;
rank: 726
score: 98.68970336914063
patch: while ( true ) { weighted CaMeL Residual (
rank: 726
score: 98.65509033203125
patch: ++ iter ] = iter ; ;
rank: 726
score: 98.5646639737216
patch: ++ iter ; try { iter ; * * /
rank: 726
score: 98.46446736653645
patch: ++ iter ; System . arraycopy ( iter , 0 ,
rank: 726
score: 98.39153289794922
patch: ++ iter ; synchronized ( this )
rank: 726
score: 98.11807250976562
patch: / ; ++ 0 ;
rank: 727
score: 98.75476837158203
patch: check CaMeL Parameters ( true ) ;
rank: 727
score: 98.74158935546875
patch: i = current CaMeL Point [ 0 ] ;
rank: 727
score: 98.70799560546875
patch: double [ ] current CaMeL Objective = get ;
rank: 727
score: 98.68917236328124
patch: while ( true ) { { qtf .
rank: 727
score: 98.65487670898438
patch: ++ iter ; if ( iter < iter ) continue ;
rank: 727
score: 98.5646084872159
patch: ++ iter ; ++ iter ; / * ++ ;
rank: 727
score: 98.46397047776442
patch: else { if ( iter == null ; return null ; }
rank: 727
score: 98.39053344726562
patch: if ( ! is CaMeL Empty )
rank: 727
score: 98.11473592122395
patch: iter iter * ++ ;
rank: 728
score: 98.75095825195312
patch: int current CaMeL Cost = current CaMeL Cost ;
rank: 728
score: 98.74105834960938
patch: ++ iter = n CaMeL R ;
rank: 728
score: 98.68739013671875
patch: ++ iter ; { final Convergence CaMeL Checker ;
rank: 728
score: 98.65476296164773
patch: ++ iter ; ++ iter ; * / * /
rank: 728
score: 98.56432233537946
patch: ++ $NUMBER$ * ++ iter ;
rank: 728
score: 98.46354166666667
patch: throw new Runtime CaMeL Exception ( $STRING$ + 0 ) ;
rank: 728
score: 98.38899739583333
patch: ++ iter 1 [ iter 0 ] ;
rank: 728
score: 98.11383056640625
patch: ++ - 1 ;
rank: 729
score: 98.7506991299716
patch: first CaMeL Iteration = current CaMeL Point . length ;
rank: 729
score: 98.74072875976563
patch: Convergence CaMeL Checker ( current CaMeL Point ) ;
rank: 729
score: 98.7076416015625
patch: if ( 0 <= n CaMeL C ) {
rank: 729
score: 98.68648529052734
patch: while ( iter <= checker ) {
rank: 729
score: 98.6545743075284
patch: ++ iter ; while ( iter == ; ) {
rank: 729
score: 98.5638760653409
patch: ++ iter ; ++ iter ; int - iter ;
rank: 729
score: 98.46351841517857
patch: throw new Runtime CaMeL Exception ( $STRING$ + iter + $STRING$ ) ;
rank: 730
score: 98.73057861328125
patch: ++ iter ; int CaMeL Value = 0 ;
rank: 730
score: 98.7074951171875
patch: String current CaMeL Point = current CaMeL Point ;
rank: 730
score: 98.68408813476563
patch: Iterator iter = checker . n CaMeL R ;
rank: 730
score: 98.65418701171875
patch: if ( ++ iter < iter ) break ;
rank: 730
score: 98.5631103515625
patch: ++ iter ; ++ iter ; - - 1 ;
rank: 730
score: 98.4628155048077
patch: else { if ( iter == 0 ; return null ; }
rank: 730
score: 98.38770751953125
patch: ++ iter ) {
rank: 730
score: 98.1127217610677
patch: ++ iter ; ++ Math
rank: 731
score: 98.72483995225694
patch: ++ iter ; ++ current CaMeL Objective ;
rank: 731
score: 98.70557861328125
patch: if ( 0 < n CaMeL R ) {
rank: 731
score: 98.6834716796875
patch: while ( iter < 0 ) {
rank: 731
score: 98.65365600585938
patch: ++ iter ; if ( ++ n CaMeL C < ;
rank: 731
score: 98.5626220703125
patch: ++ iter ; ++ iter ; try ; break ;
rank: 731
score: 98.46244594029018
patch: if ( ! 0 . is CaMeL Empty ( this . iter ;
rank: 731
score: 98.10768636067708
patch: if iter ] / /
rank: 732
score: 98.9154052734375
patch: if ( current CaMeL Cost > n CaMeL C ) {
rank: 732
score: 98.74857954545455
patch: < Point CaMeL Vector CaMeL Value CaMeL Pair >> {
rank: 732
score: 98.7218994140625
patch: i = current CaMeL Residuals [ 0 ] ;
rank: 732
score: 98.68229675292969
patch: while ( true ) { current ;
rank: 732
score: 98.65355224609375
patch: synchronized ( iter ) { ++ iter ; }
rank: 732
score: 98.56253487723214
patch: ++ iter ; ] iter ;
rank: 732
score: 98.46214881310097
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + length ;
rank: 732
score: 98.38557942708333
patch: ++ iterator ; while ( true ) {
rank: 732
score: 98.10718790690105
patch: iter iter ; ++ ;
rank: 733
score: 98.74531860351563
patch: long current CaMeL Cost = current CaMeL Cost ;
rank: 733
score: 98.7053955078125
patch: double [ ] current = current CaMeL Residuals ;
rank: 733
score: 98.68179660373264
patch: Iterator iter = checker . ( ) ;
rank: 733
score: 98.65298800998264
patch: ++ iter * / * / ; ;
rank: 733
score: 98.56230024857955
patch: ++ iter ; ++ iter ; iter * 1 ;
rank: 733
score: 98.46181815011161
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ; } if ;
rank: 733
score: 98.38437906901042
patch: if ( ! iter ) ++ iter ;
rank: 733
score: 98.10270182291667
patch: iter ; ++ ; /
rank: 734
score: 98.74275512695313
patch: result = current CaMeL Point [ iter ] ;
rank: 734
score: 98.71665736607143
patch: ++ n CaMeL R ; {
rank: 734
score: 98.6796875
patch: while ( iter <= current CaMeL Residuals ) {
rank: 734
score: 98.56212269176136
patch: ++ iter ; ++ iter ; int while iter ;
rank: 734
score: 98.46087646484375
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + ++ iter ;
rank: 734
score: 98.10190836588542
patch: ++ $STRING$ = iter ;
rank: 735
score: 98.74165174696181
patch: if ( iter < n CaMeL R )
rank: 735
score: 98.71406860351563
patch: ++ qr CaMeL Decomposition ( qtf ) ;
rank: 735
score: 98.70438058035714
patch: boolean first CaMeL Iteration ++ ;
rank: 735
score: 98.67798461914063
patch: while ( iter <= current CaMeL Objective ) {
rank: 735
score: 98.65292697482639
patch: ++ iter * / / * * /
rank: 735
score: 98.56137520926339
patch: ++ iter ; for iter {
rank: 735
score: 98.4606182391827
patch: throw new Runtime CaMeL Exception ( $STRING$ + $NUMBER$ ) ; }
rank: 735
score: 98.37431989397321
patch: if ( iter >= iter )
rank: 735
score: 98.09848022460938
patch: ++ this ;
rank: 736
score: 98.7396952311198
patch: ( ++ iter ) {
rank: 736
score: 98.71218872070312
patch: if ( x CaMeL Norm != 0 ) {
rank: 736
score: 98.7040682705966
patch: if ( true ) { ++ n CaMeL R ;
rank: 736
score: 98.67789713541667
patch: qtf [ iter ] = null ;
rank: 736
score: 98.652734375
patch: ++ iter ; iter = iter . iterator ;
rank: 736
score: 98.56059047154018
patch: ++ iter ; Integer iter ;
rank: 736
score: 98.460595703125
patch: if ( ! 0 . is CaMeL Empty ( ) ) . log ;
rank: 736
score: 98.37050083705357
patch: while ( iter != null )
rank: 736
score: 98.0984395345052
patch: ++ iter ; / ;
rank: 737
score: 98.90228271484375
patch: double [ ] current CaMeL Residuals = 0 ;
rank: 737
score: 98.73692491319444
patch: n CaMeL C < solved CaMeL Cols ;
rank: 737
score: 98.67718505859375
patch: while ( true ) continue ; }
rank: 737
score: 98.65250651041667
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current = ;
rank: 737
score: 98.560546875
patch: / * ++ iter ; / ; int iter ;
rank: 737
score: 98.45963541666667
patch: else { throw new Runtime CaMeL Exception ++ ; ; }
rank: 737
score: 98.36747523716518
patch: ++ iter + 1 ; }
rank: 737
score: 98.09656778971355
patch: ++ if ++ iter ;
rank: 738
score: 98.89834594726562
patch: int [ ] current CaMeL Objective = true ;
rank: 738
score: 98.73616027832031
patch: synchronized ( weighted CaMeL Jacobian ) {
rank: 738
score: 98.70987701416016
patch: ++ iter = current CaMeL Point ;
rank: 738
score: 98.7035888671875
patch: k = current CaMeL Point [ iter ] ;
rank: 738
score: 98.6753173828125
patch: ++ n CaMeL C ; if ( true )
rank: 738
score: 98.65189985795455
patch: ++ iter ; / * ; ++ iter * /
rank: 738
score: 98.56005859375
patch: ++ - iter ; ++ iter ; ++ iter ;
rank: 738
score: 98.4587890625
patch: throw new Runtime CaMeL Exception ( $STRING$ , this . get CaMeL Name ;
rank: 738
score: 98.36339460100446
patch: final int iter = 0 ;
rank: 738
score: 98.0950215657552
patch: if iter = iter ;
rank: 739
score: 98.89263916015625
patch: ++ [ ] current CaMeL Objective = current ;
rank: 739
score: 98.7063980102539
patch: int first CaMeL Iteration = 0 ;
rank: 739
score: 98.6498794555664
patch: ++ iter ; break ; } ;
rank: 739
score: 98.55877685546875
patch: ++ iter ; start ;
rank: 739
score: 98.4576083096591
patch: return new Object [ ] = ++ iter ; }
rank: 739
score: 98.36048235212054
patch: if ( iter <= 0 )
rank: 739
score: 98.09481201171874
patch: { ++ iter ;
rank: 740
score: 98.7310791015625
patch: System . arraycopy ( n CaMeL C , 0 ,
rank: 740
score: 98.702001953125
patch: double [ ] current CaMeL Objective = 1 ;
rank: 740
score: 98.6994873046875
patch: while ( 0 < n CaMeL C ) {
rank: 740
score: 98.67271423339844
patch: while ( iter <= 0 ) {
rank: 740
score: 98.55867513020833
patch: ++ iter ; try { ++ iter ; ++ iter ;
rank: 740
score: 98.45724722055289
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ; ; ;
rank: 740
score: 98.35933140345982
patch: ++ iter ; ; try {
rank: 740
score: 98.09379069010417
patch: if iter ; / /
rank: 741
score: 98.69874267578125
patch: if ( n CaMeL C <= 0 ) {
rank: 741
score: 98.69866943359375
patch: int CaMeL Value = current ;
rank: 741
score: 98.6705093383789
patch: while ( iter < checker ) {
rank: 741
score: 98.64945475260417
patch: ++ iter ; if ( ++ n CaMeL R > ;
rank: 741
score: 98.55846058238636
patch: ++ iter ; ++ iter ; while - iter ;
rank: 741
score: 98.4572420987216
patch: throw new Runtime CaMeL Exception ( $STRING$ ; } }
rank: 741
score: 98.35591343470982
patch: final ++ iter - 1 ;
rank: 741
score: 98.08974202473958
patch: ++ iter ; } iter
rank: 742
score: 98.8914306640625
patch: qtf . lm CaMeL Par = 0 ;
rank: 742
score: 98.72955322265625
patch: int iter = true ;
rank: 742
score: 98.6985751065341
patch: Iterator iter = current CaMeL Point [ iter ] ;
rank: 742
score: 98.69569091796875
patch: if ( first CaMeL Iteration != 0 ) {
rank: 742
score: 98.66932678222656
patch: if ( checker != 0 ) {
rank: 742
score: 98.64871978759766
patch: final ++ iter ; break ; }
rank: 742
score: 98.5579833984375
patch: ++ iter ; ++ iter ; / / int iter ;
rank: 742
score: 98.45645345052084
patch: if ( . is CaMeL Empty ( ) ) return null ; else {
rank: 742
score: 98.35591343470982
patch: ++ iter - 1 ; }
rank: 743
score: 98.88466389973958
patch: double [ ] current CaMeL Objective = x CaMeL Norm ;
rank: 743
score: 98.69799194335937
patch: if ( current CaMeL Cost > 0 ) {
rank: 743
score: 98.69385443793402
patch: int ++ iter = n CaMeL C ;
rank: 743
score: 98.66651068793402
patch: while ( ! ( true ) ) {
rank: 743
score: 98.45644124348958
patch: throw new Runtime CaMeL Exception ( $STRING$ + 1 ; }
rank: 743
score: 98.35580008370536
patch: ++ iter - iter ] ;
rank: 743
score: 98.08847045898438
patch: iter iter = iter ;
rank: 744
score: 98.88466389973958
patch: double [ ] current CaMeL Objective = current CaMeL Cost ;
rank: 744
score: 98.72746138139205
patch: if ( iter < n CaMeL C ; ) {
rank: 744
score: 98.69777610085227
patch: int current = current CaMeL Point [ 0 ] ;
rank: 744
score: 98.69096544053819
patch: boolean first CaMeL Iteration = false ; {
rank: 744
score: 98.66603088378906
patch: qr CaMeL Decomposition ( true ) ;
rank: 744
score: 98.4561767578125
patch: if ( . is CaMeL Empty ( ) ; return ; }
rank: 744
score: 98.35509381975446
patch: ++ iter ; while ( ;
rank: 744
score: 98.08711751302083
patch: ++ ; ++ 0 ;
rank: 745
score: 98.88341674804687
patch: if ( iter <= n CaMeL C ) {
rank: 745
score: 98.72626287286931
patch: Iterator < Point CaMeL Vector CaMeL Value CaMeL Pair >
rank: 745
score: 98.69770951704545
patch: if ( current CaMeL Point < n CaMeL C )
rank: 745
score: 98.688134765625
patch: if ( first CaMeL Iteration == 0 ) {
rank: 745
score: 98.66403198242188
patch: if ( iter ; true ) {
rank: 745
score: 98.45535043569711
patch: throw new Runtime CaMeL Exception ( $STRING$ + this . value ;
rank: 745
score: 98.3524678548177
patch: ++ iter ; do {
rank: 745
score: 98.08640543619792
patch: ++ ++ * iter ;
rank: 746
score: 98.72285600142045
patch: check CaMeL Parameters ( current CaMeL Point ) ; }
rank: 746
score: 98.64772033691406
patch: ++ iter * / ; * /
rank: 746
score: 98.55732865767045
patch: ++ iter ; ++ iter ; for iter ++ ;
rank: 746
score: 98.45494733537946
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ; } else ;
rank: 746
score: 98.34931291852679
patch: if ( ! start ) {
rank: 746
score: 98.0844014485677
patch: } ++ iter ; }
rank: 747
score: 98.71697443181819
patch: < Point CaMeL Vector CaMeL Value CaMeL Pair >> ;
rank: 747
score: 98.69402521306819
patch: if ( current CaMeL Cost < n CaMeL C )
rank: 747
score: 98.687890625
patch: ++ current CaMeL Residuals [ qtf ] ;
rank: 747
score: 98.65892028808594
patch: while ( true ) break ; }
rank: 747
score: 98.64738633897569
patch: ++ iter * / ++ iter ; ;
rank: 747
score: 98.55726841517857
patch: ++ iter ; int 0 ;
rank: 747
score: 98.45436789772727
patch: if ( iter == 0 ; return null ; }
rank: 747
score: 98.34910365513393
patch: for ( ; ; ) {
rank: 747
score: 98.08026123046875
patch: ++ -- ++ iter ;
rank: 748
score: 98.71633078835227
patch: current CaMeL Point = current CaMeL Point . length ;
rank: 748
score: 98.6939697265625
patch: boolean first CaMeL Iteration = true ; ++ iter ;
rank: 748
score: 98.68752034505208
patch: int iter = n CaMeL C ; {
rank: 748
score: 98.65801323784723
patch: if ( first CaMeL Iteration ) { {
rank: 748
score: 98.6473388671875
patch: Point CaMeL Vector CaMeL Value CaMeL Pair current = new ;
rank: 748
score: 98.55677286783855
patch: ++ iter ; ++ iter ; ++ iter ; iter ;
rank: 748
score: 98.45401436941964
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ; return false ;
rank: 748
score: 98.34119524274554
patch: for ( ; iter ++ )
rank: 748
score: 98.07797241210938
patch: iter iter if ++ ;
rank: 749
score: 98.87509765625
patch: double [ ] current CaMeL Objective ( ) ;
rank: 749
score: 98.71250915527344
patch: synchronized ( n CaMeL C ) {
rank: 749
score: 98.6861063639323
patch: ++ current CaMeL Objective ;
rank: 749
score: 98.65748426649306
patch: qr CaMeL Decomposition ( true ) ; }
rank: 749
score: 98.64725748697917
patch: ++ iter ; if ( iter < 0 ) break ;
rank: 749
score: 98.55657958984375
patch: / * ++ iter ; / / / ++ iter ;
rank: 749
score: 98.453857421875
patch: if ( . is CaMeL Empty ( ) ) throw ++ iter ;
rank: 749
score: 98.33975219726562
patch: ++ iter ; final ;
rank: 749
score: 98.074951171875
patch: iter ; ++ max ;
rank: 750
score: 98.86691284179688
patch: int iter = current CaMeL Residuals ( ) ;
rank: 750
score: 98.71112060546875
patch: tmp = current CaMeL Point [ 0 ] ;
rank: 750
score: 98.6822509765625
patch: ++ iter = checker . operate ( ) ;
rank: 750
score: 98.65406036376953
patch: Iterator iter = checker . true ;
rank: 750
score: 98.55647416548295
patch: ++ iter ; ++ 1 ; ++ iter ; ;
rank: 750
score: 98.45380045572917
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + $NUMBER$ + 1 ;
rank: 750
score: 98.33853585379464
patch: try { ++ iter ; else
rank: 750
score: 98.07381184895833
patch: iter ; = iter ;
rank: 751
score: 98.71048990885417
patch: n CaMeL R < solved CaMeL Cols ;
rank: 751
score: 98.68908081054687
patch: double [ ] current CaMeL Objective = $NUMBER$ ;
rank: 751
score: 98.67769165039063
patch: ++ iter ; first CaMeL Iteration = true ;
rank: 751
score: 98.64773220486111
patch: qtf [ iter ] = checker ;
rank: 751
score: 98.55643717447917
patch: ++ iter ; / * * * / ++ iter ;
rank: 751
score: 98.45362267127403
patch: if ( iter > 0 ; return . [ 1 ] ;
rank: 751
score: 98.33853149414062
patch: final ++ iter ] ;
rank: 751
score: 98.07138061523438
patch: iter ; ++ ; ;
rank: 752
score: 98.7034579190341
patch: instanceof Point CaMeL Vector CaMeL Value CaMeL Pair ) {
rank: 752
score: 98.6874667080966
patch: boolean iter = current CaMeL Point [ 0 ] ;
rank: 752
score: 98.67382134331598
patch: ++ iter ; ++ current CaMeL Residuals ;
rank: 752
score: 98.64690607244319
patch: ++ iter ; ; iter = iter . iter ;
rank: 752
score: 98.55589710582386
patch: ++ iter ; ++ iter ; if ( iter ;
rank: 752
score: 98.33644321986607
patch: final ++ iter - iter ;
rank: 753
score: 98.70110473632812
patch: long current CaMeL Cost = current CaMeL Residuals ;
rank: 753
score: 98.68739624023438
patch: boolean first CaMeL Iteration = qtf ) ;
rank: 753
score: 98.6730224609375
patch: ++ iter ; x CaMeL Norm = 0 ;
rank: 753
score: 98.64617241753473
patch: iter = current CaMeL Point . length ;
rank: 753
score: 98.55562337239583
patch: int iter ; / * * / / ++ iter ;
rank: 753
score: 98.45220540364583
patch: throw new Runtime CaMeL Exception ( $STRING$ + 1 , null ) ; }
rank: 753
score: 98.33585030691964
patch: final int start = 0 ;
rank: 753
score: 98.06942749023438
patch: if ++ iter ; ;
rank: 754
score: 98.85207297585227
patch: if ( true ) { ++ n CaMeL C ;
rank: 754
score: 98.6948974609375
patch: check CaMeL Parameters ( current CaMeL Cost ) ;
rank: 754
score: 98.6856689453125
patch: / * boolean first CaMeL Iteration = null ;
rank: 754
score: 98.64515177408855
patch: ++ iter ; if ( ++ n CaMeL R < ;
rank: 754
score: 98.55544211647727
patch: / * ++ iter ; try { ++ iter ;
rank: 754
score: 98.45217063210227
patch: ++ [ ] iter = iter ; ++ iter ;
rank: 754
score: 98.06788330078125
patch: iter else ++ ;
rank: 755
score: 98.6925048828125
patch: [ ] current = current ;
rank: 755
score: 98.68522505326705
patch: int start = current CaMeL Point [ 0 ] ;
rank: 755
score: 98.67083740234375
patch: ++ iter ; first CaMeL Iteration = 0 ;
rank: 755
score: 98.644970703125
patch: ++ iter * / ; ++ iter * /
rank: 755
score: 98.64339192708333
patch: while ( iter ; true ) { {
rank: 755
score: 98.55500932173295
patch: / * ] iter = iter ; ++ iter ;
rank: 755
score: 98.45111553485577
patch: throw new Runtime CaMeL Exception ( $STRING$ + ; , null ;
rank: 755
score: 98.0575663248698
patch: try ; ++ iter ;
rank: 756
score: 98.69063991970486
patch: first CaMeL Iteration = current CaMeL Point ;
rank: 756
score: 98.68478393554688
patch: int qr CaMeL Decomposition [ ] = current ;
rank: 756
score: 98.64450905539773
patch: ++ iter * / * ++ iter * / ;
rank: 756
score: 98.6379623413086
patch: while ( true ) return current ;
rank: 756
score: 98.55457652698864
patch: / * * ++ iter ; / ++ iter ;
rank: 756
score: 98.45088704427083
patch: if ( . is CaMeL Empty ( ; ) ) ;
rank: 756
score: 98.33034261067708
patch: ++ iter ) ++ ;
rank: 756
score: 98.05677286783855
patch: ++ ( ++ 1 ;
rank: 757
score: 98.68791198730469
patch: check CaMeL Parameters ( checker ) ;
rank: 757
score: 98.68460083007812
patch: int current CaMeL Objective = current CaMeL Residuals ;
rank: 757
score: 98.64404296875
patch: ++ iter ] = ++ iter ; ++ iter ;
rank: 757
score: 98.63720703125
patch: while ( true ) { Convergence CaMeL Checker
rank: 757
score: 98.5543212890625
patch: ++ iter ; ++ iter ; int iter ; break ;
rank: 757
score: 98.45076810396634
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + value ;
rank: 757
score: 98.32993570963542
patch: ++ iter ; continue ;
rank: 758
score: 98.8459805575284
patch: if ( true && < n CaMeL C ) {
rank: 758
score: 98.6875
patch: current CaMeL Point = current CaMeL Point ;
rank: 758
score: 98.684130859375
patch: boolean first CaMeL Iteration = jac CaMeL Norm ;
rank: 758
score: 98.669140625
patch: if ( current CaMeL Residuals < 0 ) {
rank: 758
score: 98.64353434244792
patch: int iter = current CaMeL Point . length - 1 ;
rank: 758
score: 98.63714599609375
patch: while ( ! n CaMeL R ) {
rank: 758
score: 98.55321155894886
patch: ++ iter ; ++ iter ; int iter ; }
rank: 758
score: 98.45057024274554
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + 1 ; }
rank: 758
score: 98.32967703683036
patch: final ++ n CaMeL C ;
rank: 758
score: 98.05467732747395
patch: } iter if ++ ;
rank: 759
score: 98.84595336914063
patch: int [ ] current CaMeL Objective = get ;
rank: 759
score: 98.68189086914063
patch: Point CaMeL Vector CaMeL Value CaMeL Pair ++ ;
rank: 759
score: 98.6687255859375
patch: ++ current CaMeL Point = current CaMeL Point ;
rank: 759
score: 98.63175455729167
patch: qtf [ ++ ] = current ;
rank: 759
score: 98.5528055826823
patch: int iter ; ++ iter ; / * / / /
rank: 759
score: 98.45043131510417
patch: throw new Runtime CaMeL Exception ( $STRING$ + this . get CaMeL Class ;
rank: 759
score: 98.32957240513393
patch: ++ iter ; return new ;
rank: 759
score: 98.05460611979167
patch: iter ; -- iter ;
rank: 760
score: 98.84207763671876
patch: int [ ] current CaMeL Residuals = 0 ;
rank: 760
score: 98.67811889648438
patch: end = current CaMeL Point [ 0 ] ;
rank: 760
score: 98.63158501519098
patch: while ( true ) return current ; }
rank: 760
score: 98.5527676669034
patch: / * * / ++ iter ; ++ iter ;
rank: 760
score: 98.44805908203125
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ; iter ++ ;
rank: 760
score: 98.32822091238839
patch: ++ iter ; ; if ;
rank: 760
score: 98.0447265625
patch: } iter ++ ;
rank: 761
score: 98.68061065673828
patch: int first CaMeL Iteration = current ;
rank: 761
score: 98.67463684082031
patch: synchronized ( lm CaMeL Par ) {
rank: 761
score: 98.66364135742188
patch: compute CaMeL Cost ( current CaMeL Point ) ;
rank: 761
score: 98.6424893465909
patch: ++ iter ; if ( iter == null ) {
rank: 761
score: 98.63148498535156
patch: if ( true || true ) {
rank: 761
score: 98.55265299479167
patch: / * ++ iter ; * * / ++ iter ;
rank: 761
score: 98.4476787860577
patch: throw new Runtime CaMeL Exception ( $STRING$ + 1 , iter ;
rank: 761
score: 98.32815987723214
patch: final int start = iter ;
rank: 761
score: 98.0317138671875
patch: return iter ; ;
rank: 762
score: 98.83766479492188
patch: char [ ] current CaMeL Objective = current ;
rank: 762
score: 98.68045043945312
patch: double [ ] first CaMeL Iteration = current ;
rank: 762
score: 98.67380196707589
patch: first CaMeL Iteration = true ;
rank: 762
score: 98.663330078125
patch: ++ iter * n CaMeL C ;
rank: 762
score: 98.63763427734375
patch: ++ iter ; this . ++ iter ; ++ iter ;
rank: 762
score: 98.62530517578125
patch: if ( ( true ) ) {
rank: 762
score: 98.54978434244792
patch: / ++ ++ iter ;
rank: 762
score: 98.4471944173177
patch: ++ [ ] iter ;
rank: 762
score: 98.32467651367188
patch: if ( ++ iter )
rank: 762
score: 98.02304077148438
patch: ++ iter ; try
rank: 763
score: 98.83721923828125
patch: double [ ] current CaMeL Residuals = null ;
rank: 763
score: 98.67106323242187
patch: int current CaMeL Cost = current CaMeL Residuals ;
rank: 763
score: 98.67066650390625
patch: Point CaMeL Vector CaMeL Value CaMeL Pair current ;
rank: 763
score: 98.66014099121094
patch: qtf ( qtf ) ;
rank: 763
score: 98.62466091579861
patch: Convergence CaMeL Checker < double [ ] ;
rank: 763
score: 98.54961603338069
patch: ++ iter ; ++ iter ; ++ int iter ;
rank: 763
score: 98.4471923828125
patch: if ( . is CaMeL Empty ( ) ) { iter -- ; }
rank: 763
score: 98.32143729073661
patch: final ; ++ iter ] ;
rank: 763
score: 98.02117156982422
patch: ++ null ;
rank: 764
score: 98.83620383522727
patch: qtf [ current CaMeL Objective ] = current ;
rank: 764
score: 98.67046508789062
patch: if ( 0 == n CaMeL C ) {
rank: 764
score: 98.66994222005208
patch: synchronized ( true ) {
rank: 764
score: 98.62363688151042
patch: while ( ! current CaMeL Objective ) {
rank: 764
score: 98.54951615767045
patch: ++ iter ; ++ iter ; public int iter ;
rank: 764
score: 98.44709916548295
patch: if ( iter == 0 && is CaMeL Empty ;
rank: 764
score: 98.32001604352679
patch: final ; ++ iter ++ ;
rank: 764
score: 98.01925048828124
patch: iter if ++ ;
rank: 765
score: 98.66763644748264
patch: double [ ] qtf = current ;
rank: 765
score: 98.65177001953126
patch: ++ iter ; if ( solved CaMeL Cols ;
rank: 765
score: 98.62287902832031
patch: ++ iter ; final int iter ;
rank: 765
score: 98.5489501953125
patch: ++ iter ; / * * ; * / /
rank: 765
score: 98.44639282226562
patch: / * * ;
rank: 765
score: 98.31393868582589
patch: ++ n CaMeL C ; ;
rank: 765
score: 98.01067504882812
patch: iter } ++ ;
rank: 766
score: 98.66687622070313
patch: int [ ] qr CaMeL Decomposition = current ;
rank: 766
score: 98.63687133789062
patch: ++ iter = new double [ n CaMeL C ] ;
rank: 766
score: 98.619873046875
patch: if ( current CaMeL Residuals == 0 )
rank: 766
score: 98.54835001627605
patch: ++ iter ; ++ iter ; System . iter ; ;
rank: 766
score: 98.44638296274039
patch: if ( iter > 0 ; return iter [ 0 ] ;
rank: 766
score: 98.3111572265625
patch: try { ++ iter ++ ;
rank: 766
score: 97.99110107421875
patch: if iter ++ ;
rank: 767
score: 98.66886393229167
patch: if ( iter < n CaMeL C )
rank: 767
score: 98.6666259765625
patch: boolean first CaMeL Iteration = current ;
rank: 767
score: 98.62965698242188
patch: ++ iter ; final ++ n CaMeL R ;
rank: 767
score: 98.61382293701172
patch: ++ true ; { ++ iter ;
rank: 767
score: 98.5480624112216
patch: ++ iter ; ++ iter ; ; * / ;
rank: 767
score: 98.44615827287946
patch: if ( . is CaMeL Empty ( ) || iter == null ;
rank: 767
score: 98.30764770507812
patch: assert iter >= 0 ;
rank: 767
score: 97.95247192382813
patch: ++ 1 ; ;
rank: 768
score: 98.83046653053977
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair checker =
rank: 768
score: 98.66352081298828
patch: synchronized ( solved CaMeL Cols ) {
rank: 768
score: 98.66154479980469
patch: final int CaMeL Value = current ;
rank: 768
score: 98.635986328125
patch: ++ iter ; * / * ; ++ iter ;
rank: 768
score: 98.61177825927734
patch: while ( iter = true ) {
rank: 768
score: 98.54740767045455
patch: ++ iter ; ++ iter ; int * ++ ;
rank: 768
score: 98.44614821213942
patch: throw new Runtime CaMeL Exception ( $STRING$ + 1 + 1 ;
rank: 768
score: 97.9493408203125
patch: / iter ++ ;
rank: 769
score: 98.8294921875
patch: int [ ] current CaMeL Objective ( ) ;
rank: 769
score: 98.65982666015626
patch: long current CaMeL Point = current CaMeL Point ;
rank: 769
score: 98.65958251953126
patch: if ( n CaMeL R > 0 ) {
rank: 769
score: 98.63567560369319
patch: while ( iter < n CaMeL C ) { ;
rank: 769
score: 98.61902533637152
patch: ++ iter ] = current CaMeL Point ;
rank: 769
score: 98.54700816761364
patch: ++ iter ; iter ; * ; int iter ;
rank: 769
score: 98.44613211495536
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ; } try {
rank: 769
score: 98.29866245814732
patch: if ( iter >= 1 )
rank: 769
score: 97.94816284179687
patch: ; ++ iter ;
rank: 770
score: 98.65880737304687
patch: boolean first CaMeL Iteration = double [ ] ;
rank: 770
score: 98.65548706054688
patch: int current CaMeL Cost = 0 ;
rank: 770
score: 98.63555908203125
patch: while ( false ) { ++ iter ++ ;
rank: 770
score: 98.6180648803711
patch: ++ iter < n CaMeL C ;
rank: 770
score: 98.61020333426339
patch: while ( true ) { }
rank: 770
score: 98.5462137858073
patch: ++ iter ; ++ iter ; * * / iter ;
rank: 770
score: 98.44606323242188
patch: return this ; }
rank: 770
score: 98.29738071986607
patch: ++ iter == - 1 ;
rank: 770
score: 97.94617462158203
patch: ++ value ;
rank: 771
score: 98.65584309895833
patch: boolean first CaMeL Iteration = - 1 ;
rank: 771
score: 98.65545654296875
patch: synchronized ( n CaMeL R ) {
rank: 771
score: 98.60879516601562
patch: if ( true ) { ) {
rank: 771
score: 98.44594029017857
patch: if ( ! 0 . is CaMeL Empty ( ) ) iter ;
rank: 771
score: 98.29684012276786
patch: while ( false ) { ;
rank: 771
score: 97.9450927734375
patch: ++ iter ; ++
rank: 772
score: 98.81962280273437
patch: int current CaMeL Objective [ ] = current ;
rank: 772
score: 98.6551742553711
patch: boolean first CaMeL Iteration = this ;
rank: 772
score: 98.655126953125
patch: long current CaMeL Cost = current CaMeL Point ;
rank: 772
score: 98.63511962890625
patch: ++ iter * / * * ++ iter ;
rank: 772
score: 98.61338297526042
patch: int CaMeL Value = n CaMeL C ;
rank: 772
score: 98.60745239257812
patch: while ( true ) { checker ;
rank: 772
score: 98.54484049479167
patch: ++ iter ; try { ++ iter ; break ; }
rank: 772
score: 98.29323904854911
patch: ++ iter - ~ iter ;
rank: 772
score: 97.93547821044922
patch: ++ Math ;
rank: 773
score: 98.60848999023438
patch: ++ iter ; { {
rank: 773
score: 98.60689290364583
patch: ++ iter ; { Convergence CaMeL Checker ;
rank: 773
score: 98.5445556640625
patch: ++ iter ; ++ iter ; try ; int iter ;
rank: 773
score: 98.44506022135417
patch: throw new Illegal CaMeL Argument CaMeL Exception ( new Exception ( $STRING$ ) ;
rank: 773
score: 97.91246795654297
patch: ++ false ;
rank: 774
score: 98.81814575195312
patch: int [ ] current CaMeL Objective = $NUMBER$ ;
rank: 774
score: 98.65465698242187
patch: int CaMeL Value current CaMeL Objective = current ;
rank: 774
score: 98.65316162109374
patch: if ( iter <= n CaMeL R ) {
rank: 774
score: 98.60491180419922
patch: int current CaMeL Objective = 0 ;
rank: 774
score: 98.54432262073864
patch: / * ++ iter ; ++ iter ; * /
rank: 774
score: 98.44488118489583
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + 1 ) ; ;
rank: 774
score: 98.29081508091518
patch: final ; return iter ; }
rank: 775
score: 98.8176025390625
patch: ++ current CaMeL Objective ( qtf ) ;
rank: 775
score: 98.64933776855469
patch: first CaMeL Iteration = ++ iter ;
rank: 775
score: 98.63274591619319
patch: ++ iter ; * / * * * * ;
rank: 775
score: 98.60544840494792
patch: ++ iter ; final Convergence CaMeL Checker )
rank: 775
score: 98.60268147786458
patch: Convergence CaMeL Checker ( qtf ) ;
rank: 775
score: 98.5436678799716
patch: ++ iter ; ++ iter ; try ; iter ;
rank: 775
score: 98.44423828125
patch: if ( ! 0 . is CaMeL Empty ( this . iter ) )
rank: 775
score: 98.29022216796875
patch: ++ iter ) { ++ ;
rank: 775
score: 97.89863891601563
patch: ++ 0 ; ;
rank: 776
score: 98.8079833984375
patch: double [ ] current CaMeL Residuals = qtf ;
rank: 776
score: 98.65311889648437
patch: double qr CaMeL Decomposition [ ] = current ;
rank: 776
score: 98.64884643554687
patch: result = weighted CaMeL Residual [ iter ] ;
rank: 776
score: 98.63260904947917
patch: if ( ++ iter < n CaMeL R ) continue ;
rank: 776
score: 98.59592013888889
patch: ++ iter - n CaMeL C ; {
rank: 776
score: 98.54337565104167
patch: ++ iter ; / * * ; / ++ iter ;
rank: 776
score: 98.44411057692308
patch: throw new Runtime CaMeL Exception ( $STRING$ + [ 1 ] ;
rank: 776
score: 97.894287109375
patch: ++ list ;
rank: 777
score: 98.804833984375
patch: ++ [ ] current CaMeL Objective ( ) ;
rank: 777
score: 98.6450927734375
patch: tmp = current CaMeL Point [ iter ] ;
rank: 777
score: 98.602783203125
patch: while ( true ) { do {
rank: 777
score: 98.5425692471591
patch: this . ++ iter ; ++ iter ; * ;
rank: 777
score: 98.44354802911931
patch: if ( ! iter == null ) return null ;
rank: 777
score: 98.28549194335938
patch: ++ iter * iter ;
rank: 777
score: 97.88723754882812
patch: ++ super ;
rank: 778
score: 98.64397583007812
patch: return weight CaMeL Matrix CaMeL Sqrt . operate (
rank: 778
score: 98.63203938802083
patch: ++ iter ; final double [ ] ;
rank: 778
score: 98.59711456298828
patch: / * if ( true ) {
rank: 778
score: 98.58712332589286
patch: ++ current CaMeL Objective ; {
rank: 778
score: 98.54164632161458
patch: ++ iter ; iter ; * * / ++ iter ;
rank: 778
score: 98.4431485262784
patch: if ( . is CaMeL Empty ( ) ) ;
rank: 778
score: 98.28123982747395
patch: final ; return iter ;
rank: 778
score: 97.88048095703125
patch: iter ++ ; ;
rank: 779
score: 98.80067749023438
patch: double [ ] current CaMeL Objective = $STRING$ ;
rank: 779
score: 98.64310709635417
patch: synchronized ( weight CaMeL Matrix CaMeL Sqrt )
rank: 779
score: 98.63187866210937
patch: if ( iter < ; iter ++ ) {
rank: 779
score: 98.59686279296875
patch: if ( true ) { {
rank: 779
score: 98.58686659071181
patch: ++ iter [ n CaMeL C ] ;
rank: 779
score: 98.54087136008523
patch: ++ iter ; try { ++ iter ; break ;
rank: 779
score: 98.44290364583334
patch: throw new Runtime CaMeL Exception ( $STRING$ + 1 , null , null ;
rank: 779
score: 98.28009905133929
patch: if ( iter < 1 )
rank: 779
score: 97.87857666015626
patch: iter * ++ ;
rank: 780
score: 98.64952392578125
patch: Point CaMeL Vector CaMeL Value CaMeL Pair checker ;
rank: 780
score: 98.6405517578125
patch: ( ++ iter < n CaMeL R ) {
rank: 780
score: 98.63180881076389
patch: ++ iter * * / ++ iter ;
rank: 780
score: 98.583251953125
patch: ++ iter ; ++ current CaMeL Point ;
rank: 780
score: 98.53989479758523
patch: int iter + iter ; * / ++ iter ;
rank: 780
score: 98.44269353693181
patch: try { ++ iter ; } catch ++ iter ;
rank: 780
score: 98.27989705403645
patch: ++ iter - $NUMBER$ ;
rank: 780
score: 97.87816772460937
patch: ++ ! 1 ;
rank: 781
score: 98.7857333096591
patch: final double [ ] current CaMeL Objective = 0 ;
rank: 781
score: 98.6484130859375
patch: int current CaMeL Cost = n CaMeL C ;
rank: 781
score: 98.63916625976563
patch: n CaMeL C < n CaMeL R ) {
rank: 781
score: 98.63179524739583
patch: ++ iter ; if ( iter < 1 ) break ;
rank: 781
score: 98.59191022600446
patch: while ( ! checker ) {
rank: 781
score: 98.5390116373698
patch: ++ iter ; ++ iter ; return ( ++ iter ;
rank: 781
score: 98.44264439174107
patch: if ( . is CaMeL Empty ( ; ) ) return false ;
rank: 781
score: 98.2792460123698
patch: ++ iter + $NUMBER$ ;
rank: 781
score: 97.87412109375
patch: iter / ++ ;
rank: 782
score: 98.63175048828126
patch: ++ iter ; / * * * * ;
rank: 782
score: 98.5918960571289
patch: while ( true ) { checker .
rank: 782
score: 98.57998996310764
patch: int ++ iter = n CaMeL R ;
rank: 782
score: 98.53889604048295
patch: ++ iter ; try ; ++ iter ; break ;
rank: 782
score: 98.44195963541667
patch: throw new Runtime CaMeL Exception ( $STRING$ , this . get CaMeL Runtime ;
rank: 782
score: 98.27851213727679
patch: final ; ++ iter ; ;
rank: 782
score: 97.86454772949219
patch: iter ; ;
rank: 783
score: 98.78406871448864
patch: ++ double [ ] current CaMeL Objective = current ;
rank: 783
score: 98.633056640625
patch: boolean first CaMeL Iteration = checker ;
rank: 783
score: 98.63292694091797
patch: synchronized ( current CaMeL Point ) {
rank: 783
score: 98.6303378018466
patch: ++ iter ; * / * ++ iter * ;
rank: 783
score: 98.59132385253906
patch: if ( checker != null ) {
rank: 783
score: 98.57469346788194
patch: ++ iter = n CaMeL C ; {
rank: 783
score: 98.44193522135417
patch: else { if ++ iter * 0 . 0 ; }
rank: 783
score: 98.27664620535714
patch: final double iter = 0 ;
rank: 784
score: 98.63103637695312
patch: Iterator < Point CaMeL Vector CaMeL Value CaMeL Pair
rank: 784
score: 98.62333679199219
patch: Object current CaMeL Point = current ;
rank: 784
score: 98.58927154541016
patch: while ( first CaMeL Iteration ) {
rank: 784
score: 98.53722034801136
patch: ++ iter ; iter ; * / if iter ;
rank: 784
score: 98.44151893028847
patch: else { this . iter = iter ; return iter ; }
rank: 784
score: 98.27347237723214
patch: ++ iter ; try { ;
rank: 784
score: 97.84102172851563
patch: ++ -- 1 ;
rank: 785
score: 98.77750854492187
patch: int [ ] current CaMeL Residuals = null ;
rank: 785
score: 98.6305419921875
patch: start = current CaMeL Point [ 0 ] ;
rank: 785
score: 98.63029649522569
patch: final ++ iter ; final ++ iter ;
rank: 785
score: 98.61878204345703
patch: double first CaMeL Iteration = current ;
rank: 785
score: 98.58524322509766
patch: qr CaMeL Decomposition ( checker ) ;
rank: 785
score: 98.53678755326705
patch: ++ iter ; ++ iter ; int int iter ;
rank: 785
score: 98.44147198016827
patch: throw new Runtime CaMeL Exception ( $STRING$ + $NUMBER$ + 1 ;
rank: 785
score: 98.26900809151786
patch: ; while ( true ) {
rank: 785
score: 97.8400146484375
patch: throw iter ; ;
rank: 786
score: 98.77620849609374
patch: int [ ] current CaMeL Objective = diag ;
rank: 786
score: 98.61747741699219
patch: double [ ] permutation = current ;
rank: 786
score: 98.58132934570312
patch: qr CaMeL Decomposition ( ) ; }
rank: 786
score: 98.5684814453125
patch: qtf ( current CaMeL Point ) ;
rank: 786
score: 98.53207397460938
patch: ++ iter ; ++ iter ; System . max ++ ;
rank: 786
score: 98.44139607747395
patch: else { ++ iter ; * / return iter ; }
rank: 786
score: 98.26814778645833
patch: ++ iter - 0 ;
rank: 786
score: 97.82364501953126
patch: ++ start ; ;
rank: 787
score: 98.77514038085937
patch: if ( iter <= solved CaMeL Cols ) {
rank: 787
score: 98.62673950195312
patch: if ( weight CaMeL Matrix CaMeL Sqrt ) {
rank: 787
score: 98.58075823102679
patch: while ( true ) continue ;
rank: 787
score: 98.53200276692708
patch: ++ iter ; ++ iter ; iter ; if iter ;
rank: 787
score: 98.44119466145834
patch: throw new Runtime CaMeL Exception ( $STRING$ + this . get CaMeL Id ;
rank: 787
score: 97.81135559082031
patch: throw iter ;
rank: 788
score: 98.77459716796875
patch: int [ ] current CaMeL Objective = 1 ;
rank: 788
score: 98.62847345525569
patch: ++ iter ; this . iter = iter ; }
rank: 788
score: 98.6241683959961
patch: long current CaMeL Cost = current ;
rank: 788
score: 98.60835774739583
patch: if ( current CaMeL Objective == 0 )
rank: 788
score: 98.5584945678711
patch: ++ iter + n CaMeL C ;
rank: 788
score: 98.531982421875
patch: ++ iter ; ++ iter ; * ; ++ iter ;
rank: 788
score: 98.44076102120536
patch: if ( . is CaMeL Empty ( ) ; while ++ iter ;
rank: 788
score: 97.80082397460937
patch: int iter ++ ;
rank: 789
score: 98.62804066051136
patch: ++ iter * / * ; ++ iter * /
rank: 789
score: 98.62015991210937
patch: if ( ++ iter < n CaMeL C ;
rank: 789
score: 98.59992218017578
patch: int iter = current CaMeL Point ;
rank: 789
score: 98.55739339192708
patch: ++ iter - n CaMeL R ; {
rank: 789
score: 98.53105024857955
patch: ++ iter ; if iter ; current . iter ;
rank: 789
score: 98.4405850497159
patch: else { / * * * ; ++ iter ;
rank: 789
score: 98.2637939453125
patch: ++ iter - delta ;
rank: 789
score: 97.7950210571289
patch: ++ length ;
rank: 790
score: 98.77154541015625
patch: double [ ] current CaMeL Objective ;
rank: 790
score: 98.61868896484376
patch: first CaMeL Iteration = permutation [ 0 ] ;
rank: 790
score: 98.59095764160156
patch: int current CaMeL Point = current ;
rank: 790
score: 98.57048797607422
patch: qr CaMeL Decomposition ( this ) ;
rank: 790
score: 98.53098366477273
patch: int iter ; ++ iter ; * / iter ;
rank: 790
score: 98.44039481026786
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + value ) ;
rank: 790
score: 98.26308768136161
patch: final ; ++ iter ; }
rank: 790
score: 97.79249267578125
patch: ++ ( iter ;
rank: 791
score: 98.76689009232955
patch: final double [ ] current CaMeL Objective = null ;
rank: 791
score: 98.62722778320312
patch: if ( iter < n CaMeL C ) ++ iter ;
rank: 791
score: 98.61810302734375
patch: max = current CaMeL Point [ 0 ] ;
rank: 791
score: 98.5873031616211
patch: int iter = solved CaMeL Cols ;
rank: 791
score: 98.5682373046875
patch: ++ iter ; final Object current ;
rank: 791
score: 98.5307284268466
patch: ++ iter ; try ; int iter ; iter ;
rank: 791
score: 98.44003295898438
patch: if ( . is CaMeL Empty ( ) ) . ;
rank: 791
score: 97.78126831054688
patch: ++ true ; ;
rank: 792
score: 98.62415568033855
patch: ++ iter ; * / * / ++ iter * /
rank: 792
score: 98.61275634765624
patch: ret = current CaMeL Point [ 0 ] ;
rank: 792
score: 98.53060913085938
patch: ++ iter ; while iter ; try ; ++ iter ;
rank: 792
score: 98.44003092447916
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + $NUMBER$ + 0 ;
rank: 792
score: 98.25953892299107
patch: ++ iter - iter ; }
rank: 792
score: 97.7681640625
patch: public ++ iter ;
rank: 793
score: 98.76276189630681
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair current =
rank: 793
score: 98.62351684570312
patch: final Point CaMeL Vector CaMeL Value CaMeL Pair ;
rank: 793
score: 98.61204833984375
patch: if ( iter < solved CaMeL Cols ) {
rank: 793
score: 98.57723236083984
patch: String current CaMeL Point = current ;
rank: 793
score: 98.53057306463069
patch: / * ] iter ; / / ++ iter ;
rank: 793
score: 98.43961958451705
patch: else { ++ iter ; * * * * /
rank: 793
score: 98.25339181082589
patch: while ( iter == 0 )
rank: 793
score: 97.76780395507812
patch: ++ $STRING$ ; ;
rank: 794
score: 98.76188520951705
patch: int double [ ] current CaMeL Objective = current ;
rank: 794
score: 98.62335759943181
patch: ++ iter ; if ( iter ; break ; }
rank: 794
score: 98.6087137858073
patch: Object current = current ;
rank: 794
score: 98.57638549804688
patch: if ( current CaMeL Residuals ) {
rank: 794
score: 98.55859375
patch: while ( iter ; checker ) {
rank: 794
score: 98.54138946533203
patch: ++ iter * n CaMeL R ;
rank: 794
score: 98.53021795099431
patch: ++ iter ; / * * ++ iter ; /
rank: 794
score: 98.24922398158482
patch: final ; this . ++ ;
rank: 794
score: 97.75811157226562
patch: iter iter -- ;
rank: 795
score: 98.76048583984375
patch: double current CaMeL Objective [ ] = current ;
rank: 795
score: 98.62291463216145
patch: ++ iter ; * / * ++ iter ; * /
rank: 795
score: 98.57566833496094
patch: if ( current CaMeL Objective ) {
rank: 795
score: 98.55153982979911
patch: while ( false ) { {
rank: 795
score: 98.5400161743164
patch: ++ n CaMeL C ; { {
rank: 795
score: 98.5288973721591
patch: / * ++ iter ; / * * / /
rank: 795
score: 98.43923950195312
patch: if ( . is CaMeL Empty ( ) && iter ;
rank: 795
score: 97.75572509765625
patch: ++ $NUMBER$ ; ;
rank: 796
score: 98.75362548828124
patch: ++ current CaMeL Point [ ] = current ;
rank: 796
score: 98.62220458984375
patch: ++ iter ; ++ iter * / * ;
rank: 796
score: 98.5287577311198
patch: ++ iter ; ++ iter ; / / * ; /
rank: 796
score: 98.52652740478516
patch: ++ iter ; ++ 0 ; {
rank: 796
score: 98.43895374644886
patch: if ( iter > 1 ; return null ; }
rank: 796
score: 98.24686976841518
patch: final ++ iter + 1 ;
rank: 796
score: 97.74730224609375
patch: ++ ++ 0 ;
rank: 797
score: 98.5716323852539
patch: double first CaMeL Iteration = 0 ;
rank: 797
score: 98.54704938616071
patch: qr CaMeL Decomposition ( ) ;
rank: 797
score: 98.52870686848958
patch: ++ iter ; ++ iter ; * * int iter ;
rank: 797
score: 98.52490234375
patch: ! first CaMeL Iteration = true ;
rank: 797
score: 98.43887765066964
patch: throw new Runtime CaMeL Exception ( $STRING$ + iter + $STRING$ ; ;
rank: 797
score: 97.74567260742188
patch: ++ max ++ ;
rank: 798
score: 98.75151909722223
patch: if ( < n CaMeL C ) {
rank: 798
score: 98.62190755208333
patch: ++ iter ; while ( iter < n CaMeL R )
rank: 798
score: 98.56981065538194
patch: int CaMeL Value = n CaMeL R ;
rank: 798
score: 98.54285430908203
patch: while ( false && true ) {
rank: 798
score: 98.52863103693181
patch: ++ iter ; ++ iter ; int * / ;
rank: 798
score: 98.52171325683594
patch: ++ n CaMeL R ; { {
rank: 798
score: 98.4384521484375
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ , iter ) ; }
rank: 798
score: 98.24108014787946
patch: ++ iter ; Thread . ;
rank: 798
score: 97.73426513671875
patch: ++ ++ $NUMBER$ ;
rank: 799
score: 98.74863891601562
patch: double [ ] current CaMeL Residuals = false ;
rank: 799
score: 98.62030029296875
patch: if ( iter > 0 ) { ++ iter ; }
rank: 799
score: 98.59981079101563
patch: long current CaMeL Cost = current CaMeL Objective ;
rank: 799
score: 98.54249790736607
patch: while ( iter ; ) {
rank: 799
score: 98.528564453125
patch: ++ iter ; ++ iter ; ; * * /
rank: 799
score: 98.4383075420673
patch: if ( ! 0 . is CaMeL Empty ( ) ; {
rank: 799
score: 98.24092320033482
patch: switch ; case - 1 :
rank: 799
score: 97.72978210449219
patch: ++ new ;
rank: 800
score: 98.61989920479911
patch: ++ iter * ++ * /
rank: 800
score: 98.59697265625
patch: result = current ;
rank: 800
score: 98.5423583984375
patch: if ( true ) { }
rank: 800
score: 98.52850341796875
patch: ++ iter ; ++ iter ; / * / ++ ;
rank: 800
score: 98.51363699776786
patch: i = n CaMeL C ;
rank: 800
score: 98.43814791165866
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ , $STRING$ ;
rank: 800
score: 98.24019077845982
patch: ++ n CaMeL R ; ;
rank: 800
score: 97.72943725585938
patch: long iter ++ ;
rank: 801
score: 98.61977317116477
patch: ++ iter ; while ( iter ; break ; }
rank: 801
score: 98.59633091517857
patch: synchronized ( qtf ) {
rank: 801
score: 98.5673828125
patch: double [ ] current CaMeL Objective ++ ;
rank: 801
score: 98.5362548828125
patch: ++ iter ; { ++ true ;
rank: 801
score: 98.52829996744792
patch: ++ iter ; ++ iter ; 0 ; ++ iter ;
rank: 801
score: 98.43810096153847
patch: throw new Runtime CaMeL Exception ( $STRING$ + 1 , ) ;
rank: 801
score: 98.23979840959821
patch: ++ iter ; ; break ;
rank: 801
score: 97.72794342041016
patch: ++ name ;
rank: 802
score: 98.61960671164773
patch: ++ iter ; ++ iter * / * * /
rank: 802
score: 98.59275817871094
patch: synchronized ( current CaMeL Cost ) {
rank: 802
score: 98.52738444010417
patch: ++ iter ; ++ iter ; try ; if iter ;
rank: 802
score: 98.50974527994792
patch: ++ iter = 0 ;
rank: 802
score: 98.43763224283855
patch: if ( ! iter == null ; return iter ; }
rank: 802
score: 98.23931012834821
patch: ++ iter ; throws Exception {
rank: 802
score: 97.7132568359375
patch: ++ max ; ;
rank: 803
score: 98.7419189453125
patch: return weighted CaMeL Residual ( qtf ) ;
rank: 803
score: 98.61891682942708
patch: int iter = current . index CaMeL Of ( current ;
rank: 803
score: 98.58897705078125
patch: ( true ) {
rank: 803
score: 98.5328598022461
patch: if ( iter <= 0 ) {
rank: 803
score: 98.52732340494792
patch: ++ iter ; while iter + iter ; ++ iter ;
rank: 803
score: 98.43736049107143
patch: throw new Runtime CaMeL Exception ( $STRING$ + [ 1 ] ) ;
rank: 803
score: 98.23880440848214
patch: if ( true ) break ;
rank: 803
score: 97.70421600341797
patch: ++ current ;
rank: 804
score: 98.74068603515624
patch: int [ ] current CaMeL Objective = $STRING$ ;
rank: 804
score: 98.58816189236111
patch: result = qtf [ iter ] ;
rank: 804
score: 98.55964491102431
patch: if ( 0 < n CaMeL C )
rank: 804
score: 98.53238677978516
patch: while ( true && false ) {
rank: 804
score: 98.50479125976562
patch: int current CaMeL Point = 0 ;
rank: 804
score: 98.43727805397727
patch: try { ++ iter ; } catch ; ; }
rank: 804
score: 98.23845825195312
patch: if ( ! ;
rank: 804
score: 97.68987426757812
patch: ++ $STRING$ iter ;
rank: 805
score: 98.73703002929688
patch: int [ ] current = current CaMeL Residuals ;
rank: 805
score: 98.6184414950284
patch: ++ iter ; while ( iter > 0 ) {
rank: 805
score: 98.53079986572266
patch: while ( true ) { iter .
rank: 805
score: 98.5255839029948
patch: return ( ++ iter ;
rank: 805
score: 98.50366973876953
patch: ++ iter < n CaMeL R ;
rank: 805
score: 98.43711344401042
patch: else { break ; }
rank: 805
score: 97.68895263671875
patch: ++ iter ; /
rank: 806
score: 98.61810302734375
patch: while ( iter < n CaMeL C ) ++ iter ;
rank: 806
score: 98.57965087890625
patch: i = iter ;
rank: 806
score: 98.54788547092014
patch: int CaMeL Value = current CaMeL Point ;
rank: 806
score: 98.52968924386161
patch: while ( ! true ) {
rank: 806
score: 98.5245869954427
patch: ++ iter ; ++ iter ; try { ++ iter ;
rank: 806
score: 98.50352478027344
patch: ++ iter = current CaMeL Objective ;
rank: 806
score: 98.43700062144886
patch: if ( iter == null ; / * * /
rank: 806
score: 98.23365129743304
patch: ++ iter ; continue ; }
rank: 806
score: 97.68745422363281
patch: ++ out ;
rank: 807
score: 98.73040161132812
patch: double [ ] current CaMeL Residuals = this ;
rank: 807
score: 98.57808227539063
patch: entry = current ;
rank: 807
score: 98.54631212022569
patch: int ++ iter = current CaMeL Point ;
rank: 807
score: 98.52600860595703
patch: while ( true , true ) {
rank: 807
score: 98.52423650568181
patch: ++ iter ; iter ; * - * / /
rank: 807
score: 98.436865234375
patch: if ( . is CaMeL Empty ( ) ) break ; ++ iter ;
rank: 807
score: 97.68473510742187
patch: iter = iter ;
rank: 808
score: 98.72970581054688
patch: Integer [ ] current CaMeL Objective = current ;
rank: 808
score: 98.57424926757812
patch: Object first CaMeL Iteration = current ;
rank: 808
score: 98.5457763671875
patch: boolean first CaMeL Iteration -- ;
rank: 808
score: 98.5239766438802
patch: ++ iter ; int iter = iter ; ++ iter ;
rank: 808
score: 98.52359008789062
patch: synchronized ( checker ) {
rank: 808
score: 98.50043487548828
patch: int first CaMeL Iteration = true ;
rank: 808
score: 98.4368387858073
patch: else { if ( iter > 0 ; return ; }
rank: 808
score: 98.21932373046874
patch: ++ iter 0 ;
rank: 808
score: 97.647998046875
patch: ++ < iter ;
rank: 809
score: 98.61740944602273
patch: ++ iter ; if ( iter >= iter ) {
rank: 809
score: 98.56995646158855
patch: long iter = 0 ;
rank: 809
score: 98.5237325032552
patch: int iter ; ++ iter ; / * * / /
rank: 809
score: 98.51792399088542
patch: while ( iter ; {
rank: 809
score: 98.49748229980469
patch: ++ iter + n CaMeL R ;
rank: 809
score: 98.4364901455966
patch: if ( iter > 0 ) return iter ; }
rank: 809
score: 98.21821812220982
patch: final float iter = iter ;
rank: 809
score: 97.63573455810547
patch: int iter ;
rank: 810
score: 98.7279296875
patch: ++ n CaMeL C ; current = current ;
rank: 810
score: 98.61698774857955
patch: ++ iter ] = new double [ iter ] ;
rank: 810
score: 98.56796264648438
patch: synchronized ( check CaMeL Parameters ) {
rank: 810
score: 98.53839111328125
patch: int current CaMeL Objective = current ;
rank: 810
score: 98.52365112304688
patch: ++ iter ; ++ iter ; out . iter iter ;
rank: 810
score: 98.517333984375
patch: while ( true ) break ;
rank: 810
score: 98.48995971679688
patch: ++ iter * checker ;
rank: 810
score: 98.43553059895834
patch: throw new Runtime CaMeL Exception ( $STRING$ + ++ [ 1 ] ) ;
rank: 810
score: 98.2166748046875
patch: ++ iter ; else if ;
rank: 810
score: 97.60610961914062
patch: iter iter ;
rank: 811
score: 98.56448800223214
patch: int iter = ++ iter ;
rank: 811
score: 98.53653971354167
patch: int [ ] qtf = current ;
rank: 811
score: 98.52341715494792
patch: int iter ; ++ iter ; * * ++ iter ;
rank: 811
score: 98.5164794921875
patch: if ( checker == null ) {
rank: 811
score: 98.4857421875
patch: i = 0 ;
rank: 811
score: 98.43496268136161
patch: if ( . is CaMeL Empty ( ) ; return false ; }
rank: 811
score: 98.21632893880208
patch: if ( ! iter )
rank: 811
score: 97.5877685546875
patch: ++ break ;
rank: 812
score: 98.71582709418402
patch: final int [ ] current = current ;
rank: 812
score: 98.615966796875
patch: ++ iter ; if ( iter != - 1 ;
rank: 812
score: 98.56174723307292
patch: if ( iter < n CaMeL R ;
rank: 812
score: 98.53140258789062
patch: byte [ ] current = current ;
rank: 812
score: 98.52328491210938
patch: ++ iter ; ++ iter ; iter ; int iter ;
rank: 812
score: 98.48491668701172
patch: ++ iter = current CaMeL Residuals ;
rank: 812
score: 98.43370643028847
patch: Iterator iter = iter . iterator ++ ; while ++ iter ;
rank: 812
score: 98.21475655691964
patch: if ( iter == 1 )
rank: 812
score: 97.5813217163086
patch: iter / ;
rank: 813
score: 98.71209716796875
patch: int qtf [ ] = 0 ;
rank: 813
score: 98.55916595458984
patch: synchronized ( current CaMeL Objective ) {
rank: 813
score: 98.52507866753473
patch: final boolean first CaMeL Iteration = true ;
rank: 813
score: 98.5230712890625
patch: ++ iter ; ++ iter ; else * ++ iter ;
rank: 813
score: 98.48275756835938
patch: double iter = n CaMeL C ;
rank: 813
score: 98.4333163174716
patch: else { ++ iter ; } ++ iter ; }
rank: 813
score: 97.57861328125
patch: iter ; else
rank: 814
score: 98.70873260498047
patch: ++ [ ] current = current ;
rank: 814
score: 98.61546834309895
patch: int n CaMeL R = ++ n CaMeL C ; ;
rank: 814
score: 98.55715603298611
patch: synchronized ( true ) { ++ iter ;
rank: 814
score: 98.52448187934027
patch: return current CaMeL Point [ iter ] ;
rank: 814
score: 98.5228780110677
patch: ++ iter ; ++ iter ; System . out ; ;
rank: 814
score: 98.50872802734375
patch: while ( checker && true ) {
rank: 814
score: 98.47190638950893
patch: ++ iter ] = current ;
rank: 814
score: 98.43243408203125
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + start ) ;
rank: 814
score: 98.20908900669643
patch: pos = iter + 1 ;
rank: 814
score: 97.55387878417969
patch: ++ iterator ;
rank: 815
score: 98.70489501953125
patch: int qtf [ ] = null ;
rank: 815
score: 98.61512451171875
patch: ++ iter ; while ( iter <= iter )
rank: 815
score: 98.55641004774306
patch: n CaMeL C < n CaMeL C ;
rank: 815
score: 98.52276056463069
patch: ++ iter ; ++ iter ; * * ; /
rank: 815
score: 98.51738823784723
patch: if ( n CaMeL C < 0 )
rank: 815
score: 98.50817108154297
patch: while ( iter <= iter ) {
rank: 815
score: 98.43226841517857
patch: if ( . is CaMeL Empty ( ) ) return null ; else
rank: 815
score: 98.208984375
patch: while ( iter == null )
rank: 815
score: 97.55217742919922
patch: iter -- ;
rank: 816
score: 98.70139567057292
patch: if ( false ) { ++ iter ;
rank: 816
score: 98.52259410511364
patch: / * ] iter ; ++ iter ; ++ ;
rank: 816
score: 98.48820277622768
patch: while ( true ) { final
rank: 816
score: 98.46311442057292
patch: ++ iter = current ;
rank: 816
score: 98.43225911458333
patch: if ( . is CaMeL Empty ( ; ) ) return iter ; }
rank: 816
score: 98.20821707589286
patch: if ( ! iter . ;
rank: 816
score: 97.55036926269531
patch: } iter ;
rank: 817
score: 98.6150410970052
patch: final ; ++ iter = iter . iter ( ) ;
rank: 817
score: 98.55425347222223
patch: ( iter < n CaMeL R ) {
rank: 817
score: 98.52250532670455
patch: ++ iter ; ++ iter ; * / / ;
rank: 817
score: 98.51214599609375
patch: boolean first CaMeL Iteration = 1 ;
rank: 817
score: 98.47832380022321
patch: while ( true ) { )
rank: 817
score: 98.43219549005681
patch: if ( iter < 0 ) { break ; }
rank: 817
score: 98.20782470703125
patch: ++ iter & iter ;
rank: 817
score: 97.54035949707031
patch: / ; iter
rank: 818
score: 98.68239339192708
patch: final double [ ] current = current ;
rank: 818
score: 98.61408342633929
patch: final ; ++ iter * /
rank: 818
score: 98.55166965060764
patch: n CaMeL C < current CaMeL Point ;
rank: 818
score: 98.52236938476562
patch: ++ iter ; ++ iter ; if iter ; iter ;
rank: 818
score: 98.51129150390625
patch: boolean [ ] current = current ;
rank: 818
score: 98.45397186279297
patch: ++ n CaMeL C ; continue ;
rank: 818
score: 98.431884765625
patch: else { if ++ iter > 0 . length ; }
rank: 818
score: 98.2035624186198
patch: ++ iter ] ; }
rank: 818
score: 97.53669738769531
patch: long iter ;
rank: 819
score: 98.6693344116211
patch: double [ ] current = null ;
rank: 819
score: 98.61388050426136
patch: ++ iter ; / * * * * * /
rank: 819
score: 98.55031127929688
patch: current = current ;
rank: 819
score: 98.52187093098958
patch: ++ iter ; ++ iter ; / / * iter ;
rank: 819
score: 98.49966430664062
patch: double qr CaMeL Decomposition = current ;
rank: 819
score: 98.46830240885417
patch: int iter = current ;
rank: 819
score: 98.43162434895834
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + ; , null ;
rank: 819
score: 98.20329938616071
patch: } while ( true ) {
rank: 819
score: 97.52903747558594
patch: ++ min ;
rank: 820
score: 98.65963745117188
patch: int [ ] current CaMeL Objective ;
rank: 820
score: 98.54338836669922
patch: synchronized ( current CaMeL Residuals ) {
rank: 820
score: 98.52171741832386
patch: ++ iter ; ++ 1 ; ++ iter ; }
rank: 820
score: 98.45294799804688
patch: ++ iter ; final
rank: 820
score: 98.43065534319196
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ; return iter ;
rank: 820
score: 98.20231410435268
patch: ++ iter - iter $NUMBER$ ;
rank: 820
score: 97.50788116455078
patch: iter else ;
rank: 821
score: 98.65393744574652
patch: if ( ! current CaMeL Cost ) {
rank: 821
score: 98.61277465820312
patch: if ( ++ iter < n CaMeL R ;
rank: 821
score: 98.54294259207589
patch: current CaMeL Point = current ;
rank: 821
score: 98.5215731534091
patch: ++ iter ; ; * * / int iter ;
rank: 821
score: 98.48948669433594
patch: int iter [ ] = current ;
rank: 821
score: 98.44224548339844
patch: ++ iter = solved CaMeL Cols ;
rank: 821
score: 98.43900146484376
patch: ++ true ; }
rank: 821
score: 98.1998291015625
patch: ++ iter ; System . ;
rank: 821
score: 97.49592590332031
patch: / iter ;
rank: 822
score: 98.64988878038194
patch: if ( ! n CaMeL C ) {
rank: 822
score: 98.53951590401786
patch: int ++ iter = 0 ;
rank: 822
score: 98.52117919921875
patch: ++ iter ; / * * / / int iter ;
rank: 822
score: 98.48938751220703
patch: int CaMeL Value current = current ;
rank: 822
score: 98.43816266741071
patch: ++ iter ; final else {
rank: 822
score: 98.437744140625
patch: int iter = 0 ; {
rank: 822
score: 98.43006998697916
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + 1 . 0 ;
rank: 822
score: 97.44342041015625
patch: ++ * ;
rank: 823
score: 98.64978705512152
patch: Object qtf [ ] = current ;
rank: 823
score: 98.611083984375
patch: ++ iter ; synchronized ( ++ iter ) {
rank: 823
score: 98.53880092075893
patch: n CaMeL C = current ;
rank: 823
score: 98.52100719105114
patch: ++ iter ; while ++ iter ; int iter ;
rank: 823
score: 98.48772430419922
patch: int iter = current CaMeL Residuals ;
rank: 823
score: 98.43771798270089
patch: while ( true || true )
rank: 823
score: 98.43730163574219
patch: ++ iter ; current = current ;
rank: 823
score: 98.42997602982955
patch: if ( iter == 0 ) return iter ; }
rank: 823
score: 98.19241333007812
patch: switch ( iter )
rank: 823
score: 97.42647552490234
patch: ++ $STRING$ /
rank: 824
score: 98.64548746744792
patch: int CaMeL Value [ ] = current ;
rank: 824
score: 98.53823852539062
patch: long current CaMeL Cost = permutation ;
rank: 824
score: 98.5209452311198
patch: ++ iter ; if iter + 0 ; ++ iter ;
rank: 824
score: 98.43699428013393
patch: if ( first CaMeL Iteration )
rank: 824
score: 98.42981770833333
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ , 1 ) ; }
rank: 824
score: 98.18262736002605
patch: if ( ++ iter ;
rank: 824
score: 97.42527770996094
patch: iter ; *
rank: 825
score: 98.64546203613281
patch: int [ ] current = null ;
rank: 825
score: 98.53125
patch: n CaMeL C < n CaMeL R ;
rank: 825
score: 98.52076305042614
patch: ++ iter ; ++ iter ; System . min ;
rank: 825
score: 98.42974853515625
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + ++ 1 ;
rank: 825
score: 98.17263793945312
patch: if ( ! iter ;
rank: 825
score: 97.42189025878906
patch: iter ; /
rank: 826
score: 98.61014404296876
patch: ++ iter ; while ( iter < $NUMBER$ )
rank: 826
score: 98.53091430664062
patch: synchronized ( lm CaMeL Dir ) {
rank: 826
score: 98.5200528231534
patch: ++ iter ; try { iter ; ++ iter ;
rank: 826
score: 98.47743225097656
patch: final int CaMeL Value = 0 ;
rank: 826
score: 98.4294942220052
patch: / * / * /
rank: 826
score: 98.42093331473214
patch: ++ checker [ iter ] ;
rank: 826
score: 98.4180908203125
patch: ++ iter ; { { {
rank: 826
score: 98.17130126953126
patch: while ( false )
rank: 826
score: 97.39628601074219
patch: ++ copy ;
rank: 827
score: 98.60869489397321
patch: ++ iter ; final ; ;
rank: 827
score: 98.52422332763672
patch: long [ ] current = current ;
rank: 827
score: 98.5198465983073
patch: ++ iter ; ++ iter ; for iter ; 0 ;
rank: 827
score: 98.47705078125
patch: boolean first CaMeL Iteration = $NUMBER$ ;
rank: 827
score: 98.42941518930289
patch: throw new Runtime CaMeL Exception ( $STRING$ + iter : $STRING$ ;
rank: 827
score: 98.41789899553571
patch: ++ iter ] = 0 ;
rank: 827
score: 98.16197713216145
patch: assert iter >= iter ;
rank: 827
score: 97.39573160807292
patch: } iter
rank: 828
score: 98.52119276258681
patch: < Point CaMeL Vector CaMeL Value CaMeL Pair
rank: 828
score: 98.51966441761364
patch: / * ++ iter ; ++ iter ; iter ;
rank: 828
score: 98.4292879971591
patch: if ( ! iter == iter ; ++ iter ;
rank: 828
score: 98.4118881225586
patch: ++ current CaMeL Objective ; { {
rank: 828
score: 98.1583251953125
patch: ++ iter >= 0 ;
rank: 828
score: 97.380615234375
patch: -- iter ;
rank: 829
score: 98.6077392578125
patch: result [ iter ] = ++ iter ; }
rank: 829
score: 98.52101135253906
patch: long current CaMeL Point = current ;
rank: 829
score: 98.5192362467448
patch: ++ iter ; ++ iter ; for iter + 0 ;
rank: 829
score: 98.46414184570312
patch: switch ( n CaMeL C ) {
rank: 829
score: 98.42908653846153
patch: throw new Runtime CaMeL Exception ( $STRING$ + $NUMBER$ , $STRING$ ;
rank: 829
score: 98.40999058314732
patch: if ( true && true )
rank: 829
score: 98.15415445963542
patch: ++ iter % iter ;
rank: 829
score: 97.37032063802083
patch: / ;
rank: 830
score: 98.61930084228516
patch: double [ ] current CaMeL Objective =
rank: 830
score: 98.60765491832386
patch: ++ iter * / * * / iter * /
rank: 830
score: 98.5189208984375
patch: int iter ; ++ iter ; * * / /
rank: 830
score: 98.46308898925781
patch: int [ ] permutation = current ;
rank: 830
score: 98.42886352539062
patch: ++ * iter ; }
rank: 830
score: 98.40748596191406
patch: ++ iter - solved CaMeL Cols ;
rank: 830
score: 98.406005859375
patch: ++ true ; {
rank: 830
score: 98.15201822916667
patch: ++ iter - start ;
rank: 830
score: 97.3648681640625
patch: else ; iter
rank: 831
score: 98.60757107204861
patch: int qtf [ ] = this ;
rank: 831
score: 98.60755615234375
patch: ++ iter ; new Integer ( iter ) ;
rank: 831
score: 98.51846313476562
patch: ++ iter ; ++ iter ; ++ * / iter ;
rank: 831
score: 98.51632690429688
patch: item = current ;
rank: 831
score: 98.46200561523438
patch: int qr CaMeL Decomposition = current ;
rank: 831
score: 98.4285888671875
patch: if ( . iter == 0 ) { return null ; }
rank: 831
score: 98.40584019252232
patch: i = 0 . 0 ;
rank: 831
score: 98.40416608537946
patch: ++ while ( true ) {
rank: 831
score: 98.14914957682292
patch: state = ++ iter ;
rank: 831
score: 97.36412048339844
patch: iter else iter
rank: 832
score: 98.60752175071023
patch: while ( iter < iter ; iter ++ ) {
rank: 832
score: 98.60584259033203
patch: if ( true ) { / *
rank: 832
score: 98.51805530894886
patch: ++ iter ; / * / / int iter ;
rank: 832
score: 98.51618787977431
patch: n CaMeL C = current CaMeL Point ;
rank: 832
score: 98.46133422851562
patch: ++ iter ; final = current ;
rank: 832
score: 98.42830716646634
patch: ++ iter ; for iter = iter . value CaMeL Of (
rank: 832
score: 98.40510777064732
patch: ++ iter = 0 ; {
rank: 832
score: 98.390673828125
patch: while ( iter ;
rank: 832
score: 98.14498901367188
patch: ++ iter >= 1 ;
rank: 832
score: 97.359375
patch: break ; ;
rank: 833
score: 98.6063565340909
patch: int iter = current CaMeL Point . length ; ;
rank: 833
score: 98.5178555575284
patch: ++ iter ; iter ; * * / iter ;
rank: 833
score: 98.5107421875
patch: public int do CaMeL Optimize ( ) {
rank: 833
score: 98.42777193509616
patch: throw new Runtime CaMeL Exception ( $STRING$ + $NUMBER$ + 0 ;
rank: 833
score: 98.40089416503906
patch: ++ x CaMeL Norm = 0 ;
rank: 833
score: 97.35049438476562
patch: ++ ; iter
rank: 834
score: 98.60615757533482
patch: ++ iter * / / ;
rank: 834
score: 98.60195583767361
patch: ++ n CaMeL C ; = current ;
rank: 834
score: 98.5177714029948
patch: ++ iter ; int iter ; / * * / /
rank: 834
score: 98.50998263888889
patch: check CaMeL Parameters ( current CaMeL Point ,
rank: 834
score: 98.4552993774414
patch: double iter = jac CaMeL Norm ;
rank: 834
score: 98.42726828835227
patch: if ( iter > 0 ; ++ iter 0 ;
rank: 834
score: 98.40005057198661
patch: Convergence CaMeL Checker > 0 ;
rank: 834
score: 98.37879289899554
patch: } if ( true ) {
rank: 834
score: 98.13724772135417
patch: if ( ! contains ;
rank: 834
score: 97.33786010742188
patch: ++ Arrays ;
rank: 835
score: 98.60514692826705
patch: while ( iter < n CaMeL R ) { ;
rank: 835
score: 98.60131157769098
patch: double qtf [ ] = current ;
rank: 835
score: 98.5177001953125
patch: ++ iter ; ++ iter ; System . max iter ;
rank: 835
score: 98.50865173339844
patch: Object [ ] current = current ;
rank: 835
score: 98.42701305042614
patch: if ( iter > 0 ; / * * ;
rank: 835
score: 98.42611694335938
patch: int iter = current CaMeL Objective ;
rank: 835
score: 98.37408447265625
patch: while ( iter > 0 )
rank: 835
score: 98.13621012369792
patch: for ( ; ; )
rank: 835
score: 97.31404113769531
patch: if iter ;
rank: 836
score: 98.5997543334961
patch: ++ current CaMeL Point = current ;
rank: 836
score: 98.5176669034091
patch: try { ++ iter ; ++ iter ; break ;
rank: 836
score: 98.42698317307692
patch: if ( ! iter == null ) { return null ; }
rank: 836
score: 98.39938354492188
patch: double [ ] current = 0 ;
rank: 836
score: 98.37313406808036
patch: while ( iter <= true )
rank: 836
score: 98.12826538085938
patch: final ++ iter ; ;
rank: 836
score: 97.27369689941406
patch: ++ ; /
rank: 837
score: 98.60331587357955
patch: ++ iter ; / * ++ iter ; * /
rank: 837
score: 98.59742736816406
patch: ++ x CaMeL Norm = current ;
rank: 837
score: 98.51725260416667
patch: ++ iter ; ++ iter ; try ; return iter ;
rank: 837
score: 98.50357491629464
patch: first CaMeL Iteration = null ;
rank: 837
score: 98.42559259588069
patch: else { ++ iter ; * / ++ iter ;
rank: 837
score: 98.3951416015625
patch: ++ iter ; iter = current ;
rank: 837
score: 98.35672433035714
patch: / / if ( true )
rank: 837
score: 98.126708984375
patch: ++ iter - iter )
rank: 837
score: 97.26249186197917
patch: ++ ;
rank: 838
score: 98.51715087890625
patch: int iter ; try ;
rank: 838
score: 98.49906703404018
patch: synchronized ( weighted CaMeL Residual )
rank: 838
score: 98.42557779947917
patch: else { if ( iter == 0 ) return null ;
rank: 838
score: 98.41798400878906
patch: return weight CaMeL Matrix CaMeL Sqrt ;
rank: 838
score: 98.39493560791016
patch: ++ iter * current CaMeL Objective ;
rank: 838
score: 98.34336344401042
patch: while ( checker ) {
rank: 838
score: 97.25666809082031
patch: iter * ;
rank: 839
score: 98.59608677455357
patch: ++ iter ; iter = ;
rank: 839
score: 98.51708984375
patch: ++ iter ; try { ++ iter ; iter ;
rank: 839
score: 98.49582248263889
patch: ( ++ iter < n CaMeL R )
rank: 839
score: 98.4251708984375
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ , 1 ) ;
rank: 839
score: 98.38104248046875
patch: int CaMeL Value = 0 ;
rank: 839
score: 98.34030587332589
patch: while ( iter < true )
rank: 839
score: 97.251708984375
patch: ++ in ;
rank: 840
score: 98.5170010653409
patch: ++ iter ; ++ iter ; while ( iter ;
rank: 840
score: 98.49396362304688
patch: tmp = current ;
rank: 840
score: 98.4241231282552
patch: else { if ; ++ iter ] = iter ; }
rank: 840
score: 98.3749287923177
patch: i = 0 ; {
rank: 840
score: 98.33782958984375
patch: ++ solved CaMeL Cols ;
rank: 840
score: 98.1043701171875
patch: scope = ++ iter ;
rank: 840
score: 97.25154113769531
patch: / ; ;
rank: 841
score: 98.57562255859375
patch: iter = iter . iter ;
rank: 841
score: 98.51698811848958
patch: ++ iter ; int iter ; * / ++ iter ;
rank: 841
score: 98.4918212890625
patch: protected int do CaMeL Optimize ( ) {
rank: 841
score: 98.42323996803977
patch: if ( ! iter == null ; return iter ;
rank: 841
score: 98.37318638392857
patch: ++ iter * checker ; {
rank: 841
score: 98.32591029575893
patch: / * while ( true )
rank: 841
score: 97.25012969970703
patch: ++ default ;
rank: 842
score: 98.51670143821023
patch: ++ iter ; ++ iter ; ++ * / ;
rank: 842
score: 98.48928397042411
patch: int ++ iter = iter ;
rank: 842
score: 98.42234108664773
patch: else { if ++ iter * 0 . 0 ;
rank: 842
score: 98.32484654017857
patch: while ( ( true ) )
rank: 842
score: 98.0963134765625
patch: synchronized ( iter ) {
rank: 842
score: 97.24517822265625
patch: int 1 ;
rank: 843
score: 98.56566365559895
patch: ++ iter * * /
rank: 843
score: 98.51637961647727
patch: ++ iter ; int iter ; int * * /
rank: 843
score: 98.48830740792411
patch: first CaMeL Iteration = 0 ;
rank: 843
score: 98.42117309570312
patch: if ( iter > 0 ) { return iter ; }
rank: 843
score: 98.32049560546875
patch: ++ true ; ++ true ;
rank: 843
score: 98.09608968098958
patch: if ( ! ) {
rank: 843
score: 97.21888732910156
patch: int 0 ;
rank: 844
score: 98.56462751116071
patch: ++ iter * $NUMBER$ * /
rank: 844
score: 98.515869140625
patch: ++ iter ; ++ iter ; while ++ iter ; ;
rank: 844
score: 98.48695591517857
patch: first CaMeL Iteration = permutation ;
rank: 844
score: 98.42078746448864
patch: if ( iter == 0 ; / * ++ ;
rank: 844
score: 98.4110336303711
patch: boolean first CaMeL Iteration = ) {
rank: 844
score: 98.31873430524554
patch: while ( iter < checker )
rank: 844
score: 98.09578450520833
patch: ++ iter ; null ;
rank: 844
score: 97.21402740478516
patch: ++ delta ;
rank: 845
score: 98.51549072265625
patch: i * ++ ;
rank: 845
score: 98.4836654663086
patch: result [ iter ] = current ;
rank: 845
score: 98.42012532552083
patch: else { ++ iter ; } return ++ iter ; }
rank: 845
score: 98.31712123325893
patch: while ( iter <= checker )
rank: 845
score: 98.31631905691964
patch: ++ < n CaMeL C ;
rank: 845
score: 98.09130859375
patch: i ++ ; ++ ;
rank: 845
score: 97.1849136352539
patch: = iter ;
rank: 846
score: 98.55515834263393
patch: ++ iter > - 1 ;
rank: 846
score: 98.51495916193181
patch: ++ iter ; int iter ; * * / /
rank: 846
score: 98.41966663707386
patch: if ( iter == 0 ; / * / ;
rank: 846
score: 98.31368582589286
patch: ++ current CaMeL Residuals ; }
rank: 846
score: 98.09046020507813
patch: ++ iter -- ;
rank: 846
score: 97.17662048339844
patch: ++ compare ;
rank: 847
score: 98.51495361328125
patch: ++ iter ; ++ iter ; int * * 1 ;
rank: 847
score: 98.41963704427083
patch: else { throw new Runtime CaMeL Exception ( $STRING$ ) ;
rank: 847
score: 98.40341186523438
patch: boolean first CaMeL Iteration = iter ;
rank: 847
score: 98.31397356305804
patch: i = n CaMeL R ;
rank: 847
score: 98.31304931640625
patch: while ( iter ; )
rank: 847
score: 98.08946736653645
patch: ++ iter * 1 ;
rank: 847
score: 97.1761474609375
patch: ++ stop ;
rank: 848
score: 98.51436360677083
patch: this . iter ; ++ iter ; ++ iter ; ;
rank: 848
score: 98.47102661132813
patch: previous = current ;
rank: 848
score: 98.4195048014323
patch: if ( iter == 0 ) return null ; else {
rank: 848
score: 98.4026107788086
patch: if ( true ) { break ;
rank: 848
score: 98.31158447265625
patch: while ( iter = true )
rank: 848
score: 98.08677164713542
patch: assert iter != null ;
rank: 848
score: 97.16544342041016
patch: ++ do ;
rank: 849
score: 98.51414905894886
patch: this . ++ iter ; ++ iter ; * /
rank: 849
score: 98.46915690104167
patch: Integer current = current ;
rank: 849
score: 98.41903686523438
patch: if ( iter > 0 ; return iter * ; }
rank: 849
score: 98.40121459960938
patch: / * int iter = 0 ;
rank: 849
score: 98.30889020647321
patch: while ( iter < 0 )
rank: 849
score: 98.29837036132812
patch: ++ current CaMeL Residuals ;
rank: 849
score: 98.0839131673177
patch: iter = ++ iter ;
rank: 849
score: 97.15861511230469
patch: ++ / ;
rank: 850
score: 98.54170227050781
patch: ++ current CaMeL Objective ( ) ;
rank: 850
score: 98.51413796164773
patch: ++ iter ; ; / * / int iter ;
rank: 850
score: 98.46647644042969
patch: int current CaMeL Cost = current ;
rank: 850
score: 98.30617850167411
patch: / / while ( true )
rank: 850
score: 98.2913818359375
patch: ++ current CaMeL Residuals ; {
rank: 850
score: 98.08082071940105
patch: ++ iter >= iter ;
rank: 850
score: 97.1560287475586
patch: ++ get ;
rank: 851
score: 98.54148864746094
patch: if ( true ) { / /
rank: 851
score: 98.51393636067708
patch: ++ iter ; ++ iter ; * / if iter ;
rank: 851
score: 98.46588897705078
patch: first CaMeL Iteration = qtf ;
rank: 851
score: 98.4186503092448
patch: / * ++ * /
rank: 851
score: 98.07987467447917
patch: ++ iter 1 ++ ;
rank: 851
score: 97.15133666992188
patch: if iter ]
rank: 852
score: 98.54086303710938
patch: int [ ] current = 0 ;
rank: 852
score: 98.51378284801136
patch: ++ iter ; ++ iter ; ++ for iter ;
rank: 852
score: 98.45965576171875
patch: ( true ) { ++ iter ;
rank: 852
score: 98.4185078938802
patch: throw new Runtime CaMeL Exception ( $STRING$ + iter + ;
rank: 852
score: 98.39574432373047
patch: double [ ] iter = current ;
rank: 852
score: 98.29570661272321
patch: while ( ( true ) {
rank: 852
score: 98.28269740513393
patch: ++ iter * > 0 ;
rank: 852
score: 97.1500473022461
patch: else iter ;
rank: 853
score: 98.51271565755208
patch: ++ iter ; ++ iter ; * * iter ; /
rank: 853
score: 98.45732770647321
patch: check CaMeL Parameters ( ) ;
rank: 853
score: 98.39739990234375
patch: / * += iter ;
rank: 853
score: 98.06884765625
patch: do { ++ iter ;
rank: 853
score: 97.14065551757812
patch: } iter iter
rank: 854
score: 98.51253255208333
patch: ++ iter ; else { ++ iter ; break ; }
rank: 854
score: 98.45433044433594
patch: long first CaMeL Iteration = current ;
rank: 854
score: 98.3961181640625
patch: ++ iter iter ; }
rank: 854
score: 98.39471435546875
patch: int n CaMeL R = current ;
rank: 854
score: 98.26648966471355
patch: if ( checker ) {
rank: 854
score: 98.06852213541667
patch: final ; if ( ;
rank: 854
score: 97.115966796875
patch: int iter /
rank: 855
score: 98.53277587890625
patch: int [ ] current CaMeL Objective =
rank: 855
score: 98.52983747209821
patch: ++ iter = iter . ;
rank: 855
score: 98.51238458806819
patch: ++ iter ; ++ iter ; / / * ;
rank: 855
score: 98.39276123046875
patch: / * * * ;
rank: 855
score: 98.39165496826172
patch: ++ iter ; final / * /
rank: 855
score: 97.08595275878906
patch: ++ $STRING$ *
rank: 856
score: 98.44619750976562
patch: if ( ! first CaMeL Iteration )
rank: 856
score: 98.3886006673177
patch: double [ ] current ;
rank: 856
score: 98.38717651367188
patch: return true ; }
rank: 856
score: 98.27736409505208
patch: ++ iter = checker ;
rank: 856
score: 98.22823079427083
patch: while ( iter ; final
rank: 856
score: 97.083740234375
patch: ++ Integer ;
rank: 857
score: 98.52531215122768
patch: ++ iter ; * ; ;
rank: 857
score: 98.51125081380208
patch: int iter ; ++ iter + iter ; ++ iter ;
rank: 857
score: 98.38851165771484
patch: double qr CaMeL Decomposition = 0 ;
rank: 857
score: 98.27490234375
patch: ++ iter * 0 ;
rank: 857
score: 98.22813720703125
patch: ++ checker ; }
rank: 857
score: 98.06348673502605
patch: float iter = iter ;
rank: 857
score: 97.08110809326172
patch: try ; iter
rank: 858
score: 98.5221455891927
patch: ++ iter * ++ ;
rank: 858
score: 98.51108805338542
patch: ++ iter ; ++ iter ; / * if iter ;
rank: 858
score: 98.4410400390625
patch: ( ++ iter ) ;
rank: 858
score: 98.38363647460938
patch: boolean first CaMeL Iteration = ) ;
rank: 858
score: 98.3770039876302
patch: / * * ++ ;
rank: 858
score: 97.07860565185547
patch: ++ abs ;
rank: 859
score: 98.52158028738839
patch: this . ++ iter ++ ;
rank: 859
score: 98.51091974431819
patch: ++ iter ; ++ iter ; iter * * /
rank: 859
score: 98.5072250366211
patch: double current CaMeL Objective = 0 ;
rank: 859
score: 98.44007219587054
patch: first CaMeL Iteration = iter ;
rank: 859
score: 98.380859375
patch: double [ ] qr CaMeL Decomposition ;
rank: 859
score: 98.05362955729167
patch: ++ iter += iter ;
rank: 859
score: 97.0745849609375
patch: iter else
rank: 860
score: 98.51877267020089
patch: if ; ++ iter ++ ;
rank: 860
score: 98.51066080729167
patch: int iter * ++ ;
rank: 860
score: 98.50347900390625
patch: if ( false && true ) {
rank: 860
score: 98.42591857910156
patch: public int do CaMeL Optimize ( )
rank: 860
score: 98.20236206054688
patch: ++ current CaMeL Cost ;
rank: 860
score: 97.0616455078125
patch: ++ super .
rank: 861
score: 98.50927734375
patch: ++ iter ; ++ iter ; ++ * * iter ;
rank: 861
score: 98.42093912760417
patch: i = ++ iter ;
rank: 861
score: 98.37854766845703
patch: switch ( n CaMeL R ) {
rank: 861
score: 98.36612955729167
patch: } return ++ iter ;
rank: 861
score: 98.18489583333333
patch: while ( iter ) {
rank: 861
score: 98.05171712239583
patch: final ++ iter ; }
rank: 861
score: 97.06071472167969
patch: ++ trim ;
rank: 862
score: 98.51637486049107
patch: ++ iter - iter * /
rank: 862
score: 98.50892130533855
patch: ++ iter ; ++ iter ; int * * iter ;
rank: 862
score: 98.42032296316964
patch: i < n CaMeL R ;
rank: 862
score: 98.17125701904297
patch: ++ checker ;
rank: 862
score: 98.05043538411458
patch: ++ iter == 1 ;
rank: 862
score: 97.05177307128906
patch: ++ iter .
rank: 863
score: 98.51546020507813
patch: ++ iter * ;
rank: 863
score: 98.50879923502605
patch: ++ iter ; ++ iter ; start ; ++ iter ;
rank: 863
score: 98.35741170247395
patch: return iter ; ; }
rank: 863
score: 97.04873657226562
patch: int iter *
rank: 864
score: 98.5137939453125
patch: ++ iter % $NUMBER$ ;
rank: 864
score: 98.48798370361328
patch: double current CaMeL Objective = current ;
rank: 864
score: 98.25472005208333
patch: int iter = 1 ;
rank: 864
score: 98.16168212890625
patch: final Convergence CaMeL Checker ;
rank: 864
score: 98.03270263671875
patch: final ; final ;
rank: 864
score: 97.04854583740234
patch: ++ / /
rank: 865
score: 98.508544921875
patch: ++ iter ; ++ iter ; int * * ; /
rank: 865
score: 98.48456573486328
patch: ++ n CaMeL C ; / *
rank: 865
score: 98.40327671595982
patch: x CaMeL Norm = 0 ;
rank: 865
score: 98.35448201497395
patch: ++ $NUMBER$ * iter ;
rank: 865
score: 98.25279889787946
patch: ++ iter ; ++ ; {
rank: 865
score: 98.1536153157552
patch: while ( ! checker )
rank: 865
score: 98.03263346354167
patch: result = ++ iter ;
rank: 865
score: 97.03103637695312
patch: ++ System ;
rank: 866
score: 98.50759887695312
patch: ++ iter ; ++ iter ; if ++ iter ; ;
rank: 866
score: 98.48411560058594
patch: int [ ] current = this ;
rank: 866
score: 98.39999825613839
patch: i < n CaMeL C ;
rank: 866
score: 98.35203857421875
patch: } return iter ;
rank: 866
score: 98.32506713867187
patch: int ++ iter ;
rank: 866
score: 98.25137765066964
patch: ++ iter * 0 ; {
rank: 866
score: 98.15257771809895
patch: Iterator iter = current ;
rank: 866
score: 98.03143310546875
patch: final ; iter ++ ;
rank: 866
score: 97.01995849609375
patch: ++ super /
rank: 867
score: 98.50851004464286
patch: ++ iter ; return ; }
rank: 867
score: 98.50716145833333
patch: ++ iter ; int iter ; / * / / /
rank: 867
score: 98.3973388671875
patch: break ; }
rank: 867
score: 98.35049438476562
patch: else { ++ max ;
rank: 867
score: 98.14312744140625
patch: assert ( true ) ;
rank: 867
score: 98.02903238932292
patch: ++ iter ; finally {
rank: 867
score: 97.0159912109375
patch: Iterator 0 ;
rank: 868
score: 98.50575764973958
patch: ++ iter ; ++ iter ; / * * ++ /
rank: 868
score: 98.39443533761161
patch: first CaMeL Iteration = false ;
rank: 868
score: 98.24513462611607
patch: ++ solved CaMeL Cols ; {
rank: 868
score: 98.02876790364583
patch: final ++ iter ++ ;
rank: 868
score: 97.01118469238281
patch: ++ insert ;
rank: 869
score: 98.50548299153645
patch: ++ iter ; if iter ; try ; ++ iter ;
rank: 869
score: 98.50083705357143
patch: ++ iter / * * /
rank: 869
score: 98.46754455566406
patch: if ( permutation == 0 ) {
rank: 869
score: 98.381591796875
patch: int current = current ;
rank: 869
score: 98.34390258789062
patch: / * = iter ;
rank: 869
score: 98.29764811197917
patch: int [ ] current ;
rank: 869
score: 98.0851542154948
patch: while ( ! true )
rank: 869
score: 98.02744547526042
patch: ++ iter ] ; ;
rank: 869
score: 97.00547790527344
patch: ; iter ;
rank: 870
score: 98.50437418619792
patch: ++ iter ; ++ iter ; while iter ; break ;
rank: 870
score: 98.50026157924107
patch: final ; ++ iter * ;
rank: 870
score: 98.34193929036458
patch: else if ++ iter ;
rank: 870
score: 98.26988728841145
patch: boolean first CaMeL Iteration ;
rank: 870
score: 98.24432373046875
patch: e = current CaMeL Point ;
rank: 870
score: 98.08408813476562
patch: if ( iter ;
rank: 870
score: 98.02440388997395
patch: ++ iter == 0 ;
rank: 870
score: 97.00187683105469
patch: ++ split ;
rank: 871
score: 98.50374348958333
patch: ++ iter ; iter ; * / * ++ iter ;
rank: 871
score: 98.34085083007812
patch: / * ; * /
rank: 871
score: 98.07616170247395
patch: ++ x CaMeL Norm ;
rank: 871
score: 98.02156982421874
patch: this . ++ ;
rank: 871
score: 96.99005126953125
patch: iter iter
rank: 872
score: 98.49911499023438
patch: iter = iter . ;
rank: 872
score: 98.498291015625
patch: ++ iter ; out ;
rank: 872
score: 98.36021118164062
patch: node = current ;
rank: 872
score: 98.3390604654948
patch: else { return ; }
rank: 872
score: 98.26456124441964
patch: int ++ iter = current ;
rank: 872
score: 98.075732421875
patch: Convergence CaMeL Checker ;
rank: 872
score: 98.02108764648438
patch: Object iter = iter ;
rank: 872
score: 96.98738098144531
patch: { iter ;
rank: 873
score: 98.49725341796875
patch: ++ iter ; if ; ;
rank: 873
score: 98.48939005533855
patch: ++ $NUMBER$ ++ iter ;
rank: 873
score: 98.338623046875
patch: else return null ; }
rank: 873
score: 98.01957194010417
patch: ++ iter ^ iter ;
rank: 873
score: 96.9748764038086
patch: ++ continue ;
rank: 874
score: 98.49229939778645
patch: ++ iter ; new ;
rank: 874
score: 98.47709147135417
patch: int iter + 0 ;
rank: 874
score: 98.34378487723214
patch: long iter = ++ iter ;
rank: 874
score: 98.336572265625
patch: else { else {
rank: 874
score: 98.24728829520089
patch: ++ iter ; / * /
rank: 874
score: 98.22891671316964
patch: else { ++ iter ; {
rank: 874
score: 98.01922607421875
patch: int start = iter ;
rank: 874
score: 96.96593475341797
patch: iter iter else
rank: 875
score: 98.4920654296875
patch: ++ iter / * * ;
rank: 875
score: 98.47231038411458
patch: return new ++ iter ;
rank: 875
score: 98.34105224609375
patch: key = current ;
rank: 875
score: 98.335693359375
patch: else { ++ in ;
rank: 875
score: 98.24404471261161
patch: if ( true ) continue ;
rank: 875
score: 98.0323486328125
patch: ++ first CaMeL Iteration ;
rank: 875
score: 98.0179443359375
patch: ++ iter / $NUMBER$ ;
rank: 875
score: 96.96505737304688
patch: iter / /
rank: 876
score: 98.4696044921875
patch: i ; ++ iter ;
rank: 876
score: 98.33746337890625
patch: long current = current ;
rank: 876
score: 98.32996622721355
patch: else { ++ 0 ;
rank: 876
score: 98.22419084821429
patch: ++ iter ; ++ checker ;
rank: 876
score: 98.02907307942708
patch: Iterator iter = true ;
rank: 876
score: 98.01492309570312
patch: final ++ iter ) {
rank: 876
score: 96.95808410644531
patch: ++ * /
rank: 877
score: 98.33647809709821
patch: rs = current CaMeL Point ;
rank: 877
score: 98.02878824869792
patch: if ( iter ) {
rank: 877
score: 98.01478068033855
patch: ++ iter + delta ;
rank: 877
score: 96.95327758789062
patch: iter ; }
rank: 878
score: 98.48234340122768
patch: while ( true ; ) {
rank: 878
score: 98.46060180664062
patch: ++ * - iter ;
rank: 878
score: 98.33498709542411
patch: result = current CaMeL Point ;
rank: 878
score: 98.32369995117188
patch: ++ [ 1 ] ;
rank: 878
score: 98.2227783203125
patch: ++ iter ; final ; {
rank: 878
score: 98.01413981119792
patch: ++ iter -= iter ;
rank: 878
score: 97.991357421875
patch: return current ; }
rank: 878
score: 96.95113372802734
patch: ++ ++ ;
rank: 879
score: 98.48092215401786
patch: ++ iter * / * *
rank: 879
score: 98.4598388671875
patch: int iter ; else ;
rank: 879
score: 98.21392822265625
patch: ++ iter + 0 ;
rank: 879
score: 98.01358032226562
patch: final int iter -- ;
rank: 879
score: 97.98560791015625
patch: while ( ! {
rank: 879
score: 96.94474029541016
patch: ++ read ;
rank: 880
score: 98.4587910970052
patch: ++ 1 + iter ;
rank: 880
score: 98.3259765625
patch: cur = current ;
rank: 880
score: 98.31955973307292
patch: ++ += ++ iter ;
rank: 880
score: 98.20998709542411
patch: ++ iter ; / / ;
rank: 880
score: 98.01152954101562
patch: while ( true ;
rank: 880
score: 97.93677978515625
patch: synchronized ( checker )
rank: 880
score: 96.94462585449219
patch: ++ - ;
rank: 881
score: 98.47652762276786
patch: ++ iter ; do { ;
rank: 881
score: 98.31870524088542
patch: else { ++ * ;
rank: 881
score: 98.1892598470052
patch: double iter = 0 ;
rank: 881
score: 98.00746663411458
patch: double iter = iter ;
rank: 881
score: 97.89414672851562
patch: iter = current ;
rank: 881
score: 96.94291687011719
patch: start ; iter
rank: 882
score: 98.47446986607143
patch: ++ iter * ++ iter ;
rank: 882
score: 98.436767578125
patch: return new int iter ;
rank: 882
score: 98.31858317057292
patch: else { ++ value ;
rank: 882
score: 98.31651814778645
patch: <= n CaMeL C ;
rank: 882
score: 98.18130929129464
patch: int CaMeL Value = this ;
rank: 882
score: 98.0044657389323
patch: ++ iter != null ;
rank: 882
score: 96.9342269897461
patch: ++ ; *
rank: 883
score: 98.4718729654948
patch: ++ iter ] = ;
rank: 883
score: 98.42965698242188
patch: int iter ; break ;
rank: 883
score: 98.3182861328125
patch: else { if ;
rank: 883
score: 98.30882917131696
patch: synchronized ( solved CaMeL Cols )
rank: 883
score: 97.9996846516927
patch: if ; iter ++ ;
rank: 883
score: 96.93411254882812
patch: iter break ;
rank: 884
score: 98.42909749348958
patch: / ; int iter ;
rank: 884
score: 98.31346638997395
patch: / * / * ;
rank: 884
score: 98.30584716796875
patch: synchronized ( weighted CaMeL Jacobian )
rank: 884
score: 98.17957414899554
patch: boolean first CaMeL Iteration = )
rank: 884
score: 97.9987548828125
patch: changed = true ;
rank: 884
score: 97.87927856445313
patch: if ( false )
rank: 884
score: 96.92945098876953
patch: ++ exit ;
rank: 885
score: 98.46621268136161
patch: ++ iter ; new ; ;
rank: 885
score: 98.41519165039062
patch: return new ++ ;
rank: 885
score: 98.31085968017578
patch: } else {
rank: 885
score: 98.29746791294643
patch: weighted CaMeL Residual = 0 ;
rank: 885
score: 98.1826680501302
patch: ++ ++ iter ; {
rank: 885
score: 98.17724609375
patch: int iter = $NUMBER$ ;
rank: 885
score: 96.92889404296875
patch: iter * /
rank: 886
score: 98.46294294084821
patch: ++ iter = iter ; ;
rank: 886
score: 98.41176350911458
patch: ++ $NUMBER$ + iter ;
rank: 886
score: 98.29619489397321
patch: i = iter ; ++ ;
rank: 886
score: 98.17498779296875
patch: if ( checker == 0 )
rank: 886
score: 97.99191284179688
patch: ++ iter 1 ; ;
rank: 886
score: 97.86220703125
patch: while ( iter )
rank: 886
score: 96.9216537475586
patch: iter ; {
rank: 887
score: 98.46194893973214
patch: ++ iter - 1 * /
rank: 887
score: 98.4109395345052
patch: ++ iter ; 0 ;
rank: 887
score: 98.30918579101562
patch: ++ += iter ;
rank: 887
score: 98.27991943359375
patch: ( ++ iter ;
rank: 887
score: 98.25008719308036
patch: weighted CaMeL Residual = current ;
rank: 887
score: 98.17252022879464
patch: int CaMeL Value = 1 ;
rank: 887
score: 96.91928100585938
patch: long 0 ;
rank: 888
score: 98.46147809709821
patch: ++ iter * * / ;
rank: 888
score: 98.30446370442708
patch: else { continue ; }
rank: 888
score: 98.2743408203125
patch: >= iter ) {
rank: 888
score: 98.17092459542411
patch: int iter = - 1 ;
rank: 888
score: 97.98953247070312
patch: key = ++ iter ;
rank: 888
score: 96.9151840209961
patch: iter / iter
rank: 889
score: 98.46117292131696
patch: ++ iter ] = ; }
rank: 889
score: 98.2996114095052
patch: * * ++ iter ;
rank: 889
score: 98.2663330078125
patch: prev = current ;
rank: 889
score: 98.16879708426339
patch: ++ < n CaMeL R ;
rank: 889
score: 97.98875122070312
patch: synchronized ( this )
rank: 889
score: 97.81373291015625
patch: ++ length ; }
rank: 889
score: 96.91230010986328
patch: this ; iter
rank: 890
score: 98.45846557617188
patch: ++ iter > 0 ;
rank: 890
score: 98.29960123697917
patch: return new Object ; }
rank: 890
score: 98.22651018415179
patch: double [ ] = current ;
rank: 890
score: 98.16840471540179
patch: iter = current CaMeL Point ;
rank: 890
score: 98.14707438151042
patch: ++ iter ++ ; {
rank: 890
score: 97.8113037109375
patch: qr CaMeL Decomposition (
rank: 890
score: 96.90866088867188
patch: iter ; try
rank: 891
score: 98.45520891462054
patch: ++ iter * / iter ;
rank: 891
score: 98.29595947265625
patch: else { ++ 1 ;
rank: 891
score: 98.2626241048177
patch: long iter = true ;
rank: 891
score: 97.81058959960937
patch: return checker ; }
rank: 891
score: 96.89932250976562
patch: ++ iter /
rank: 892
score: 98.25063069661458
patch: >= n CaMeL C ;
rank: 892
score: 98.1351826985677
patch: qtf = current ;
rank: 892
score: 97.97695922851562
patch: synchronized ( ++ iter )
rank: 892
score: 97.8037109375
patch: while ( checker )
rank: 892
score: 96.89830780029297
patch: for ++ ;
rank: 893
score: 98.45093645368304
patch: if ( iter ; break ;
rank: 893
score: 98.39164225260417
patch: / ] iter ++ ;
rank: 893
score: 98.29262288411458
patch: * * * * /
rank: 893
score: 98.15217808314732
patch: if ( current CaMeL Point )
rank: 893
score: 97.97658081054688
patch: ++ iter false ;
rank: 893
score: 97.79346313476563
patch: synchronized ( true )
rank: 893
score: 96.89720153808594
patch: ++ clone ;
rank: 894
score: 98.38510131835938
patch: this ; ++ iter ;
rank: 894
score: 98.2471435546875
patch: j = current ;
rank: 894
score: 98.14990234375
patch: double < permutation [ ] ;
rank: 894
score: 97.97243245442708
patch: final int iter ++ ;
rank: 894
score: 96.8938217163086
patch: Iterator iter ;
rank: 895
score: 98.28324381510417
patch: / * / ++ ;
rank: 895
score: 98.24515380859376
patch: o = current ;
rank: 895
score: 98.16300455729167
patch: ++ current CaMeL Point ;
rank: 895
score: 98.12261962890625
patch: qtf = 0 ;
rank: 895
score: 97.97216796875
patch: final ; ++ iter )
rank: 895
score: 97.77435913085938
patch: ++ 1 ; }
rank: 895
score: 96.89006042480469
patch: ++ sum ;
rank: 896
score: 98.44644601004464
patch: ++ iter ; int current ;
rank: 896
score: 98.38096110026042
patch: finally { ++ iter ;
rank: 896
score: 98.24336751302083
patch: <= n CaMeL R ;
rank: 896
score: 98.11549886067708
patch: int iter = final ;
rank: 896
score: 98.10326131184895
patch: boolean max = true ;
rank: 896
score: 97.9721171061198
patch: ++ iter * $NUMBER$ ;
rank: 896
score: 97.7456298828125
patch: ++ current ; }
rank: 896
score: 96.76236979166667
patch: else iter
rank: 897
score: 98.44606236049107
patch: ++ iter ; new Integer ;
rank: 897
score: 98.3807373046875
patch: else ++ iter ; ;
rank: 897
score: 98.2332255045573
patch: synchronized ( diag ) {
rank: 897
score: 98.1127421061198
patch: i ] = current ;
rank: 897
score: 97.97163899739583
patch: assert iter >= 1 ;
rank: 897
score: 97.74073486328125
patch: ++ 1 ; {
rank: 897
score: 96.73562622070312
patch: /
rank: 898
score: 98.11252848307292
patch: ++ iter ] ; {
rank: 898
score: 98.0883076985677
patch: boolean iter = 0 ;
rank: 898
score: 97.72744750976562
patch: l = current ;
rank: 898
score: 96.6007080078125
patch: break ;
rank: 899
score: 98.41555786132812
patch: ++ iter ; false ;
rank: 899
score: 98.37646484375
patch: return new ++ ; ;
rank: 899
score: 98.22318522135417
patch: long iter = current ;
rank: 899
score: 98.08939208984376
patch: ++ 0 ; {
rank: 899
score: 98.0873514811198
patch: switch ( true ) {
rank: 899
score: 97.96849568684895
patch: if ( ! ; ;
rank: 899
score: 97.7251220703125
patch: ++ start ; }
rank: 899
score: 96.56846110026042
patch: / iter
rank: 900
score: 98.370263671875
patch: catch ++ iter ;
rank: 900
score: 98.20994873046875
patch: column = current ;
rank: 900
score: 98.09231567382812
patch: int start = 0 ;
rank: 900
score: 98.08484903971355
patch: ++ iter ; final else
rank: 900
score: 97.96636962890625
patch: ++ iter ; } ;
rank: 900
score: 97.72135620117187
patch: ++ break ; }
rank: 900
score: 96.50341796875
patch: ++ super
rank: 901
score: 98.25396728515625
patch: , iter = iter ;
rank: 901
score: 98.20150756835938
patch: ( ++ iter )
rank: 901
score: 98.07550048828125
patch: String current = current ;
rank: 901
score: 97.96588134765625
patch: ++ iter = iter )
rank: 901
score: 97.7164794921875
patch: ++ checker ; {
rank: 901
score: 96.50187683105469
patch: 
rank: 902
score: 98.19036254882812
patch: state = current ;
rank: 902
score: 98.0744120279948
patch: ++ iter = true ;
rank: 902
score: 97.94265747070312
patch: final ; try {
rank: 902
score: 97.70592041015625
patch: iter = true ;
rank: 902
score: 96.47841389973958
patch: ++ $STRING$
rank: 903
score: 98.3588155110677
patch: int iter ; * ;
rank: 903
score: 98.17928466796874
patch: element = current ;
rank: 903
score: 97.93882446289062
patch: ++ iter true ;
rank: 903
score: 97.691064453125
patch: if ( checker )
rank: 903
score: 96.45851643880208
patch: ; iter
rank: 904
score: 98.2201904296875
patch: / * ++ ;
rank: 904
score: 98.0171610514323
patch: System . ++ iter ;
rank: 904
score: 97.93743896484375
patch: final int iter ;
rank: 904
score: 97.68961181640626
patch: / * / }
rank: 904
score: 96.427001953125
patch: iter }
rank: 905
score: 98.3916524251302
patch: new ; ++ iter ;
rank: 905
score: 98.34397379557292
patch: ++ 0 ++ iter ;
rank: 905
score: 98.20967864990234
patch: / * ;
rank: 905
score: 98.16054077148438
patch: result = true ;
rank: 905
score: 97.90411376953125
patch: ++ iter iter ;
rank: 905
score: 97.6701416015625
patch: / / * /
rank: 905
score: 96.40972900390625
patch: else ;
rank: 906
score: 98.20731201171876
patch: , ++ iter ;
rank: 906
score: 98.158154296875
patch: <= iter ) {
rank: 906
score: 98.06711832682292
patch: int iter = $STRING$ ;
rank: 906
score: 96.4014383951823
patch: { iter
rank: 907
score: 98.20520629882813
patch: * * * /
rank: 907
score: 98.0670166015625
patch: ++ iter <= 0 ;
rank: 907
score: 98.05150349934895
patch: ++ current = current ;
rank: 907
score: 98.00565592447917
patch: int break = 0 ;
rank: 907
score: 97.89224853515626
patch: ++ iter $NUMBER$ ;
rank: 907
score: 96.35647583007812
patch: ++ else
rank: 908
score: 98.33551025390625
patch: int iter + ++ ;
rank: 908
score: 98.12406616210937
patch: a = current ;
rank: 908
score: 98.00513712565105
patch: double iter = current ;
rank: 908
score: 97.88404541015625
patch: final int current ;
rank: 908
score: 97.63740844726563
patch: i = current ;
rank: 908
score: 96.34452056884766
patch: ++
rank: 909
score: 98.17882537841797
patch: return null ;
rank: 909
score: 98.11762084960938
patch: ret = current ;
rank: 909
score: 98.0626729329427
patch: ++ iter < 0 ;
rank: 909
score: 97.88038940429688
patch: cancelled = true ;
rank: 909
score: 96.30963134765625
patch: ++ do
rank: 910
score: 98.16757202148438
patch: return false ;
rank: 910
score: 98.11578979492188
patch: resource = current ;
rank: 910
score: 98.00358072916667
patch: int max = 0 ;
rank: 910
score: 97.97304280598958
patch: boolean max = false ;
rank: 910
score: 97.61474609375
patch: ++ continue ; }
rank: 910
score: 96.2021484375
patch: ++ }
rank: 911
score: 98.3252665201823
patch: ++ start + iter ;
rank: 911
score: 98.11256103515625
patch: result = null ;
rank: 911
score: 97.8685531616211
patch: i ++ ;
rank: 911
score: 97.61466064453126
patch: ++ checker . {
rank: 911
score: 96.15732828776042
patch: continue ;
rank: 912
score: 98.15128173828126
patch: * * * ;
rank: 912
score: 98.10889892578125
patch: curr = current ;
rank: 912
score: 98.04508463541667
patch: ++ iter ; ) {
rank: 912
score: 97.9544169108073
patch: boolean start = true ;
rank: 912
score: 97.85687255859375
patch: final ;
rank: 912
score: 97.6118896484375
patch: ++ this ; }
rank: 912
score: 96.15707397460938
patch: }
rank: 913
score: 98.31458536783855
patch: ++ iter ; current ;
rank: 913
score: 98.149560546875
patch: else ++ out ;
rank: 913
score: 98.0440673828125
patch: { ++ iter ; {
rank: 913
score: 97.85040893554688
patch: node = iter ;
rank: 913
score: 97.6075439453125
patch: ++ 0 ; }
rank: 913
score: 96.15374755859375
patch: iter /
rank: 914
score: 98.145458984375
patch: if ( false ;
rank: 914
score: 98.07627563476562
patch: found = true ;
rank: 914
score: 97.847998046875
patch: final ; if ;
rank: 914
score: 97.60731201171875
patch: checker = current ;
rank: 914
score: 96.11236572265625
patch: } ;
rank: 915
score: 98.31020100911458
patch: ++ iter * ; ;
rank: 915
score: 98.21634521484376
patch: key { ++ ;
rank: 915
score: 98.14534912109374
patch: ++ -= iter ;
rank: 915
score: 97.94720458984375
patch: boolean max = 0 ;
rank: 915
score: 97.8392822265625
patch: final ++ iter )
rank: 915
score: 97.60447387695312
patch: while ( iter {
rank: 915
score: 96.0842793782552
patch: ++ iter
rank: 916
score: 98.13898315429688
patch: ++ >= iter ;
rank: 916
score: 98.07042236328125
patch: pos = iter ;
rank: 916
score: 98.02334594726562
patch: { { ++ iter ;
rank: 916
score: 97.9796875
patch: ++ - $NUMBER$ ;
rank: 916
score: 97.8043212890625
patch: root = iter ;
rank: 916
score: 97.60411376953125
patch: Convergence CaMeL Checker .
rank: 916
score: 96.02789306640625
patch: * ;
rank: 917
score: 98.20755615234376
patch: / ] iter ;
rank: 917
score: 98.12183380126953
patch: return this ;
rank: 917
score: 97.93370564778645
patch: int min = 0 ;
rank: 917
score: 97.77322387695312
patch: input = iter ;
rank: 917
score: 96.01076253255208
patch: try ;
rank: 918
score: 98.28448486328125
patch: current ; ++ iter ;
rank: 918
score: 98.19620971679687
patch: } int iter ;
rank: 918
score: 98.11951904296875
patch: ++ * * ;
rank: 918
score: 98.0685791015625
patch: block = current ;
rank: 918
score: 98.0133768717448
patch: ++ iter ; ++ }
rank: 918
score: 97.76710815429688
patch: data . ++ ;
rank: 918
score: 95.97108459472656
patch: try
rank: 919
score: 98.27775065104167
patch: while ; iter ++ ;
rank: 919
score: 98.19208374023438
patch: * ++ iter ;
rank: 919
score: 98.06409301757813
patch: j = iter ;
rank: 919
score: 97.76499938964844
patch: final ; ;
rank: 919
score: 95.93678792317708
patch: this ;
rank: 920
score: 98.27650960286458
patch: ++ iter *= iter ;
rank: 920
score: 98.18455810546875
patch: iter { ++ ;
rank: 920
score: 97.9230244954427
patch: ++ qr CaMeL Decomposition ;
rank: 920
score: 97.7625732421875
patch: final ; do {
rank: 920
score: 95.93487548828125
patch: logger ;
rank: 921
score: 98.18323974609375
patch: ++ iter ; *
rank: 921
score: 98.09647827148437
patch: else return null ;
rank: 921
score: 97.9171651204427
patch: int CaMeL Value ++ ;
rank: 921
score: 97.48707580566406
patch: ++ checker .
rank: 921
score: 95.9087422688802
patch: ++ Math
rank: 922
score: 98.2616678873698
patch: ++ iter << $NUMBER$ ;
rank: 922
score: 98.04974365234375
patch: rs = current ;
rank: 922
score: 97.91346232096355
patch: Object current CaMeL Point ;
rank: 922
score: 97.74617767333984
patch: if ( ;
rank: 922
score: 97.47674560546875
patch: / * /
rank: 922
score: 95.88888549804688
patch: start ;
rank: 923
score: 98.2579345703125
patch: ++ iter *= $NUMBER$ ;
rank: 923
score: 98.16734008789062
patch: this . iter ;
rank: 923
score: 98.0432373046875
patch: id = current ;
rank: 923
score: 97.9014180501302
patch: int current = 0 ;
rank: 923
score: 97.74212646484375
patch: key = iter ;
rank: 923
score: 97.46527099609375
patch: return current ;
rank: 923
score: 95.82228597005208
patch: / /
rank: 924
score: 98.2520243326823
patch: ++ iter ; double ;
rank: 924
score: 98.16260986328125
patch: ++ 1 iter ;
rank: 924
score: 98.0406494140625
patch: token = current ;
rank: 924
score: 97.89613850911458
patch: double iter = 1 ;
rank: 924
score: 97.71307373046875
patch: new ; ++ ;
rank: 924
score: 97.41714477539062
patch: while ( !
rank: 924
score: 95.77262369791667
patch: Logger ;
rank: 925
score: 98.251220703125
patch: ; ++ iter * /
rank: 925
score: 98.15474853515624
patch: value { ++ ;
rank: 925
score: 98.0649185180664
patch: } if ;
rank: 925
score: 98.02880859375
patch: group = current ;
rank: 925
score: 97.70026245117188
patch: scope = iter ;
rank: 925
score: 97.3968505859375
patch: return checker ;
rank: 925
score: 95.76465861002605
patch: throw new
rank: 926
score: 98.24801635742188
patch: ++ iter >> $NUMBER$ ;
rank: 926
score: 98.1501953125
patch: j * ++ ;
rank: 926
score: 98.03507080078126
patch: ++ >= 0 ;
rank: 926
score: 98.02568969726562
patch: temp = current ;
rank: 926
score: 97.6968505859375
patch: state = iter ;
rank: 926
score: 97.37759399414062
patch: int current ;
rank: 926
score: 95.7360127766927
patch: iter *
rank: 927
score: 98.14913330078124
patch: while ++ iter ;
rank: 927
score: 97.92802124023437
patch: e = current ;
rank: 927
score: 97.88367716471355
patch: double current = current ;
rank: 927
score: 95.67905680338542
patch: System ;
rank: 928
score: 98.23976643880208
patch: ++ iter ; int ;
rank: 928
score: 98.02197265625
patch: meta = current ;
rank: 928
score: 97.924072265625
patch: i = 1 ;
rank: 928
score: 97.87725830078125
patch: int chars = 0 ;
rank: 928
score: 97.74321899414062
patch: c = current ;
rank: 928
score: 97.692333984375
patch: while ( false ;
rank: 928
score: 95.67669677734375
patch: super ;
rank: 929
score: 98.23519897460938
patch: new ; iter ++ ;
rank: 929
score: 98.02018432617187
patch: other = current ;
rank: 929
score: 97.87379964192708
patch: switch ( iter ) {
rank: 929
score: 97.68541259765625
patch: ++ iter ( ;
rank: 929
score: 95.64598592122395
patch: iter try
rank: 930
score: 98.01417236328125
patch: position = iter ;
rank: 930
score: 97.8713887532552
patch: int iter = false ;
rank: 930
score: 97.70741577148438
patch: p = current ;
rank: 930
score: 97.65809326171875
patch: ++ iter . ;
rank: 930
score: 95.58071899414062
patch: result ;
rank: 931
score: 98.00743408203125
patch: id = iter ;
rank: 931
score: 97.86879475911458
patch: double iter = $NUMBER$ ;
rank: 931
score: 97.65352172851563
patch: block = iter ;
rank: 931
score: 95.5777587890625
patch: ++ try
rank: 932
score: 98.12666625976563
patch: Integer iter ++ ;
rank: 932
score: 97.99287109375
patch: / * iter ;
rank: 932
score: 97.648828125
patch: if ( true ;
rank: 932
score: 97.29534149169922
patch: qtf .
rank: 932
score: 95.57139078776042
patch: ++ /
rank: 933
score: 98.12523193359375
patch: synchronized ++ iter ;
rank: 933
score: 98.00562133789063
patch: data = current ;
rank: 933
score: 97.83838500976563
patch: ++ iter ] {
rank: 933
score: 97.67642822265626
patch: if ( ) {
rank: 933
score: 97.63634033203125
patch: if ( current ;
rank: 933
score: 97.29523468017578
patch: assert true ;
rank: 933
score: 95.56105550130208
patch: } else
rank: 934
score: 98.2210693359375
patch: final double [ ] ;
rank: 934
score: 97.99974365234375
patch: synchronized ( ) {
rank: 934
score: 97.74686889648437
patch: break ; * /
rank: 934
score: 97.63412475585938
patch: ++ iter ; )
rank: 934
score: 97.2928466796875
patch: while ( iter
rank: 934
score: 95.53812662760417
patch: ++ finally
rank: 935
score: 98.21780395507812
patch: ++ iter | iter ;
rank: 935
score: 97.99146118164063
patch: i = true ;
rank: 935
score: 97.98309936523438
patch: else { / ;
rank: 935
score: 97.63350830078124
patch: ++ iter / *
rank: 935
score: 97.2691421508789
patch: continue ; }
rank: 935
score: 95.52320353190105
patch: ++ this
rank: 936
score: 97.81433715820313
patch: d = current ;
rank: 936
score: 97.63173828125
patch: return new ; }
rank: 936
score: 97.59366455078126
patch: double [ ] current
rank: 936
score: 95.50762939453125
patch: ++ *
rank: 937
score: 98.2040506998698
patch: for ; ; ; )
rank: 937
score: 97.98699340820312
patch: state = true ;
rank: 937
score: 97.9676025390625
patch: else return iter ;
rank: 937
score: 97.63128662109375
patch: result = iter ;
rank: 937
score: 97.59276123046875
patch: ++ iter ; .
rank: 937
score: 97.21858215332031
patch: / / /
rank: 937
score: 95.50077311197917
patch: return ;
rank: 938
score: 98.07006072998047
patch: Integer iter ;
rank: 938
score: 97.7786376953125
patch: ++ - 0 ;
rank: 938
score: 97.20297241210938
patch: ++ iter ,
rank: 938
score: 95.49312337239583
patch: : iter
rank: 939
score: 98.0635498046875
patch: return false ; ;
rank: 939
score: 97.98328247070313
patch: pos = 0 ;
rank: 939
score: 97.96129150390625
patch: else ++ iterator ;
rank: 939
score: 97.77278442382813
patch: -- iter ; {
rank: 939
score: 97.66358032226563
patch: k = current ;
rank: 939
score: 97.62664184570312
patch: final ++ iterator ;
rank: 939
score: 97.19567108154297
patch: double current ;
rank: 939
score: 95.4259262084961
patch: else
rank: 940
score: 97.93148193359374
patch: ++ * iter /
rank: 940
score: 97.66140747070312
patch: int CaMeL Value ;
rank: 940
score: 97.62247924804687
patch: switch ( iter ;
rank: 940
score: 95.01432800292969
patch: final
rank: 941
score: 97.97345581054688
patch: ( iter ) {
rank: 941
score: 97.92791748046875
patch: return ++ $NUMBER$ ;
rank: 941
score: 97.74491577148437
patch: e = 0 ;
rank: 941
score: 97.61516723632812
patch: synchronized ( this ;
rank: 941
score: 95.00669860839844
patch: throw
rank: 942
score: 97.92725830078125
patch: ++ *= iter ;
rank: 942
score: 97.61168212890625
patch: ++ iter ) ;
rank: 942
score: 97.1414794921875
patch: ++ T ;
rank: 942
score: 94.75422668457031
patch: {
rank: 943
score: 98.09937744140625
patch: ++ iter = ;
rank: 943
score: 97.96856079101562
patch: row = current ;
rank: 943
score: 97.92592163085938
patch: else ++ false ;
rank: 943
score: 97.13825988769531
patch: ++ FALSE ;
rank: 943
score: 94.48582458496094
patch: next
rank: 944
score: 98.08807373046875
patch: iter += iter ;
rank: 944
score: 97.92236328125
patch: ++ return iter ;
rank: 944
score: 97.60943603515625
patch: try {
rank: 944
score: 94.45515441894531
patch: iterator
rank: 945
score: 98.028515625
patch: iter -= iter ;
rank: 945
score: 97.73953247070312
patch: it = current ;
rank: 945
score: 97.60637817382812
patch: binding = iter ;
rank: 945
score: 97.11124420166016
patch: * * /
rank: 945
score: 94.45391845703125
patch: *
rank: 946
score: 97.95839233398438
patch: marker = current ;
rank: 946
score: 97.90725708007812
patch: ++ iterator ; }
rank: 946
score: 97.6060791015625
patch: true = true ;
rank: 946
score: 97.5199951171875
patch: pk = current ;
rank: 946
score: 94.3827896118164
patch: finally
rank: 947
score: 98.00233154296875
patch: j { ++ ;
rank: 947
score: 97.98753662109375
patch: ++ iter - ;
rank: 947
score: 97.95028076171874
patch: obj = current ;
rank: 947
score: 97.9039306640625
patch: return true ;
rank: 947
score: 97.6057861328125
patch: context . ++ ;
rank: 947
score: 97.09202575683594
patch: ++ TRUE ;
rank: 947
score: 94.30699157714844
patch: ;
rank: 948
score: 97.999462890625
patch: name { ++ ;
rank: 948
score: 97.98319091796876
patch: for ++ iter ;
rank: 948
score: 97.948095703125
patch: != iter ) {
rank: 948
score: 97.90357666015625
patch: ++ * * /
rank: 948
score: 97.70598754882812
patch: t = current ;
rank: 948
score: 97.6036376953125
patch: final double iter ;
rank: 948
score: 97.09154510498047
patch: int iter =
rank: 948
score: 94.12642669677734
patch: count
rank: 949
score: 97.99501953125
patch: boolean iter ++ ;
rank: 949
score: 97.94805297851562
patch: member = current ;
rank: 949
score: 97.89802856445313
patch: ++ * 1 ;
rank: 949
score: 97.603515625
patch: final ; break ;
rank: 949
score: 97.55717163085937
patch: int -- iter ;
rank: 949
score: 94.08614349365234
patch: public
rank: 950
score: 97.94554443359375
patch: current = null ;
rank: 950
score: 97.69619140625
patch: i = $NUMBER$ ;
rank: 950
score: 97.59609985351562
patch: source = iter ;
rank: 950
score: 97.554296875
patch: / / / /
rank: 950
score: 97.06620788574219
patch: while ( checker
rank: 950
score: 93.96636962890625
patch: end
rank: 951
score: 97.98225708007813
patch: I new ++ ;
rank: 951
score: 97.944775390625
patch: ( true ) ;
rank: 951
score: 97.9407470703125
patch: double [ ] ;
rank: 951
score: 97.594287109375
patch: changed = false ;
rank: 951
score: 97.54312744140626
patch: double [ ] }
rank: 951
score: 97.05416870117188
patch: while ( true
rank: 951
score: 93.90373229980469
patch: start
rank: 952
score: 97.97373657226562
patch: String iter ++ ;
rank: 952
score: 97.923388671875
patch: ++ iter + ;
rank: 952
score: 97.68370971679687
patch: ++ + iter ;
rank: 952
score: 97.03756713867188
patch: if ( iter
rank: 952
score: 93.88323211669922
patch: return
rank: 953
score: 97.81863403320312
patch: , iter ;
rank: 953
score: 97.01786804199219
patch: Iterator true ;
rank: 953
score: 93.85342407226562
patch: default
rank: 954
score: 97.96455688476563
patch: p . ++ ;
rank: 954
score: 97.93651733398437
patch: <= ++ iter ;
rank: 954
score: 97.56300354003906
patch: return new ;
rank: 954
score: 93.84246826171875
patch: result
rank: 955
score: 97.96085205078126
patch: int iter ; else
rank: 955
score: 97.9362060546875
patch: y = current ;
rank: 955
score: 97.661767578125
patch: i = $STRING$ ;
rank: 955
score: 97.56048583984375
patch: if ;
rank: 955
score: 97.51094360351563
patch: / * / {
rank: 955
score: 97.39281463623047
patch: ++ / *
rank: 955
score: 96.99649047851562
patch: if ( {
rank: 955
score: 93.71347045898438
patch: this
rank: 956
score: 97.93612670898438
patch: tree = current ;
rank: 956
score: 97.90448608398438
patch: throw new ; }
rank: 956
score: 97.7867660522461
patch: else { }
rank: 956
score: 97.55289459228516
patch: / / ;
rank: 956
score: 96.99393463134766
patch: ++ iter [
rank: 956
score: 93.64148712158203
patch: super
rank: 957
score: 97.93095703125
patch: entry = true ;
rank: 957
score: 97.7415542602539
patch: * * ;
rank: 957
score: 93.58760070800781
patch: ret
rank: 958
score: 97.93037109375
patch: list = current ;
rank: 958
score: 97.84901428222656
patch: Token iter ;
rank: 958
score: 97.71454620361328
patch: return ; }
rank: 958
score: 97.49203491210938
patch: final / * /
rank: 958
score: 97.37779235839844
patch: final ; }
rank: 958
score: 93.32968139648438
patch: c
rank: 959
score: 97.91907348632813
patch: r = current ;
rank: 959
score: 97.8449935913086
patch: boolean iter ;
rank: 959
score: 97.80916748046874
patch: i ++ ; ;
rank: 959
score: 93.32270812988281
patch: max
rank: 960
score: 97.91402587890624
patch: body = current ;
rank: 960
score: 96.96501159667969
patch: ++ SIZE ;
rank: 960
score: 93.30438232421875
patch: logger
rank: 961
score: 97.26982116699219
patch: pos ++ ;
rank: 961
score: 96.95741271972656
patch: / finally {
rank: 961
score: 93.30191802978516
patch: do
rank: 962
score: 97.904931640625
patch: ref = current ;
rank: 962
score: 97.8099594116211
patch: String iter ;
rank: 962
score: 97.6941146850586
patch: long ++ ;
rank: 962
score: 97.4347412109375
patch: break ; 0 ;
rank: 962
score: 97.23895263671875
patch: i -- ;
rank: 962
score: 93.27069091796875
patch: m
rank: 963
score: 97.9022705078125
patch: event = current ;
rank: 963
score: 97.4293212890625
patch: / *
rank: 963
score: 97.42208099365234
patch: ++ iter 1
rank: 963
score: 93.22721862792969
patch: it
rank: 964
score: 97.35040283203125
patch: else { {
rank: 964
score: 93.18594360351562
patch: s
rank: 965
score: 97.898681640625
patch: || true ) {
rank: 965
score: 97.71742248535156
patch: Font iter ;
rank: 965
score: 97.07257080078125
patch: ++ $NUMBER$ :
rank: 965
score: 93.17774963378906
patch: i
rank: 966
score: 97.89655151367188
patch: size = true ;
rank: 966
score: 97.29049682617188
patch: return 0 ;
rank: 966
score: 93.15702819824219
patch: error
rank: 967
score: 97.89148712158203
patch: ( iter ;
rank: 967
score: 97.69194793701172
patch: int value ;
rank: 967
score: 97.56797790527344
patch: else { ;
rank: 967
score: 97.40171813964844
patch: String current ;
rank: 967
score: 97.18327331542969
patch: if ; ;
rank: 967
score: 96.39756266276042
patch: checker .
rank: 967
score: 93.1461181640625
patch: System
rank: 968
score: 97.7669906616211
patch: ( true )
rank: 968
score: 97.67261505126953
patch: Node iter ;
rank: 968
score: 97.58421325683594
patch: int ++ ;
rank: 968
score: 97.39358520507812
patch: Object current ;
rank: 968
score: 97.17333984375
patch: j ++ ;
rank: 968
score: 97.04558563232422
patch: if ( )
rank: 968
score: 93.13681030273438
patch: My@@
rank: 969
score: 97.65678405761719
patch: value ++ ;
rank: 969
score: 97.58090209960938
patch: new ++ ;
rank: 969
score: 97.1533203125
patch: if ; else
rank: 969
score: 96.36033121744792
patch: finally {
rank: 969
score: 93.13644409179688
patch: pos
rank: 970
score: 97.54116821289062
patch: } else ;
rank: 970
score: 97.13648986816406
patch: idx ++ ;
rank: 970
score: 93.13526916503906
patch: :
rank: 971
score: 97.67552185058594
patch: >= iter ;
rank: 971
score: 97.53150939941406
patch: ++ sort ;
rank: 971
score: 97.5228271484375
patch: iter = ;
rank: 971
score: 96.33400472005208
patch: ) {
rank: 971
score: 93.11306762695312
patch: size
rank: 972
score: 97.50779724121094
patch: final double ;
rank: 972
score: 93.09973907470703
patch: out
rank: 973
score: 97.53727722167969
patch: key ++ ;
rank: 973
score: 97.02659606933594
patch: ++ finally {
rank: 973
score: 93.0887680053711
patch: prev
rank: 974
score: 97.57107543945312
patch: state ++ ;
rank: 974
score: 97.53628540039062
patch: ] iter ;
rank: 974
score: 97.48662567138672
patch: else ; ;
rank: 974
score: 97.45707702636719
patch: ++ iter =
rank: 974
score: 97.14676666259766
patch: ++ iter <
rank: 974
score: 96.2228495279948
patch: / finally
rank: 974
score: 93.03382873535156
patch: j
rank: 975
score: 97.52793884277344
patch: Object iter ;
rank: 975
score: 97.14590454101562
patch: / / {
rank: 975
score: 97.0512186686198
patch: while ;
rank: 975
score: 96.15852864583333
patch: for (
rank: 975
score: 92.99791717529297
patch: r
rank: 976
score: 97.513671875
patch: i * ;
rank: 976
score: 97.50804901123047
patch: size ++ ;
rank: 976
score: 97.40118408203125
patch: new ; ;
rank: 976
score: 97.12886047363281
patch: ++ iter :
rank: 976
score: 96.98748016357422
patch: ++ iter *
rank: 976
score: 92.96195983886719
patch: index
rank: 977
score: 97.50422668457031
patch: -= iter ;
rank: 977
score: 97.45023345947266
patch: return ; ;
rank: 977
score: 97.01631164550781
patch: root = ;
rank: 977
score: 96.12418619791667
patch: Iterator ;
rank: 977
score: 92.9619140625
patch: found
rank: 978
score: 97.49781799316406
patch: start ++ ;
rank: 978
score: 97.49641418457031
patch: true ) {
rank: 978
score: 96.9332275390625
patch: if ( true
rank: 978
score: 96.10855102539062
patch: ++ {
rank: 978
score: 92.95283508300781
patch: t
rank: 979
score: 97.49561309814453
patch: <= iter ;
rank: 979
score: 97.49124145507812
patch: char iter ;
rank: 979
score: 97.42512512207031
patch: else if ;
rank: 979
score: 97.07608032226562
patch: * / {
rank: 979
score: 96.8032938639323
patch: new ;
rank: 979
score: 96.08376057942708
patch: iter =
rank: 979
score: 92.92774200439453
patch: pop
rank: 980
score: 97.48756408691406
patch: short iter ;
rank: 980
score: 97.4826889038086
patch: >= iter )
rank: 980
score: 97.29976654052734
patch: int start ;
rank: 980
score: 96.90442657470703
patch: ++ ) {
rank: 980
score: 96.7896728515625
patch: do {
rank: 980
score: 95.94979858398438
patch: current ;
rank: 980
score: 92.91400146484375
patch: offset
rank: 981
score: 97.47542572021484
patch: double iter ;
rank: 981
score: 97.40393829345703
patch: , * ;
rank: 981
score: 97.28366088867188
patch: while ; ;
rank: 981
score: 96.93917846679688
patch: int final ;
rank: 981
score: 92.89712524414062
patch: l
rank: 982
score: 97.46830749511719
patch: byte iter ;
rank: 982
score: 97.40348052978516
patch: } return ;
rank: 982
score: 97.27649688720703
patch: long start ;
rank: 982
score: 95.9187520345052
patch: checker ;
rank: 982
score: 92.88143920898438
patch: @
rank: 983
score: 96.86616516113281
patch: final / *
rank: 983
score: 92.849853515625
patch: mark
rank: 984
score: 97.44271850585938
patch: float iter ;
rank: 984
score: 96.93581136067708
patch: true ;
rank: 984
score: 96.48593139648438
patch: ( ;
rank: 984
score: 95.86991373697917
patch: previous ;
rank: 984
score: 92.82020568847656
patch: value
rank: 985
score: 96.89329020182292
patch: synchronized (
rank: 985
score: 96.8456039428711
patch: / * final
rank: 985
score: 96.21859741210938
patch: Simple ;
rank: 985
score: 96.12185668945312
patch: if (
rank: 985
score: 95.86415608723958
patch: * /
rank: 985
score: 92.79969787597656
patch: self
rank: 986
score: 97.43046569824219
patch: f ++ ;
rank: 986
score: 97.37442779541016
patch: } finally {
rank: 986
score: 97.22152709960938
patch: counter ++ ;
rank: 986
score: 96.89314778645833
patch: true {
rank: 986
score: 96.84530639648438
patch: / / final
rank: 986
score: 92.7926025390625
patch: input
rank: 987
score: 97.42027282714844
patch: += iter ;
rank: 987
score: 97.21951293945312
patch: it ++ ;
rank: 987
score: 92.79237365722656
patch: Logger
rank: 988
score: 97.34977722167969
patch: break ; else
rank: 988
score: 96.83005777994792
patch: state ;
rank: 988
score: 96.1687723795573
patch: AST ;
rank: 988
score: 92.78782653808594
patch: e
rank: 989
score: 96.78554280598958
patch: false ;
rank: 989
score: 96.23223876953125
patch: { {
rank: 989
score: 96.15995279947917
patch: temp ;
rank: 989
score: 92.75758361816406
patch: b
rank: 990
score: 96.13901774088542
patch: field ;
rank: 990
score: 92.75643920898438
patch: =
rank: 991
score: 97.40875244140625
patch: result ++ ;
rank: 991
score: 97.17680358886719
patch: double ++ ;
rank: 991
score: 96.77384440104167
patch: false {
rank: 991
score: 96.1253662109375
patch: boolean ;
rank: 991
score: 95.79229736328125
patch: System .
rank: 991
score: 92.75568389892578
patch: loop
rank: 992
score: 97.16895294189453
patch: inst = ;
rank: 992
score: 96.72607421875
patch: [ ;
rank: 992
score: 96.11248779296875
patch: block ;
rank: 992
score: 96.0717061360677
patch: int CaMeL
rank: 992
score: 92.75254821777344
patch: position
rank: 993
score: 97.40384674072266
patch: int name ;
rank: 993
score: 96.72044881184895
patch: i ;
rank: 993
score: 96.0172831217448
patch: / ?
rank: 993
score: 92.73188781738281
patch: p
rank: 994
score: 96.69093831380208
patch: tree ;
rank: 994
score: 92.72978210449219
patch: cur
rank: 995
score: 96.65773518880208
patch: ( (
rank: 995
score: 96.42409261067708
patch: double ;
rank: 995
score: 96.0787862141927
patch: ; ;
rank: 995
score: 95.9698994954427
patch: - ;
rank: 995
score: 92.71670532226562
patch: line
rank: 996
score: 96.88332112630208
patch: , ;
rank: 996
score: 92.65933227539062
patch: empty
rank: 997
score: 96.06748453776042
patch: update ;
rank: 997
score: 92.64509582519531
patch: in
rank: 998
score: 95.27035522460938
patch: ?
rank: 998
score: 93.910400390625
patch: boolean
rank: 998
score: 92.64216613769531
patch: context
rank: 999
score: 96.36661783854167
patch: synchronized ;
rank: 999
score: 96.03804524739583
patch: long ;
rank: 999
score: 94.95246887207031
patch: (
rank: 999
score: 93.59319305419922
patch: int
rank: 999
score: 93.52572631835938
patch: )
rank: 999
score: 92.6159896850586
patch: number
rank: 1000
score: 92.58477783203125
patch: tree
