rank: 1
score: 99.71735382080078
patch: ++ iter ;
rank: 1
score: 99.45980834960938
patch: double f CaMeL Val = f CaMeL Val ;
rank: 1
score: 99.4481689453125
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 1
score: 99.43589564732143
patch: ++ iter ; ++ iter ;
rank: 1
score: 99.22064208984375
patch: if ( ! iter . is CaMeL Empty ( ) ;
rank: 1
score: 99.16623757102273
patch: return compute CaMeL Objective CaMeL Value ( x ) ;
rank: 2
score: 99.38068181818181
patch: final double f CaMeL Val = f CaMeL Val ;
rank: 2
score: 99.37286376953125
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 2
score: 99.20365142822266
patch: ++ iter ; ++ iter ; ;
rank: 2
score: 99.12294311523438
patch: int f CaMeL Val = f CaMeL Val ;
rank: 3
score: 99.38648986816406
patch: double f CaMeL Val = 0 ;
rank: 3
score: 99.34844970703125
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker ;
rank: 3
score: 99.19450378417969
patch: while ( iter < n ) {
rank: 3
score: 99.155029296875
patch: ++ iter ; ++ iter ; ++ iter ;
rank: 3
score: 99.13961791992188
patch: ++ iter ; ++ - iter ;
rank: 3
score: 99.12281290690105
patch: result = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 3
score: 99.0741475423177
patch: if ( ! iter . is CaMeL Empty ( ) )
rank: 4
score: 99.38010817307692
patch: ++ iter ; double f CaMeL Val = f CaMeL Val ;
rank: 4
score: 99.28945025275735
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( f CaMeL Val ) ;
rank: 4
score: 99.17654418945312
patch: ++ iter ; if ( iter ;
rank: 4
score: 99.15421295166016
patch: ++ iter ; ; ++ iter ;
rank: 4
score: 99.10612487792969
patch: ++ iter ; ++ * * /
rank: 4
score: 99.10442756204044
patch: return ( Point CaMeL Value CaMeL Pair ) checker . get CaMeL Value ( ) ;
rank: 4
score: 99.0462646484375
patch: Iterator iter = iter . iterator ( ) ;
rank: 4
score: 99.03542258522727
patch: if ( ! iter . is CaMeL Empty ++ )
rank: 5
score: 99.3759829872533
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 5
score: 99.31100899832589
patch: double f CaMeL Val = f CaMeL Val - f CaMeL Val ;
rank: 5
score: 99.28766276041667
patch: int f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 5
score: 99.16775076729911
patch: ++ iter ; if ( ;
rank: 5
score: 99.13371276855469
patch: ++ iter ; ++ iter ; }
rank: 5
score: 99.1009521484375
patch: return get CaMeL Goal CaMeL Type ( ) . get CaMeL Value ( ) ;
rank: 5
score: 99.09573800223214
patch: ++ iter ; ++ 1 ;
rank: 5
score: 99.02992757161458
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ;
rank: 5
score: 99.02099609375
patch: else { ++ iter ; }
rank: 6
score: 99.2806640625
patch: double [ ] x = f CaMeL Val ;
rank: 6
score: 99.26847700639205
patch: double [ ] x 1 = f CaMeL Val ;
rank: 6
score: 99.1333516438802
patch: ++ iter ; * /
rank: 6
score: 99.09616524832589
patch: ++ n ; ++ iter ;
rank: 6
score: 99.095703125
patch: ++ iter ; if ++ iter ;
rank: 6
score: 98.99807739257812
patch: ++ iter ; } ++ iter ;
rank: 6
score: 98.99259033203126
patch: throw new Runtime CaMeL Exception ( $STRING$ ) ;
rank: 7
score: 99.26216634114583
patch: double [ ] f CaMeL Val = f CaMeL Val ;
rank: 7
score: 99.07204674030173
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ;
rank: 7
score: 98.99099295479911
patch: if ( iter == null ;
rank: 7
score: 98.99085489908855
patch: throw new Illegal CaMeL State CaMeL Exception ( $STRING$ ) ;
rank: 8
score: 99.34592692057292
patch: double f CaMeL Val = x . clone ( ) ;
rank: 8
score: 99.26251220703125
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( f CaMeL Val ) ;
rank: 8
score: 99.07685089111328
patch: ++ iter ; while ++ iter ;
rank: 8
score: 99.06907348632812
patch: return line . get CaMeL Value ( ) ;
rank: 8
score: 99.06618826729911
patch: ++ iter ; ++ start ;
rank: 8
score: 98.98864135742187
patch: if ( iter == null ; return iter ;
rank: 9
score: 99.33530560661765
patch: double f CaMeL Val = Math . copy CaMeL Of ( f CaMeL Val ) ;
rank: 9
score: 99.25834655761719
patch: final double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 9
score: 99.07551792689732
patch: ++ 1 ; ++ iter ;
rank: 9
score: 99.063525390625
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair > iter = 0 ;
rank: 9
score: 99.05950927734375
patch: ++ 0 ; ++ iter ;
rank: 9
score: 98.98174176897321
patch: else { return iter ; }
rank: 9
score: 98.96211242675781
patch: while ( iter != null ) {
rank: 10
score: 99.24151611328125
patch: double f CaMeL Val = f CaMeL Val + f CaMeL Val ;
rank: 10
score: 99.23509870256696
patch: int f CaMeL Val = f CaMeL Val - f CaMeL Val ;
rank: 10
score: 99.07542419433594
patch: ++ iter ; if ( ! ;
rank: 10
score: 99.06575012207031
patch: ++ iter ; ++ - 1 ;
rank: 10
score: 99.05457481971153
patch: Iterator < Point CaMeL Value CaMeL Pair > iter = 0 ;
rank: 10
score: 98.95908610026042
patch: throw new Unsupported CaMeL Operation CaMeL Exception ( $STRING$ ) ;
rank: 11
score: 99.24541473388672
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = null ;
rank: 11
score: 99.06732732599431
patch: ++ iter ; while ( iter < n ) {
rank: 11
score: 99.0562744140625
patch: i * ++ ; ++ iter ;
rank: 11
score: 99.05230102539062
patch: return converged . get CaMeL Value ( ) ;
rank: 11
score: 99.0467529296875
patch: } ++ iter ; ++ iter ;
rank: 11
score: 98.93678977272727
patch: throw new Unsupported CaMeL Operation CaMeL Exception ( ) ;
rank: 11
score: 98.92560424804688
patch: ++ iter ; }
rank: 12
score: 99.2938565340909
patch: ++ iter ; double f CaMeL Val = 0 ;
rank: 12
score: 99.22826276506696
patch: double f CaMeL Val = f CaMeL Val . clone ( ) ;
rank: 12
score: 99.2271728515625
patch: double f CaMeL Val = x . get CaMeL Value ( ) ;
rank: 12
score: 99.06429290771484
patch: ++ iter ; * / * /
rank: 12
score: 99.05535888671875
patch: / * ] ++ iter ;
rank: 12
score: 99.03837076822917
patch: return compute CaMeL Objective CaMeL Value ( x $NUMBER$ ) ;
rank: 12
score: 99.0312728881836
patch: ++ iter ; ++ iter ; else
rank: 12
score: 98.92888726128473
patch: iter = iter . iterator ( ) ;
rank: 12
score: 98.92332874644886
patch: if ( iter == null ; return iter ; }
rank: 13
score: 99.28058825041118
patch: int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 13
score: 99.22087751116071
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( ) ;
rank: 13
score: 99.21814682904412
patch: int f CaMeL Val = compute CaMeL Objective CaMeL Value ( f CaMeL Val ) ;
rank: 13
score: 99.0478759765625
patch: ++ iter ; double f CaMeL Val = Double . MAX _ VALUE ;
rank: 13
score: 99.04466417100694
patch: ++ iter ; ++ iter ; iter ;
rank: 13
score: 99.03822326660156
patch: result = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 13
score: 99.01604461669922
patch: ++ new ++ ; ++ iter ;
rank: 13
score: 98.92287375710227
patch: if ( ! iter . is CaMeL Empty ( ;
rank: 13
score: 98.9213134765625
patch: ++ iter ; ;
rank: 14
score: 99.213427734375
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( 0 ) ;
rank: 14
score: 99.04618835449219
patch: while ( iter < iter ) {
rank: 14
score: 99.03631998697917
patch: return Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 14
score: 98.99708557128906
patch: ++ iter ; iter * * /
rank: 14
score: 98.99434988839286
patch: ++ iter ; ++ n ;
rank: 14
score: 98.92129516601562
patch: if ( ! iter . is CaMeL Empty ;
rank: 15
score: 99.20012555803571
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ;
rank: 15
score: 99.04222615559895
patch: throw new Unsupported CaMeL Operation CaMeL Exception ( ) ; }
rank: 15
score: 99.03556315104167
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ) {
rank: 15
score: 98.9792709350586
patch: ++ iter ; ++ ++ iter ;
rank: 15
score: 98.97828674316406
patch: ++ iter ; iter ; * /
rank: 15
score: 98.9212417602539
patch: else { ++ * iter ; }
rank: 15
score: 98.90465291341145
patch: try { ++ iter ;
rank: 16
score: 99.18375651041667
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = null ;
rank: 16
score: 99.037939453125
patch: ++ iter ; double f CaMeL Val = Double . MIN _ VALUE ;
rank: 16
score: 99.03228290264423
patch: result = compute CaMeL Objective CaMeL Value ( x $NUMBER$ ) ;
rank: 16
score: 98.9775390625
patch: ++ iter ; try ; ++ iter ;
rank: 16
score: 98.90884399414062
patch: while ( ! iter . is CaMeL Empty ( ) ;
rank: 16
score: 98.89530726841518
patch: ++ n ; ++ n ;
rank: 17
score: 99.03124060997597
patch: ++ iter ; return new Point CaMeL Value CaMeL Pair ( ;
rank: 17
score: 99.0275634765625
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair [ ]
rank: 17
score: 98.97344207763672
patch: ++ ++ iter ; ++ iter ;
rank: 17
score: 98.896728515625
patch: ++ [ ] iter ;
rank: 17
score: 98.88621012369792
patch: while ( ! iter . is CaMeL Empty ( ) )
rank: 18
score: 99.24517267400569
patch: final int f CaMeL Val = f CaMeL Val ;
rank: 18
score: 99.20247977120536
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker =
rank: 18
score: 99.17793782552083
patch: double f CaMeL Val = Math . abs ( f CaMeL Val ) ;
rank: 18
score: 99.02345784505208
patch: ++ iter ; * / ++ iter ;
rank: 18
score: 99.02232259114584
patch: long f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 18
score: 98.96797398158482
patch: ++ value ; ++ iter ;
rank: 18
score: 98.96316964285714
patch: ++ start ; ++ iter ;
rank: 18
score: 98.895751953125
patch: else { iter += iter ; }
rank: 19
score: 99.24344211154514
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 19
score: 99.01676432291667
patch: if ( f CaMeL Val < f CaMeL Val ) {
rank: 19
score: 98.96316964285714
patch: ++ iter ; ++ value ;
rank: 19
score: 98.96282958984375
patch: ++ iter ; ++ iter ; -- iter ;
rank: 19
score: 98.89039829799107
patch: ++ [ ] iter ; }
rank: 20
score: 99.23284912109375
patch: final double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 20
score: 99.1949462890625
patch: double f CaMeL Val = f CaMeL Val . get CaMeL Value ( ) ;
rank: 20
score: 99.01641082763672
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( f CaMeL Val ) ;
rank: 20
score: 99.01400417751736
patch: while ( true ) { ++ iter ;
rank: 20
score: 98.95625135633681
patch: ++ iter ; ++ iter ; break ;
rank: 20
score: 98.9246826171875
patch: ++ $NUMBER$ ; ++ iter ;
rank: 20
score: 98.88838334517045
patch: if ( ! iter . is CaMeL Empty ++ ;
rank: 20
score: 98.85463169642857
patch: if ( ! iter . is CaMeL Empty ( ) ) continue ;
rank: 21
score: 99.23283835018383
patch: int f CaMeL Val = Math . copy CaMeL Of ( f CaMeL Val ) ;
rank: 21
score: 99.19194479549633
patch: double [ ] f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 21
score: 99.17975725446429
patch: int f CaMeL Val = f CaMeL Val + f CaMeL Val ;
rank: 21
score: 99.01515299479166
patch: return new CaMeL Point CaMeL And CaMeL Direction ( f CaMeL Val ) ;
rank: 21
score: 98.91824776785714
patch: iter ++ ; ++ iter ;
rank: 21
score: 98.88728637695313
patch: if ( iter == 0 ; return iter ;
rank: 21
score: 98.8493182842548
patch: int n = iter . index CaMeL Of ( $STRING$ ) ;
rank: 22
score: 99.23130289713542
patch: double f CaMeL Val = line . clone ( ) ;
rank: 22
score: 99.01388784555289
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair > ++ ;
rank: 22
score: 98.94639078776042
patch: ++ iter ; ++ * ++ iter ;
rank: 22
score: 98.9178799715909
patch: ++ iter ; ++ iter ; } ++ iter ;
rank: 22
score: 98.88227844238281
patch: i ++ ; } ++ iter ;
rank: 23
score: 99.18211146763393
patch: int f CaMeL Val = f CaMeL Val . clone ( ) ;
rank: 23
score: 99.17698669433594
patch: if ( f CaMeL Val . length < f CaMeL Val . length ) {
rank: 23
score: 99.01231282552084
patch: Object f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 23
score: 99.01130814985795
patch: while ( iter < n ) { ++ iter ;
rank: 23
score: 98.90432400173611
patch: ++ iter ; ++ iter ; / /
rank: 23
score: 98.87669677734375
patch: ++ [ ] iter = iter . length ;
rank: 23
score: 98.8487548828125
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + n ) ;
rank: 24
score: 99.22101508246527
patch: ++ iter ; double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 24
score: 99.18206024169922
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x $NUMBER$ ) ;
rank: 24
score: 99.17100016276042
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( direc ) ;
rank: 24
score: 99.16246686662946
patch: double f CaMeL Val = x . get CaMeL Point ( ) ;
rank: 24
score: 99.0118741122159
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair >
rank: 24
score: 99.00767517089844
patch: ++ iter ; * ++ iter ;
rank: 24
score: 98.876025390625
patch: if ( ! iter . is CaMeL Empty ( ) ; return iter ;
rank: 24
score: 98.84361572265625
patch: int iter = iter . iterator ( ) ;
rank: 25
score: 99.18145751953125
patch: double CaMeL Value = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 25
score: 99.16395786830357
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ,
rank: 25
score: 99.01162614493535
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair )
rank: 25
score: 99.00580388849431
patch: return new Point CaMeL Value CaMeL Pair ( ; }
rank: 25
score: 98.94132486979167
patch: ++ iter ; ++ * - iter ;
rank: 25
score: 98.88395385742187
patch: ++ iter ; ++ iter ; return iter ;
rank: 25
score: 98.87468719482422
patch: ++ iter ; } return iter ;
rank: 25
score: 98.84223937988281
patch: if ( iter != null ) {
rank: 26
score: 99.19814724392361
patch: final double f CaMeL Val = compute CaMeL Objective CaMeL Value ( f CaMeL Val ) ;
rank: 26
score: 99.16325109145221
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( direc [
rank: 26
score: 99.15379842122395
patch: double f CaMeL Val = f CaMeL Val - 0 ;
rank: 26
score: 99.00327662417763
patch: return get CaMeL Goal CaMeL Type ( f CaMeL Val ) . get CaMeL Value ( ) ;
rank: 26
score: 98.99977620442708
patch: ++ iter - 1 ;
rank: 26
score: 98.88191731770833
patch: / ; ++ iter ; ++ iter ;
rank: 26
score: 98.87291463216145
patch: } if ++ iter ;
rank: 26
score: 98.84137432391827
patch: if ( ! iter . is CaMeL Empty ( ) ) {
rank: 27
score: 99.1957015991211
patch: double f CaMeL Val $NUMBER$ = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 27
score: 99.16706085205078
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair && f CaMeL Val ;
rank: 27
score: 99.15220642089844
patch: f CaMeL Val = Math . copy CaMeL Of ( f CaMeL Val ) ;
rank: 27
score: 99.00206298828125
patch: long f CaMeL Val = f CaMeL Val ;
rank: 27
score: 98.9986328125
patch: ++ iter ; while ( iter < n )
rank: 27
score: 98.87848578559027
patch: ++ iter ; ++ iter ; } iter
rank: 27
score: 98.87068176269531
patch: else { if ++ iter ; }
rank: 28
score: 99.19449869791667
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ) ;
rank: 28
score: 99.15046691894531
patch: if ( f CaMeL Val . length > f CaMeL Val . length ) {
rank: 28
score: 99.14715576171875
patch: double f CaMeL Val = f CaMeL Val - iter ;
rank: 28
score: 98.99718475341797
patch: ++ iter ; / * * ;
rank: 28
score: 98.9866943359375
patch: Iterator < Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > iter = 0 ;
rank: 28
score: 98.9271011352539
patch: ++ iter ; ++ * iter ;
rank: 28
score: 98.87670026506696
patch: ++ iter ; ++ max ;
rank: 28
score: 98.86563546316964
patch: else { iter ++ ; }
rank: 28
score: 98.84065464564732
patch: if ( ! iter . is CaMeL Empty ( ) ) break ;
rank: 29
score: 99.19062732514881
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , 0 ) ;
rank: 29
score: 98.98626999627976
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > iter = 0 ;
rank: 29
score: 98.97955791766827
patch: ++ iter ; int n = Double . MAX _ VALUE ;
rank: 29
score: 98.87635149274554
patch: ++ iter ; iter ++ ;
rank: 29
score: 98.83238874162946
patch: throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + n ) ;
rank: 30
score: 99.18994140625
patch: int f CaMeL Val = x . clone ( ) ;
rank: 30
score: 99.15582275390625
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( 0 ) ;
rank: 30
score: 98.98275756835938
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair > }
rank: 30
score: 98.9721435546875
patch: return new Point CaMeL Value CaMeL Pair ( ;
rank: 30
score: 98.8616943359375
patch: if ( iter == 0 ;
rank: 30
score: 98.83174896240234
patch: ++ n ;
rank: 31
score: 99.18608940972223
patch: final double f CaMeL Val = 0 ;
rank: 31
score: 99.15478515625
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x 1 ) ;
rank: 31
score: 98.97643432617187
patch: Object f CaMeL Val = f CaMeL Val ;
rank: 31
score: 98.97057233537946
patch: ++ iter ; return new Point CaMeL Value CaMeL Pair ( ; }
rank: 31
score: 98.91716003417969
patch: ++ iter ; ++ - 0 ;
rank: 31
score: 98.86131286621094
patch: / * * ; ++ iter ;
rank: 32
score: 99.14013671875
patch: double f CaMeL Val = f CaMeL Val - 0 . 0 ;
rank: 32
score: 98.97519259982639
patch: Iterator < Point CaMeL Value CaMeL Pair >
rank: 32
score: 98.97056749131944
patch: ++ iter ; while ( ; ) {
rank: 32
score: 98.91338348388672
patch: ++ iter ; ++ * * ;
rank: 32
score: 98.8610610961914
patch: } if ( iter == null ;
rank: 32
score: 98.85631561279297
patch: if ++ iter ; ++ iter ;
rank: 33
score: 99.1808090209961
patch: d = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 33
score: 99.148193359375
patch: double iter = f CaMeL Val . clone ( ) ;
rank: 33
score: 98.95584810697116
patch: ++ iter ; double iter = Double . MAX _ VALUE ;
rank: 33
score: 98.91067165798611
patch: ++ iter ; ++ * * iter ;
rank: 33
score: 98.86067417689732
patch: if ( ! iter . is CaMeL Empty ++ this . iter ;
rank: 33
score: 98.85588727678571
patch: ++ max ; ++ iter ;
rank: 33
score: 98.80625563401442
patch: while ( ! iter . is CaMeL Empty ( ) ) {
rank: 34
score: 99.17948404947917
patch: if ( f CaMeL Val > f CaMeL Val ) {
rank: 34
score: 99.13672688802083
patch: final double f CaMeL Val = f CaMeL Val - f CaMeL Val ;
rank: 34
score: 98.97095598493304
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair
rank: 34
score: 98.95199584960938
patch: ++ iter ; while ( iter ; ) {
rank: 34
score: 98.91020856584821
patch: / * ; ++ iter ;
rank: 34
score: 98.85774061414931
patch: Iterator iter = iter . iterator ++ ;
rank: 34
score: 98.85458374023438
patch: ++ iter ; iter if ++ ;
rank: 34
score: 98.80577674278847
patch: sb . append ( $STRING$ ) . append ( iter ) ;
rank: 35
score: 99.17799377441406
patch: int f CaMeL Val = 0 ;
rank: 35
score: 99.14345974392361
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( x , f CaMeL Val ) ;
rank: 35
score: 99.13383214613971
patch: double f CaMeL Val = f CaMeL Val . search ( f CaMeL Val ) ;
rank: 35
score: 98.97072838092673
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair >
rank: 35
score: 98.95151774088542
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ; }
rank: 35
score: 98.91001892089844
patch: ++ iter ; while ++ 1 ;
rank: 35
score: 98.85305786132812
patch: ++ iter ; ++ iter ; try
rank: 35
score: 98.84857940673828
patch: ++ * * * iter ; /
rank: 35
score: 98.8010762532552
patch: while ( true ) {
rank: 36
score: 99.14199829101562
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = true ;
rank: 36
score: 99.13453020368304
patch: double f CaMeL Val = f CaMeL Val . iterator ( ) ;
rank: 36
score: 99.12972819010416
patch: int f CaMeL Val = compute CaMeL Objective CaMeL Value ( 0 ) ;
rank: 36
score: 98.96768188476562
patch: int iter = 0 ;
rank: 36
score: 98.95088704427083
patch: return new Point CaMeL Value CaMeL Pair ( iter , ;
rank: 36
score: 98.90770721435547
patch: ++ iter ; ++ - $NUMBER$ ;
rank: 36
score: 98.84654541015625
patch: if ( iter != null ; return iter ;
rank: 36
score: 98.84201049804688
patch: ++ iter ; ++ iter ; iter
rank: 36
score: 98.79941231863839
patch: Point CaMeL Value CaMeL Pair iter = iter . iter ( ) ;
rank: 37
score: 99.16951206752232
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ) ;
rank: 37
score: 99.14145132211539
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker ;
rank: 37
score: 98.96351841517857
patch: return new Point CaMeL Value CaMeL Pair ( f CaMeL Val ) ;
rank: 37
score: 98.95034555288461
patch: ++ iter ; double n = Double . MAX _ VALUE ;
rank: 37
score: 98.90477752685547
patch: ++ iter ; ++ 1 ; ;
rank: 37
score: 98.84129028320312
patch: ++ iter ; ++ iter ; ++ start ;
rank: 37
score: 98.79911586216518
patch: int n = iter . last CaMeL Index CaMeL Of ( $STRING$ ;
rank: 38
score: 99.16606903076172
patch: final int f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 38
score: 98.9615478515625
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ) ;
rank: 38
score: 98.94451141357422
patch: ++ iter * / ++ iter ;
rank: 38
score: 98.90448676215277
patch: ++ iter ; iter ; int iter ;
rank: 38
score: 98.8426005045573
patch: if ( ! iter . is CaMeL Empty ++ ) ;
rank: 38
score: 98.8408203125
patch: / ; ++ iter ;
rank: 38
score: 98.79560198102679
patch: Point CaMeL Value CaMeL Pair iter = iter . iterator ( ) ;
rank: 39
score: 99.138427734375
patch: Point CaMeL Value CaMeL Pair checker = line . get CaMeL Value ( ) ;
rank: 39
score: 98.96081122036638
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . double CaMeL Value ( ) ;
rank: 39
score: 98.94242720170455
patch: ++ iter ; while ( iter < iter ) {
rank: 39
score: 98.90364583333333
patch: ++ iter ; ++ * * / /
rank: 39
score: 98.84254455566406
patch: / * * / ++ iter ;
rank: 39
score: 98.83858642578124
patch: ++ iter ; ++ start ; ++ iter ;
rank: 39
score: 98.79510498046875
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + iter ) ;
rank: 40
score: 99.13672814002403
patch: final double [ ] f CaMeL Val = f CaMeL Val ;
rank: 40
score: 99.1263427734375
patch: double f CaMeL Val = f CaMeL Val . to CaMeL String ( ) ;
rank: 40
score: 98.95824178059895
patch: ret = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 40
score: 98.94239908854166
patch: ++ iter ; double f CaMeL Val = Double . POSITIVE _ INFINITY ;
rank: 40
score: 98.89998626708984
patch: else ++ iter ; ++ iter ;
rank: 40
score: 98.84224446614583
patch: ++ * iter ; }
rank: 40
score: 98.83798217773438
patch: iter ; ++ iter ;
rank: 40
score: 98.79509626116071
patch: while ( iter != null )
rank: 41
score: 99.15859840029762
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = get CaMeL Goal CaMeL Type ( ) ;
rank: 41
score: 99.12809535435268
patch: double f CaMeL Val = f CaMeL Val + 0 . 0 ;
rank: 41
score: 99.11976623535156
patch: double iter = f CaMeL Val ;
rank: 41
score: 98.95780436197917
patch: return new CaMeL Point CaMeL And CaMeL Direction ( x ,
rank: 41
score: 98.9378662109375
patch: throw new Illegal CaMeL Argument CaMeL Exception ( ) ; }
rank: 41
score: 98.8397216796875
patch: if ( ! iter . is CaMeL Empty ++ ) {
rank: 41
score: 98.83283233642578
patch: ++ iter ; iter / * /
rank: 41
score: 98.78820190429687
patch: ++ iter ; while ( iter != null )
rank: 42
score: 99.13395182291667
patch: f CaMeL Val = f CaMeL Val ;
rank: 42
score: 99.1258316040039
patch: if ( f CaMeL Val . length >= f CaMeL Val . length ) {
rank: 42
score: 98.95740464154412
patch: return ( Point CaMeL Value CaMeL Pair ) checker . get CaMeL Point ( ) ;
rank: 42
score: 98.93244280133929
patch: ++ iter * / * /
rank: 42
score: 98.89508734809027
patch: ++ iter ; try ; int iter ;
rank: 42
score: 98.83001098632812
patch: } ++ iter ;
rank: 42
score: 98.8222885131836
patch: ++ ++ 1 ; ++ iter ;
rank: 42
score: 98.7831143465909
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ;
rank: 43
score: 99.1561767578125
patch: final int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 43
score: 99.1314697265625
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = false ;
rank: 43
score: 98.9567626953125
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ) ;
rank: 43
score: 98.932373046875
patch: int n = Double . MAX _ VALUE ;
rank: 43
score: 98.89362250434027
patch: ++ iter ; try { ++ iter ;
rank: 43
score: 98.82880510602679
patch: if ( ! iter . is CaMeL Empty ( ) ; break ;
rank: 43
score: 98.81597222222223
patch: iter ; ++ iter ; ++ iter ;
rank: 43
score: 98.77984619140625
patch: if ( ++ n > 0 )
rank: 44
score: 99.15424940321181
patch: final double f CaMeL Val = Math . copy CaMeL Of ( f CaMeL Val ) ;
rank: 44
score: 99.12722778320312
patch: double f CaMeL Val = f CaMeL Val . get CaMeL Point ( ) ;
rank: 44
score: 99.12427475873162
patch: return ( Point CaMeL Value CaMeL Pair ) checker . do CaMeL Optimize ( ) ;
rank: 44
score: 99.11506870814732
patch: int f CaMeL Val = f CaMeL Val . iterator ( ) ;
rank: 44
score: 98.9563220796131
patch: return Point CaMeL Value CaMeL Pair . new CaMeL Point CaMeL And CaMeL Direction ( f CaMeL Val ) ;
rank: 44
score: 98.93081868489584
patch: ++ iter ; double f CaMeL Val = Double . Na CaMeL N ;
rank: 44
score: 98.89106750488281
patch: ++ iter ; iter = iter ;
rank: 44
score: 98.82828194754464
patch: if ( ! iter . is CaMeL Empty ( ) ) . ;
rank: 45
score: 99.15360107421876
patch: double f CaMeL Val $NUMBER$ = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 45
score: 99.12230631510417
patch: if ( f CaMeL Val . length < f CaMeL Val . length )
rank: 45
score: 99.11320277622768
patch: double f CaMeL Val = line . get CaMeL Value ( ) ;
rank: 45
score: 98.95547380118535
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair {
rank: 45
score: 98.93048773871527
patch: ++ iter ; while ( iter ; )
rank: 45
score: 98.88939073350694
patch: / * ++ iter ; ++ iter ;
rank: 45
score: 98.8260726928711
patch: ++ * * * iter ; }
rank: 45
score: 98.8131103515625
patch: ++ 1 ; ++ iter ; ++ iter ;
rank: 45
score: 98.77386474609375
patch: throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + iter ) ;
rank: 46
score: 99.153466796875
patch: double f CaMeL Val = Univariate CaMeL Point CaMeL Value CaMeL Pair . get CaMeL Value ( ) ;
rank: 46
score: 99.12456597222223
patch: final double [ ] f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 46
score: 98.95411265980114
patch: Iterator < Point CaMeL Value CaMeL Pair > ++ ;
rank: 46
score: 98.9300308227539
patch: ++ iter ; if ( ; ;
rank: 46
score: 98.88885498046875
patch: ++ * ++ iter ; ++ iter ;
rank: 46
score: 98.82305145263672
patch: else { return iter ; } }
rank: 46
score: 98.81260986328125
patch: ++ 0 ; ++ iter ; ++ iter ;
rank: 46
score: 98.77238325639205
patch: throw new Illegal CaMeL State CaMeL Exception ( ) ;
rank: 47
score: 99.15169270833333
patch: ++ iter ; double f CaMeL Val = Univariate CaMeL Point CaMeL Value CaMeL Pair . f CaMeL Val ;
rank: 47
score: 99.12395629882812
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker . get CaMeL Value ( ) ;
rank: 47
score: 99.11539035373264
patch: int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( direc ) ;
rank: 47
score: 98.82254367404514
patch: if ( iter == null ; * /
rank: 47
score: 98.80620783025569
patch: ++ iter ; ++ iter ; ; ++ iter ;
rank: 48
score: 99.15010209517045
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , f CaMeL Val ) ;
rank: 48
score: 99.12324523925781
patch: int f CaMeL Val = f CaMeL Val . get CaMeL Value ( ) ;
rank: 48
score: 99.11420641447368
patch: double f CaMeL Val = ( Univariate CaMeL Point CaMeL Value CaMeL Pair ) f CaMeL Val ;
rank: 48
score: 98.95156715029762
patch: return Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) . get CaMeL Value ( ) ;
rank: 48
score: 98.9269510904948
patch: return new Point CaMeL Value CaMeL Pair ( ++ iter ;
rank: 48
score: 98.88341606987848
patch: / * ] iter ; ++ iter ;
rank: 48
score: 98.82244001116071
patch: else { ++ 0 ; }
rank: 48
score: 98.80516967773437
patch: ++ iter ; ++ iter ; ++ n ;
rank: 49
score: 99.14582170758929
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , x ) ;
rank: 49
score: 99.11197335379464
patch: double f CaMeL Val = f CaMeL Val * f CaMeL Val ;
rank: 49
score: 99.11128234863281
patch: if ( f CaMeL Val . length <= f CaMeL Val . length ) {
rank: 49
score: 98.951416015625
patch: return new Point CaMeL Value CaMeL Pair ( x 1 , f CaMeL Val ) ;
rank: 49
score: 98.92677815755208
patch: ++ iter ; final Point CaMeL Value CaMeL Pair ++ ;
rank: 49
score: 98.87985229492188
patch: / * ] iter = iter ;
rank: 49
score: 98.81588309151786
patch: if ( ! iter . is CaMeL Empty ( ) ; * /
rank: 49
score: 98.80482700892857
patch: ++ iter ; iter * /
rank: 49
score: 98.7640889485677
patch: throw new Illegal CaMeL State CaMeL Exception ( ) ; }
rank: 50
score: 99.14458550347223
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . f CaMeL Val ) ;
rank: 50
score: 99.111767578125
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( x $NUMBER$ ) ;
rank: 50
score: 99.11115579044117
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( x ) ;
rank: 50
score: 98.95128631591797
patch: Math CaMeL Arrays . copy CaMeL Of ( x , f CaMeL Val ) ;
rank: 50
score: 98.92420450846355
patch: return new Point CaMeL Value CaMeL Pair ( x , ;
rank: 50
score: 98.87870279947917
patch: ++ * ++ iter ;
rank: 50
score: 98.81587219238281
patch: if ++ [ 0 ] ; }
rank: 50
score: 98.80219116210938
patch: ++ n ; ++ iter ; ++ iter ;
rank: 50
score: 98.75626046316964
patch: while ( iter < n )
rank: 51
score: 99.1102627840909
patch: final double [ ] x = f CaMeL Val ;
rank: 51
score: 99.10964965820312
patch: double f CaMeL Val = f CaMeL Val - 1 ;
rank: 51
score: 98.95112827845982
patch: result = Math CaMeL Arrays . copy CaMeL Of ( x ) ;
rank: 51
score: 98.92216491699219
patch: ++ iter ; while ( ; )
rank: 51
score: 98.87808663504464
patch: ++ iter ; while iter ;
rank: 51
score: 98.80216979980469
patch: ++ iter ; iter / / /
rank: 51
score: 98.75508422851563
patch: ++ iter ; if ( iter != null )
rank: 52
score: 99.14256702769886
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of (
rank: 52
score: 99.10880533854167
patch: double [ ] x 1 = 0 ;
rank: 52
score: 99.10573443244485
patch: int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( direc [
rank: 52
score: 98.94972446986607
patch: Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 52
score: 98.91914506392045
patch: while ( iter < iter ) { ++ iter ;
rank: 52
score: 98.87724958147321
patch: / * ] iter ++ ;
rank: 52
score: 98.81304931640625
patch: if ( ! iter . is CaMeL Empty ++ ) return null ;
rank: 52
score: 98.8011807528409
patch: ++ iter ; ++ iter ; ++ iter ; }
rank: 52
score: 98.75272623697917
patch: throw new Runtime CaMeL Exception ( $STRING$ + n ) ;
rank: 53
score: 99.1384610262784
patch: double f CaMeL Val $NUMBER$ = f CaMeL Val ;
rank: 53
score: 99.10189208984374
patch: double f CaMeL Val += f CaMeL Val ;
rank: 53
score: 98.94952862079327
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( x ,
rank: 53
score: 98.91773139105902
patch: ++ iter ; this . ++ iter ;
rank: 53
score: 98.87545437282986
patch: ++ iter ; ++ iter ; * /
rank: 53
score: 98.80978393554688
patch: else { ++ iter ; * /
rank: 53
score: 98.79212535511364
patch: ++ iter ; ; ++ iter ; ++ iter ;
rank: 53
score: 98.75205641526442
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + n ;
rank: 54
score: 99.1050537109375
patch: double f CaMeL Val = x . search ( f CaMeL Val ) ;
rank: 54
score: 99.10157993861607
patch: ( ( Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > )
rank: 54
score: 99.1015689247533
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = Math CaMeL Arrays . copy CaMeL
rank: 54
score: 98.94851449819711
patch: return Math CaMeL Arrays . copy CaMeL Of ( x ) ;
rank: 54
score: 98.916162109375
patch: ++ iter ; throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ;
rank: 54
score: 98.87205287388393
patch: finally { ++ iter ; }
rank: 54
score: 98.80940755208333
patch: if ( iter < 0 ; * /
rank: 54
score: 98.7916015625
patch: ++ iter ; ++ n ; ++ iter ;
rank: 54
score: 98.74901234019886
patch: ++ iter ; while ( iter != null ) {
rank: 55
score: 99.13741932744566
patch: double f CaMeL Val = Univariate CaMeL Point CaMeL Value CaMeL Pair . get CaMeL Point ( f CaMeL Val ) ;
rank: 55
score: 99.10309159128289
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x . clone ( ) ) ;
rank: 55
score: 99.10139734604779
patch: double f CaMeL Val = Math CaMeL Arrays . abs ( f CaMeL Val ) ;
rank: 55
score: 98.94831085205078
patch: [ ] f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 55
score: 98.91607666015625
patch: ++ iter ; System . arraycopy ( ;
rank: 55
score: 98.87166748046874
patch: ++ iter ; ++ iter ; for iter ;
rank: 55
score: 98.80866088867188
patch: else { ++ * 0 . 0 ; }
rank: 55
score: 98.77894810267857
patch: ++ iter ; ++ 0 ;
rank: 55
score: 98.74730335582386
patch: throw new Illegal CaMeL State CaMeL Exception ( $STRING$ ;
rank: 56
score: 99.10132553998162
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( direc ) ;
rank: 56
score: 99.10001627604167
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( n ) ;
rank: 56
score: 98.91524564302884
patch: ++ iter ; int iter = Double . MAX _ VALUE ;
rank: 56
score: 98.86845397949219
patch: ++ iter ; else ++ iter ;
rank: 56
score: 98.80434348366477
patch: Set < ? > iter = iter . length ;
rank: 56
score: 98.74601606889205
patch: ++ iter ; System . exit ( 0 ) ;
rank: 57
score: 99.1331787109375
patch: ++ iter ; int f CaMeL Val = f CaMeL Val ;
rank: 57
score: 99.1010030110677
patch: double f CaMeL Val = guess . clone ( ) ;
rank: 57
score: 99.09933035714286
patch: double f CaMeL Val = f CaMeL Val : f CaMeL Val ;
rank: 57
score: 99.096435546875
patch: int f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ;
rank: 57
score: 98.94317626953125
patch: result = Math CaMeL Arrays . copy CaMeL Of ( x . clone ( ) ) ;
rank: 57
score: 98.91121732271634
patch: ++ iter ; double n = Double . MIN _ VALUE ;
rank: 57
score: 98.86457824707031
patch: ++ 1 ; ++ - iter ;
rank: 57
score: 98.80420939127605
patch: if ( ! iter . is CaMeL Empty ++ iter ;
rank: 57
score: 98.77375030517578
patch: ++ iter ; iter / ++ ;
rank: 57
score: 98.742919921875
patch: ++ iter = iter . iterator ( ) ;
rank: 58
score: 99.13294175091912
patch: double f CaMeL Val = f CaMeL Val ; double f CaMeL Val = 0 ;
rank: 58
score: 99.1010009765625
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( x 1 ) ;
rank: 58
score: 99.09852359169408
patch: String f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 58
score: 99.0960693359375
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( n ) ;
rank: 58
score: 98.94224717881944
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( x , f CaMeL Val ) ;
rank: 58
score: 98.91033257378473
patch: ++ iter ; while ( true ) {
rank: 58
score: 98.86349487304688
patch: ++ 1 ; ++ iter ; ;
rank: 58
score: 98.80378723144531
patch: else { ++ [ ] ; }
rank: 58
score: 98.77154541015625
patch: ++ -- iter ; ++ iter ;
rank: 58
score: 98.74022498497597
patch: buffer . append ( $STRING$ ) . append ( iter ) ;
rank: 59
score: 99.09906005859375
patch: double iter = f CaMeL Val . get CaMeL Value ( ) ;
rank: 59
score: 99.09622628348214
patch: int f CaMeL Val = x . get CaMeL Value ( ) ;
rank: 59
score: 99.09565286075367
patch: double iter = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 59
score: 98.94038609095982
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ( f CaMeL Val ) ;
rank: 59
score: 98.86346435546875
patch: ++ iter ; ++ - - iter ;
rank: 59
score: 98.80344801682692
patch: if ( ! iter . is CaMeL Empty ( ) ; }
rank: 59
score: 98.76978217230902
patch: ++ iter ; ++ iter ; ; iter
rank: 59
score: 98.73894708806819
patch: final int iter = iter . iterator ( ) ;
rank: 60
score: 99.1325619346217
patch: double f CaMeL Val = Univariate CaMeL Point CaMeL Value CaMeL Pair ( f CaMeL Val ) ;
rank: 60
score: 98.93995824353448
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair )
rank: 60
score: 98.90673828125
patch: return new Point CaMeL Value CaMeL Pair ( iter , ; }
rank: 60
score: 98.76634385850694
patch: ++ iter ; iter / / / /
rank: 61
score: 99.131572265625
patch: d = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ) ;
rank: 61
score: 99.09555489676339
patch: int f CaMeL Val = compute CaMeL Objective CaMeL Value ( ) ;
rank: 61
score: 99.095068359375
patch: final double f CaMeL Val = f CaMeL Val + f CaMeL Val ;
rank: 61
score: 98.93971252441406
patch: tmp = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 61
score: 98.90622780539773
patch: throw new Runtime CaMeL Exception ( $STRING$ ) ; }
rank: 61
score: 98.85679626464844
patch: ++ * * / ++ iter ;
rank: 61
score: 98.8006591796875
patch: if ( ! iter . is CaMeL Empty ++ ) return iter ;
rank: 62
score: 99.1299072265625
patch: double f CaMeL Val = copy CaMeL Of ( f CaMeL Val ) ;
rank: 62
score: 99.09463661595395
patch: final Univariate CaMeL Point CaMeL Value CaMeL Pair checker = line . get CaMeL Value ( ) ;
rank: 62
score: 99.09207313939145
patch: final double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( direc ) ;
rank: 62
score: 98.93943684895834
patch: return new Point CaMeL Value CaMeL Pair ( x 1 , x ) ;
rank: 62
score: 98.9058329264323
patch: return new Point CaMeL Value CaMeL Pair ( x ) ;
rank: 62
score: 98.85570068359375
patch: ++ iter ; ++ iter ; while iter ;
rank: 62
score: 98.79873221261161
patch: if ( ! iter . is CaMeL Empty ++ ) . ; }
rank: 62
score: 98.76230294363839
patch: ++ iter ; iter -- ;
rank: 62
score: 98.73382013494319
patch: while ( iter != null ) { ++ iter ;
rank: 63
score: 99.12953814338235
patch: double value = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 63
score: 98.9384053548177
patch: if ( f CaMeL Val < 0 . 0 ) {
rank: 63
score: 98.90561147836539
patch: ++ iter ; int n = Double . MIN _ VALUE ;
rank: 63
score: 98.85047064887152
patch: ++ iter ; iter ; ++ iter ;
rank: 63
score: 98.79859924316406
patch: else { ++ iter ; } }
rank: 63
score: 98.75980224609376
patch: ++ iter ; ++ iter ; iter ++ ;
rank: 63
score: 98.73098318917411
patch: throw new Unsupported CaMeL Operation CaMeL Exception ( $STRING$ + n ) ;
rank: 64
score: 99.12937330163044
patch: double f CaMeL Val = ( Univariate CaMeL Point CaMeL Value CaMeL Pair ) checker . get CaMeL Value ( ) ;
rank: 64
score: 99.0910175030048
patch: f CaMeL Val = f CaMeL Val + f CaMeL Val ;
rank: 64
score: 99.08850969587054
patch: double f CaMeL Val = checker . get CaMeL Value ( ) ;
rank: 64
score: 99.086181640625
patch: double f CaMeL Val = x . to CaMeL String ( ) ;
rank: 64
score: 98.93636380709134
patch: return ( Point CaMeL Value CaMeL Pair ) f CaMeL Val ;
rank: 64
score: 98.90540422712054
patch: Iterator < Point CaMeL Value CaMeL Pair > iter = iter . ;
rank: 64
score: 98.85007052951389
patch: ++ iter ; ++ * int iter ;
rank: 64
score: 98.79652622767857
patch: else { iter -- ; }
rank: 64
score: 98.75631713867188
patch: ++ 0 ; ; ++ iter ;
rank: 64
score: 98.72908158735795
patch: throw new Illegal CaMeL Argument CaMeL Exception ( ) ;
rank: 65
score: 99.12859429253473
patch: double f CaMeL Val $NUMBER$ = 0 ;
rank: 65
score: 99.08725120907738
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x . get CaMeL Value ( ) ) ;
rank: 65
score: 99.08443196614583
patch: int f CaMeL Val = f CaMeL Val - 0 ;
rank: 65
score: 98.93484497070312
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ) {
rank: 65
score: 98.90509796142578
patch: while ( iter <= n ) {
rank: 65
score: 98.79477945963542
patch: if ( . equals ( iter ) ;
rank: 65
score: 98.75550842285156
patch: ++ 1 ;
rank: 65
score: 98.72828979492188
patch: Iterator iterator = iter . iterator ( ) ;
rank: 66
score: 99.12778657058189
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . this . f CaMeL Val ) ;
rank: 66
score: 99.08399873621323
patch: f CaMeL Val = f CaMeL Val ; f CaMeL Val = f CaMeL Val ;
rank: 66
score: 98.93434244791666
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair 1 ;
rank: 66
score: 98.9036865234375
patch: return new Point CaMeL Value CaMeL Pair ( x , iter ;
rank: 66
score: 98.84865025111607
patch: ++ * / ++ iter ;
rank: 66
score: 98.79457785866477
patch: if ( iter == 0 ; return iter ; }
rank: 66
score: 98.75524139404297
patch: ++ 0 ;
rank: 66
score: 98.72676908052884
patch: if ( ! iter . is CaMeL Empty ( ; ) )
rank: 67
score: 99.08328450520834
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( length ) ;
rank: 67
score: 98.932861328125
patch: v = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 67
score: 98.8949483235677
patch: return new Point CaMeL Value CaMeL Pair ( ++ n ;
rank: 67
score: 98.84839545355902
patch: ++ iter ; ++ * * ; /
rank: 67
score: 98.79353550502232
patch: ++ * * iter ; }
rank: 67
score: 98.75386265345982
patch: ++ $STRING$ ; ++ iter ;
rank: 68
score: 99.1254131610577
patch: ++ true ; double f CaMeL Val = f CaMeL Val ;
rank: 68
score: 99.08681640625
patch: if ( f CaMeL Val . length > f CaMeL Val . length )
rank: 68
score: 99.08296712239583
patch: double f CaMeL Val = f CaMeL Val - n ;
rank: 68
score: 98.93269348144531
patch: ret = new CaMeL Point CaMeL And CaMeL Direction ( f CaMeL Val ) ;
rank: 68
score: 98.89341430664062
patch: ++ iter ; while ( iter < iter )
rank: 68
score: 98.84339141845703
patch: ++ iter ; ++ case iter ;
rank: 68
score: 98.78883361816406
patch: } if ++ 0 * iter ;
rank: 68
score: 98.7537841796875
patch: ++ - 1 ; ++ iter ;
rank: 68
score: 98.7242901141827
patch: throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + n ;
rank: 69
score: 99.12369577508224
patch: double f CaMeL Val = Math . copy CaMeL Of ( f CaMeL Val , 0 ) ;
rank: 69
score: 99.08500366210937
patch: double f CaMeL Val = 0 . 0 ;
rank: 69
score: 99.0835712139423
patch: f CaMeL Val = f CaMeL Val . clone ( ) ;
rank: 69
score: 99.08252671185662
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( direc ;
rank: 69
score: 98.9321925951087
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ;
rank: 69
score: 98.89071890024039
patch: return new Point CaMeL Value CaMeL Pair ( iter , x ;
rank: 69
score: 98.78736877441406
patch: ++ iter ; return iter ; }
rank: 69
score: 98.7533935546875
patch: ++ iter ; ++ iter ; = iter ;
rank: 69
score: 98.71795654296875
patch: ++ iter ; throw new Illegal CaMeL State CaMeL Exception ( ) ;
rank: 70
score: 99.1196925951087
patch: double f CaMeL Val = Univariate CaMeL Point CaMeL Value CaMeL Pair . get CaMeL Value ( f CaMeL Val ) ;
rank: 70
score: 99.08197021484375
patch: double f CaMeL Val = f CaMeL Val . to CaMeL String ( ) . clone ( ) ;
rank: 70
score: 98.93126953125
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair < Univariate CaMeL Point CaMeL Value CaMeL Pair >
rank: 70
score: 98.88905164930556
patch: ++ iter ; if ; ++ iter ;
rank: 70
score: 98.83299255371094
patch: ++ iter ; ++ * / ;
rank: 70
score: 98.78466033935547
patch: ++ x [ 0 ] ; }
rank: 70
score: 98.75189971923828
patch: ++ iter ; ++ -- iter ;
rank: 71
score: 99.11896623883929
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( this . f CaMeL Val ) ;
rank: 71
score: 99.08139474051339
patch: int f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ,
rank: 71
score: 99.0809390419408
patch: double f CaMeL Val = Fast CaMeL Math . copy CaMeL Of ( f CaMeL Val ) ;
rank: 71
score: 98.93101671006944
patch: return get CaMeL Goal CaMeL Type ( ) . get CaMeL Goal CaMeL Type ( ) ;
rank: 71
score: 98.88795823317308
patch: return new Point CaMeL Value CaMeL Pair ( x , ; }
rank: 71
score: 98.83299255371094
patch: ++ iter ; ++ x iter ;
rank: 71
score: 98.7845967610677
patch: if ( ! iter . is CaMeL Empty ( ; }
rank: 71
score: 98.74951171875
patch: / iter ++ ; ++ iter ;
rank: 71
score: 98.71665261008523
patch: Iterator iter = ++ iter . iterator ( ) ;
rank: 72
score: 99.1153076171875
patch: double f CaMeL Val = Math . copy CaMeL Of ( x ) ;
rank: 72
score: 99.08109777113971
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( double CaMeL Value ) ;
rank: 72
score: 98.93061266447368
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > ++ ;
rank: 72
score: 98.82945251464844
patch: i * ] ; ++ iter ;
rank: 72
score: 98.78416748046875
patch: ++ * ( 0 . 0 / iter ;
rank: 72
score: 98.74891967773438
patch: ++ start ; ++ iter ; ++ iter ;
rank: 72
score: 98.71584065755208
patch: if ( iter == null ) break ;
rank: 73
score: 99.0793701171875
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > direc ;
rank: 73
score: 99.07840169270834
patch: int f CaMeL Val = Math . abs ( f CaMeL Val ) ;
rank: 73
score: 98.93042710248162
patch: return Math CaMeL Arrays . copy CaMeL Of ( x . clone ( ) ) ;
rank: 73
score: 98.88613891601562
patch: while ( iter >= n ) {
rank: 73
score: 98.82815115792411
patch: ++ iter ; ++ $NUMBER$ ;
rank: 73
score: 98.78315873579545
patch: if ( iter != null ; return iter ; }
rank: 73
score: 98.74848090277777
patch: ++ iter ; ++ iter ; else ;
rank: 73
score: 98.71580200195312
patch: ++ iter ; while ( iter == n )
rank: 74
score: 99.07823893229167
patch: f CaMeL Val = f CaMeL Val . get CaMeL Value ( ) ;
rank: 74
score: 99.0762077780331
patch: int f CaMeL Val = f CaMeL Val . search ( f CaMeL Val ) ;
rank: 74
score: 98.92965698242188
patch: Node f CaMeL Val = f CaMeL Val . get CaMeL Value ( ) ;
rank: 74
score: 98.88569471571181
patch: while ( false ) { ++ iter ;
rank: 74
score: 98.82681274414062
patch: ++ iter ; int iter ++ ;
rank: 74
score: 98.78313337053571
patch: if ( ! iter . is CaMeL Empty ++ this . iter )
rank: 74
score: 98.74625244140626
patch: iter ++ ; ++ iter ; ++ iter ;
rank: 74
score: 98.71514892578125
patch: if ( ! iter . is CaMeL Empty ( ) ; else {
rank: 75
score: 99.11363002232143
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( direc [ 0 ] ) ;
rank: 75
score: 99.07819213867188
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( f CaMeL Val , f CaMeL Val ) ;
rank: 75
score: 99.07733154296875
patch: final double f CaMeL Val $NUMBER$ = f CaMeL Val ;
rank: 75
score: 98.92935384114584
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ] ;
rank: 75
score: 98.88490295410156
patch: while ( true ) ++ iter ;
rank: 75
score: 98.82148573133681
patch: ++ iter ; try ; if iter ;
rank: 75
score: 98.78181966145833
patch: if ( ! iter . is CaMeL Empty ( ) ; ++ iter ;
rank: 75
score: 98.74610900878906
patch: ++ - iter ; ++ iter ;
rank: 75
score: 98.71453387920673
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; }
rank: 76
score: 99.0779167624081
patch: final Point CaMeL Value CaMeL Pair checker = line . get CaMeL Value ( ) ;
rank: 76
score: 98.92835489908855
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair > ;
rank: 76
score: 98.88374837239583
patch: ++ iter ; f CaMeL Val ++ ;
rank: 76
score: 98.78056335449219
patch: else { * * * / }
rank: 76
score: 98.74463653564453
patch: / ++ iter ; ++ iter ;
rank: 76
score: 98.7144775390625
patch: if ( iter != null )
rank: 77
score: 99.11118570963542
patch: double f CaMeL Val $NUMBER$ = compute CaMeL Objective CaMeL Value ( f CaMeL Val ) ;
rank: 77
score: 99.07676344651442
patch: double [ ] x 1 = x . clone ( ) ;
rank: 77
score: 98.92743883634868
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair < Univariate CaMeL Point CaMeL Value CaMeL Pair >
rank: 77
score: 98.88307542067308
patch: ++ iter ; double iter = Double . MIN _ VALUE ;
rank: 77
score: 98.81978607177734
patch: ++ iter ; if ++ 1 ;
rank: 77
score: 98.77833251953125
patch: throw new Runtime CaMeL Exception ( $STRING$ ; }
rank: 77
score: 98.74456232244319
patch: ++ iter ; } ++ iter ; ++ iter ;
rank: 77
score: 98.71442522321429
patch: try { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ;
rank: 78
score: 99.1108929177989
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) . clone ( ) ;
rank: 78
score: 99.07399495442708
patch: double iter = f CaMeL Val . iterator ( ) ;
rank: 78
score: 98.92738743832237
patch: return ( Point CaMeL Value CaMeL Pair ) checker . get CaMeL Goal CaMeL Type ( ) ;
rank: 78
score: 98.8828633626302
patch: throw new Illegal CaMeL State CaMeL Exception ( $STRING$ ; }
rank: 78
score: 98.81774030412946
patch: i * ; ++ iter ;
rank: 78
score: 98.77783203125
patch: if ( iter == null ; }
rank: 78
score: 98.74422781808036
patch: ++ null ; ++ iter ;
rank: 78
score: 98.71370239257813
patch: int n = iter . iterator ( ) ;
rank: 79
score: 99.07633463541667
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = line . get CaMeL Value ( ) ;
rank: 79
score: 99.073486328125
patch: double f CaMeL Val = x . get CaMeL Size ( ) ;
rank: 79
score: 98.92693328857422
patch: found = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 79
score: 98.88272094726562
patch: ++ iter ; new Point CaMeL Value CaMeL Pair ( ;
rank: 79
score: 98.81319851345486
patch: ++ iter ; ++ * / iter ;
rank: 79
score: 98.77650553385416
patch: if ( ! iter . is CaMeL Empty ( ) ) return iter ;
rank: 79
score: 98.7434814453125
patch: ++ iter ; ++ iter ; ++ 1 ;
rank: 79
score: 98.71197509765625
patch: ++ iter ; iter = iter . iterator ( ) ;
rank: 80
score: 99.10638897235577
patch: double f CaMeL Val = Univariate CaMeL Point CaMeL Value CaMeL Pair . get CaMeL Point ( ) . get CaMeL Value ( ) ;
rank: 80
score: 99.07626953125
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair : checker . get CaMeL Value ( ) ;
rank: 80
score: 99.07210286458333
patch: double iter = x . get CaMeL Value ( ) ;
rank: 80
score: 98.92595079210069
patch: return ( Point CaMeL Value CaMeL Pair ) checker . get CaMeL Value ( ) ; }
rank: 80
score: 98.88198852539062
patch: ++ iter ; return new Point CaMeL Value CaMeL Pair ;
rank: 80
score: 98.81024169921875
patch: ++ * ] iter ; ++ iter ;
rank: 80
score: 98.77386067708333
patch: if ( ! iter . is CaMeL Empty ( ) ) return null ;
rank: 80
score: 98.74051513671876
patch: ++ iter ; ++ max ; ++ iter ;
rank: 80
score: 98.70796034071181
patch: if ( iter == null ) continue ;
rank: 81
score: 99.10623046875
patch: double f CaMeL Val = Math . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . f CaMeL Val ) ;
rank: 81
score: 99.07588195800781
patch: double CaMeL Value = compute CaMeL Objective CaMeL Value ( f CaMeL Val ) ;
rank: 81
score: 99.07090759277344
patch: double [ ] x = 0 ;
rank: 81
score: 98.92568790211396
patch: return new CaMeL Point CaMeL And CaMeL Direction ( x , f CaMeL Val ) ;
rank: 81
score: 98.88189697265625
patch: ++ iter ; * / ;
rank: 81
score: 98.8099594116211
patch: i * * / ++ iter ;
rank: 81
score: 98.77101353236607
patch: if ( iter != null ;
rank: 81
score: 98.74000549316406
patch: ++ 1 ; ; ++ iter ;
rank: 81
score: 98.70437622070312
patch: Enumeration iter = iter . iterator ( ) ;
rank: 82
score: 99.10609944661458
patch: final int f CaMeL Val = compute CaMeL Objective CaMeL Value ( f CaMeL Val ) ;
rank: 82
score: 99.0704116821289
patch: final double f CaMeL Val = Math . abs ( f CaMeL Val ) ;
rank: 82
score: 99.069287109375
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( 1 ) ;
rank: 82
score: 98.92477101293103
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair (
rank: 82
score: 98.88160118689903
patch: ++ iter ; throw new Illegal CaMeL Argument CaMeL Exception ( ;
rank: 82
score: 98.80967712402344
patch: j * ++ ; ++ iter ;
rank: 82
score: 98.770703125
patch: if ( ! iter . is CaMeL Empty ++ ) return iter ; }
rank: 82
score: 98.73993598090277
patch: ++ iter ; ++ ; ++ iter ;
rank: 82
score: 98.702392578125
patch: ++ iter ; throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ;
rank: 83
score: 99.10494559151786
patch: int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , 0 ) ;
rank: 83
score: 99.07582397460938
patch: d = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , f CaMeL Val ) ;
rank: 83
score: 99.06912667410714
patch: double f CaMeL Val = f CaMeL Val . trim ( ) ;
rank: 83
score: 99.06773274739584
patch: float f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 83
score: 98.9245834350586
patch: return get CaMeL Goal CaMeL Type ( ) . get CaMeL Point ( ) ;
rank: 83
score: 98.80867767333984
patch: ++ iter ; try ; break ;
rank: 83
score: 98.73672485351562
patch: } iter ++ ; ++ iter ;
rank: 84
score: 99.0751201923077
patch: double iter = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 84
score: 98.924072265625
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair Point CaMeL Value CaMeL Pair ;
rank: 84
score: 98.87371826171875
patch: ++ iter ; * / * * /
rank: 84
score: 98.80826144748264
patch: ++ * ++ iter ; while iter ;
rank: 84
score: 98.76634385850694
patch: if ( iter == null ; break ;
rank: 84
score: 98.69711303710938
patch: ++ iter ; f CaMeL Val = iter ;
rank: 85
score: 99.07246907552083
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( iter ) ;
rank: 85
score: 98.9239273071289
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( x , x ) ;
rank: 85
score: 98.76568603515625
patch: ++ * * ++ iter ; }
rank: 85
score: 98.73531341552734
patch: ++ n ; ; ++ iter ;
rank: 85
score: 98.69608931107955
patch: ++ iter ; System . exit ( 1 ) ;
rank: 86
score: 99.1030029296875
patch: final double f CaMeL Val $NUMBER$ = 0 ;
rank: 86
score: 99.0718017578125
patch: String f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 86
score: 99.06668090820312
patch: f CaMeL Val = Math . copy CaMeL Of ( f CaMeL Val , f CaMeL Val ) ;
rank: 86
score: 99.06597137451172
patch: double [ ] f CaMeL Val = x . get CaMeL Value ( ) ;
rank: 86
score: 98.92344665527344
patch: int f CaMeL Val = compute CaMeL Objective CaMeL Value ( x $NUMBER$ ) ;
rank: 86
score: 98.87248992919922
patch: ++ iter ; * / * ;
rank: 86
score: 98.80223846435547
patch: / * ] ; ++ iter ;
rank: 86
score: 98.76560974121094
patch: return iter ; } ++ iter ;
rank: 86
score: 98.73527388139205
patch: ++ iter ; ++ ++ iter ; ++ iter ;
rank: 86
score: 98.69324747721355
patch: throw new Runtime CaMeL Exception ( $STRING$ + iter ) ;
rank: 87
score: 99.10299246651786
patch: int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ) ;
rank: 87
score: 99.07157135009766
patch: int f CaMeL Val = f CaMeL Val . get CaMeL Point ( ) ;
rank: 87
score: 99.06217447916667
patch: double iter = 0 ;
rank: 87
score: 99.0619140625
patch: double [ ] x = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 87
score: 98.9227294921875
patch: Iterator < Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > ++ ;
rank: 87
score: 98.87008666992188
patch: ++ iter ; double f CaMeL Val = ;
rank: 87
score: 98.80137803819444
patch: ++ iter ; / * * / /
rank: 87
score: 98.76487513950893
patch: else { if ( ! iter . is CaMeL Empty ( ) ;
rank: 87
score: 98.73505316840277
patch: ++ iter ; ; ++ iter ; ;
rank: 88
score: 99.10268040707237
patch: double f CaMeL Val = f CaMeL Val - compute CaMeL Objective CaMeL Value ( x ) ;
rank: 88
score: 99.06195940290179
patch: double f CaMeL Val += f CaMeL Val - f CaMeL Val ;
rank: 88
score: 98.92222595214844
patch: r = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 88
score: 98.86949157714844
patch: while ( iter < n ) ;
rank: 88
score: 98.79827008928571
patch: / * ] iter * /
rank: 88
score: 98.76481628417969
patch: ++ * * iter ; * /
rank: 89
score: 99.10237984035327
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val . clone ( ) ) ;
rank: 89
score: 99.05962524414062
patch: if ( f CaMeL Val != null ) {
rank: 89
score: 98.9219970703125
patch: return new Point CaMeL Value CaMeL Pair ( x , x ) ;
rank: 89
score: 98.86941867404514
patch: if ( iter < n ) break ;
rank: 89
score: 98.79530334472656
patch: ++ iter ; ++ * / /
rank: 89
score: 98.73389434814453
patch: iter else ++ ; ++ iter ;
rank: 89
score: 98.68952026367188
patch: ++ iter ; if ( iter < n )
rank: 90
score: 99.070751953125
patch: final double f CaMeL Val = f CaMeL Val . clone ( ) ;
rank: 90
score: 99.0592400045956
patch: long f CaMeL Val = compute CaMeL Objective CaMeL Value ( f CaMeL Val ) ;
rank: 90
score: 98.92195638020833
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ) ;
rank: 90
score: 98.86841692243304
patch: while ( iter ; ) {
rank: 90
score: 98.79511369977679
patch: ++ * * ++ iter ;
rank: 90
score: 98.76382010323661
patch: if ( ! iter . is CaMeL Empty ( ) ; continue ;
rank: 90
score: 98.7302978515625
patch: ++ iter ; ++ iter ; throw iter ;
rank: 91
score: 99.10176418138587
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , f CaMeL Val ) ;
rank: 91
score: 98.86772017045455
patch: if ( iter != null ) { ++ iter ;
rank: 91
score: 98.7943344116211
patch: / * ] iter ; * /
rank: 91
score: 98.72877502441406
patch: ++ iter ; ; ++ start ;
rank: 91
score: 98.68824114118304
patch: if ( iter < n )
rank: 92
score: 99.06896254595588
patch: final double f CaMeL Val = f CaMeL Val . get CaMeL Value ( ) ;
rank: 92
score: 99.05510397518383
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( int CaMeL Value ) ;
rank: 92
score: 98.9205093383789
patch: return new Point CaMeL Value CaMeL Pair ( x , f CaMeL Val ) ;
rank: 92
score: 98.79366302490234
patch: ++ iter ; ++ ] iter ;
rank: 92
score: 98.7609634399414
patch: ++ * * * * / /
rank: 92
score: 98.68824114118304
patch: throw new Unsupported CaMeL Operation CaMeL Exception ( $STRING$ + iter ) ;
rank: 93
score: 99.10008409288194
patch: double f CaMeL Val = Univariate CaMeL Point CaMeL Value CaMeL Pair . f CaMeL Val ;
rank: 93
score: 99.06887950067934
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = new CaMeL Point CaMeL And CaMeL Direction ( ) ;
rank: 93
score: 99.05450846354167
patch: double f CaMeL Val = Math . clone ( f CaMeL Val ) ;
rank: 93
score: 98.91853133491848
patch: return Point CaMeL Value CaMeL Pair . new CaMeL Point CaMeL And CaMeL Direction ( x , f CaMeL Val ) ;
rank: 93
score: 98.86532253689236
patch: ++ iter - 1 ; ++ iter ;
rank: 93
score: 98.79326629638672
patch: ++ * iter ; ++ iter ;
rank: 93
score: 98.76091918945312
patch: else { iter = iter . length ; }
rank: 93
score: 98.72822788783482
patch: ++ true ; ++ iter ;
rank: 94
score: 99.0997314453125
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( f CaMeL Val , 0 ) ;
rank: 94
score: 99.06821899414062
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair && f CaMeL Val . clone ( ) ;
rank: 94
score: 99.0578254250919
patch: double f CaMeL Val = f CaMeL Val 1 . get CaMeL Value ( ) ;
rank: 94
score: 99.05385916573661
patch: int f CaMeL Val = x . get CaMeL Point ( ) ;
rank: 94
score: 98.91831752232143
patch: return Point CaMeL Value CaMeL Pair . new CaMeL Point CaMeL And CaMeL Direction ( x , x ) ;
rank: 94
score: 98.86527252197266
patch: ++ iter ; / * * /
rank: 94
score: 98.79212951660156
patch: ++ iter ; ++ 1 iter ;
rank: 94
score: 98.75740051269531
patch: / * * * / * /
rank: 94
score: 98.72798295454545
patch: ++ iter ; ++ iter ; else ++ iter ;
rank: 94
score: 98.6858154296875
patch: Math . max ( 0 , n ) ;
rank: 95
score: 99.06649017333984
patch: final double f CaMeL Val = compute CaMeL Objective CaMeL Value ( 0 ) ;
rank: 95
score: 99.05771053538604
patch: double [ ] x = Math CaMeL Arrays . copy CaMeL Of ( x ) ;
rank: 95
score: 99.05340983072917
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x 1 ,
rank: 95
score: 98.91742350260417
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair > iter = n ;
rank: 95
score: 98.8651455965909
patch: ++ iter ; while ( iter < n ) ;
rank: 95
score: 98.79025607638889
patch: ++ iter ; int iter = iter ;
rank: 95
score: 98.75729370117188
patch: ++ iter [ 0 ] ; }
rank: 95
score: 98.72549099392361
patch: ++ iter ; ; ++ iter ; }
rank: 95
score: 98.68535505022321
patch: ++ iter ; throw new Illegal CaMeL State CaMeL Exception ( $STRING$ ;
rank: 96
score: 99.05764770507812
patch: double f CaMeL Val = 1 . 0 ;
rank: 96
score: 98.9168701171875
patch: instanceof Univariate CaMeL Point CaMeL Value CaMeL Pair ) {
rank: 96
score: 98.78776332310268
patch: ++ * ; ++ iter ;
rank: 96
score: 98.75552804129464
patch: if ( ! iter . is CaMeL Empty ( ) ) return ;
rank: 96
score: 98.68471272786458
patch: return new Point CaMeL Value CaMeL Pair ( iter ) ;
rank: 97
score: 99.09697723388672
patch: double f CaMeL Val 1 = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 97
score: 99.06383167613636
patch: double CaMeL Value = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , f CaMeL Val ) ;
rank: 97
score: 99.0572509765625
patch: int f CaMeL Val = Math CaMeL Arrays . abs ( f CaMeL Val ) ;
rank: 97
score: 99.05233999399039
patch: f CaMeL Val = f CaMeL Val - f CaMeL Val ;
rank: 97
score: 98.91686197916667
patch: Iterator < Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair
rank: 97
score: 98.86424255371094
patch: ++ iter * / * * /
rank: 97
score: 98.7867202758789
patch: else { ++ iter ; break ;
rank: 97
score: 98.75550079345703
patch: / * * ++ * * /
rank: 97
score: 98.72373657226562
patch: ++ $NUMBER$ ; ++ iter ; ++ iter ;
rank: 97
score: 98.68361118861607
patch: try { throw new Illegal CaMeL State CaMeL Exception ( $STRING$ ) ;
rank: 98
score: 99.09674479166667
patch: double f CaMeL Val $NUMBER$ = f CaMeL Val - f CaMeL Val ;
rank: 98
score: 99.06377495659723
patch: double CaMeL Value = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 98
score: 98.86254272460937
patch: if ( iter < n ) ++ iter ;
rank: 98
score: 98.78648158482143
patch: ++ iter ; ++ * /
rank: 98
score: 98.75493621826172
patch: * * * / ++ iter ;
rank: 98
score: 98.72188991970486
patch: ++ iter ; ; if ++ iter ;
rank: 98
score: 98.67970493861607
patch: ++ iter ; throw new Illegal CaMeL Argument CaMeL Exception ( ) ;
rank: 99
score: 99.09572143554688
patch: if ( f CaMeL Val > 0 ) {
rank: 99
score: 99.06362915039062
patch: double f CaMeL Val = value . clone ( ) ;
rank: 99
score: 99.05376790364583
patch: if ( f CaMeL Val . length >= f CaMeL Val . length )
rank: 99
score: 99.05044119698661
patch: int f CaMeL Val = f CaMeL Val : f CaMeL Val ;
rank: 99
score: 98.91629231770834
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair > }
rank: 99
score: 98.86234537760417
patch: ++ iter ; f CaMeL Val = ;
rank: 99
score: 98.7852783203125
patch: ++ iter ; ++ case 1 ;
rank: 99
score: 98.75421549479167
patch: if ( ! iter . is CaMeL Empty ++ ) return null ; }
rank: 99
score: 98.71974690755208
patch: ++ iter ; iter ;
rank: 100
score: 99.05018717447916
patch: final double f CaMeL Val = x . get CaMeL Value ( ) ;
rank: 100
score: 98.91583251953125
patch: return Point CaMeL Value CaMeL Pair . new CaMeL Point CaMeL And CaMeL Direction ( x ,
rank: 100
score: 98.86234283447266
patch: if ( iter > 0 ) {
rank: 100
score: 98.78520965576172
patch: ++ iter ; synchronized ++ iter ;
rank: 100
score: 98.71931457519531
patch: ++ iter ; iter return iter ;
rank: 101
score: 99.062841796875
patch: double [ ] x 1 = x . get CaMeL Value ( ) ;
rank: 101
score: 99.04996744791667
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair extends Point CaMeL Value CaMeL Pair ;
rank: 101
score: 98.9154541015625
patch: return new CaMeL Point CaMeL And CaMeL Direction ( x , x ) ;
rank: 101
score: 98.86233084542411
patch: ++ iter ; } return new Point CaMeL Value CaMeL Pair ( ;
rank: 101
score: 98.78284454345703
patch: ++ iter ; for ++ iter ;
rank: 101
score: 98.75229317801339
patch: if ( ! iter . is CaMeL Empty ; ++ 0 . ;
rank: 101
score: 98.71889426491477
patch: } ++ iter ; ++ iter ; ++ iter ;
rank: 101
score: 98.6765848795573
patch: sb . append ( $STRING$ ) . append ( iter ;
rank: 102
score: 99.06278852982955
patch: f CaMeL Val = f CaMeL Val ; f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 102
score: 99.05109719669117
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( iter ) ;
rank: 102
score: 99.0499267578125
patch: double f CaMeL Val = f CaMeL Val 1 ;
rank: 102
score: 98.9153564453125
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ] {
rank: 102
score: 98.7825927734375
patch: i ++ ; ++ iter ;
rank: 102
score: 98.7521743774414
patch: * * * ; ++ iter ;
rank: 102
score: 98.71732788085937
patch: ++ iter ; ++ iter ; iter -- ;
rank: 103
score: 99.06241861979167
patch: final double f CaMeL Val = compute CaMeL Objective CaMeL Value ( ) ;
rank: 103
score: 99.050927734375
patch: double [ ] x = 0 . 0 ;
rank: 103
score: 99.04974920099431
patch: final double f CaMeL Val += f CaMeL Val ;
rank: 103
score: 98.91354031032986
patch: Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , f CaMeL Val ) ;
rank: 103
score: 98.86070556640625
patch: ++ iter ; if ( iter > 0 ;
rank: 103
score: 98.78170776367188
patch: ++ iter ; iter * * ;
rank: 103
score: 98.67622884114583
patch: iter = iter . iterator ( ) ; ++ iter ;
rank: 104
score: 99.0941162109375
patch: ++ iter ; double f CaMeL Val $NUMBER$ = 0 ;
rank: 104
score: 99.04972330729167
patch: double f CaMeL Val = f CaMeL Val - $NUMBER$ ;
rank: 104
score: 98.9118423461914
patch: ret = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 104
score: 98.85914024939903
patch: return new Point CaMeL Value CaMeL Pair ( x ) ; }
rank: 104
score: 98.77976989746094
patch: ++ iter ; else iter * /
rank: 104
score: 98.74967447916667
patch: if ( ! iter . is CaMeL Empty ++ 1 ;
rank: 104
score: 98.71589006696429
patch: ++ iter ; ++ $STRING$ ;
rank: 104
score: 98.67469024658203
patch: while ( iter == n ) {
rank: 105
score: 99.09358520507813
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , 0 ) ;
rank: 105
score: 99.04838053385417
patch: int f CaMeL Val = f CaMeL Val - iter ;
rank: 105
score: 98.9106674194336
patch: p = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 105
score: 98.85662841796875
patch: throw new Runtime CaMeL Exception ( $STRING$ ;
rank: 105
score: 98.77901611328124
patch: ++ iter ; ++ * / ++ iter ;
rank: 105
score: 98.74961635044643
patch: if ( ! iter . is CaMeL Empty ( ) ; return ;
rank: 105
score: 98.71499294704861
patch: ++ iter ; ++ iter + iter ;
rank: 105
score: 98.67428823617789
patch: throw new Illegal CaMeL State CaMeL Exception ( $STRING$ ) ; }
rank: 106
score: 99.09323354867789
patch: double f CaMeL Val $NUMBER$ = x . clone ( ) ;
rank: 106
score: 99.04782284007354
patch: int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( n ) ;
rank: 106
score: 99.04541829427083
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = true ;
rank: 106
score: 98.9099833170573
patch: return compute CaMeL Objective CaMeL Value ( x ) ; }
rank: 106
score: 98.8560302734375
patch: ++ iter ; * / * ++ iter ;
rank: 106
score: 98.77591705322266
patch: ++ value ; ++ iter ; ;
rank: 106
score: 98.74729919433594
patch: * * * * ++ iter ;
rank: 106
score: 98.67368570963542
patch: ++ iter - iter ;
rank: 107
score: 99.092900390625
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . x ) ;
rank: 107
score: 99.04677036830357
patch: f CaMeL Val = x . search ( f CaMeL Val ) ;
rank: 107
score: 98.90996262122844
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair < Univariate CaMeL Point CaMeL Value CaMeL Pair > iter = 0 ;
rank: 107
score: 98.85372488839286
patch: ++ iter ; while ( iter < n ) { ++ iter ;
rank: 107
score: 98.77505493164062
patch: ++ iter ; ++ 1 ; ++ iter ;
rank: 107
score: 98.74566650390625
patch: if ( ! iter . is CaMeL Empty ( ; )
rank: 107
score: 98.71229137073864
patch: ++ iter ; ++ iter ; / ++ iter ;
rank: 107
score: 98.67335094105114
patch: ++ iter ; if ( iter != null ) {
rank: 108
score: 99.09115487557871
patch: double f CaMeL Val = Math . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . this . f CaMeL Val ) ;
rank: 108
score: 99.0570068359375
patch: double iter = f CaMeL Val . get CaMeL Point ( ) ;
rank: 108
score: 99.046142578125
patch: int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( x ) ;
rank: 108
score: 98.9096450805664
patch: y = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 108
score: 98.77320098876953
patch: ++ iter ; ++ iter ; ++
rank: 108
score: 98.74552917480469
patch: ++ * * * ++ iter ;
rank: 108
score: 98.71161566840277
patch: ++ ; ++ iter ; ++ iter ;
rank: 108
score: 98.67322387695313
patch: Iterator n = iter . iterator ( ) ;
rank: 109
score: 99.08975558810764
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ;
rank: 109
score: 99.05601399739584
patch: final double CaMeL Value = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 109
score: 99.04479166666667
patch: double f CaMeL Val = f CaMeL Val . search ( 0 ) ;
rank: 109
score: 99.04391915457589
patch: double f CaMeL Val = line . get CaMeL Point ( ) ;
rank: 109
score: 98.90943224676724
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair }
rank: 109
score: 98.85165640024039
patch: return new Point CaMeL Value CaMeL Pair ( ++ n ) ;
rank: 109
score: 98.77307807074652
patch: ++ iter ; ++ value ; iter ;
rank: 109
score: 98.7451171875
patch: if ( ! iter . is CaMeL Empty ( ; ;
rank: 109
score: 98.71084255642361
patch: ++ iter ; ++ iter ; } else
rank: 109
score: 98.66969604492188
patch: while ( iter < iter . length ) {
rank: 110
score: 99.08968680245536
patch: double f CaMeL Val = Math . abs ( f CaMeL Val ;
rank: 110
score: 99.04436700994319
patch: double [ ] x 1 = 0 . 0 ;
rank: 110
score: 98.909423828125
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair ) {
rank: 110
score: 98.85110812717014
patch: while ( ; ) { ++ iter ;
rank: 110
score: 98.76992797851562
patch: ++ iter ; ++ iter ; *
rank: 110
score: 98.74267578125
patch: else { iter * 0 . 0 ; }
rank: 110
score: 98.71014404296875
patch: ++ iter ; ++ iter ; / / /
rank: 110
score: 98.66944376627605
patch: ++ iter + 1 ;
rank: 111
score: 99.08711460658482
patch: double f CaMeL Val = search . get CaMeL Value ( ) ;
rank: 111
score: 99.05479600694444
patch: final double iter = f CaMeL Val ;
rank: 111
score: 99.04163818359375
patch: double f CaMeL Val = new Univariate CaMeL Point CaMeL Value CaMeL Pair ( f CaMeL Val ) ;
rank: 111
score: 98.90932280441811
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair = x . clone ( ) ;
rank: 111
score: 98.85099962022569
patch: while ( iter < n ) { ;
rank: 111
score: 98.76713731553819
patch: / * ] * / ++ iter ;
rank: 111
score: 98.74078369140625
patch: / * * * ++ * /
rank: 111
score: 98.6681416829427
patch: Iterator iter = iter . iterator ( ) ; while ;
rank: 112
score: 99.05228097098214
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( iter ) ;
rank: 112
score: 99.04315185546875
patch: double [ ] f CaMeL Val = 0 ;
rank: 112
score: 99.04163469587054
patch: int f CaMeL Val = f CaMeL Val * f CaMeL Val ;
rank: 112
score: 98.90899299172794
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair >
rank: 112
score: 98.84906475360577
patch: ++ iter ; throw new Runtime CaMeL Exception ( $STRING$ ) ;
rank: 112
score: 98.76558140345982
patch: ++ * ] ++ iter ;
rank: 112
score: 98.74072943793402
patch: ++ iter ; } if ++ iter ;
rank: 112
score: 98.70431518554688
patch: ++ iter ; ; return iter ;
rank: 113
score: 99.08579950747283
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( (
rank: 113
score: 99.04305826822916
patch: if ( f CaMeL Val . length <= f CaMeL Val . length )
rank: 113
score: 99.04139539930556
patch: double f CaMeL Val = x . to CaMeL String ( ) . clone ( ) ;
rank: 113
score: 98.90836588541667
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > iter = 0 ;
rank: 113
score: 98.84894353693181
patch: ++ iter ; if ( iter > 0 ) {
rank: 113
score: 98.76233673095703
patch: ++ iter ; ++ - value ;
rank: 113
score: 98.74012340198864
patch: while ( ! iter . is CaMeL Empty ++ )
rank: 113
score: 98.7029037475586
patch: ++ iter ; ++ x 1 ;
rank: 113
score: 98.66713645241477
patch: ++ iter ; while ( iter . ; ) {
rank: 114
score: 99.08517140355603
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . get CaMeL Value ( ) ) ;
rank: 114
score: 99.03980928308823
patch: double f CaMeL Val = Fast CaMeL Math . abs ( f CaMeL Val ) ;
rank: 114
score: 98.90823567708334
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair do {
rank: 114
score: 98.73973846435547
patch: / * * * ; * /
rank: 114
score: 98.70186157226563
patch: ++ iter ; iter ++ ; ++ iter ;
rank: 114
score: 98.66652610085227
patch: ++ iter ; System . exit ( $NUMBER$ ) ;
rank: 115
score: 99.08482142857143
patch: double f CaMeL Val = Univariate CaMeL Point CaMeL Value CaMeL Pair . get CaMeL Value ( x ) ;
rank: 115
score: 99.05045572916667
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( x . clone ( ) ) ;
rank: 115
score: 99.03963894314236
patch: final double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( direc ;
rank: 115
score: 98.90759765625
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair [ ] ;
rank: 115
score: 98.84848022460938
patch: ++ iter * /
rank: 115
score: 98.75810241699219
patch: ++ 0 ; ++ iter ; ;
rank: 115
score: 98.73769124348958
patch: / * * * / ++ iter ;
rank: 115
score: 98.70133972167969
patch: ++ n ; ++ iter ; }
rank: 115
score: 98.66527303059895
patch: int iter = 0 ; while ( iter < n )
rank: 116
score: 99.082392578125
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . 1 ) ;
rank: 116
score: 99.05005821814903
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( ) ;
rank: 116
score: 99.03905029296875
patch: double [ ] x = 1 . 0 ;
rank: 116
score: 99.03891888786765
patch: double f CaMeL Val = f CaMeL Val . get CaMeL Value ( 0 ) ;
rank: 116
score: 98.90735284213362
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair .
rank: 116
score: 98.75715467664931
patch: this . ++ iter ; ++ iter ;
rank: 116
score: 98.7372055053711
patch: / * * * / / /
rank: 116
score: 98.69902692522321
patch: ++ iter ; ++ break ;
rank: 116
score: 98.662841796875
patch: ++ iter ; try {
rank: 117
score: 99.08096168154762
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , 1 ) ;
rank: 117
score: 99.04954892113095
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = new CaMeL Point CaMeL And CaMeL Direction ;
rank: 117
score: 99.03889016544117
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( 0 . 0 ) ;
rank: 117
score: 98.90662841796875
patch: return new Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ( f CaMeL Val ) ;
rank: 117
score: 98.84771728515625
patch: int n = Double . MIN _ VALUE ;
rank: 117
score: 98.75654432508681
patch: ++ iter ; iter ; * * /
rank: 117
score: 98.73692830403645
patch: if ( ! iter . is CaMeL Empty ++ ( ;
rank: 117
score: 98.69773559570312
patch: ++ iter ; iter / / = iter ;
rank: 117
score: 98.66258239746094
patch: float n = iter * n ;
rank: 118
score: 99.03667805989583
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( true ) ;
rank: 118
score: 98.90587116109914
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair =
rank: 118
score: 98.75609479631696
patch: ++ name ; ++ iter ;
rank: 118
score: 98.73679896763393
patch: if ( ! iter . is CaMeL Empty ++ ) break ; }
rank: 118
score: 98.69632720947266
patch: ++ iter ; ++ ++ 1 ;
rank: 118
score: 98.66204364483173
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + iter ;
rank: 119
score: 99.03653971354167
patch: final double x = f CaMeL Val ;
rank: 119
score: 98.9055812669837
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair )
rank: 119
score: 98.84531947544643
patch: return new Point CaMeL Value CaMeL Pair ( ++ iter , x ;
rank: 119
score: 98.75590515136719
patch: ++ ] iter ; ++ iter ;
rank: 119
score: 98.73402913411458
patch: if ( ! iter . is CaMeL Empty ++ 0 ;
rank: 119
score: 98.69576263427734
patch: ++ iter ; iter * / /
rank: 119
score: 98.66132061298077
patch: ++ iter ; throw new Illegal CaMeL State CaMeL Exception ( ;
rank: 120
score: 99.07933553059895
patch: double f CaMeL Val = 1 . clone ( ) ;
rank: 120
score: 99.04795532226562
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair extends Point CaMeL Value CaMeL Pair > checker ;
rank: 120
score: 99.03582763671875
patch: double f CaMeL Val = f CaMeL Val : 0 ;
rank: 120
score: 98.90485250538794
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ]
rank: 120
score: 98.8424823467548
patch: return new Point CaMeL Value CaMeL Pair ( iter , iter ;
rank: 120
score: 98.75588989257812
patch: ++ iter ; ++ value ; ;
rank: 120
score: 98.733984375
patch: if ( iter == null ; break ; }
rank: 120
score: 98.69292602539062
patch: ++ iter ; ++ iter ; if iter ;
rank: 120
score: 98.66065673828125
patch: ++ iter ; hash CaMeL Code = iter ;
rank: 121
score: 99.04732055664063
patch: Point CaMeL Value CaMeL Pair checker = Math CaMeL Arrays . copy CaMeL Of ( direc ) ;
rank: 121
score: 99.03547014508929
patch: double f CaMeL Val = f CaMeL Val + 0 . 1 ;
rank: 121
score: 98.90237559442934
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair < Univariate CaMeL Point CaMeL Value CaMeL Pair > iter = 0 ;
rank: 121
score: 98.84146881103516
patch: if ( iter < n ) {
rank: 121
score: 98.75487518310547
patch: ++ * * ; ++ iter ;
rank: 121
score: 98.73346710205078
patch: ++ iter ; iter ++ ; }
rank: 121
score: 98.69273376464844
patch: iter iter ++ ; ++ iter ;
rank: 121
score: 98.66007777622768
patch: if ( ! iter . is CaMeL Empty ( ; ) ) {
rank: 122
score: 99.07847243088942
patch: final double f CaMeL Val = x . clone ( ) ;
rank: 122
score: 99.04623046875
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = Math CaMeL Arrays . copy CaMeL Of ( direc ) ;
rank: 122
score: 99.03481820913461
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ;
rank: 122
score: 98.90159505208334
patch: return new CaMeL Point CaMeL And CaMeL Direction ( x , iter ) ;
rank: 122
score: 98.83961995442708
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + ;
rank: 122
score: 98.73345075334821
patch: } ++ [ ] iter ;
rank: 122
score: 98.69194793701172
patch: ++ 0 ; ++ iter ; }
rank: 123
score: 99.07783059512867
patch: double f CaMeL Val = Integer . copy CaMeL Of ( f CaMeL Val ) ;
rank: 123
score: 99.045458984375
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( clone ) ;
rank: 123
score: 99.03243815104166
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( false ) ;
rank: 123
score: 98.89979654947916
patch: return Math CaMeL Arrays . copy CaMeL Of ( x , iter ) ;
rank: 123
score: 98.75389099121094
patch: ++ iter ; else * * /
rank: 123
score: 98.73272705078125
patch: / * * * ++ ; /
rank: 123
score: 98.69145965576172
patch: ++ 1 ; ++ iter ; }
rank: 123
score: 98.65648651123047
patch: if ( ++ n > 1 )
rank: 124
score: 99.07703575721153
patch: double f CaMeL Val = Math . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ) ;
rank: 124
score: 99.0444580078125
patch: final f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 124
score: 99.0324939546131
patch: int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( direc [ 0 ] ) ;
rank: 124
score: 99.03187052408855
patch: int f CaMeL Val = f CaMeL Val - 1 ;
rank: 124
score: 98.89950125558036
patch: result = compute CaMeL Objective CaMeL Value ( f CaMeL Val ) ;
rank: 124
score: 98.8393221768466
patch: ++ iter ; if ( iter < n ) {
rank: 124
score: 98.75251908735795
patch: ++ iter ; ++ iter ; if ++ iter ;
rank: 124
score: 98.73228102463942
patch: else { if ( ! iter . is CaMeL Empty ++ )
rank: 124
score: 98.69036865234375
patch: ++ iter ; ++ iter ; for ++ ;
rank: 124
score: 98.65607244318181
patch: throw new Unsupported CaMeL Operation CaMeL Exception ( $STRING$ ;
rank: 125
score: 99.07615309495192
patch: ++ iter ; double f CaMeL Val = 0 . 0 ;
rank: 125
score: 99.04435221354167
patch: double [ ] f CaMeL Val = f CaMeL Val . get CaMeL Value ( ) ;
rank: 125
score: 99.03105236235119
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x . do CaMeL Optimize ( ) ) ;
rank: 125
score: 98.89945714613971
patch: return get CaMeL Goal CaMeL Type ( ) . get CaMeL Value ( ) ; }
rank: 125
score: 98.8388671875
patch: ++ iter ; while ( iter <= n ) {
rank: 125
score: 98.7509765625
patch: ++ iter ; int iter ;
rank: 125
score: 98.7317626953125
patch: if ( ! iter . is CaMeL Empty ( ) ) throw null ;
rank: 125
score: 98.68834092881944
patch: ++ iter ; ; if iter ++ ;
rank: 125
score: 98.65280983664773
patch: try { iter = iter . iterator ( ) ;
rank: 126
score: 99.0755550986842
patch: double < Univariate CaMeL Point CaMeL Value CaMeL Pair > f CaMeL Val = f CaMeL Val ;
rank: 126
score: 99.0308837890625
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( x ;
rank: 126
score: 99.03075062144886
patch: double [ ] x $NUMBER$ = f CaMeL Val ;
rank: 126
score: 98.8992919921875
patch: n = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 126
score: 98.83811598557692
patch: return new Point CaMeL Value CaMeL Pair ( ++ iter ) ;
rank: 126
score: 98.7509765625
patch: ++ iter ; iter + 0 ;
rank: 126
score: 98.73016357421875
patch: i ++ ; if ++ iter ;
rank: 126
score: 98.68792724609375
patch: ++ iter ; ; -- iter ;
rank: 126
score: 98.65204535590277
patch: synchronized ( this ) { ++ iter ;
rank: 127
score: 99.07489304315476
patch: double f CaMeL Val = Univariate CaMeL Point CaMeL Value CaMeL Pair . get CaMeL Point ( x ) ;
rank: 127
score: 99.04276529947917
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = new CaMeL Point CaMeL And CaMeL Direction ( x ) ;
rank: 127
score: 98.89789895450367
patch: Iterator < Point CaMeL Value CaMeL Pair protected Univariate CaMeL Point CaMeL Value CaMeL Pair >
rank: 127
score: 98.83762613932292
patch: ++ iter ; while ;
rank: 127
score: 98.74932861328125
patch: ++ iter ; for iter ++ ;
rank: 127
score: 98.72828674316406
patch: i ++ ; } return iter ;
rank: 127
score: 98.68768310546875
patch: ++ iter ; ++ iter ; /
rank: 128
score: 99.07455926192434
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( f CaMeL Val , x ) ;
rank: 128
score: 99.04148763020834
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = false ;
rank: 128
score: 99.02988009982639
patch: final double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( direc [
rank: 128
score: 98.89724864130434
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair >
rank: 128
score: 98.83711751302083
patch: ++ iter ; if ;
rank: 128
score: 98.74749755859375
patch: ++ iter ; while iter ; ;
rank: 128
score: 98.72823079427083
patch: else { ++ * * iter ; }
rank: 128
score: 98.68680148654514
patch: ++ iter ; iter if iter ++ ;
rank: 128
score: 98.64881243024554
patch: sb . append ( $STRING$ ) . append ( ++ n ) ;
rank: 129
score: 99.07424926757812
patch: double f CaMeL Val = Univariate CaMeL Point CaMeL Value CaMeL Pair . get CaMeL Point ( ) ;
rank: 129
score: 99.04132843017578
patch: int f CaMeL Val = compute CaMeL Objective CaMeL Value ( x 1 ) ;
rank: 129
score: 99.02906558388158
patch: int f CaMeL Val = ( Univariate CaMeL Point CaMeL Value CaMeL Pair ) f CaMeL Val ;
rank: 129
score: 99.02825927734375
patch: double f CaMeL Val = f CaMeL Val - 0 . 1 ;
rank: 129
score: 98.89508688038794
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair >
rank: 129
score: 98.83702503551136
patch: ++ iter ; while ( iter >= n ) {
rank: 129
score: 98.74605984157986
patch: ++ iter ; iter ; if iter ;
rank: 129
score: 98.72764587402344
patch: ++ * * * * ; /
rank: 129
score: 98.686767578125
patch: ++ iter ; ++ iter ; ++ ++ iter ;
rank: 129
score: 98.64730224609374
patch: final ++ iter ;
rank: 130
score: 99.0738525390625
patch: if ( f CaMeL Val == null ) {
rank: 130
score: 99.03987630208333
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( $STRING$ ) ;
rank: 130
score: 99.02880859375
patch: double iter = Math CaMeL Arrays . copy CaMeL Of ( direc ) ;
rank: 130
score: 99.02627999441964
patch: f CaMeL Val = Math . abs ( f CaMeL Val ) ;
rank: 130
score: 98.89491780598958
patch: return compute CaMeL Objective CaMeL Value ( x 1 ) ;
rank: 130
score: 98.74577331542969
patch: ++ * * ++ iter ; /
rank: 130
score: 98.72745455228366
patch: if ( ! iter . is CaMeL Empty ( iter ) ;
rank: 130
score: 98.68647904829545
patch: ++ iter ; ++ iter ; ++ iter ; ;
rank: 130
score: 98.64683532714844
patch: int n = iter * n ;
rank: 131
score: 98.89398552389706
patch: return get CaMeL Goal CaMeL Type ( goal ) . get CaMeL Value ( ) ;
rank: 131
score: 98.83447265625
patch: return new Point CaMeL Value CaMeL Pair ( ++ iter , ;
rank: 131
score: 98.74567413330078
patch: ++ iter ; int * * /
rank: 131
score: 98.72702026367188
patch: return ++ [ 0 ] ; }
rank: 131
score: 98.6861572265625
patch: ++ iter ; ++ iter ; iterator ;
rank: 131
score: 98.64642333984375
patch: if ( ++ iter ) {
rank: 132
score: 99.07328491210937
patch: double f CaMeL Val 1 = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 132
score: 99.03868815104167
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( this ) ;
rank: 132
score: 99.02851418887867
patch: double f CaMeL Val = Math . to CaMeL String ( f CaMeL Val ) ;
rank: 132
score: 98.8936767578125
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair [ ]
rank: 132
score: 98.8334228515625
patch: int n = Integer . MAX _ VALUE ;
rank: 132
score: 98.72611490885417
patch: if ( ! iter . is CaMeL Empty ( ) ; break ; }
rank: 132
score: 98.68270438058036
patch: ++ n ; ++ start ;
rank: 133
score: 99.0383056640625
patch: else f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 133
score: 99.02117919921875
patch: final double n = f CaMeL Val ;
rank: 133
score: 98.89354248046875
patch: Iterator < Point CaMeL Value CaMeL Pair ) {
rank: 133
score: 98.8326416015625
patch: Iterator < Point CaMeL Value CaMeL Pair > iterator = iter . ;
rank: 133
score: 98.74552408854167
patch: ++ iter ; iter ; int * /
rank: 133
score: 98.72456359863281
patch: ++ iter ; for ; * /
rank: 133
score: 98.68132188585069
patch: ++ iter ; ; iter if ++ ;
rank: 134
score: 99.03722534179687
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair > checker ;
rank: 134
score: 99.0275943153783
patch: double f CaMeL Val = Math . copy CaMeL Value CaMeL Of ( f CaMeL Val ) ;
rank: 134
score: 99.02114868164062
patch: final double f CaMeL Val = f CaMeL Val 1 ;
rank: 134
score: 98.8928955078125
patch: Integer f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 134
score: 98.8317538174716
patch: ++ iter ; f CaMeL Val = ++ iter ;
rank: 134
score: 98.74540879991319
patch: ++ iter ; iter ; * / /
rank: 134
score: 98.72401258680556
patch: if ( iter == null ; return ;
rank: 134
score: 98.67951965332031
patch: ++ max ++ ; ++ iter ;
rank: 134
score: 98.6431884765625
patch: sb . append ( $STRING$ ) . append ( iter ) . ;
rank: 135
score: 99.07101440429688
patch: int f CaMeL Val = line . clone ( ) ;
rank: 135
score: 99.03714425223214
patch: Point CaMeL Value CaMeL Pair checker = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 135
score: 98.89141845703125
patch: c = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 135
score: 98.83169320913461
patch: return new Point CaMeL Value CaMeL Pair ( ++ n ; }
rank: 135
score: 98.72258843315973
patch: else { * * * * / }
rank: 136
score: 99.07003445095486
patch: final int f CaMeL Val = Math . copy CaMeL Of ( f CaMeL Val ) ;
rank: 136
score: 99.02529296875
patch: final double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ;
rank: 136
score: 98.89117024739583
patch: Iterator < Point CaMeL Value CaMeL Pair protected Point CaMeL Value CaMeL Pair >
rank: 136
score: 98.83042214133523
patch: ++ iter ; while ( iter == n ) {
rank: 136
score: 98.74458312988281
patch: ++ $NUMBER$ ; ++ - iter ;
rank: 136
score: 98.72242228190105
patch: Iterator < Integer > iter = iter . iterator ++ ;
rank: 136
score: 98.6777572631836
patch: if iter ++ ; ++ iter ;
rank: 136
score: 98.64216444227431
patch: try { ++ iter ; ++ iter ;
rank: 137
score: 99.03579711914062
patch: double [ ] x 1 = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 137
score: 98.89095052083333
patch: Iterator < Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair >
rank: 137
score: 98.82945251464844
patch: ++ iter ; ; if ( ;
rank: 137
score: 98.744384765625
patch: ++ iter ; ++ - - 1 ;
rank: 137
score: 98.72196197509766
patch: } if ++ 1 * iter ;
rank: 137
score: 98.67697143554688
patch: iter } ++ ; ++ iter ;
rank: 137
score: 98.6407001201923
patch: throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + iter ;
rank: 138
score: 99.06972830636161
patch: double f CaMeL Val = 0 . 0 - f CaMeL Val ;
rank: 138
score: 99.03509521484375
patch: double iter = line . clone ( ) ;
rank: 138
score: 99.02460123697917
patch: double iter = Math CaMeL Arrays . copy CaMeL Of ( direc [
rank: 138
score: 99.01994977678571
patch: double f CaMeL Val = f CaMeL Val = f CaMeL Val ;
rank: 138
score: 98.89053109975961
patch: ret = compute CaMeL Objective CaMeL Value ( x $NUMBER$ ) ;
rank: 138
score: 98.82943289620536
patch: return new Point CaMeL Value CaMeL Pair ( x , iter ) ;
rank: 138
score: 98.7443514737216
patch: ++ iter ; ++ * * / ++ iter ;
rank: 138
score: 98.7217041015625
patch: if ( iter != 0 ; return iter ;
rank: 139
score: 99.069033203125
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . this ) ;
rank: 139
score: 99.0337626139323
patch: d = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 139
score: 99.02212524414062
patch: delta = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 139
score: 99.01983235677083
patch: double f CaMeL Val = f CaMeL Val - - f CaMeL Val ;
rank: 139
score: 98.89008037860577
patch: return compute CaMeL Objective CaMeL Value ( f CaMeL Val ) ;
rank: 139
score: 98.8290127840909
patch: ++ iter ; while ( iter > 0 ) {
rank: 139
score: 98.74372863769531
patch: ++ iter ; ++ - * /
rank: 139
score: 98.72136688232422
patch: Object iter = iter . length ;
rank: 139
score: 98.67359076605902
patch: ++ iter ; ++ iter ; / ;
rank: 139
score: 98.63714599609375
patch: iter = iter . iter ( ) ;
rank: 140
score: 99.033056640625
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( line ) ;
rank: 140
score: 99.02166389016544
patch: int x = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 140
score: 98.88999430338542
patch: r = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 140
score: 98.82869096235795
patch: while ( iter < n ; iter ++ ) {
rank: 140
score: 98.74348449707031
patch: ++ iter ; ++ - $STRING$ ;
rank: 140
score: 98.72108677455357
patch: } if ++ * iter ;
rank: 140
score: 98.67098999023438
patch: ++ ++ iter ;
rank: 140
score: 98.63661193847656
patch: ++ iter ; while ( true )
rank: 141
score: 99.06866244612068
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of (
rank: 141
score: 99.02065142463235
patch: float f CaMeL Val = compute CaMeL Objective CaMeL Value ( f CaMeL Val ) ;
rank: 141
score: 99.01931966145834
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( start ) ;
rank: 141
score: 98.88994891826923
patch: result = compute CaMeL Objective CaMeL Value ( x 1 ) ;
rank: 141
score: 98.82649230957031
patch: while ( iter ; ) { ;
rank: 141
score: 98.743408203125
patch: else { ++ iter ;
rank: 141
score: 98.72088153545673
patch: if ( . is CaMeL Empty ( ) ; return iter ;
rank: 141
score: 98.66987609863281
patch: iter
rank: 141
score: 98.6365254720052
patch: ++ iter ; throw new Illegal CaMeL Argument CaMeL Exception ;
rank: 142
score: 99.06706799958882
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ) . clone ( ) ;
rank: 142
score: 99.03092651367187
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( x . get CaMeL Value ( ) ) ;
rank: 142
score: 98.88992874710648
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair = f CaMeL Val ;
rank: 142
score: 98.82612440321181
patch: ++ iter ; / * * * ;
rank: 142
score: 98.72079467773438
patch: if ( ! iter . is CaMeL Empty ++ this ;
rank: 142
score: 98.66983468191964
patch: ++ this ; ++ iter ;
rank: 142
score: 98.63536834716797
patch: if ( ++ n > iter )
rank: 143
score: 99.06699916294643
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , $NUMBER$ ) ;
rank: 143
score: 99.03059895833333
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( double ) ;
rank: 143
score: 99.0193204012784
patch: final double f CaMeL Val = 0 . 0 ;
rank: 143
score: 98.88976287841797
patch: s = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 143
score: 98.72076416015625
patch: return ++ [ 0 ] ;
rank: 143
score: 98.66957092285156
patch: ++ iter ; ++ start ; }
rank: 143
score: 98.63503011067708
patch: int n = iter . index CaMeL Of ( $STRING$ ;
rank: 144
score: 99.06678508890086
patch: final double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ) ;
rank: 144
score: 99.03042805989584
patch: d = Math CaMeL Arrays . copy CaMeL Of ( direc ) ;
rank: 144
score: 98.88828461745689
patch: Iterator < Point CaMeL Value CaMeL Pair protected Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ;
rank: 144
score: 98.82517311789773
patch: throw new Runtime CaMeL Exception ( $STRING$ + n ;
rank: 144
score: 98.74213324652777
patch: / * ] iter ; / * /
rank: 144
score: 98.71968841552734
patch: / * ++ * * / }
rank: 144
score: 98.66874694824219
patch: ++ iter ; ; iter ++ ;
rank: 145
score: 99.06673457704741
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . x . clone ( ) ) ;
rank: 145
score: 99.0298583984375
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( $NUMBER$ ) ;
rank: 145
score: 99.01901041666666
patch: double f CaMeL Val = f CaMeL Val . search ( x ) ;
rank: 145
score: 98.88634033203125
patch: return new CaMeL Point CaMeL And CaMeL Direction ( new CaMeL Point CaMeL And CaMeL Direction ( x ,
rank: 145
score: 98.82259427584134
patch: return new Point CaMeL Value CaMeL Pair ( ++ iter ; }
rank: 145
score: 98.74114118303571
patch: / * ++ ++ iter ;
rank: 145
score: 98.71900939941406
patch: else { iter * * / }
rank: 145
score: 98.66826837713069
patch: ++ iter ; ++ iter ; else -- iter ;
rank: 145
score: 98.63423374720982
patch: int n = iter . last CaMeL Index CaMeL Of ( $STRING$ )
rank: 146
score: 99.06521426930146
patch: final double f CaMeL Val $NUMBER$ = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 146
score: 98.8862060546875
patch: Iterator < Point CaMeL Value CaMeL Pair > }
rank: 146
score: 98.74104614257813
patch: ++ iter ; ++ * * ++ iter ;
rank: 146
score: 98.71763916015625
patch: if ( . is CaMeL Empty ( ) ;
rank: 146
score: 98.66803533380681
patch: ++ iter ; ++ iter ; if iter ++ ;
rank: 146
score: 98.63367638221153
patch: Iterator iter = iter . iterator ( ) ; ++ iter ;
rank: 147
score: 99.06446126302083
patch: final int f CaMeL Val = f CaMeL Val - f CaMeL Val ;
rank: 147
score: 99.02718912760416
patch: final int f CaMeL Val = f CaMeL Val . clone ( ) ;
rank: 147
score: 98.8858173076923
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Point CaMeL Value CaMeL Pair . line . get CaMeL Value ( ) ) ;
rank: 147
score: 98.74049886067708
patch: ++ * ++ iter ; if iter ;
rank: 147
score: 98.71694946289062
patch: if ( ! iter . is CaMeL Empty ++ ) }
rank: 147
score: 98.66800362723214
patch: ++ iter ; ++ name ;
rank: 147
score: 98.63360595703125
patch: ++ iter ; throw new Illegal CaMeL State CaMeL Exception ;
rank: 148
score: 99.06294519761029
patch: ++ iter ; double f CaMeL Val = compute CaMeL Objective CaMeL Value ( ) ;
rank: 148
score: 99.02459247295673
patch: f CaMeL Val = checker . get CaMeL Value ( ) ;
rank: 148
score: 99.01779656661184
patch: double f CaMeL Val = f CaMeL Val : compute CaMeL Objective CaMeL Value ( x ) ;
rank: 148
score: 99.01365152994792
patch: double f CaMeL Val = f CaMeL Val + 0 ;
rank: 148
score: 98.88466796875
patch: return new Point CaMeL Value CaMeL Pair ( Point CaMeL Value CaMeL Pair . Math CaMeL Arrays . copy CaMeL Of ( x ,
rank: 148
score: 98.82189002403847
patch: return new Point CaMeL Value CaMeL Pair ( ++ n , ;
rank: 148
score: 98.71680559430804
patch: else { ++ 1 ; }
rank: 148
score: 98.66728210449219
patch: ++ ++ iter ; ++ start ;
rank: 148
score: 98.63314383370536
patch: while ( iter == n )
rank: 149
score: 99.06260614809783
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = this . get CaMeL Goal CaMeL Type ( ) ;
rank: 149
score: 99.02442568824405
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x . get CaMeL Point ( ) ) ;
rank: 149
score: 99.01257934570313
patch: final double x 1 = f CaMeL Val ;
rank: 149
score: 98.88405198317308
patch: Iterator < Point CaMeL Value CaMeL Pair > iter = n ;
rank: 149
score: 98.82113647460938
patch: ++ iter ; if ( iter < n ) break ;
rank: 149
score: 98.71678924560547
patch: } if ( iter != null ;
rank: 149
score: 98.66663208007813
patch: ++ iter ; ++ iter ; ++ max ;
rank: 150
score: 99.01701917146382
patch: double [ ] x = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 150
score: 99.01182797080592
patch: double f CaMeL Val = f CaMeL Val ; double f CaMeL Val = f CaMeL Val ;
rank: 150
score: 98.88369645743535
patch: Iterator < Point CaMeL Value CaMeL Pair , Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ;
rank: 150
score: 98.8208984375
patch: ++ iter ; return new Point CaMeL Value CaMeL Pair ( iter , ;
rank: 150
score: 98.71675109863281
patch: else { iter += $NUMBER$ ; }
rank: 151
score: 99.06159078663794
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) , 0 ) ;
rank: 151
score: 99.02206217447916
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( max ) ;
rank: 151
score: 99.01126098632812
patch: double [ ] f CaMeL Val = line . get CaMeL Value ( ) ;
rank: 151
score: 98.88286675347223
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Point CaMeL Value CaMeL Pair . new CaMeL Point CaMeL And CaMeL Direction ( x ,
rank: 151
score: 98.82018025716145
patch: ++ iter ; new Point CaMeL Value CaMeL Pair < ;
rank: 151
score: 98.73922293526786
patch: ++ 1 ; ++ 1 ;
rank: 151
score: 98.71662248883929
patch: if ( ! iter . is CaMeL Empty ( ) ) throw ;
rank: 151
score: 98.66292317708333
patch: ++ iter ; ; iter
rank: 151
score: 98.63210824819711
patch: int n = Math . max ( n , n ) ;
rank: 152
score: 99.06138209292763
patch: Object f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 152
score: 99.01046752929688
patch: double iter = f CaMeL Val + f CaMeL Val ;
rank: 152
score: 98.88286675347223
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair < Univariate CaMeL Point CaMeL Value CaMeL Pair > ++ ;
rank: 152
score: 98.81948513454861
patch: ++ iter * / * ++ iter ;
rank: 152
score: 98.73774719238281
patch: / ] iter ; ++ iter ;
rank: 152
score: 98.71588897705078
patch: ++ iter ; * * * /
rank: 152
score: 98.6300557454427
patch: if ( ! iter . is CaMeL Empty ; ) {
rank: 153
score: 99.0613025483631
patch: double f CaMeL Val = Math . copy CaMeL Of ( f CaMeL Val ) . clone ( ) ;
rank: 153
score: 99.0219140625
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ) ;
rank: 153
score: 99.01619262695313
patch: ( ( Univariate CaMeL Point CaMeL Value CaMeL Pair ) checker ) . get CaMeL Value ( ) ;
rank: 153
score: 99.01045735677083
patch: double [ ] f CaMeL Val += f CaMeL Val ;
rank: 153
score: 98.8828457919034
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ( f CaMeL Val ) ;
rank: 153
score: 98.81940569196429
patch: return new Point CaMeL Value CaMeL Pair ( x , iter , ;
rank: 153
score: 98.73648071289062
patch: ++ 0 ; ++ - iter ;
rank: 153
score: 98.71572043678977
patch: if ( ! iter . is CaMeL Empty iter )
rank: 153
score: 98.66276332310268
patch: ++ iter ; iter / /
rank: 154
score: 99.02147327769886
patch: final Point CaMeL Value CaMeL Pair checker = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 154
score: 99.00795491536458
patch: double f CaMeL Val = x . trim ( ) ;
rank: 154
score: 98.88239203559027
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( x . clone ( ) ) ;
rank: 154
score: 98.81676567925348
patch: ++ iter ; ; if ( iter ;
rank: 154
score: 98.73646545410156
patch: ++ iter ; if iter ++ ;
rank: 154
score: 98.71419525146484
patch: } else { return iter ; }
rank: 154
score: 98.66098458426339
patch: if iter ; ++ iter ;
rank: 154
score: 98.62777005709134
patch: int n = Math . max ( iter , n ) ;
rank: 155
score: 99.06031334918478
patch: ++ iter ; double f CaMeL Val = Univariate CaMeL Point CaMeL Value CaMeL Pair . get CaMeL Value ( ) ;
rank: 155
score: 99.02066476004464
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > -- ;
rank: 155
score: 99.00790584788604
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x , iter ) ;
rank: 155
score: 98.88236860795455
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( checker . get CaMeL Goal CaMeL Type ( ) ) ;
rank: 155
score: 98.81671142578125
patch: throw new Unsupported CaMeL Operation CaMeL Exception ( $STRING$ ; }
rank: 155
score: 98.73641967773438
patch: ++ iter ; iter ; * ;
rank: 155
score: 98.7135986328125
patch: if ( ! iter . is CaMeL Empty ( ) ) . ; }
rank: 155
score: 98.66084120008681
patch: ++ iter ; ++ iter ; else }
rank: 155
score: 98.62773786272321
patch: for ( ; ; ) {
rank: 156
score: 99.00483254825367
patch: final double f CaMeL Val = f CaMeL Val . to CaMeL String ( ) ;
rank: 156
score: 98.88216426454741
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair , Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ;
rank: 156
score: 98.81659807477679
patch: return new Point CaMeL Value CaMeL Pair ( iter , x ) ;
rank: 156
score: 98.71317291259766
patch: else { * * * * /
rank: 156
score: 98.65994873046876
patch: ++ iter ; ; if iter = iter ;
rank: 156
score: 98.62742106119792
patch: if ( iter == 0 ) continue ;
rank: 157
score: 99.05950372869319
patch: int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of (
rank: 157
score: 99.00478001644737
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x , f CaMeL Val ) ;
rank: 157
score: 98.88150024414062
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair ) {
rank: 157
score: 98.73626708984375
patch: ++ iter ; ++ * ; iter ;
rank: 157
score: 98.712890625
patch: ++ * * iter ;
rank: 157
score: 98.6272442157452
patch: while ( ! iter . is CaMeL Empty ( ; ) )
rank: 158
score: 99.05782645089286
patch: int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , x ) ;
rank: 158
score: 99.0042724609375
patch: String f CaMeL Val = f CaMeL Val ;
rank: 158
score: 98.88060087316177
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair >
rank: 158
score: 98.81195068359375
patch: ++ iter ; if ( iter != null ;
rank: 158
score: 98.7349609375
patch: else ++ iter ;
rank: 158
score: 98.71198120117188
patch: Iterator iter = iter . iterator ++ ; }
rank: 158
score: 98.65678267045455
patch: ++ iter ; ++ iter ; iter / ++ ;
rank: 158
score: 98.62677001953125
patch: final ++ iter ; ++ iter ;
rank: 159
score: 99.05550130208333
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , n ) ;
rank: 159
score: 99.0178955078125
patch: i = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , f CaMeL Val ) ;
rank: 159
score: 98.878525390625
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair = 0 ;
rank: 159
score: 98.81173095703124
patch: while ( iter < n ) ++ iter ;
rank: 159
score: 98.73421478271484
patch: ++ n ; ++ iter ; ;
rank: 159
score: 98.71189880371094
patch: if ( ! iter != null ;
rank: 159
score: 98.65588989257813
patch: ++ iter ; iter * / ++ iter ;
rank: 160
score: 99.0552978515625
patch: double f CaMeL Val = Univariate CaMeL Point CaMeL Value CaMeL Pair . get CaMeL Value ( ) . clone ( ) ;
rank: 160
score: 99.003466796875
patch: final double f CaMeL Val = f CaMeL Val : f CaMeL Val ;
rank: 160
score: 98.8784891764323
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Point CaMeL Value CaMeL Pair . get CaMeL Value ( ) ) ;
rank: 160
score: 98.81067657470703
patch: ++ iter * / * iter ;
rank: 160
score: 98.73416476779514
patch: ++ iter ; ++ * * * /
rank: 160
score: 98.71182250976562
patch: else { if ; * * /
rank: 160
score: 98.62435477120536
patch: throw new Runtime CaMeL Exception ( $STRING$ + n + $STRING$ ) ;
rank: 161
score: 99.05517578125
patch: final double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , 0 ) ;
rank: 161
score: 99.0170261548913
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( f CaMeL Val . get CaMeL Value ( ) ) ;
rank: 161
score: 99.01315307617188
patch: double [ ] f CaMeL Val = 1 . 0 ;
rank: 161
score: 98.87848663330078
patch: state = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 161
score: 98.8097635904948
patch: ++ iter ; while ( iter < n ) { ;
rank: 161
score: 98.73371124267578
patch: try { ++ iter ; break ;
rank: 161
score: 98.71048736572266
patch: } else { ++ iter ; }
rank: 161
score: 98.6545654296875
patch: ++ max ; ++ iter ; ++ iter ;
rank: 162
score: 99.054072265625
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . 0 ) ;
rank: 162
score: 99.01680210658482
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > * ;
rank: 162
score: 99.01295572916666
patch: int f CaMeL Val = x . search ( f CaMeL Val ) ;
rank: 162
score: 99.001904296875
patch: double f CaMeL Val = Math . iterator ( f CaMeL Val ) ;
rank: 162
score: 98.878349609375
patch: return new Point CaMeL Value CaMeL Pair ( Point CaMeL Value CaMeL Pair . new CaMeL Point CaMeL And CaMeL Direction ( x ,
rank: 162
score: 98.80908203125
patch: ++ iter ; while ( iter ; ) { ;
rank: 162
score: 98.73170471191406
patch: ++ * ] iter ; * /
rank: 162
score: 98.7098388671875
patch: if ++ [ 0 ] ;
rank: 162
score: 98.6227557842548
patch: throw new Unsupported CaMeL Operation CaMeL Exception ( $STRING$ ) ; }
rank: 163
score: 99.0525614420573
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . ) ;
rank: 163
score: 99.01625061035156
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = $NUMBER$ ;
rank: 163
score: 99.012890625
patch: double f CaMeL Val = Math . copy CaMeL Of ( direc [
rank: 163
score: 98.87802734375
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . double CaMeL Value ( f CaMeL Val ) ;
rank: 163
score: 98.80832926432292
patch: if ( iter < iter ) break ;
rank: 163
score: 98.73166910807292
patch: ++ iter ; ++ iter ; ; *
rank: 163
score: 98.70966932508681
patch: i ++ ; } if ++ iter ;
rank: 163
score: 98.65296519886364
patch: ++ iter ; ++ iter ; ; -- iter ;
rank: 163
score: 98.62235804966518
patch: if ( ! iter . is CaMeL Empty ( ) ) { }
rank: 164
score: 99.0524151141827
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( x ) ) ;
rank: 164
score: 99.015966796875
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker . get CaMeL Point ( ) ;
rank: 164
score: 99.01220703125
patch: double [ ] x = Math CaMeL Arrays . copy CaMeL Of (
rank: 164
score: 98.876708984375
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > }
rank: 164
score: 98.8072176846591
patch: int n = Integer . parse CaMeL Int ( ;
rank: 164
score: 98.7310562133789
patch: / * ] ++ ++ iter ;
rank: 164
score: 98.70819498697917
patch: if ( ! iter . is CaMeL Empty ++ ) . ++ iter ;
rank: 165
score: 99.0521240234375
patch: final int f CaMeL Val = 0 ;
rank: 165
score: 99.01566256009616
patch: f CaMeL Val = x . get CaMeL Value ( ) ;
rank: 165
score: 99.01215277777777
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ,
rank: 165
score: 98.87655639648438
patch: entry = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 165
score: 98.80528675426136
patch: ++ iter ; throw new Runtime CaMeL Exception ( ;
rank: 165
score: 98.72987583705357
patch: ++ iter ; return iter ;
rank: 165
score: 98.7071533203125
patch: if ( ! iter . is CaMeL Empty ( && ) ;
rank: 165
score: 98.6513900756836
patch: ++ iter ; iter * ; /
rank: 165
score: 98.61688232421875
patch: return new Point CaMeL Value CaMeL Pair ( n , ;
rank: 166
score: 99.00128532858456
patch: double n = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 166
score: 98.87589888139205
patch: if ( f CaMeL Val < f CaMeL Val )
rank: 166
score: 98.80463201349431
patch: throw new Runtime CaMeL Exception ( $STRING$ + iter ;
rank: 166
score: 98.70697021484375
patch: / * ++ * * / /
rank: 166
score: 98.65072970920139
patch: ++ iter ; ++ ++ iter ; ;
rank: 166
score: 98.61623128255208
patch: buffer . append ( $STRING$ ) . append ( iter ;
rank: 167
score: 99.05157791940789
patch: double f CaMeL Val $NUMBER$ = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ;
rank: 167
score: 99.0147705078125
patch: double [ ] f CaMeL Val = compute CaMeL Objective CaMeL Value ( 0 ) ;
rank: 167
score: 99.01153205422794
patch: int iter = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 167
score: 99.00127096737133
patch: double f CaMeL Val = f CaMeL Val . get CaMeL Point ( 0 ) ;
rank: 167
score: 98.87581176757813
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Point CaMeL Value CaMeL Pair . 0 ) ;
rank: 167
score: 98.80462239583333
patch: ++ iter ; return new Point CaMeL Value CaMeL Pair ( x ) ;
rank: 167
score: 98.7066983309659
patch: Iterator iter = iter . iterator ++ ; while ;
rank: 167
score: 98.650634765625
patch: ++ iter ; ++ this ;
rank: 167
score: 98.61544095552884
patch: if ( ! iter . is CaMeL Empty ( ) ; else
rank: 168
score: 99.05152180989583
patch: ++ iter ; double f CaMeL Val = x . clone ( ) ;
rank: 168
score: 99.0010274251302
patch: double iter = x . get CaMeL Point ( ) ;
rank: 168
score: 98.87531389508929
patch: Iterator < Point CaMeL Value CaMeL Pair protected Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair
rank: 168
score: 98.80419921875
patch: return new Point CaMeL Value CaMeL Pair ( ++ n ) ; }
rank: 168
score: 98.7279764811198
patch: ++ iter ; break ;
rank: 168
score: 98.7061767578125
patch: else { if ( ! iter . is CaMeL Empty ( ) )
rank: 168
score: 98.65060085720486
patch: ++ iter ; ++ iter ; else *
rank: 168
score: 98.61539306640626
patch: ++ iter ; while ( iter != 0 )
rank: 169
score: 99.05048571134868
patch: double f CaMeL Val = Math . copy CaMeL Of ( f CaMeL Val , x ) ;
rank: 169
score: 99.01292201450893
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( n ) ;
rank: 169
score: 98.99991647820724
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = checker . get CaMeL Point CaMeL
rank: 169
score: 98.87509155273438
patch: list = new CaMeL Point CaMeL And CaMeL Direction ( f CaMeL Val ) ;
rank: 169
score: 98.804150390625
patch: throw new Illegal CaMeL Argument CaMeL Exception ( ;
rank: 169
score: 98.72762298583984
patch: ++ 1 ; ++ - 1 ;
rank: 169
score: 98.70523775540866
patch: if ( ! iter . is CaMeL Empty ++ ( ) ;
rank: 169
score: 98.65056610107422
patch: return iter ; ; ++ iter ;
rank: 169
score: 98.61445448133681
patch: it = iter . iterator ( ) ;
rank: 170
score: 99.01248604910714
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > < Point CaMeL Value CaMeL Pair > checker ;
rank: 170
score: 99.00758272058823
patch: double f CaMeL Val = ( Univariate CaMeL Point CaMeL Value CaMeL Pair ) n ;
rank: 170
score: 98.87494187127976
patch: return Point CaMeL Value CaMeL Pair . new CaMeL Point CaMeL And CaMeL Direction ( x , iter ) ;
rank: 170
score: 98.80352783203125
patch: return new Point CaMeL Value CaMeL Pair ( ++ iter ) ; }
rank: 170
score: 98.72651890345982
patch: int iter ; ++ iter ;
rank: 170
score: 98.70484008789063
patch: return iter ; }
rank: 170
score: 98.64962158203124
patch: ++ iter ; ++ 0 ; ++ iter ;
rank: 170
score: 98.61419677734375
patch: try { throw new Illegal CaMeL Argument CaMeL Exception ( ;
rank: 171
score: 99.04993693033855
patch: ++ iter ; f CaMeL Val = f CaMeL Val ;
rank: 171
score: 99.01242963005515
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = f CaMeL Val ;
rank: 171
score: 99.00649007161458
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( x + f CaMeL Val ) ;
rank: 171
score: 98.87478637695312
patch: tmp = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 171
score: 98.80345458984375
patch: long start = Double . MAX _ VALUE ;
rank: 171
score: 98.72412109375
patch: } ++ iter ; while iter ;
rank: 171
score: 98.70371500651042
patch: else { throw new Runtime CaMeL Exception ( $STRING$ ; }
rank: 171
score: 98.64818572998047
patch: ++ new ++ ; ++ start ;
rank: 171
score: 98.61391775948661
patch: buffer . append ( $STRING$ ) . append ( iter ) . ;
rank: 172
score: 99.04984283447266
patch: double double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 172
score: 99.0123760516827
patch: final double iter = f CaMeL Val . clone ( ) ;
rank: 172
score: 99.00613563939145
patch: double f CaMeL Val = f CaMeL Val + compute CaMeL Objective CaMeL Value ( x ) ;
rank: 172
score: 98.99872233072917
patch: final double f CaMeL Val = x . get CaMeL Point ( ) ;
rank: 172
score: 98.874755859375
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair > iter = 0 ;
rank: 172
score: 98.80338287353516
patch: if ( iter >= n ) {
rank: 172
score: 98.72355433872768
patch: i * / ++ iter ;
rank: 172
score: 98.70353480747768
patch: if ( ! iter . is CaMeL Empty ( ; ) . ;
rank: 172
score: 98.64729447798295
patch: ++ iter ; iter if ++ ; ++ iter ;
rank: 172
score: 98.61302354600694
patch: if ( ++ n > 0 ) {
rank: 173
score: 99.04943084716797
patch: delta = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 173
score: 99.0116678873698
patch: double iter = line . get CaMeL Value ( ) ;
rank: 173
score: 98.99763997395833
patch: double f CaMeL Val = Math . max ( f CaMeL Val ) ;
rank: 173
score: 98.87452189127605
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Point CaMeL Value CaMeL Pair . line . clone ( ) ) ;
rank: 173
score: 98.80324881417411
patch: return new Point CaMeL Value CaMeL Pair ( x [ iter ] ;
rank: 173
score: 98.70327758789062
patch: ++ * * * * iter ;
rank: 173
score: 98.64673961292614
patch: ++ iter ; ++ iter ; while ++ iter ;
rank: 173
score: 98.6127197265625
patch: throw new Unsupported CaMeL Operation CaMeL Exception ( ;
rank: 174
score: 99.04921264648438
patch: int f CaMeL Val $NUMBER$ = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 174
score: 99.01164899553571
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair >> checker ;
rank: 174
score: 99.00485026041666
patch: double [ ] x = Math CaMeL Arrays . copy CaMeL Of ( [
rank: 174
score: 98.99716366038604
patch: String f CaMeL Val = Math . copy CaMeL Of ( f CaMeL Val ) ;
rank: 174
score: 98.87371194773706
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair >>
rank: 174
score: 98.72273254394531
patch: ++ iter ; ; iter * /
rank: 174
score: 98.70319959852431
patch: if ( iter == null ; / ;
rank: 174
score: 98.64581976996527
patch: ++ iter ; iter / / / ;
rank: 175
score: 99.04918715533088
patch: int f CaMeL Val = f CaMeL Val ; double f CaMeL Val = 0 ;
rank: 175
score: 99.00379231770833
patch: int f CaMeL Val = compute CaMeL Objective CaMeL Value ( 1 ) ;
rank: 175
score: 98.99673461914062
patch: int f CaMeL Val = f CaMeL Val - n ;
rank: 175
score: 98.87344255118535
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair >
rank: 175
score: 98.80280095880681
patch: while ( iter <= n ) { ++ iter ;
rank: 175
score: 98.72201199001736
patch: ++ 1 ; ++ iter ; iter ;
rank: 175
score: 98.70313371930804
patch: if ( . is CaMeL Empty ( ) ; return iter ; }
rank: 175
score: 98.64581298828125
patch: ++ ; ++ iter ;
rank: 175
score: 98.6094501201923
patch: int n = iter . last CaMeL Index CaMeL Of ( ;
rank: 176
score: 99.04918494591347
patch: double f CaMeL Val = Univariate CaMeL Point CaMeL Value CaMeL Pair . get CaMeL Point ( ) . get CaMeL Point ( ) ;
rank: 176
score: 98.99559529622395
patch: double iter = f CaMeL Val - f CaMeL Val ;
rank: 176
score: 98.87343528053977
patch: return new Point CaMeL Value CaMeL Pair ( x ,
rank: 176
score: 98.80250901442308
patch: return new Point CaMeL Value CaMeL Pair ( x , n ;
rank: 176
score: 98.72193603515625
patch: ++ iter ; try ; if ++ iter ;
rank: 176
score: 98.70288848876953
patch: * * * * / * /
rank: 176
score: 98.64519500732422
patch: ++ < iter ; ++ iter ;
rank: 176
score: 98.60728624131944
patch: if ( iter == 0 ) break ;
rank: 177
score: 98.87319841056035
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair [
rank: 177
score: 98.80047607421875
patch: ++ iter ; while ( ; ; )
rank: 177
score: 98.72138129340277
patch: ++ iter ; ++ 1 ; iter ;
rank: 177
score: 98.70232747395833
patch: if ( ! iter . is CaMeL Empty ( ) ) break ; }
rank: 177
score: 98.6071307842548
patch: ++ iter ; if ( ! iter . is CaMeL Empty ;
rank: 178
score: 99.04778421336206
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , 0 ) ) ;
rank: 178
score: 99.00881476151316
patch: final double [ ] f CaMeL Val = f CaMeL Val . get CaMeL Value ( ) ;
rank: 178
score: 99.00227573939732
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( 0 ;
rank: 178
score: 98.99479406020221
patch: double x = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 178
score: 98.87238018329327
patch: Iterator < Point CaMeL Value CaMeL Pair protected Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair
rank: 178
score: 98.79877319335938
patch: throw new Runtime CaMeL Exception ( $STRING$ + ;
rank: 178
score: 98.7021484375
patch: if ( ! iter . is CaMeL Empty ++ ) ++ iter ;
rank: 178
score: 98.64512329101562
patch: ++ iter ; ++ iter ; -- start ;
rank: 179
score: 99.00853329613095
patch: final Point CaMeL Value CaMeL Pair checker = Math CaMeL Arrays . copy CaMeL Of ( direc ) ;
rank: 179
score: 99.00214700137867
patch: int f CaMeL Val = compute CaMeL Objective CaMeL Value ( double CaMeL Value ) ;
rank: 179
score: 98.87189850983796
patch: Iterator < Point CaMeL Value CaMeL Pair protected Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ;
rank: 179
score: 98.79833221435547
patch: ++ iter ; while ( true ;
rank: 179
score: 98.72096761067708
patch: ++ 1 ; ++ iter ; break ;
rank: 179
score: 98.70162963867188
patch: return iter [ 0 ] ; }
rank: 179
score: 98.64507293701172
patch: ++ iter ; ; iter -- ;
rank: 179
score: 98.60591888427734
patch: ++ iter ; for ; ) {
rank: 180
score: 99.04637858072917
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . new CaMeL Point CaMeL And CaMeL Direction (
rank: 180
score: 99.00789602179276
patch: int f CaMeL Val = compute CaMeL Objective CaMeL Value ( x . clone ( ) ) ;
rank: 180
score: 98.9930419921875
patch: double f CaMeL Val = Math . n ( f CaMeL Val ) ;
rank: 180
score: 98.87141418457031
patch: long f CaMeL Val = compute CaMeL Objective CaMeL Value ( x $NUMBER$ ) ;
rank: 180
score: 98.7974344889323
patch: ++ iter - n ;
rank: 180
score: 98.72081298828125
patch: ++ iter ; ++ value ; ++ iter ;
rank: 180
score: 98.70133463541667
patch: if ( ! iter . is CaMeL Empty ++ ; }
rank: 180
score: 98.60511192908653
patch: Set < String > iter = iter . iterator ( ) ;
rank: 181
score: 99.04609206627156
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . line . f CaMeL Val ) ;
rank: 181
score: 99.0072998046875
patch: Point CaMeL Value CaMeL Pair checker = new Point CaMeL Value CaMeL Pair ( f CaMeL Val ) ;
rank: 181
score: 98.79702419704861
patch: ++ iter ; if ( ++ iter ;
rank: 181
score: 98.72068956163194
patch: ++ iter ; ++ iter ; out ;
rank: 181
score: 98.70117950439453
patch: i ] [ 0 ] ++ ;
rank: 181
score: 98.64320591517857
patch: ++ length ; ++ iter ;
rank: 182
score: 99.00682431175595
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = checker . get CaMeL Value ( ) ;
rank: 182
score: 99.00123814174107
patch: double f CaMeL Val = f CaMeL Val . f CaMeL Val ;
rank: 182
score: 98.87084056712963
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Point CaMeL Value CaMeL Pair . Math CaMeL Arrays . copy CaMeL Of ( x ,
rank: 182
score: 98.79669189453125
patch: ++ iter ; / * ;
rank: 182
score: 98.7204818725586
patch: ++ iter ; ++ < iter ;
rank: 182
score: 98.70097351074219
patch: / * * ++ ; * /
rank: 182
score: 98.64268663194444
patch: ++ iter = iter ; ++ iter ;
rank: 182
score: 98.602294921875
patch: iter = iter . clone ( ) ;
rank: 183
score: 99.04361572265626
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val 1 ) ;
rank: 183
score: 99.00674641927084
patch: / * Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker ;
rank: 183
score: 99.00056726792279
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x , x ) ;
rank: 183
score: 98.99135916573661
patch: double f CaMeL Val = f CaMeL Val <= f CaMeL Val ;
rank: 183
score: 98.8703143780048
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair f CaMeL Val ;
rank: 183
score: 98.79629080636161
patch: return new Point CaMeL Value CaMeL Pair ( x ) . ++ ;
rank: 183
score: 98.699951171875
patch: else { iter * * * /
rank: 183
score: 98.641357421875
patch: ++ iter ; ; ++ n ;
rank: 183
score: 98.60219116210938
patch: if ( iter != null ) ++ iter ;
rank: 184
score: 99.04341125488281
patch: int f CaMeL Val $NUMBER$ = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 184
score: 98.9908676147461
patch: double [ ] f CaMeL Val = x . get CaMeL Point ( ) ;
rank: 184
score: 98.79607282366071
patch: while ( iter < iter )
rank: 184
score: 98.72010498046875
patch: ++ iter ; ++ iter ; int * /
rank: 184
score: 98.69961983816964
patch: else { ++ n ; }
rank: 184
score: 98.6412582397461
patch: ++ iter ; ++ n ; }
rank: 184
score: 98.60101318359375
patch: if ( ! ++ n ) {
rank: 185
score: 99.0432765794837
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( get CaMeL Goal CaMeL Type ( ) ) ;
rank: 185
score: 99.00553131103516
patch: final double [ ] x 1 ;
rank: 185
score: 98.9997802734375
patch: int f CaMeL Val = compute CaMeL Objective CaMeL Value ( n ) ;
rank: 185
score: 98.86946323939732
patch: return compute CaMeL Objective CaMeL Value ( x $NUMBER$ , x ) ;
rank: 185
score: 98.7960713704427
patch: Iterator < Point CaMeL Value CaMeL Pair > iter = ;
rank: 185
score: 98.71997680664063
patch: ++ iter ; ++ iter ; int iter ;
rank: 185
score: 98.69948167067308
patch: synchronized ( . is CaMeL Empty ( ) ; return iter ;
rank: 185
score: 98.6404141512784
patch: ++ new ++ ; ++ iter ; ++ iter ;
rank: 186
score: 99.00468893612133
patch: final double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x 1 ) ;
rank: 186
score: 98.99900716145834
patch: final double f CaMeL Val = f CaMeL Val + 0 . 0 ;
rank: 186
score: 98.86932663690476
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair < Univariate CaMeL Point CaMeL Value CaMeL Pair > ++ ;
rank: 186
score: 98.79466663707386
patch: throw new Illegal CaMeL Argument CaMeL Exception ( ; }
rank: 186
score: 98.71967315673828
patch: ++ iter ; iter iter * /
rank: 186
score: 98.69883728027344
patch: / * * ++ iter * /
rank: 186
score: 98.6396484375
patch: ++ iter ; iter if iter = iter ;
rank: 186
score: 98.59917340959821
patch: while ( ! iter . is CaMeL Empty ( ) ; ) {
rank: 187
score: 99.04304108796296
patch: double f CaMeL Val = Math . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . get CaMeL Value ( ) ) ;
rank: 187
score: 99.00406494140626
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker . double . clone ( ) ;
rank: 187
score: 98.86802842881944
patch: Iterator < Point CaMeL Value CaMeL Pair protected Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair )
rank: 187
score: 98.79440307617188
patch: ++ iter ; / * ; ;
rank: 187
score: 98.71893920898438
patch: / * ] ++ iter ; ++ iter ;
rank: 187
score: 98.69874156605114
patch: if ( ! iter . contains ( iter ) ;
rank: 187
score: 98.63856336805556
patch: ++ iter ; ; ++ iter ; else
rank: 187
score: 98.59849039713542
patch: if ( iter < n ) continue ;
rank: 188
score: 99.04278564453125
patch: double f CaMeL Val $NUMBER$ = Math . copy CaMeL Of ( f CaMeL Val ) ;
rank: 188
score: 98.86780894886364
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Point CaMeL Value CaMeL Pair . f CaMeL Val ) ;
rank: 188
score: 98.79246937144886
patch: while ( iter >= n ) { ++ iter ;
rank: 188
score: 98.71792941623264
patch: else * ++ iter ; ++ iter ;
rank: 188
score: 98.69845241970486
patch: Set iter = iter . iterator ++ ;
rank: 188
score: 98.63797760009766
patch: ++ iter ; ++ n ; ;
rank: 188
score: 98.59641810825893
patch: sb . append ( $STRING$ ) . append ( ++ iter ) ;
rank: 189
score: 98.9892069498698
patch: double f CaMeL Val = x . iterator ( ) ;
rank: 189
score: 98.86764210668103
patch: Iterator < Point CaMeL Value CaMeL Pair protected Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair )
rank: 189
score: 98.79176839192708
patch: return new Point CaMeL Value CaMeL Pair ( this , ;
rank: 189
score: 98.71741485595703
patch: ++ * ++ iter ; iter ;
rank: 189
score: 98.69734497070313
patch: if ( iter == null ; return false ;
rank: 189
score: 98.63788396661931
patch: ++ iter ; ++ iter ; / -- iter ;
rank: 189
score: 98.59608811598558
patch: throw new Unsupported CaMeL Operation CaMeL Exception ( $STRING$ + n ;
rank: 190
score: 99.0418359375
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) . get CaMeL Value ( ) ;
rank: 190
score: 99.00187413832721
patch: String f CaMeL Val = compute CaMeL Objective CaMeL Value ( f CaMeL Val ) ;
rank: 190
score: 98.99762573242188
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( x , f CaMeL Val ) ;
rank: 190
score: 98.98855411305146
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( float CaMeL Value ) ;
rank: 190
score: 98.86745198567708
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Point CaMeL Value CaMeL Pair . x , f CaMeL Val ) ;
rank: 190
score: 98.79169108072917
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + n ) ; }
rank: 190
score: 98.71694946289062
patch: ++ iter ; start - iter ;
rank: 190
score: 98.69715118408203
patch: if ( < 0 ; * /
rank: 191
score: 99.0417010967548
patch: ++ n ; double f CaMeL Val = f CaMeL Val ;
rank: 191
score: 99.001513671875
patch: double iter = x . clone ( ) ;
rank: 191
score: 98.99758475167411
patch: double f CaMeL Val = f CaMeL Val * 0 . 0 ;
rank: 191
score: 98.98843383789062
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ) ; final
rank: 191
score: 98.86742054332386
patch: if ( f CaMeL Val < 0 . 0 )
rank: 191
score: 98.79153645833334
patch: ++ iter ; throw new Illegal CaMeL Argument CaMeL Exception ( ) ; }
rank: 191
score: 98.71646881103516
patch: ++ iter ; try + iter ;
rank: 191
score: 98.69697709517045
patch: if ( iter == null ) return null ; }
rank: 191
score: 98.63594360351563
patch: ++ iter ; ++ iter ; ++ break ;
rank: 192
score: 99.0408245584239
patch: int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) . clone ( ) ;
rank: 192
score: 99.00037493024554
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( clone ) ;
rank: 192
score: 98.99734497070312
patch: double [ ] f CaMeL Val = 0 . 0 ;
rank: 192
score: 98.86726888020833
patch: return new Point CaMeL Value CaMeL Pair ( Point CaMeL Value CaMeL Pair . line . get CaMeL Value ( ) ) ;
rank: 192
score: 98.71536593967014
patch: ++ iter ; ++ iter ; try ;
rank: 192
score: 98.69677734375
patch: if ( ! iter == null ;
rank: 192
score: 98.63562883649554
patch: ++ iter ; ++ false ;
rank: 193
score: 99.00018601190476
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = line . get CaMeL Point ( ) ;
rank: 193
score: 98.99666922433036
patch: delta = compute CaMeL Objective CaMeL Value ( f CaMeL Val ) ;
rank: 193
score: 98.98816636029412
patch: int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( direc ;
rank: 193
score: 98.86712036132812
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Point CaMeL Value CaMeL Pair . 1 ) ;
rank: 193
score: 98.79103781960227
patch: if ( iter > 0 ) { ++ iter ;
rank: 193
score: 98.71506754557292
patch: ++ iter ; try { int iter ;
rank: 193
score: 98.69622802734375
patch: if ( iter ; ++ iter ;
rank: 193
score: 98.63546752929688
patch: ++ ++ n ; ++ iter ;
rank: 193
score: 98.59382768110795
patch: sb . append ( $STRING$ ) . append ( ;
rank: 194
score: 99.04019165039062
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > < Point CaMeL Value CaMeL Pair > ) {
rank: 194
score: 98.99625436883224
patch: double f CaMeL Val = ( Univariate CaMeL Point CaMeL Value CaMeL Pair ) 0 . 0 ;
rank: 194
score: 98.8670654296875
patch: result = Math CaMeL Arrays . copy CaMeL Of ( checker . get CaMeL Goal CaMeL Type ( ) ) ;
rank: 194
score: 98.7907958984375
patch: ++ iter ; return new Point CaMeL Value CaMeL Pair ( x , ;
rank: 194
score: 98.71498107910156
patch: ++ iter ; ++ 1 ; }
rank: 194
score: 98.69611065204327
patch: if ( ! iter . is CaMeL Empty ( ; return ;
rank: 194
score: 98.59284973144531
patch: if ( ++ n > 0 ;
rank: 195
score: 99.0394287109375
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , x ) ;
rank: 195
score: 98.98676215277777
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( x 1 ) ;
rank: 195
score: 98.8665412454044
patch: Iterator < Point CaMeL Value CaMeL Pair < Univariate CaMeL Point CaMeL Value CaMeL Pair >
rank: 195
score: 98.79021344866071
patch: ++ iter ; return new Point CaMeL Value CaMeL Pair ( x ;
rank: 195
score: 98.71404266357422
patch: ++ iter ; int iter * /
rank: 195
score: 98.69435119628906
patch: * * * * ; * /
rank: 195
score: 98.6341552734375
patch: ++ 0 ; ++ iter ; else
rank: 195
score: 98.59163208007813
patch: synchronized ( this ) { ++ iter ; }
rank: 196
score: 99.03749150815217
patch: double f CaMeL Val = Math . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . x ) ;
rank: 196
score: 98.9997802734375
patch: final double [ ] x 1 = 0 ;
rank: 196
score: 98.99519856770833
patch: int f CaMeL Val = compute CaMeL Objective CaMeL Value ( iter ) ;
rank: 196
score: 98.78982543945312
patch: ++ iter ; / ++ iter ;
rank: 196
score: 98.7139892578125
patch: i * ++ ; iter * * /
rank: 196
score: 98.69424438476562
patch: Set iter = iter . length ;
rank: 196
score: 98.63401794433594
patch: ++ $NUMBER$ ; ; ++ iter ;
rank: 196
score: 98.59149169921875
patch: iter = iter . iterator ( ) ; }
rank: 197
score: 99.03727583451705
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( direc . clone ( ) ) ;
rank: 197
score: 98.99952043805804
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( 1 ) ;
rank: 197
score: 98.99509974888393
patch: double f CaMeL Val = f CaMeL Val : 0 . 0 ;
rank: 197
score: 98.69404432508681
patch: ++ * * * * / iter ;
rank: 197
score: 98.63373357599431
patch: ++ ++ iter ; ++ iter ; ++ iter ;
rank: 197
score: 98.59010823567708
patch: while ( false ) {
rank: 198
score: 99.03658718532986
patch: ++ true ; double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 198
score: 98.9994140625
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker . do CaMeL Optimize ( ) ;
rank: 198
score: 98.98619887408088
patch: final double f CaMeL Val = f CaMeL Val . get CaMeL Point ( ) ;
rank: 198
score: 98.86555989583333
patch: if ( f CaMeL Val > 0 . 0 ) {
rank: 198
score: 98.6331787109375
patch: return iter ; ++ iter ;
rank: 198
score: 98.58902316623264
patch: while ( true ) { ++ n ;
rank: 199
score: 99.0363833778783
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( double CaMeL Value ) ;
rank: 199
score: 98.99831973805146
patch: final double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x $NUMBER$ ) ;
rank: 199
score: 98.994921875
patch: int [ ] x = f CaMeL Val ;
rank: 199
score: 98.865478515625
patch: return new CaMeL Point CaMeL And CaMeL Direction ( f CaMeL Val ;
rank: 199
score: 98.78939819335938
patch: for ( ; ; ; ) {
rank: 199
score: 98.71271514892578
patch: ++ iter ; ++ iter ; start
rank: 199
score: 98.69314575195312
patch: } if ++ $NUMBER$ * iter ;
rank: 199
score: 98.63288879394531
patch: } ++ iter ; ++ start ;
rank: 199
score: 98.58733367919922
patch: int iter = iter - iter ;
rank: 200
score: 99.03569030761719
patch: x = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 200
score: 98.99824523925781
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = 0 ;
rank: 200
score: 98.99474334716797
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( guess ;
rank: 200
score: 98.98367130055146
patch: int f CaMeL Val = f CaMeL Val . index CaMeL Of ( 1 ) ;
rank: 200
score: 98.86508178710938
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Point CaMeL Value CaMeL Pair . x ) ;
rank: 200
score: 98.78891427176339
patch: ++ iter ; * * /
rank: 200
score: 98.71223958333333
patch: ++ iter ; iter * * / /
rank: 200
score: 98.6923828125
patch: / * * * * ; /
rank: 200
score: 98.6322250366211
patch: ++ n ; ++ iter ; else
rank: 200
score: 98.58669809194711
patch: sb . append ( $STRING$ ) . append ( n ) ;
rank: 201
score: 99.03468919836956
patch: double f CaMeL Val = Math . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . 1 ) ;
rank: 201
score: 98.99823961759868
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair extends Point CaMeL Value CaMeL Pair > checker ;
rank: 201
score: 98.9943359375
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( direc [ 0 ] ) ;
rank: 201
score: 98.98348659939236
patch: double x 1 = f CaMeL Val ;
rank: 201
score: 98.86458587646484
patch: value = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 201
score: 98.78736223493304
patch: return new Point CaMeL Value CaMeL Pair ( ++ iter , ; }
rank: 201
score: 98.71148681640625
patch: ++ * ++ iter ; break ;
rank: 201
score: 98.69186636117789
patch: if ( ! iter . is CaMeL Empty ( ) ) ;
rank: 201
score: 98.63113064236111
patch: ++ iter + iter ; ++ iter ;
rank: 201
score: 98.58538208007812
patch: ++ iter ; while ( iter . ; )
rank: 202
score: 98.99759114583334
patch: x f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 202
score: 98.98321533203125
patch: double f CaMeL Val = ( f CaMeL Val - f CaMeL Val ) ;
rank: 202
score: 98.86397611177884
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > ++ iter ;
rank: 202
score: 98.78582763671875
patch: int iter = Double . MAX _ VALUE ;
rank: 202
score: 98.71144409179688
patch: try { ++ iter ; } ++ iter ;
rank: 202
score: 98.69112141927083
patch: * * * * / ++ iter ;
rank: 202
score: 98.63083224826389
patch: ++ iter ; iter / / * /
rank: 202
score: 98.58531775841347
patch: int n = iter . index CaMeL Of ( x ) ;
rank: 203
score: 99.03292083740234
patch: double f CaMeL Val = f CaMeL Val - x . clone ( ) ;
rank: 203
score: 98.99725341796875
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = $STRING$ ;
rank: 203
score: 98.9941177368164
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ) ; {
rank: 203
score: 98.98272298177083
patch: double f CaMeL Val = Math . min ( f CaMeL Val ) ;
rank: 203
score: 98.86391194661458
patch: res = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 203
score: 98.78579915364584
patch: ++ iter ; return new Point CaMeL Value CaMeL Pair ( ++ iter ;
rank: 203
score: 98.69094412667411
patch: if ( ! iter . is CaMeL Empty ( ) ; / ;
rank: 203
score: 98.58469801682692
patch: throw new Runtime CaMeL Exception ( $STRING$ + n + $STRING$ ;
rank: 204
score: 99.03275390625
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math . copy CaMeL Of ( f CaMeL Val ) ) ;
rank: 204
score: 98.99724872295673
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair $NUMBER$ ;
rank: 204
score: 98.9824969951923
patch: double iter = Math . abs ( f CaMeL Val ) ;
rank: 204
score: 98.86361799568965
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . double CaMeL Value = 0 ;
rank: 204
score: 98.78522135416667
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + iter ) ; }
rank: 204
score: 98.7105941772461
patch: ++ ++ iter ; ++ 1 ;
rank: 204
score: 98.69085138494319
patch: if ( ! iter . equals ( iter ) ;
rank: 204
score: 98.58468627929688
patch: int n = iter - n ;
rank: 205
score: 99.03268299932066
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( ;
rank: 205
score: 98.99722055288461
patch: double CaMeL Value = f CaMeL Val . clone ( ) ;
rank: 205
score: 98.98118760850694
patch: double f CaMeL Val = f CaMeL Val ; f CaMeL Val = f CaMeL Val ;
rank: 205
score: 98.86304649939903
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ( x ) ;
rank: 205
score: 98.78447265625
patch: ++ iter ; throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ; }
rank: 205
score: 98.68989562988281
patch: / * * ++ * / /
rank: 205
score: 98.62886186079545
patch: ++ iter ; ++ iter ; } -- iter ;
rank: 205
score: 98.58435997596153
patch: if ( iter != null && iter . length > 0 )
rank: 206
score: 99.03204752604167
patch: double f CaMeL Val = Math . abs ( 0 . 0 ) ;
rank: 206
score: 98.99674718520221
patch: Iterator < Point CaMeL Value CaMeL Pair > f CaMeL Val = f CaMeL Val ;
rank: 206
score: 98.99330647786458
patch: int f CaMeL Val = f CaMeL Val + 0 ;
rank: 206
score: 98.98031180245536
patch: double [ ] x = line . get CaMeL Value ( ) ;
rank: 206
score: 98.86143493652344
patch: o = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 206
score: 98.78441365559895
patch: return new Point CaMeL Value CaMeL Pair ( x ; }
rank: 206
score: 98.7101058959961
patch: ++ iter ; iter ; / ;
rank: 206
score: 98.68958458533653
patch: if ( ! iter . is CaMeL Empty ++ ) continue ;
rank: 206
score: 98.62850341796874
patch: ++ $STRING$ ; ++ iter ; ++ iter ;
rank: 206
score: 98.58432006835938
patch: ++ iter ; if ( iter == null )
rank: 207
score: 99.0320245150862
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair .
rank: 207
score: 98.99668375651042
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( Math CaMeL Arrays . copy CaMeL Of ( direc ) ) ;
rank: 207
score: 98.99304809570313
patch: delta = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , f CaMeL Val ) ;
rank: 207
score: 98.9795633951823
patch: final final double f CaMeL Val = f CaMeL Val ;
rank: 207
score: 98.70952606201172
patch: ++ $NUMBER$ ; ++ iter ; ;
rank: 207
score: 98.68928358289931
patch: if ( iter != null ; break ;
rank: 207
score: 98.62847137451172
patch: ++ 1 ; ++ iter ; else
rank: 207
score: 98.58417619977679
patch: int iter = ++ iter ;
rank: 208
score: 99.03184291294643
patch: double f CaMeL Val = Univariate CaMeL Point CaMeL Value CaMeL Pair . get CaMeL Value ( 0 ) ;
rank: 208
score: 98.99638227982955
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker . get CaMeL Goal CaMeL Type ( ) ;
rank: 208
score: 98.86044311523438
patch: result = Math CaMeL Arrays . copy CaMeL Of ( x , iter ) ;
rank: 208
score: 98.78364780970982
patch: return new Point CaMeL Value CaMeL Pair ( ++ n , ; }
rank: 208
score: 98.70933837890625
patch: ++ iter ; ++ iter ; ++ * /
rank: 208
score: 98.6886494954427
patch: if ( ! iter . is CaMeL Empty ; break ;
rank: 208
score: 98.62841796875
patch: ++ iter ; ++ iter ; -- iter ; }
rank: 208
score: 98.58414400540866
patch: if ( ! iter . is CaMeL Empty ( ; ) ;
rank: 209
score: 99.03180252878289
patch: int f CaMeL Val = Math . copy CaMeL Of ( f CaMeL Val , 0 ) ;
rank: 209
score: 98.99580652573529
patch: f CaMeL Val = f CaMeL Val - f CaMeL Val - f CaMeL Val ;
rank: 209
score: 98.86037973257211
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair < Univariate CaMeL Point CaMeL Value CaMeL Pair > }
rank: 209
score: 98.78328080610795
patch: ++ iter ; if ( iter >= n ) {
rank: 209
score: 98.70891571044922
patch: / * ] iter iter * /
rank: 209
score: 98.68803405761719
patch: / * ++ * * * /
rank: 209
score: 98.62840687144886
patch: ++ iter ; ++ iter ; return iter ; }
rank: 209
score: 98.58387974330357
patch: int n = iter . last CaMeL Index CaMeL Of ( ) ;
rank: 210
score: 99.03170572916666
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( (
rank: 210
score: 98.86017315204327
patch: Iterator <= Point CaMeL Value CaMeL Pair > iter = 0 ;
rank: 210
score: 98.78267415364583
patch: ++ iter ; if ( iter == 0 ) break ;
rank: 210
score: 98.708837890625
patch: ++ iter ; iter ; if ++ iter ;
rank: 210
score: 98.6880111694336
patch: / * ++ iter * * /
rank: 210
score: 98.6265869140625
patch: ++ iter ; ++ iter ; / *
rank: 210
score: 98.58262282151442
patch: while ( ! iter . is CaMeL Empty ( ) ; )
rank: 211
score: 99.03114897629311
patch: double f CaMeL Val = Math . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . line . get CaMeL Value ( ) ) ;
rank: 211
score: 98.99490176930146
patch: ( ( Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > ) checker ) .
rank: 211
score: 98.99153406479779
patch: double [ ] x = Math CaMeL Arrays . copy CaMeL Of ( iter ) ;
rank: 211
score: 98.86011505126953
patch: Object f CaMeL Val = compute CaMeL Objective CaMeL Value ( x $NUMBER$ ) ;
rank: 211
score: 98.78203667534723
patch: throw new Runtime CaMeL Exception ( ; }
rank: 211
score: 98.70829772949219
patch: ++ value ; ++ - iter ;
rank: 211
score: 98.68700408935547
patch: / * * * / } /
rank: 211
score: 98.62515869140626
patch: ++ iter ; ++ iter ; iter * /
rank: 212
score: 98.99478004092262
patch: int f CaMeL Val = compute CaMeL Objective CaMeL Value ( x . get CaMeL Value ( ) ) ;
rank: 212
score: 98.99150933159723
patch: ( ( Point CaMeL Value CaMeL Pair ) checker ) . get CaMeL Value ( ) ;
rank: 212
score: 98.97589111328125
patch: int f CaMeL Val += f CaMeL Val ;
rank: 212
score: 98.86001481681035
patch: Iterator < Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > iter = 0 ;
rank: 212
score: 98.68613503196023
patch: } if ( iter == null ; return iter ;
rank: 212
score: 98.624365234375
patch: ++ iter ; ++ iter ; / * /
rank: 212
score: 98.5814960186298
patch: ++ n ; return new Point CaMeL Value CaMeL Pair ( ;
rank: 213
score: 99.02961730957031
patch: alpha = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 213
score: 98.99376627604167
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( int ) ;
rank: 213
score: 98.97475179036458
patch: double f CaMeL Val = this . f CaMeL Val ;
rank: 213
score: 98.85996907552084
patch: Iterator < Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair >
rank: 213
score: 98.70722198486328
patch: i * ++ ; iter * /
rank: 213
score: 98.68597412109375
patch: } if ; ++ iter ;
rank: 213
score: 98.62359619140625
patch: ++ iter ; iter } ++ ;
rank: 213
score: 98.58092389787946
patch: if ( ! iter . is CaMeL Empty ( ) ++ iter )
rank: 214
score: 99.02838134765625
patch: double f CaMeL Val $NUMBER$ = f CaMeL Val $NUMBER$ ;
rank: 214
score: 98.99311828613281
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ] ) ;
rank: 214
score: 98.99122450086806
patch: final double f CaMeL Val = f CaMeL Val . search ( f CaMeL Val ) ;
rank: 214
score: 98.97459501378677
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x , n ) ;
rank: 214
score: 98.85922580295139
patch: ret = new CaMeL Point CaMeL And CaMeL Direction ( x , f CaMeL Val ) ;
rank: 214
score: 98.7808837890625
patch: ++ iter ; throw new Illegal CaMeL Argument CaMeL Exception ( ; }
rank: 214
score: 98.70709991455078
patch: * ++ iter ; ++ iter ;
rank: 214
score: 98.68587820870536
patch: if ( ! iter . is CaMeL Empty ( ) ; * ;
rank: 214
score: 98.62352837456598
patch: ++ iter ; iter / * / /
rank: 215
score: 99.02828776041666
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) , 0 ) ;
rank: 215
score: 98.99282004616477
patch: d = line . get CaMeL Value ( ) ;
rank: 215
score: 98.97422688802084
patch: double f CaMeL Val = compute CaMeL Value ( f CaMeL Val ) ;
rank: 215
score: 98.85898844401042
patch: return new Point CaMeL Value CaMeL Pair ( x 1 ,
rank: 215
score: 98.78067016601562
patch: ++ iter ; while ( ! ;
rank: 215
score: 98.68563079833984
patch: ++ * * * * / }
rank: 215
score: 98.62344360351562
patch: ++ iter ++ ; ++ iter ;
rank: 215
score: 98.58029174804688
patch: try { throw new Illegal CaMeL State CaMeL Exception ( ;
rank: 216
score: 99.02782185872395
patch: double f CaMeL Val = search . clone ( ) ;
rank: 216
score: 98.99279203869048
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = new Convergence CaMeL Checker ( ) ;
rank: 216
score: 98.99016256893383
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( 0 . 1 ) ;
rank: 216
score: 98.9740498860677
patch: double f CaMeL Val [ ] = f CaMeL Val ;
rank: 216
score: 98.8587979403409
patch: return new Point CaMeL Value CaMeL Pair ( Point CaMeL Value CaMeL Pair . line . f CaMeL Val ) ;
rank: 216
score: 98.78045099431819
patch: return new Point CaMeL Value CaMeL Pair ( x ;
rank: 216
score: 98.70435926649306
patch: try { ++ iter ; while iter ;
rank: 216
score: 98.62195587158203
patch: ++ iter ; iter / -- ;
rank: 216
score: 98.57843889508929
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ++ n ) ;
rank: 217
score: 99.0275242017663
patch: int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val . clone ( ) ) ;
rank: 217
score: 98.99004255022321
patch: double f CaMeL Val = f CaMeL Val + 1 . 0 ;
rank: 217
score: 98.85875786675348
patch: return new Point CaMeL Value CaMeL Pair ( f CaMeL Val , f CaMeL Val ) ;
rank: 217
score: 98.70331682477679
patch: try { ++ iter ; }
rank: 217
score: 98.68502103365384
patch: if ( ! iter . is CaMeL Empty ( ; break ;
rank: 217
score: 98.62163628472223
patch: ++ iter ; ++ iter ; * ;
rank: 217
score: 98.57746887207031
patch: ++ iter ? iter : iter ;
rank: 218
score: 99.02742513020833
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > < Point CaMeL Value CaMeL Pair > ) {
rank: 218
score: 98.98972681949013
patch: int f CaMeL Val = compute CaMeL Objective CaMeL Value ( f CaMeL Val , 0 ) ;
rank: 218
score: 98.85875244140625
patch: result = Math CaMeL Arrays . copy CaMeL Of ( checker . get CaMeL Value ( ) ) ;
rank: 218
score: 98.7794189453125
patch: return new Point CaMeL Value CaMeL Pair ( x , n ) ;
rank: 218
score: 98.70330810546875
patch: i * * ; ++ iter ;
rank: 218
score: 98.68486870659723
patch: / * * * ; ++ iter ;
rank: 218
score: 98.62134552001953
patch: ++ iter ; iter * ++ ;
rank: 219
score: 98.99245383522727
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair extends Point CaMeL Value CaMeL Pair > checker = null ;
rank: 219
score: 98.98961684283088
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( 0 ) ;
rank: 219
score: 98.858642578125
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair > n = 0 ;
rank: 219
score: 98.77904052734375
patch: ++ iter ; if ( iter > 0 )
rank: 219
score: 98.70323944091797
patch: ++ iter ; ++ for iter ;
rank: 219
score: 98.68435668945312
patch: if ( ! iter . is CaMeL Empty ++ iter )
rank: 219
score: 98.61943708147321
patch: ++ x ; ++ iter ;
rank: 219
score: 98.57593536376953
patch: sb . append ( $STRING$ ) ;
rank: 220
score: 98.9923095703125
patch: final double iter = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 220
score: 98.98956909179688
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , x ;
rank: 220
score: 98.85814368206522
patch: Iterator < Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > iter = 0 ;
rank: 220
score: 98.77873992919922
patch: ++ iter * / * / ;
rank: 220
score: 98.70296478271484
patch: ++ iter ; ; * * /
rank: 220
score: 98.68404447115384
patch: if ( . is CaMeL Empty ( ) ) return iter ;
rank: 220
score: 98.61925506591797
patch: ++ iter ; ; ++ max ;
rank: 220
score: 98.57537841796875
patch: j = iter . iter ( ) ;
rank: 221
score: 99.02623291015625
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( direc [ ] ) ;
rank: 221
score: 98.99181189903847
patch: double [ ] x 1 = line . clone ( ) ;
rank: 221
score: 98.98951551649306
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x . search ( x ;
rank: 221
score: 98.9715576171875
patch: final double f CaMeL Val = Math CaMeL Arrays . abs ( f CaMeL Val ) ;
rank: 221
score: 98.85770670572917
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Point CaMeL Value CaMeL Pair . line . f CaMeL Val ) ;
rank: 221
score: 98.70283726283482
patch: ++ * ] iter ++ ;
rank: 221
score: 98.68396868024554
patch: if ( ! iter . is CaMeL Empty ; this . iter ;
rank: 221
score: 98.61821831597223
patch: iter ; ++ iter ; -- iter ;
rank: 221
score: 98.57448167067308
patch: int n = Math . min ( n , n ) ;
rank: 222
score: 98.99046741832386
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair extends Univariate CaMeL Point CaMeL Value CaMeL Pair > checker ;
rank: 222
score: 98.9892578125
patch: double [ ] x 1 = 1 . 0 ;
rank: 222
score: 98.85761461759868
patch: Integer f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 222
score: 98.77785818917411
patch: return new Point CaMeL Value CaMeL Pair ( ++ iter , iter ;
rank: 222
score: 98.70259094238281
patch: / * ++ ; ++ iter ;
rank: 222
score: 98.6839090983073
patch: if ( ! iter . is CaMeL Empty ++ $NUMBER$ ;
rank: 222
score: 98.61756591796875
patch: ++ iter ; iter -- ; ++ iter ;
rank: 222
score: 98.57419259207589
patch: buffer . append ( $STRING$ ) . append ( ++ n ) ;
rank: 223
score: 99.02574666341145
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( compute CaMeL Objective CaMeL Value ( x ) ) ;
rank: 223
score: 98.99045034555289
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker
rank: 223
score: 98.8574930826823
patch: state = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 223
score: 98.701904296875
patch: ++ value ; ++ iter ; ++ iter ;
rank: 223
score: 98.68377685546875
patch: / * * * ++ iter ;
rank: 223
score: 98.615625
patch: ++ iter ; ++ $STRING$ ; ++ iter ;
rank: 223
score: 98.57374924879808
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + ; }
rank: 224
score: 99.02555338541667
patch: if ( true ) {
rank: 224
score: 98.85693359375
patch: Iterator < Point CaMeL Value CaMeL Pair < Univariate CaMeL Point CaMeL Value CaMeL Pair > iter = 0 ;
rank: 224
score: 98.77515665690105
patch: if ( iter < n ) { ++ iter ; }
rank: 224
score: 98.70140075683594
patch: ++ - 0 ; ++ iter ;
rank: 224
score: 98.6837158203125
patch: ++ * * * / iter ;
rank: 224
score: 98.61528015136719
patch: ++ iter ; ; / / /
rank: 224
score: 98.57356262207031
patch: if ( ! ++ iter ) {
rank: 225
score: 99.02547607421874
patch: if ( f CaMeL Val > n ) {
rank: 225
score: 98.98977322048611
patch: f CaMeL Val = f CaMeL Val . search ( x , f CaMeL Val ) ;
rank: 225
score: 98.98864028033088
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( guess ) ;
rank: 225
score: 98.96939086914062
patch: double n = f CaMeL Val ;
rank: 225
score: 98.85685929008152
patch: return new Point CaMeL Value CaMeL Pair ( Point CaMeL Value CaMeL Pair . Math CaMeL Arrays . copy CaMeL Of (
rank: 225
score: 98.77501502403847
patch: ++ iter ; if ( iter < n ) ++ iter ;
rank: 225
score: 98.70128038194444
patch: ++ iter ; ++ x - iter ;
rank: 225
score: 98.68368094308036
patch: if ( . is CaMeL Empty ( ) ) return iter ; }
rank: 225
score: 98.57344360351563
patch: ++ iter ; while ( iter == 0 )
rank: 226
score: 99.02541185461956
patch: final double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of (
rank: 226
score: 98.98974609375
patch: int f CaMeL Val = guess . clone ( ) ;
rank: 226
score: 98.988525390625
patch: double iter = Math . copy CaMeL Of ( f CaMeL Val ) ;
rank: 226
score: 98.96934407552084
patch: final double f CaMeL Val = f CaMeL Val . iterator ( ) ;
rank: 226
score: 98.85676012541118
patch: return ( Point CaMeL Value CaMeL Pair ) checker . get CaMeL Start CaMeL Value ( ) ;
rank: 226
score: 98.77273123604911
patch: return new Point CaMeL Value CaMeL Pair ( x , n , ;
rank: 226
score: 98.70121934678819
patch: ++ iter ; ++ iter ; iter *
rank: 226
score: 98.6832784016927
patch: while ( ! iter . is CaMeL Empty ++ ) {
rank: 226
score: 98.57332763671874
patch: Iterator iter = iter . iter ( ) ;
rank: 227
score: 98.85658330502717
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair {
rank: 227
score: 98.77239312065973
patch: ++ iter ; for ( ; ; )
rank: 227
score: 98.69998931884766
patch: ++ iter ; ++ * 1 ;
rank: 227
score: 98.68291558159723
patch: ++ * iter ; } ++ iter ;
rank: 228
score: 99.02475080818965
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) , x ) ;
rank: 228
score: 98.98814481847427
patch: double f CaMeL Val = ( Univariate CaMeL Point CaMeL Value CaMeL Pair ) 0 ;
rank: 228
score: 98.96772003173828
patch: double f CaMeL Val = f CaMeL Val ; f CaMeL Val = 0 ;
rank: 228
score: 98.85650344122024
patch: return Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) . get CaMeL Point ( ) ;
rank: 228
score: 98.77200317382812
patch: ++ iter ; / * * iter * /
rank: 228
score: 98.69906955295139
patch: ++ iter ; iter * * * /
rank: 228
score: 98.68254852294922
patch: / * * / * / /
rank: 228
score: 98.61116790771484
patch: ++ start ; ++ iter ; }
rank: 228
score: 98.5732421875
patch: if ( f CaMeL Val == null ) break ;
rank: 229
score: 99.02449340820313
patch: double f CaMeL Val = Math . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of (
rank: 229
score: 98.98764038085938
patch: double f CaMeL Val = new double [ n ] ;
rank: 229
score: 98.96737467447916
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( null ) ;
rank: 229
score: 98.6988296508789
patch: iter * ++ ; ++ iter ;
rank: 229
score: 98.682373046875
patch: else { for ; * * /
rank: 229
score: 98.60974884033203
patch: if ++ 1 ; ++ iter ;
rank: 230
score: 99.02416120256696
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ) ; }
rank: 230
score: 98.98839393028847
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker =
rank: 230
score: 98.85630289713542
patch: if ( f CaMeL Val == f CaMeL Val ) {
rank: 230
score: 98.77036539713542
patch: ++ iter ; while ( ! ; )
rank: 230
score: 98.69879828559027
patch: ++ iter ; ++ 1 + iter ;
rank: 230
score: 98.68178304036458
patch: if ( iter != null ; * /
rank: 230
score: 98.57269287109375
patch: throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + ;
rank: 231
score: 98.987724609375
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = . new CaMeL Point CaMeL And CaMeL Direction ( ) ;
rank: 231
score: 98.96689324629934
patch: int f CaMeL Val = f CaMeL Val - compute CaMeL Objective CaMeL Value ( x ) ;
rank: 231
score: 98.85587565104167
patch: return new Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ( x 1 , x ) ;
rank: 231
score: 98.76988874162946
patch: return new Point CaMeL Value CaMeL Pair ( x [ 0 ] ;
rank: 231
score: 98.6962890625
patch: / * ] iter ; ++ * /
rank: 231
score: 98.68168131510417
patch: if ( iter != null && iter . is CaMeL Empty ( ) ;
rank: 231
score: 98.60911560058594
patch: ++ iter + ; ++ iter ;
rank: 231
score: 98.57175990513393
patch: ++ n ; return new Point CaMeL Value CaMeL Pair ( ; }
rank: 232
score: 99.02378443667763
patch: ++ iter ; double f CaMeL Val = Univariate CaMeL Point CaMeL Value CaMeL Pair . x ;
rank: 232
score: 98.98752848307292
patch: final double f CaMeL Val = compute CaMeL Objective CaMeL Value ( double CaMeL Value ) ;
rank: 232
score: 98.85579707704741
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair do CaMeL Optimize ( x ) ;
rank: 232
score: 98.69612121582031
patch: / * ++ ++ iter * /
rank: 232
score: 98.68158513849431
patch: if ( iter == null ) return iter ; }
rank: 232
score: 98.60841200086806
patch: ++ iter ; ; ; ++ iter ;
rank: 232
score: 98.57146344866071
patch: while ( ! iter . is CaMeL Empty ( ) ) break ;
rank: 233
score: 99.02356487771739
patch: double f CaMeL Val = Math . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . this ) ;
rank: 233
score: 98.9875244140625
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair extends Univariate CaMeL Point CaMeL Value CaMeL Pair ;
rank: 233
score: 98.98687065972223
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( - f CaMeL Val ) ;
rank: 233
score: 98.9657470703125
patch: final double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ,
rank: 233
score: 98.85560302734375
patch: return ( Point CaMeL Value CaMeL Pair ) Math CaMeL Arrays . copy CaMeL Of ( x ) ;
rank: 233
score: 98.76806640625
patch: throw new Runtime CaMeL Exception ( $STRING$ + n ) ; }
rank: 233
score: 98.69499206542969
patch: i * ++ ; ++ 1 ;
rank: 233
score: 98.68109893798828
patch: else { / * ++ * /
rank: 233
score: 98.60836791992188
patch: ++ start ;
rank: 234
score: 99.02269222861842
patch: double f CaMeL Val 1 = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ;
rank: 234
score: 98.9873046875
patch: double iter = guess . clone ( ) ;
rank: 234
score: 98.96566569010416
patch: double f CaMeL Val += compute CaMeL Objective CaMeL Value ( x ) ;
rank: 234
score: 98.85559844970703
patch: b = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 234
score: 98.69485812717014
patch: ++ iter ; * / int iter ;
rank: 234
score: 98.68087768554688
patch: ++ * 0 . 0 ; }
rank: 234
score: 98.60653250558036
patch: ++ 0 ; ++ start ;
rank: 234
score: 98.56998116629464
patch: throw new Illegal CaMeL State CaMeL Exception ( $STRING$ ++ n ) ;
rank: 235
score: 99.02262369791667
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( x ,
rank: 235
score: 98.98651529947917
patch: final double iter = f CaMeL Val . get CaMeL Value ( ) ;
rank: 235
score: 98.96561686197917
patch: int f CaMeL Val = f CaMeL Val - $NUMBER$ ;
rank: 235
score: 98.8548648231908
patch: return new CaMeL Point CaMeL And CaMeL Direction ( f CaMeL Val , f CaMeL Val ) ;
rank: 235
score: 98.68067932128906
patch: / * * ++ * / }
rank: 235
score: 98.6052474975586
patch: iter ++ ; ; ++ iter ;
rank: 235
score: 98.56930202907986
patch: iter = iter . read ( ) ;
rank: 236
score: 98.98601684570312
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( direc , 0 ) ;
rank: 236
score: 98.98590087890625
patch: double CaMeL Value = compute CaMeL Objective CaMeL Value ( x , f CaMeL Val ) ;
rank: 236
score: 98.85479736328125
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair double CaMeL Value = 0 ;
rank: 236
score: 98.67999737079327
patch: if ( ! iter . is CaMeL Empty ( ; ) {
rank: 236
score: 98.60476684570312
patch: iter ++ ; ++ iter ; }
rank: 237
score: 98.96414794921876
patch: double f CaMeL Val = relative CaMeL Threshold ;
rank: 237
score: 98.8543701171875
patch: return new Point CaMeL Value CaMeL Pair ( Point CaMeL Value CaMeL Pair . x , f CaMeL Val ) ;
rank: 237
score: 98.76586042131696
patch: ++ iter ; while ( iter < iter ) { ++ iter ;
rank: 237
score: 98.69367218017578
patch: ++ x iter ; ++ iter ;
rank: 237
score: 98.67993927001953
patch: / * * * / iter ;
rank: 237
score: 98.56641564002403
patch: Iterator < Integer > iter = iter . iterator ( ) ;
rank: 238
score: 99.0223452919408
patch: double f CaMeL Val = Math . copy CaMeL Of ( x . clone ( ) ) ;
rank: 238
score: 98.98556518554688
patch: double [ ] f CaMeL Val = compute CaMeL Objective CaMeL Value ( ) ;
rank: 238
score: 98.98532284007354
patch: double [ ] x = Math CaMeL Arrays . copy CaMeL Of ( n ) ;
rank: 238
score: 98.85421187789352
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair >> iter = 0 ;
rank: 238
score: 98.69329155815973
patch: / * ++ iter ; iter * /
rank: 238
score: 98.67975725446429
patch: / * * ; * /
rank: 238
score: 98.60418023003473
patch: ++ iter ; ++ iter = iter ;
rank: 238
score: 98.56580810546875
patch: ++ iter ; ++ n ; ++ n ;
rank: 239
score: 99.02162571957237
patch: final Univariate CaMeL Point CaMeL Value CaMeL Pair < double , Univariate CaMeL Point CaMeL Value CaMeL Pair
rank: 239
score: 98.8539794921875
patch: return new Point CaMeL Value CaMeL Pair ( x 1 , iter ) ;
rank: 239
score: 98.76448567708333
patch: ++ iter ; if ( ! iter . is CaMeL Empty ( ) )
rank: 239
score: 98.69315011160714
patch: / * ++ iter * /
rank: 239
score: 98.67926494891827
patch: if ( ! iter . is CaMeL Empty ( || ) ;
rank: 239
score: 98.60369873046875
patch: ++ iter ; ++ iter ; for iter
rank: 239
score: 98.56470665564903
patch: Iterator < String > iter = iter . iterator ( ) ;
rank: 240
score: 99.02023182744566
patch: double f CaMeL Val = Math . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . 0 ) ;
rank: 240
score: 98.98469682173295
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val + f CaMeL Val ) ;
rank: 240
score: 98.98367745535714
patch: int f CaMeL Val = f CaMeL Val + 0 . 0 ;
rank: 240
score: 98.96262428977273
patch: int f CaMeL Val $NUMBER$ = f CaMeL Val ;
rank: 240
score: 98.85390403053977
patch: result = guess . get CaMeL Value ( ) ;
rank: 240
score: 98.76432037353516
patch: while ( iter > 0 ) {
rank: 240
score: 98.69294569227431
patch: ++ iter ; ++ * * ++ /
rank: 240
score: 98.678466796875
patch: while ( ! iter . is CaMeL Empty ( ) ; break ;
rank: 240
score: 98.60359022352431
patch: ++ iter ; iter / ; / /
rank: 241
score: 98.9846700032552
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = Math CaMeL Arrays . copy CaMeL Of ( guess ) ;
rank: 241
score: 98.98365693933823
patch: int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( iter ) ;
rank: 241
score: 98.8536376953125
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Point CaMeL Value CaMeL Pair . get CaMeL Goal CaMeL Type ( ) ) ;
rank: 241
score: 98.76411743164063
patch: if ( iter < iter ) ++ iter ;
rank: 241
score: 98.69052124023438
patch: ++ iter ; ++ * ; ++ iter ;
rank: 241
score: 98.60356903076172
patch: ++ iter ; ++ ++ start ;
rank: 241
score: 98.5637715657552
patch: if ( iter != null ) { ++ iter ; }
rank: 242
score: 99.02005440848214
patch: double f CaMeL Val $NUMBER$ = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val $NUMBER$ ) ;
rank: 242
score: 98.85240263097427
patch: return new Point CaMeL Value CaMeL Pair ( Point CaMeL Value CaMeL Pair . 1 ;
rank: 242
score: 98.76344807942708
patch: ++ iter ; / * iter * /
rank: 242
score: 98.68954467773438
patch: } ++ iter ; ++ 1 ;
rank: 242
score: 98.6780014038086
patch: ++ [ ] iter = iter ;
rank: 242
score: 98.56351047092014
patch: ++ iter 1 [ iter 1 ] ;
rank: 243
score: 98.98443603515625
patch: double f CaMeL Val = f CaMeL Val . search ( x $NUMBER$ ) ;
rank: 243
score: 98.98260498046875
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( f CaMeL Val ) ; {
rank: 243
score: 98.96240234375
patch: double [ ] x 1 = Math CaMeL Arrays . copy CaMeL
rank: 243
score: 98.8522616299716
patch: result = compute CaMeL Objective CaMeL Value ( x ,
rank: 243
score: 98.76319173177083
patch: ++ iter ; catch ( Clone CaMeL Not CaMeL Supported CaMeL Exception ; }
rank: 243
score: 98.68901062011719
patch: i * ++ ; ++ * /
rank: 243
score: 98.67758178710938
patch: * * * * / iter ;
rank: 243
score: 98.60291137695313
patch: ++ 0 ; ++ iter ; -- iter ;
rank: 243
score: 98.5631436434659
patch: ++ iter ; while ( iter != 0 ) {
rank: 244
score: 98.98390826056985
patch: f CaMeL Val = f CaMeL Val + f CaMeL Val - f CaMeL Val ;
rank: 244
score: 98.98248291015625
patch: double f CaMeL Val = Math . copy CaMeL Of ( direc ) ;
rank: 244
score: 98.96201578776042
patch: double f CaMeL Val = f CaMeL Val - max ;
rank: 244
score: 98.8521484375
patch: return new Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ( x , x ) ;
rank: 244
score: 98.7631591796875
patch: return new Point CaMeL Value CaMeL Pair ( x , iter ) ; }
rank: 244
score: 98.67730034722223
patch: if ( iter < 0 ; break ;
rank: 244
score: 98.60286254882813
patch: ++ null ; ++ iter ; ++ iter ;
rank: 244
score: 98.56255231584821
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + n + ;
rank: 245
score: 99.01974354619566
patch: int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , f CaMeL Val ) ;
rank: 245
score: 98.982421875
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( f CaMeL Val , 0 ) ;
rank: 245
score: 98.96175944010416
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( name ) ;
rank: 245
score: 98.8519870923913
patch: return new Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ( x 1 , f CaMeL Val ) ;
rank: 245
score: 98.76246861049107
patch: return new Point CaMeL Value CaMeL Pair ( iter , iter ) ;
rank: 245
score: 98.68744659423828
patch: ++ iter ; iter - * /
rank: 245
score: 98.6766690340909
patch: else throw new Runtime CaMeL Exception ( $STRING$ ) ;
rank: 245
score: 98.60237630208333
patch: ++ iter ; ++ iter ; iter }
rank: 245
score: 98.56251831054688
patch: if ( iter == null ) return null ;
rank: 246
score: 99.01931423611111
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , compute CaMeL Objective CaMeL Value ( x ) ) ;
rank: 246
score: 98.98273383246527
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( x - f CaMeL Val ) ;
rank: 246
score: 98.982373046875
patch: double f CaMeL Val = f CaMeL Val . search ( $STRING$ ) ;
rank: 246
score: 98.851533203125
patch: return Point CaMeL Value CaMeL Pair . new CaMeL Point CaMeL And CaMeL Direction ( f CaMeL Val , f CaMeL Val ) ;
rank: 246
score: 98.68672180175781
patch: ++ iter ; ++ 0 ; ;
rank: 246
score: 98.6765380859375
patch: if ( iter == iter ; return iter ;
rank: 246
score: 98.6021728515625
patch: ++ iter ; iter throw iter ;
rank: 246
score: 98.56241861979167
patch: ++ iter ; if ( iter == null ) break ;
rank: 247
score: 99.01831817626953
patch: double [ ] f CaMeL Val = f CaMeL Val . clone ( ) ;
rank: 247
score: 98.98224283854167
patch: int f CaMeL Val = f CaMeL Val . search ( 0 ) ;
rank: 247
score: 98.98206147693452
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = x . get CaMeL Value ( ) ;
rank: 247
score: 98.96127115885416
patch: final double f CaMeL Val = f CaMeL Val - 0 . 0 ;
rank: 247
score: 98.85134451729911
patch: long f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ,
rank: 247
score: 98.76135864257813
patch: ++ iter ; while ( iter >= n )
rank: 247
score: 98.68577575683594
patch: ++ * * ++ ++ iter ;
rank: 247
score: 98.67572784423828
patch: / * * * ; / /
rank: 247
score: 98.60206434461806
patch: ++ iter ; ++ iter ; ; ;
rank: 248
score: 99.01787860576923
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ,
rank: 248
score: 98.98207720588235
patch: int [ ] f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 248
score: 98.98183186848958
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = Math CaMeL Arrays . copy CaMeL Of ( checker ) ;
rank: 248
score: 98.9605379971591
patch: double f CaMeL Val = f CaMeL Val ; final
rank: 248
score: 98.85122445913461
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair iter = 0 ;
rank: 248
score: 98.76115587022569
patch: while ( true ; ) ++ iter ;
rank: 248
score: 98.68521118164062
patch: ++ iter ; try { iter ;
rank: 248
score: 98.67544555664062
patch: / * * * * / /
rank: 248
score: 98.60011121961806
patch: ++ iter ; else ; ++ iter ;
rank: 248
score: 98.560302734375
patch: Iterator iter = iter . iterator ( ) ; break ;
rank: 249
score: 99.0171429177989
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair ) ;
rank: 249
score: 98.98167509191177
patch: final double iter = Math CaMeL Arrays . copy CaMeL Of ( direc ) ;
rank: 249
score: 98.96053314208984
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL
rank: 249
score: 98.85104709201389
patch: Iterator < Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair >
rank: 249
score: 98.76071999289773
patch: while ( iter < n ) { ++ n ;
rank: 249
score: 98.68516540527344
patch: } ++ iter ; if iter ;
rank: 249
score: 98.67460123697917
patch: Iterator < ? > iter = iter . iterator ++ ;
rank: 249
score: 98.5999267578125
patch: ++ iter ; ++ iter ; -- n ;
rank: 249
score: 98.56002103365384
patch: int n = Math . min ( iter , n ) ;
rank: 250
score: 99.01686197916666
patch: int f CaMeL Val = Math . copy CaMeL Of ( x ) ;
rank: 250
score: 98.98147786458334
patch: double [ ] x 1 = f CaMeL Val . clone ( ) ;
rank: 250
score: 98.96030680338542
patch: double f CaMeL Val = f CaMeL Val + 1 ;
rank: 250
score: 98.8508071899414
patch: tmp = new CaMeL Point CaMeL And CaMeL Direction ( f CaMeL Val ) ;
rank: 250
score: 98.7605731670673
patch: return new Point CaMeL Value CaMeL Pair ( n , ; }
rank: 250
score: 98.68478732638889
patch: / * ] ++ iter ; * /
rank: 250
score: 98.67431640625
patch: if ( ! iter . is CaMeL Empty ++ false ;
rank: 250
score: 98.59967041015625
patch: ++ iter ; ++ start ; -- iter ;
rank: 251
score: 98.98158094618056
patch: double f CaMeL Val = new Univariate CaMeL Point CaMeL Value CaMeL Pair ( x ) ;
rank: 251
score: 98.98135196461396
patch: final double [ ] f CaMeL Val = x . get CaMeL Value ( ) ;
rank: 251
score: 98.85075774016204
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair + f CaMeL Val ;
rank: 251
score: 98.684765625
patch: ++ iter ; ++ iter ; ++ value ;
rank: 251
score: 98.6740214029948
patch: if ( ! iter . is CaMeL Empty ++ true ;
rank: 251
score: 98.59941864013672
patch: ; ++ iter ; ++ iter ;
rank: 252
score: 98.98154025607639
patch: double f CaMeL Val = new Univariate CaMeL Point CaMeL Value CaMeL Pair [ n ] ;
rank: 252
score: 98.95994657628677
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( x 1 ,
rank: 252
score: 98.85011291503906
patch: iter = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 252
score: 98.75951334635417
patch: return new Point CaMeL Value CaMeL Pair ( iter , x . length ;
rank: 252
score: 98.68475341796875
patch: ++ 1 ; if ++ iter ;
rank: 252
score: 98.67366027832031
patch: else { ++ 0 ; } }
rank: 252
score: 98.59941864013672
patch: iter ; ++ iter ; break ;
rank: 252
score: 98.55852801983173
patch: try { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ;
rank: 253
score: 99.01644897460938
patch: ++ iter ; double f CaMeL Val = compute CaMeL Objective CaMeL Value ( f CaMeL Val ) ;
rank: 253
score: 98.98090471540179
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( line ) ;
rank: 253
score: 98.85008893694196
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair < Univariate CaMeL Point CaMeL Value CaMeL Pair > ++ iter ;
rank: 253
score: 98.75945366753473
patch: ++ iter ; for ; ; ) {
rank: 253
score: 98.68446180555556
patch: / * ] iter ; int iter ;
rank: 253
score: 98.67347717285156
patch: else { ++ * * * /
rank: 253
score: 98.59920247395833
patch: ++ iter ; ++ iter ; iter /
rank: 253
score: 98.55848911830357
patch: int n = ++ n ;
rank: 254
score: 99.01644094366776
patch: ++ iter ; double f CaMeL Val = Univariate CaMeL Point CaMeL Value CaMeL Pair . 0 ;
rank: 254
score: 98.98082914806548
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = . get CaMeL Value ( ) ;
rank: 254
score: 98.97860514322916
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( [
rank: 254
score: 98.8499422940341
patch: return new Point CaMeL Value CaMeL Pair ( Point CaMeL Value CaMeL Pair . get CaMeL Value ( ) ) ;
rank: 254
score: 98.75908551897321
patch: ++ iter ; catch ( Clone CaMeL Not CaMeL Supported CaMeL Exception ;
rank: 254
score: 98.68439275568181
patch: ++ iter ; ++ iter ; for ++ iter ;
rank: 254
score: 98.67340698242188
patch: ++ * * * * * / iter ;
rank: 254
score: 98.59901012073864
patch: ++ iter ; ++ iter ; else return iter ;
rank: 254
score: 98.55802001953126
patch: ++ iter ; while ( iter <= n )
rank: 255
score: 99.01585852581522
patch: int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( (
rank: 255
score: 98.95946248372395
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value (
rank: 255
score: 98.84881591796875
patch: Iterator < Point CaMeL Value CaMeL Pair , Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair
rank: 255
score: 98.759033203125
patch: ++ iter - 1 ; ;
rank: 255
score: 98.67191859654018
patch: if ( ! iter . is CaMeL Empty ( ) ++ iter ;
rank: 255
score: 98.598193359375
patch: ++ iter ; iter / ; ++ iter ;
rank: 255
score: 98.557421875
patch: throw new Illegal CaMeL State CaMeL Exception ( ;
rank: 256
score: 99.01571655273438
patch: double f CaMeL Val = $NUMBER$ . clone ( ) ;
rank: 256
score: 98.98003540039062
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair : checker . get CaMeL Point ( ) ;
rank: 256
score: 98.97846013849431
patch: final double f CaMeL Val = 1 . 0 ;
rank: 256
score: 98.8486095610119
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair > iter = 0 ;
rank: 256
score: 98.75713500976562
patch: if ( iter > 0 ) ++ iter ;
rank: 256
score: 98.67097981770833
patch: * * * * ; ++ iter ;
rank: 256
score: 98.59788818359375
patch: ++ 1 ; ++ iter ; -- iter ;
rank: 256
score: 98.55699744591347
patch: int iter = 0 ; while ( iter < n ) {
rank: 257
score: 99.0155388327206
patch: ++ iter ; double f CaMeL Val = f CaMeL Val . clone ( ) ;
rank: 257
score: 98.97825113932292
patch: double [ ] x = guess . f CaMeL Val ;
rank: 257
score: 98.84829711914062
patch: return Point CaMeL Value CaMeL Pair . new CaMeL Point CaMeL And CaMeL Direction ( f CaMeL Val ;
rank: 257
score: 98.75705973307292
patch: return new Point CaMeL Value CaMeL Pair ( 0 , ;
rank: 257
score: 98.68132019042969
patch: / * ++ iter ; * /
rank: 257
score: 98.67086087740384
patch: if ( ! iter . is CaMeL Empty ++ ) break ;
rank: 257
score: 98.55645751953125
patch: ++ iter ; while ( iter == iter )
rank: 258
score: 99.01553239493535
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , x ) ) ;
rank: 258
score: 98.97925567626953
patch: final double [ ] x = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 258
score: 98.95810418379934
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , (
rank: 258
score: 98.84823713631465
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair <= Point CaMeL Value CaMeL Pair >
rank: 258
score: 98.75668770926339
patch: while ( true ; ) {
rank: 258
score: 98.68083360460069
patch: ++ iter ; int iter + iter ;
rank: 258
score: 98.67085484095982
patch: if ( ! iter . is CaMeL Empty ++ ; return iter ;
rank: 258
score: 98.59695434570312
patch: ++ iter ; ++ iter ; ++ iter ; iter ;
rank: 258
score: 98.55594482421876
patch: ++ n ; ++ n ; ++ n ;
rank: 259
score: 99.015380859375
patch: if ( checker != null ) {
rank: 259
score: 98.97836100260416
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( value ) ;
rank: 259
score: 98.97771253083882
patch: double f CaMeL Val = f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 259
score: 98.84802827380952
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > iter = n ;
rank: 259
score: 98.7565409342448
patch: Iterator < Point CaMeL Value CaMeL Pair > iterator = ;
rank: 259
score: 98.68070220947266
patch: ++ value ; ++ iter ; }
rank: 259
score: 98.67083740234375
patch: if ( ! iter . is CaMeL Empty ++ ) continue ; }
rank: 259
score: 98.59561157226562
patch: ++ iter ; ++ n ; else
rank: 259
score: 98.55374581473214
patch: if ( ! ++ iter )
rank: 260
score: 99.01528785342262
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . TRUE ) ;
rank: 260
score: 98.97786218979779
patch: double [ ] x 1 = compute CaMeL Objective CaMeL Value ( x $NUMBER$ ) ;
rank: 260
score: 98.97754923502605
patch: i = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 260
score: 98.95764838324652
patch: String f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( direc ) ;
rank: 260
score: 98.84795587713069
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > direc = 0 ;
rank: 260
score: 98.7561767578125
patch: Iterator < Point CaMeL Value CaMeL Pair > iter = iter . iterator ;
rank: 260
score: 98.67955186631944
patch: ++ value ; ++ iter ; iter ;
rank: 260
score: 98.67070661272321
patch: if ( ! iter . is CaMeL Empty ( ) ) ; }
rank: 260
score: 98.59541320800781
patch: ++ iter ; ; ++ 1 ;
rank: 260
score: 98.55366734095982
patch: throw new Runtime CaMeL Exception ( $STRING$ + iter + $STRING$ ) ;
rank: 261
score: 99.01480305989584
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . get CaMeL Value ( x ) ) ;
rank: 261
score: 98.97744954427084
patch: double f CaMeL Val = f CaMeL Val [ f CaMeL Val ] ;
rank: 261
score: 98.95732286241319
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( Math CaMeL Arrays . copy CaMeL
rank: 261
score: 98.84778941761364
patch: state = get CaMeL Goal CaMeL Type ( ) ;
rank: 261
score: 98.75382232666016
patch: ++ iter ; if ( n ;
rank: 261
score: 98.6794204711914
patch: ++ iter ; iter + 1 ;
rank: 261
score: 98.67019653320312
patch: else { iter ++ ; } }
rank: 261
score: 98.59513092041016
patch: if ++ 0 ; ++ iter ;
rank: 261
score: 98.55355398995536
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ++ iter ) ;
rank: 262
score: 99.01475306919643
patch: d = Math . copy CaMeL Of ( f CaMeL Val ) ;
rank: 262
score: 98.97720336914062
patch: double [ ] x = guess . clone ( ) ;
rank: 262
score: 98.84777379918981
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair = Math . 0 ;
rank: 262
score: 98.75226236979167
patch: ++ iter ; while ( ! iter . is CaMeL Empty ( ) )
rank: 262
score: 98.67927381727431
patch: / * ++ iter ; ++ * /
rank: 262
score: 98.67017711292614
patch: Set < ? > iter = iter . iterator ;
rank: 262
score: 98.5949951171875
patch: ++ n ; ++ iter ; -- iter ;
rank: 262
score: 98.5517578125
patch: ++ iter ] [ n ] ;
rank: 263
score: 99.01452055431548
patch: double f CaMeL Val = Math . copy CaMeL Of ( f CaMeL Val , f CaMeL Val ) ;
rank: 263
score: 98.97716674804687
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ; ;
rank: 263
score: 98.97662908380681
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 263
score: 98.84776204427084
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair > iter = x ;
rank: 263
score: 98.7516620342548
patch: return new Point CaMeL Value CaMeL Pair ( this , ; }
rank: 263
score: 98.67852105034723
patch: i * * / / ++ iter ;
rank: 263
score: 98.66970825195312
patch: * * * * * / }
rank: 263
score: 98.59453790838069
patch: ++ iter ; ++ iter ; ++ -- iter ;
rank: 263
score: 98.55105356069711
patch: throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + ; }
rank: 264
score: 99.01442357113487
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( f CaMeL Val , n ) ;
rank: 264
score: 98.97625411184211
patch: ++ f CaMeL Val ; f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 264
score: 98.9560482627467
patch: int f CaMeL Val = f CaMeL Val ; double f CaMeL Val = f CaMeL Val ;
rank: 264
score: 98.84758890086206
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . x = f CaMeL Val ;
rank: 264
score: 98.75164031982422
patch: while ( iter < iter ) ;
rank: 264
score: 98.6761245727539
patch: ++ iter ; ++ * out ;
rank: 264
score: 98.66928439670139
patch: else { ++ iter ; break ; }
rank: 264
score: 98.5931625366211
patch: iter if ++ ; ++ iter ;
rank: 264
score: 98.5509745279948
patch: ++ iter ; if ( iter == 0 ) continue ;
rank: 265
score: 99.014404296875
patch: double f CaMeL Val = Math . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . x . clone ( ) ) ;
rank: 265
score: 98.95603942871094
patch: if ( f CaMeL Val == get CaMeL Goal CaMeL Type ( ) ) {
rank: 265
score: 98.84728131975446
patch: Iterator < Point CaMeL Value CaMeL Pair protected Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ) {
rank: 265
score: 98.75156471946023
patch: ++ iter ; iter = iter . iterator ( ;
rank: 265
score: 98.67608642578125
patch: ++ iter ; else * ++ iter ;
rank: 265
score: 98.66915130615234
patch: return iter ;
rank: 265
score: 98.59286159939236
patch: ++ iter ; ++ iter ; ; }
rank: 265
score: 98.55061558314732
patch: int n = ++ iter ;
rank: 266
score: 99.01400390625
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . $STRING$ ) ;
rank: 266
score: 98.97630673363095
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ) . get CaMeL Value ( ) ;
rank: 266
score: 98.97460123697917
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( min ) ;
rank: 266
score: 98.84716796875
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair < Univariate CaMeL Point CaMeL Value CaMeL Pair > ;
rank: 266
score: 98.75118815104166
patch: return new Point CaMeL Value CaMeL Pair ( iter , x ) ; }
rank: 266
score: 98.67575509207589
patch: ++ iter ; ++ out ;
rank: 266
score: 98.66841125488281
patch: ++ iter ; if ; * /
rank: 266
score: 98.59282892400569
patch: ++ iter ; ++ iter ; iter / -- ;
rank: 266
score: 98.5503641764323
patch: if ( ! iter . is CaMeL Empty ; else {
rank: 267
score: 98.97475022536058
patch: double f CaMeL Val = ( int ) f CaMeL Val ;
rank: 267
score: 98.95536295572917
patch: double f CaMeL Val = f CaMeL Val - x ;
rank: 267
score: 98.84681285511364
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair
rank: 267
score: 98.67549641927083
patch: ++ iter ; iter ; int 1 ;
rank: 267
score: 98.66840362548828
patch: / * * ; * * /
rank: 267
score: 98.59086470170455
patch: ++ iter ; iter / * / ++ iter ;
rank: 267
score: 98.54959869384766
patch: ++ iter ; final ++ iter ;
rank: 268
score: 99.01397494612068
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( this . f CaMeL Val ) ) ;
rank: 268
score: 98.97437744140625
patch: double f CaMeL Val = $NUMBER$ . 0 ;
rank: 268
score: 98.95505196707589
patch: double f CaMeL Val = f CaMeL Val . start ( ) ;
rank: 268
score: 98.84606512661638
patch: Iterator < Point CaMeL Value CaMeL Pair protected Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair {
rank: 268
score: 98.75083414713542
patch: ++ iter ; if ( iter ; ;
rank: 268
score: 98.66749572753906
patch: / * * * / / }
rank: 268
score: 98.59084250710227
patch: ++ 0 ; ++ iter ; } ++ iter ;
rank: 268
score: 98.54938354492188
patch: ++ iter ; if ( iter == 0 )
rank: 269
score: 99.01371256510417
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( ) . clone ( ) ;
rank: 269
score: 98.974169921875
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( direc . x ) ;
rank: 269
score: 98.84581163194444
patch: return new Point CaMeL Value CaMeL Pair ( Point CaMeL Value CaMeL Pair . line ) ;
rank: 269
score: 98.75012817382813
patch: ++ iter ; / * ++ iter * /
rank: 269
score: 98.66725510817308
patch: synchronized ( . is CaMeL Empty ( ) ) return iter ;
rank: 269
score: 98.59075927734375
patch: ++ iter ; ++ iter ; else /
rank: 270
score: 99.013671875
patch: double f CaMeL Val = Math . copy CaMeL Of ( Math . copy CaMeL Of ( f CaMeL Val ) ) ;
rank: 270
score: 98.97411391314338
patch: long f CaMeL Val = Math . copy CaMeL Of ( f CaMeL Val ) ;
rank: 270
score: 98.97257232666016
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = this ;
rank: 270
score: 98.95447591145833
patch: double f CaMeL Val = x . get CaMeL Point ( 0 ) ;
rank: 270
score: 98.84571422230114
patch: return new Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ( x , f CaMeL Val ) ;
rank: 270
score: 98.75003814697266
patch: while ( false ) ++ iter ;
rank: 270
score: 98.67401801215277
patch: ++ iter ; ++ iter ; * *
rank: 270
score: 98.6666488647461
patch: / * * ; ++ * /
rank: 270
score: 98.58906773158482
patch: ++ list ; ++ iter ;
rank: 270
score: 98.54861215444711
patch: int iter = Math . max ( iter , n ) ;
rank: 271
score: 99.01329752604167
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , 0 ) ) ;
rank: 271
score: 98.97257173978366
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 271
score: 98.95436314174107
patch: double [ ] f CaMeL Val = compute CaMeL Objective CaMeL Value (
rank: 271
score: 98.84569594439338
patch: return Math CaMeL Arrays . copy CaMeL Of ( direc [ 0 ] ) ;
rank: 271
score: 98.7498446377841
patch: while ( iter > 0 ) { ++ iter ;
rank: 271
score: 98.67375352647569
patch: ++ iter ; while iter + iter ;
rank: 271
score: 98.66578258167614
patch: Set < ? > iter = iter . start ;
rank: 271
score: 98.58904351128473
patch: ++ ( ++ iter ; ++ iter ;
rank: 272
score: 98.97272135416667
patch: f CaMeL Val = new double [ f CaMeL Val . length ] ;
rank: 272
score: 98.95394558376736
patch: final double n = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 272
score: 98.8456394361413
patch: return Point CaMeL Value CaMeL Pair . new CaMeL Point CaMeL And CaMeL Direction ( f CaMeL Val , 0 ) ;
rank: 272
score: 98.74979341947116
patch: throw new Runtime CaMeL Exception ( $STRING$ + iter ) ; }
rank: 272
score: 98.67366027832031
patch: int iter ; ++ - iter ;
rank: 272
score: 98.66569519042969
patch: ++ iter ; if ++ n ;
rank: 272
score: 98.58870152064732
patch: ++ 1 ; ++ start ;
rank: 272
score: 98.54839618389423
patch: throw new Runtime CaMeL Exception ( $STRING$ + ++ n ) ;
rank: 273
score: 98.97268880208334
patch: double f CaMeL Val = f CaMeL Val . get ( 0 ) ;
rank: 273
score: 98.97225247896634
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair -- ;
rank: 273
score: 98.95389556884766
patch: double [ ] x = f CaMeL Val . get CaMeL Value ( ) ;
rank: 273
score: 98.84541151258681
patch: return ( Point CaMeL Value CaMeL Pair ) compute CaMeL Objective CaMeL Value ( x ) ;
rank: 273
score: 98.74931196732955
patch: ++ iter ; while ( iter < iter ) ;
rank: 273
score: 98.67353057861328
patch: i * ++ ; if iter ;
rank: 273
score: 98.66551208496094
patch: / * * ; * / /
rank: 273
score: 98.54823655348558
patch: if ( ! iter . is CaMeL Empty ( ) ) }
rank: 274
score: 99.01291419719827
patch: final int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ) ;
rank: 274
score: 98.9725341796875
patch: int f CaMeL Val = compute CaMeL Objective CaMeL Value ( 0 . 0 ) ;
rank: 274
score: 98.97218919836956
patch: f CaMeL Val = f CaMeL Val ; f CaMeL Val = f CaMeL Val . get CaMeL Value ( ) ;
rank: 274
score: 98.9537109375
patch: final double f CaMeL Val = f CaMeL Val * f CaMeL Val ;
rank: 274
score: 98.84530978732639
patch: found = Math CaMeL Arrays . copy CaMeL Of ( x . clone ( ) ) ;
rank: 274
score: 98.74897984095982
patch: return new Point CaMeL Value CaMeL Pair ( ++ n , x ;
rank: 274
score: 98.67333306206598
patch: ++ iter ; ++ * + iter ;
rank: 274
score: 98.66466267903645
patch: else { break ; }
rank: 274
score: 98.58756510416667
patch: ++ iter ; ++ iter ; ; else
rank: 274
score: 98.54801802201705
patch: int n = iter [ n ] . length ;
rank: 275
score: 98.95314654181985
patch: double f CaMeL Val = f CaMeL Val . get CaMeL Value ( x ) ;
rank: 275
score: 98.84529331752232
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair , Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair
rank: 275
score: 98.747314453125
patch: throw new Unsupported CaMeL Operation CaMeL Exception ( ) ; ;
rank: 275
score: 98.67266845703125
patch: ++ iter ; ++ * ; ;
rank: 275
score: 98.66416713169643
patch: / * * ++ * /
rank: 275
score: 98.58735795454545
patch: ++ n ; ++ iter ; } ++ iter ;
rank: 275
score: 98.54631805419922
patch: while ( n < n ) {
rank: 276
score: 99.0128173828125
patch: int f CaMeL Val = Math . abs ( f CaMeL Val ;
rank: 276
score: 98.97212727864583
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( direc [
rank: 276
score: 98.97086007254464
patch: double f CaMeL Val = x . search ( x $NUMBER$ ) ;
rank: 276
score: 98.84489610460069
patch: return new CaMeL Point CaMeL And CaMeL Direction ( x 1 , f CaMeL Val ) ;
rank: 276
score: 98.74679565429688
patch: ++ iter * / * / ++ iter ;
rank: 276
score: 98.67234584263393
patch: ++ * ++ ++ iter ;
rank: 276
score: 98.66342397836539
patch: if ( ! iter . is CaMeL Empty ++ ) * /
rank: 276
score: 98.58663330078124
patch: iter ++ ; ++ iter ; -- iter ;
rank: 276
score: 98.54620361328125
patch: while ( ! iter . is CaMeL Empty ( ) ) continue ;
rank: 277
score: 99.01253255208333
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . to CaMeL
rank: 277
score: 98.97207980685764
patch: double f CaMeL Val = ( Univariate CaMeL Point CaMeL Value CaMeL Pair ) direc ;
rank: 277
score: 98.9707421875
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = new CaMeL Point CaMeL And CaMeL Direction ( x 1 ) ;
rank: 277
score: 98.95299530029297
patch: double x = f CaMeL Val ;
rank: 277
score: 98.8447201377467
patch: Iterator < Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair > iter = 0 ;
rank: 277
score: 98.74674479166667
patch: return new Point CaMeL Value CaMeL Pair ( iter , x , iter ;
rank: 277
score: 98.67215983072917
patch: ++ iter ; ++ * - 1 ;
rank: 277
score: 98.66325239701705
patch: Set < ? > iter = iter . max ;
rank: 277
score: 98.58550470525569
patch: ++ iter ; iter / ++ ; ++ iter ;
rank: 277
score: 98.5458096590909
patch: buffer . append ( $STRING$ ) . append ( ;
rank: 278
score: 99.01239372702206
patch: int value = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 278
score: 98.970703125
patch: double [ ] x 1 = x . get CaMeL Point ( ) ;
rank: 278
score: 98.952685546875
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x $NUMBER$ ,
rank: 278
score: 98.84465475643383
patch: return Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , 0 ) ;
rank: 278
score: 98.66323852539062
patch: ++ [ ] ++ iter ; }
rank: 278
score: 98.5841397372159
patch: ++ 1 ; ++ iter ; } ++ iter ;
rank: 278
score: 98.54554966517857
patch: ++ iter ; ++ iterator ;
rank: 279
score: 99.01232379415761
patch: ++ iter ; double f CaMeL Val = Univariate CaMeL Point CaMeL Value CaMeL Pair . x . clone ( ) ;
rank: 279
score: 98.97051130022321
patch: double [ ] iter = checker . get CaMeL Value ( ) ;
rank: 279
score: 98.95184881036931
patch: int f CaMeL Val = f CaMeL Val 1 ;
rank: 279
score: 98.66939290364583
patch: ++ iter ; ++ ++ - iter ;
rank: 279
score: 98.66292572021484
patch: / * ++ iter * / /
rank: 279
score: 98.58385552300348
patch: ++ iter ; ++ iter ; } }
rank: 280
score: 99.01219540550595
patch: double f CaMeL Val = Univariate CaMeL Point CaMeL Value CaMeL Pair . get CaMeL Point ( 0 ) ;
rank: 280
score: 98.9517822265625
patch: double f CaMeL Val = f CaMeL Val - f CaMeL Val -
rank: 280
score: 98.8440234375
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Point CaMeL Value CaMeL Pair . Math CaMeL Arrays . copy CaMeL Of (
rank: 280
score: 98.74524739583333
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + n + $STRING$ ;
rank: 280
score: 98.66873168945312
patch: int iter ; ++ - 1 ;
rank: 280
score: 98.6628887469952
patch: throw new Runtime CaMeL Exception ( $STRING$ + iter + $STRING$ ;
rank: 280
score: 98.58350287543402
patch: iter iter if ++ ; ++ iter ;
rank: 280
score: 98.54451497395833
patch: ++ iter ; if ( iter == null ) continue ;
rank: 281
score: 99.0120849609375
patch: double x $NUMBER$ = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 281
score: 98.97026134672619
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( f CaMeL Val , f CaMeL Val ) ;
rank: 281
score: 98.9517110188802
patch: int [ ] f CaMeL Val = f CaMeL Val ;
rank: 281
score: 98.8438949584961
patch: Iterator < Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > }
rank: 281
score: 98.74401041666667
patch: ++ iter ; return new Point CaMeL Value CaMeL Pair ( ++ n ;
rank: 281
score: 98.66767120361328
patch: } ++ iter ; int iter ;
rank: 281
score: 98.66227504185268
patch: if ( iter < 0 )
rank: 281
score: 98.58305220170455
patch: ++ iter ; ++ iter ; ; return iter ;
rank: 281
score: 98.54387958233173
patch: float n = Math . max ( n , n ) ;
rank: 282
score: 99.01185438368056
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . x , x ) ;
rank: 282
score: 98.97096761067708
patch: final double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( x ) ;
rank: 282
score: 98.97021484375
patch: final ( ( Point CaMeL Value CaMeL Pair ) f CaMeL Val ) .
rank: 282
score: 98.9515380859375
patch: final double x = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 282
score: 98.84360758463542
patch: result = Math CaMeL Arrays . copy CaMeL Of ( direc [ 0 ] ) ;
rank: 282
score: 98.74363014914773
patch: ++ iter - 1 [ iter ] . length ;
rank: 282
score: 98.666015625
patch: / * ++ iter ; / * /
rank: 282
score: 98.66158447265624
patch: i ++ ; }
rank: 282
score: 98.58229758522727
patch: ++ iter ; ++ iter ; } return iter ;
rank: 282
score: 98.54334513346355
patch: j = Math . max ( iter , n ) ;
rank: 283
score: 99.01174926757812
patch: if ( f CaMeL Val < 0 ) {
rank: 283
score: 98.95112609863281
patch: double [ ] x = Math CaMeL Arrays . copy CaMeL Of ( x ;
rank: 283
score: 98.84357561383929
patch: Iterator < Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair >
rank: 283
score: 98.74349212646484
patch: ++ iter ; ++ iter * /
rank: 283
score: 98.66533203125
patch: ++ iter ; ++ * / int iter ;
rank: 283
score: 98.66123962402344
patch: ++ [ ] [ ] iter ;
rank: 283
score: 98.58207702636719
patch: ++ for ++ ; ++ iter ;
rank: 283
score: 98.54293823242188
patch: ++ iter ; if ( iter != 0 )
rank: 284
score: 99.01148897058823
patch: double f CaMeL Val = Univariate CaMeL Point CaMeL Value CaMeL Pair ( x ) ;
rank: 284
score: 98.9696514423077
patch: double iter = x . search ( f CaMeL Val ) ;
rank: 284
score: 98.94950727982955
patch: final String f CaMeL Val = f CaMeL Val ;
rank: 284
score: 98.843349609375
patch: Iterator < Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair )
rank: 284
score: 98.74331325954861
patch: while ( iter < iter ) { ;
rank: 284
score: 98.665087890625
patch: i * ++ ;
rank: 284
score: 98.66100202287946
patch: if ( iter > 0 ;
rank: 284
score: 98.58067016601562
patch: ++ iter ; ++ x ; ++ iter ;
rank: 285
score: 99.01123046875
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > < Point CaMeL Value CaMeL Pair >
rank: 285
score: 98.96903773716518
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( max ) ;
rank: 285
score: 98.94924926757812
patch: final double f CaMeL Val = compute CaMeL Objective CaMeL Value ( n ) ;
rank: 285
score: 98.8431865985577
patch: Iterator < Point CaMeL Value CaMeL Pair >> iter = 0 ;
rank: 285
score: 98.7427490234375
patch: throw new Unsupported CaMeL Operation CaMeL Exception ( ) ; } ++ iter ;
rank: 285
score: 98.66504778180804
patch: else * ; ++ iter ;
rank: 285
score: 98.58051091974431
patch: ++ iter ; ++ iter ; } = iter ;
rank: 285
score: 98.54215785435268
patch: throw new Illegal CaMeL State CaMeL Exception ( $STRING$ ++ iter ) ;
rank: 286
score: 99.01110387731481
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . this . guess ) ;
rank: 286
score: 98.96863664899554
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( $STRING$ ) ;
rank: 286
score: 98.94840494791667
patch: final double f CaMeL Val = f CaMeL Val ; final
rank: 286
score: 98.84292457217262
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > iter = null ;
rank: 286
score: 98.66447618272569
patch: ++ iter ; ++ iter ; int *
rank: 286
score: 98.5802001953125
patch: ++ iter ; iter / - * /
rank: 286
score: 98.54157049005681
patch: if ( ! iter . contains ( x ) )
rank: 287
score: 99.01105143229167
patch: double f CaMeL Val = 0 ; double f CaMeL Val = 0 ;
rank: 287
score: 98.96832275390625
patch: double CaMeL Value = compute CaMeL Objective CaMeL Value ( 0 ) ;
rank: 287
score: 98.9473876953125
patch: double f CaMeL Val = new Point CaMeL Value CaMeL Pair ( f CaMeL Val ) ;
rank: 287
score: 98.8427734375
patch: return new CaMeL Point CaMeL And CaMeL Direction ( x . clone ( ) ) ;
rank: 287
score: 98.7414217862216
patch: ++ iter ; * / * / ++ iter ;
rank: 287
score: 98.66386413574219
patch: else ++ iter ; ++ 1 ;
rank: 287
score: 98.6600341796875
patch: i ] [ 0 ] = iter ; }
rank: 287
score: 98.57990264892578
patch: ++ -- 1 ; ++ iter ;
rank: 287
score: 98.54071044921875
patch: float n = iter - iter ;
rank: 288
score: 99.01085611979167
patch: double f CaMeL Val = Math . copy CaMeL Of ( 0 ) ;
rank: 288
score: 98.96820537860577
patch: double f CaMeL Val = x . search ( x ) ;
rank: 288
score: 98.96783447265625
patch: int f CaMeL Val = f CaMeL Val - 0 . 0 ;
rank: 288
score: 98.9470926920573
patch: double f CaMeL Val = f CaMeL Val - true ;
rank: 288
score: 98.84266493055556
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ) {
rank: 288
score: 98.74131774902344
patch: ++ iter ; / iter * /
rank: 288
score: 98.6635409268466
patch: ++ iter ; ++ iter ; ++ - iter ;
rank: 288
score: 98.65982055664062
patch: else { if ( ! iter . is CaMeL Empty ;
rank: 288
score: 98.57908412388393
patch: ++ Math ; ++ iter ;
rank: 288
score: 98.54044596354167
patch: int iter = iter ; while ( iter < n )
rank: 289
score: 99.01080729166667
patch: ++ iter ; double f CaMeL Val = this . f CaMeL Val ;
rank: 289
score: 98.842568359375
patch: Iterator < Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair > iter = 0 ;
rank: 289
score: 98.74123313210227
patch: if ( iter < n ; iter ++ ) {
rank: 289
score: 98.66336398654514
patch: ++ iter ; * / if iter ;
rank: 289
score: 98.6597900390625
patch: if ( . is CaMeL Empty ( ) ) continue ;
rank: 289
score: 98.57835083007812
patch: ++ true ; ++ iter ; ++ iter ;
rank: 289
score: 98.54022216796875
patch: j = Math . max ( n , n ) ;
rank: 290
score: 99.0103759765625
patch: double f CaMeL Val 1 = f CaMeL Val - f CaMeL Val ;
rank: 290
score: 98.96761322021484
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x . get CaMeL
rank: 290
score: 98.84253991168478
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair >
rank: 290
score: 98.74034772600446
patch: ++ iter ; return new Point CaMeL Value CaMeL Pair ( iter ;
rank: 290
score: 98.663330078125
patch: ++ iter ; ++ 1 ++ iter ;
rank: 290
score: 98.65975516183036
patch: if ( ! iter . is CaMeL Empty ( ; * / ;
rank: 290
score: 98.5782241821289
patch: ++ $NUMBER$ ; ++ iter ; }
rank: 290
score: 98.54011535644531
patch: while ( true ) { try {
rank: 291
score: 99.0101318359375
patch: double f CaMeL Val 1 = f CaMeL Val ;
rank: 291
score: 98.9672622680664
patch: final double f CaMeL Val = x . search ( f CaMeL Val ) ;
rank: 291
score: 98.94671223958333
patch: int f CaMeL Val = f CaMeL Val - - f CaMeL Val ;
rank: 291
score: 98.84239196777344
patch: l = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 291
score: 98.73949381510417
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + iter + $STRING$ ;
rank: 291
score: 98.66313934326172
patch: ++ iter ; try ; * /
rank: 291
score: 98.65967668805804
patch: if ( ! iter . is CaMeL Empty ( ; - 1 ;
rank: 291
score: 98.57808685302734
patch: ++ iter ; ++ start ; ;
rank: 291
score: 98.53913225446429
patch: final int iter = iter ;
rank: 292
score: 99.00977172851563
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > < Point CaMeL Value CaMeL Pair > ;
rank: 292
score: 98.96619873046875
patch: final double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x . clone ( ) ) ;
rank: 292
score: 98.9466796875
patch: double iter = f CaMeL Val . index CaMeL Of ( 1 ) ;
rank: 292
score: 98.84210205078125
patch: return compute CaMeL Objective CaMeL Value ( x $NUMBER$ , f CaMeL Val ) ;
rank: 292
score: 98.66287994384766
patch: ++ * / ++ ++ iter ;
rank: 292
score: 98.578076171875
patch: ++ iter ; ++ ++ iter ; iter ;
rank: 293
score: 99.00961449032738
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( x . clone ( ) ) ;
rank: 293
score: 98.9665168313419
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x , 0 ) ;
rank: 293
score: 98.84177734375
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair > ++ ;
rank: 293
score: 98.66261121961806
patch: ++ iter ; if iter ; iter ;
rank: 293
score: 98.65890502929688
patch: / * * / ++ iter /
rank: 293
score: 98.57789916992188
patch: ++ iter ; ++ iter ; break ; ;
rank: 294
score: 99.00944438733552
patch: ++ ( ( Point CaMeL Value CaMeL Pair ) checker ) . get CaMeL Value ( ) ;
rank: 294
score: 98.84165649414062
patch: [ ] f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 294
score: 98.73868408203126
patch: ++ iter ; if ( iter < n ;
rank: 294
score: 98.65848388671876
patch: ++ [ ] iter ; if ++ iter ;
rank: 294
score: 98.57770385742188
patch: ++ this ; ++ iter ; ++ iter ;
rank: 294
score: 98.53857421875
patch: @ Override public void run ( ) {
rank: 295
score: 99.0094353170956
patch: Object f CaMeL Val = Math . copy CaMeL Of ( f CaMeL Val ) ;
rank: 295
score: 98.96638706752232
patch: double f CaMeL Val = f CaMeL Val . search ( x ;
rank: 295
score: 98.9646465594952
patch: f CaMeL Val = x . search ( x $NUMBER$ ) ;
rank: 295
score: 98.945703125
patch: int f CaMeL Val = compute CaMeL Objective CaMeL Value ( length ) ;
rank: 295
score: 98.84149639423077
patch: Iterator < Point CaMeL Value CaMeL Pair > iter = x ;
rank: 295
score: 98.73860677083333
patch: ++ iter ; while ( ; ) { ++ iter ;
rank: 295
score: 98.66229248046875
patch: i * ++ ; ++ iter ; ;
rank: 295
score: 98.65799386160714
patch: if ( ! iter . is CaMeL Empty ( ) ) iter ;
rank: 295
score: 98.53851318359375
patch: if ( ! ++ n )
rank: 296
score: 99.00923665364583
patch: double f CaMeL Val $NUMBER$ = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val . clone ( ) ) ;
rank: 296
score: 98.96632021949405
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = Math CaMeL Arrays . copy CaMeL Of (
rank: 296
score: 98.9646355124081
patch: final double [ ] f CaMeL Val = compute CaMeL Objective CaMeL Value ( ) ;
rank: 296
score: 98.9456428079044
patch: final double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL
rank: 296
score: 98.84107462565105
patch: v = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 296
score: 98.66198052300348
patch: ++ 1 ; ++ iter ; * /
rank: 296
score: 98.65794372558594
patch: ++ * * iter ; } /
rank: 296
score: 98.5767822265625
patch: iter ++ ; ++ iter ; ;
rank: 296
score: 98.53778076171875
patch: throw new Unsupported CaMeL Operation CaMeL Exception ( ) ; ++ iter ;
rank: 297
score: 99.00913492838542
patch: ++ iter ; int f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 297
score: 98.96592494419643
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( 1 ;
rank: 297
score: 98.9645487467448
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair extends Univariate CaMeL Point CaMeL Value CaMeL Pair > checker = null ;
rank: 297
score: 98.84105088975694
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > ;
rank: 297
score: 98.73817661830357
patch: return new Point CaMeL Value CaMeL Pair ( iter , iter , ;
rank: 297
score: 98.65757751464844
patch: else { / * * / }
rank: 297
score: 98.57656028053977
patch: ++ iter ; ++ -- iter ; ++ iter ;
rank: 297
score: 98.53759155273437
patch: while ( true )
rank: 298
score: 99.0091219815341
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = get CaMeL Goal CaMeL Type ( goal ) ;
rank: 298
score: 98.96574964021382
patch: double f CaMeL Val = ( Univariate CaMeL Point CaMeL Value CaMeL Pair ) checker . x ;
rank: 298
score: 98.96439034598214
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( this ) ;
rank: 298
score: 98.94309895833334
patch: double f CaMeL Val = f CaMeL Val ; double f CaMeL Val ;
rank: 298
score: 98.84071978400735
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair > double CaMeL Value = 0 ;
rank: 298
score: 98.73816935221355
patch: while ( iter < n ; iter ++ ) { ;
rank: 298
score: 98.65709339488636
patch: throw new Runtime CaMeL Exception ( $STRING$ + 1 ;
rank: 298
score: 98.5756607055664
patch: ++ iter ; ; if iter ;
rank: 298
score: 98.53730991908482
patch: Iterator < Point CaMeL Value CaMeL Pair > iter = ++ iter ;
rank: 299
score: 99.00885881696429
patch: double f CaMeL Val = Math . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . new CaMeL Point CaMeL And CaMeL Direction (
rank: 299
score: 98.96568467881944
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( 0 , f CaMeL Val ) ;
rank: 299
score: 98.96370239257813
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair extends Point CaMeL Value CaMeL Pair > checker =
rank: 299
score: 98.94300426136364
patch: double f CaMeL Val = f CaMeL Val ) ;
rank: 299
score: 98.840576171875
patch: tmp = Math CaMeL Arrays . copy CaMeL Of ( x . clone ( ) ) ;
rank: 299
score: 98.65707833426339
patch: if ( ! iter . is CaMeL Empty ( ; ++ iter ;
rank: 299
score: 98.57504272460938
patch: ++ start ; ++ iter ; ;
rank: 300
score: 98.963623046875
patch: final double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x . get CaMeL Value ( ) ) ;
rank: 300
score: 98.84056091308594
patch: return new Univariate CaMeL Point CaMeL Value CaMeL Pair ( f CaMeL Val ) ;
rank: 300
score: 98.73792521158855
patch: ++ iter ; if ( iter < iter ) break ;
rank: 300
score: 98.66014946831598
patch: ++ iter ; ++ iter ; ++ *
rank: 300
score: 98.65634390024039
patch: else { if ( ! iter . is CaMeL Empty ( ;
rank: 300
score: 98.57413330078126
patch: ++ iter ; ++ iter ; ++ 0 ;
rank: 300
score: 98.53634982638889
patch: ++ iter ; else { ++ iter ;
rank: 301
score: 98.96333240327381
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( f CaMeL Val . clone ( ) ) ;
rank: 301
score: 98.84052734375
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Point CaMeL Value CaMeL Pair . $STRING$ ) ;
rank: 301
score: 98.7378921508789
patch: throw new Runtime CaMeL Exception ( ;
rank: 301
score: 98.65634155273438
patch: / * * * / * ;
rank: 301
score: 98.57407448508523
patch: ++ iter ; ++ start ; } ++ iter ;
rank: 301
score: 98.5363300030048
patch: try { throw new Illegal CaMeL State CaMeL Exception ( $STRING$ ;
rank: 302
score: 99.00846915409483
patch: double f CaMeL Val = Math . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . get CaMeL Goal CaMeL Type ( ) ) ;
rank: 302
score: 98.96329398777173
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = . get CaMeL Goal CaMeL Type ( ) ;
rank: 302
score: 98.84046020507813
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( get CaMeL Goal CaMeL Type ( ) ) ;
rank: 302
score: 98.73766276041667
patch: throw new Unsupported CaMeL Operation CaMeL Exception ( ) ; } ++ n ;
rank: 302
score: 98.65910508897569
patch: / * ] iter ; * / /
rank: 302
score: 98.65632768110795
patch: Set < Object > iter = iter . length ;
rank: 302
score: 98.57313368055556
patch: ++ iter ; ++ ++ iter ; }
rank: 302
score: 98.53522283380681
patch: return new Point CaMeL Value CaMeL Pair ( iter ;
rank: 303
score: 99.008056640625
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) , x 1 ) ;
rank: 303
score: 98.96490478515625
patch: if ( f CaMeL Val == 0 ) {
rank: 303
score: 98.94131469726562
patch: int f CaMeL Val = f CaMeL Val : 0 ;
rank: 303
score: 98.83964233398437
patch: Iterator < Point CaMeL Value CaMeL Pair > ;
rank: 303
score: 98.7370849609375
patch: for ( ; ; ) { ++ iter ;
rank: 303
score: 98.65890502929688
patch: ++ * * ++ iter ; ++ iter ;
rank: 303
score: 98.65563092912946
patch: ++ iter ; break ; }
rank: 303
score: 98.57278006417411
patch: ++ iter ; -- iter ;
rank: 303
score: 98.53512573242188
patch: int iter = iter * n ;
rank: 304
score: 99.0080078125
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , ) ;
rank: 304
score: 98.9621814546131
patch: f CaMeL Val = f CaMeL Val ; f CaMeL Val = compute CaMeL Objective CaMeL Value ( ) ;
rank: 304
score: 98.83953857421875
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair do CaMeL Optimize ( ) ;
rank: 304
score: 98.7365253155048
patch: return new Point CaMeL Value CaMeL Pair ( this , iter ;
rank: 304
score: 98.65865749782986
patch: ++ iter ; int * ++ iter ;
rank: 304
score: 98.65555419921876
patch: Iterator iter = iter . iterator ++ ; else
rank: 304
score: 98.57255554199219
patch: if iter * ; ++ iter ;
rank: 304
score: 98.53376116071429
patch: while ( ! iter . is CaMeL Empty ( ; ) ) {
rank: 305
score: 99.00792100694444
patch: d = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of (
rank: 305
score: 98.96441243489583
patch: double iter = Math CaMeL Arrays . copy CaMeL Of ( n ) ;
rank: 305
score: 98.96210479736328
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = 1 ;
rank: 305
score: 98.94094613882211
patch: final double f CaMeL Val = f CaMeL Val - 0 ;
rank: 305
score: 98.83948771158855
patch: return Point CaMeL Value CaMeL Pair . new CaMeL Point CaMeL And CaMeL Direction ( x 1 , f CaMeL Val ) ;
rank: 305
score: 98.7364990234375
patch: return new Point CaMeL Value CaMeL Pair ( x , iter , x ;
rank: 305
score: 98.6586026278409
patch: ++ iter ; ++ iter ; ++ * * /
rank: 305
score: 98.65543619791667
patch: if ( ! iter . is CaMeL Empty ( ) ) . ; else
rank: 305
score: 98.5722989169034
patch: ++ iter ; ; ++ iter ; -- iter ;
rank: 305
score: 98.53343616832386
patch: try { iter = iter . read ( ) ;
rank: 306
score: 99.00781928168402
patch: double f CaMeL Val 1 = compute CaMeL Objective CaMeL Value ( f CaMeL Val ) ;
rank: 306
score: 98.94066097861842
patch: final int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( direc ) ;
rank: 306
score: 98.8393887606534
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > ++ iter = 0 ;
rank: 306
score: 98.73618570963542
patch: return new Point CaMeL Value CaMeL Pair ( iter ; }
rank: 306
score: 98.65801323784723
patch: ++ iter ; break ; int iter ;
rank: 306
score: 98.65528700086806
patch: else { iter * * * / }
rank: 306
score: 98.53317495492789
patch: float n = Math . max ( iter , n ) ;
rank: 307
score: 99.0072265625
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ;
rank: 307
score: 98.9631103515625
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ; {
rank: 307
score: 98.96142578125
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( $NUMBER$ ) ;
rank: 307
score: 98.94055989583333
patch: final int f CaMeL Val = f CaMeL Val + f CaMeL Val ;
rank: 307
score: 98.8393798828125
patch: if ( ! f CaMeL Val . is CaMeL Empty ( ) ) {
rank: 307
score: 98.73615180121527
patch: while ( iter ; ) ++ iter ;
rank: 307
score: 98.65713840060764
patch: ++ iter ; else if ++ iter ;
rank: 307
score: 98.65525124289773
patch: if ( iter == null ; return false ; }
rank: 307
score: 98.57108764648437
patch: ++ iter ; ++ n ; -- iter ;
rank: 307
score: 98.53219839242789
patch: try { throw new Illegal CaMeL State CaMeL Exception ( ) ;
rank: 308
score: 99.007109375
patch: double f CaMeL Val = Univariate CaMeL Point CaMeL Value CaMeL Pair . f CaMeL Val ; double f CaMeL Val = 0 ;
rank: 308
score: 98.96129789806548
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x . to CaMeL String ( ) ) ;
rank: 308
score: 98.9405517578125
patch: double [ ] x = x . get CaMeL Value ( ) ;
rank: 308
score: 98.83931884765624
patch: return compute CaMeL Objective CaMeL Value ( x ,
rank: 308
score: 98.73612467447917
patch: ++ iter ; if ( iter < n ) continue ;
rank: 308
score: 98.656982421875
patch: ++ iter ; ++ 1 ; break ;
rank: 308
score: 98.65515747070313
patch: if ( iter == null ; ++ iter ;
rank: 308
score: 98.57095772879464
patch: ++ iter ; ++ * ;
rank: 308
score: 98.53130548650569
patch: int n = iter . read ( x ) ;
rank: 309
score: 99.00679285386029
patch: double f CaMeL Val = f CaMeL Val ; int f CaMeL Val = 0 ;
rank: 309
score: 98.94041041324013
patch: int f CaMeL Val = f CaMeL Val : compute CaMeL Objective CaMeL Value ( x ) ;
rank: 309
score: 98.839111328125
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair int CaMeL Value = 0 ;
rank: 309
score: 98.73400268554687
patch: ++ iter ; while ( ; ) { ;
rank: 309
score: 98.65488106863839
patch: synchronized ( . is CaMeL Empty ( ) ; return iter ; }
rank: 309
score: 98.57057698567708
patch: ++ iter ; ++ Math + iter ;
rank: 309
score: 98.53060913085938
patch: if ( ++ n == 0 )
rank: 310
score: 98.96239420572917
patch: double iter = compute CaMeL Objective CaMeL Value ( f CaMeL Val ) ;
rank: 310
score: 98.96076965332031
patch: double f CaMeL Val = f CaMeL Val . search ( x 1 ) ;
rank: 310
score: 98.83900390625
patch: Iterator < Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair >
rank: 310
score: 98.65597873263889
patch: ++ * * / / ++ iter ;
rank: 310
score: 98.65435791015625
patch: Set < ? > iter = iter . iterator ++ ;
rank: 310
score: 98.57008192274306
patch: ++ iter ; ++ iter ; null ;
rank: 310
score: 98.53038787841797
patch: ++ iter 1 [ n ] ;
rank: 311
score: 99.00639415922619
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , false ) ;
rank: 311
score: 98.96234130859375
patch: int x = f CaMeL Val . clone ( ) ;
rank: 311
score: 98.94026453354779
patch: double start = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 311
score: 98.7334493001302
patch: ++ iter ; throw new Runtime CaMeL Exception ( $STRING$ ;
rank: 311
score: 98.65469021267361
patch: else if ++ iter ; ++ iter ;
rank: 311
score: 98.65431906960227
patch: Set < Integer > iter = iter . length ;
rank: 311
score: 98.56985473632812
patch: ++ iter ; ++ iter ; / / ;
rank: 311
score: 98.52751020951705
patch: input = new char [ n ] [ ] ;
rank: 312
score: 99.00634765625
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . n ) ;
rank: 312
score: 98.94019272748162
patch: double f CaMeL Val = f CaMeL Val . get CaMeL Point ( x ) ;
rank: 312
score: 98.83856879340277
patch: Iterator < Point CaMeL Value CaMeL Pair protected Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair {
rank: 312
score: 98.73275052584134
patch: return new Point CaMeL Value CaMeL Pair ( x , x ;
rank: 312
score: 98.65400041852679
patch: ++ * iter ; * /
rank: 312
score: 98.56982421875
patch: ++ $STRING$ ; ; ++ iter ;
rank: 312
score: 98.52675083705357
patch: ++ iter ; while ( iter != null ) { ++ iter ;
rank: 313
score: 98.96205139160156
patch: int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( x ;
rank: 313
score: 98.95894949776786
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > = line . get CaMeL Value ( ) ;
rank: 313
score: 98.83843994140625
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( x , iter ) ;
rank: 313
score: 98.7314682006836
patch: ++ iter ] [ iter ] ;
rank: 313
score: 98.65444607204861
patch: ++ iter ; ++ - iter ; ;
rank: 313
score: 98.65375627790179
patch: return iter [ 0 ] ;
rank: 313
score: 98.56898328993056
patch: ++ iter ; ++ iter ; ++ ;
rank: 313
score: 98.5267001065341
patch: while ( iter == n ) { ++ iter ;
rank: 314
score: 99.00611514136905
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , $STRING$ ) ;
rank: 314
score: 98.93987274169922
patch: double f CaMeL Val = ( f CaMeL Val + f CaMeL Val ) ;
rank: 314
score: 98.83784623579545
patch: return new Point CaMeL Value CaMeL Pair ( Point CaMeL Value CaMeL Pair . line . clone ( ) ) ;
rank: 314
score: 98.65335422092014
patch: if ( iter < $NUMBER$ ; * /
rank: 314
score: 98.56891424005681
patch: ++ iter ; ++ iter ; ++ iter ; else
rank: 314
score: 98.52659098307292
patch: pos = Math . max ( 0 , n ) ;
rank: 315
score: 98.95810953776042
patch: double [ ] x = line . clone ( ) ;
rank: 315
score: 98.9398681640625
patch: double f CaMeL Val = x . get CaMeL Value ( 0 ) ;
rank: 315
score: 98.83760579427083
patch: return new Point CaMeL Value CaMeL Pair ( Point CaMeL Value CaMeL Pair . x ) ;
rank: 315
score: 98.6539306640625
patch: ++ * / ++ iter ; ++ iter ;
rank: 315
score: 98.65316772460938
patch: Set iter = iter . length ; while ;
rank: 315
score: 98.56862967354911
patch: ++ false ; ++ iter ;
rank: 315
score: 98.52623748779297
patch: int iter = iter - n ;
rank: 316
score: 99.00592041015625
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . this . direc ) ;
rank: 316
score: 98.96176292782738
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = checker . do CaMeL Optimize ( ) ;
rank: 316
score: 98.95701497395834
patch: double iter = Math CaMeL Arrays . abs ( f CaMeL Val ) ;
rank: 316
score: 98.9396484375
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x 1 ;
rank: 316
score: 98.6529541015625
patch: i * ++ ; if ++ iter ;
rank: 316
score: 98.65248107910156
patch: / * * * ++ * ;
rank: 316
score: 98.56854858398438
patch: ++ iter ; ++ iter ; else iter ;
rank: 317
score: 99.00591571514423
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math . copy CaMeL Of ( f CaMeL Val ) ) ;
rank: 317
score: 98.95662434895833
patch: Point CaMeL Value CaMeL Pair checker = new Point CaMeL Value CaMeL Pair ( x ) ;
rank: 317
score: 98.83737618582589
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( x ) ;
rank: 317
score: 98.73051452636719
patch: if ( iter < iter ) {
rank: 317
score: 98.6524658203125
patch: else { * * * / /
rank: 317
score: 98.56764221191406
patch: ++ ++ 0 ; ++ iter ;
rank: 318
score: 98.961669921875
patch: delta = Math . copy CaMeL Of ( f CaMeL Val , f CaMeL Val ) ;
rank: 318
score: 98.95654296875
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = . new CaMeL Point CaMeL And CaMeL Direction ( x ) ;
rank: 318
score: 98.93815612792969
patch: final double f CaMeL Val = compute CaMeL Objective CaMeL Value ( length ) ;
rank: 318
score: 98.837255859375
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( x . clone ( ) ) ;
rank: 318
score: 98.72978515625
patch: ++ iter ; if ( iter < iter )
rank: 318
score: 98.65214538574219
patch: else { n += iter ; }
rank: 318
score: 98.65212673611111
patch: else { ++ iter ; while iter ;
rank: 318
score: 98.56697082519531
patch: ++ iter ; ++ start ; else
rank: 318
score: 98.52501569475446
patch: return new Point CaMeL Value CaMeL Pair ( ; ++ iter ) ;
rank: 319
score: 99.00555710565476
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , null ) ;
rank: 319
score: 98.96158541165866
patch: double f CaMeL Val = f CaMeL Val [ 0 ] ;
rank: 319
score: 98.95649937220982
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( double ) ;
rank: 319
score: 98.83709716796875
patch: n = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 319
score: 98.72964816623264
patch: if ( iter <= n ) break ;
rank: 319
score: 98.65169270833333
patch: if ( . is CaMeL Empty ( ) ) . ++ iter ; }
rank: 319
score: 98.65013970269098
patch: ++ iter ; ++ - x iter ;
rank: 319
score: 98.56692165798611
patch: ++ iter ; ++ iter ; ++ iter
rank: 319
score: 98.5233154296875
patch: throw new Unsupported CaMeL Operation CaMeL Exception ( $STRING$ + iter ;
rank: 320
score: 99.0054931640625
patch: double f CaMeL Val = f CaMeL Val $NUMBER$ . clone ( ) ;
rank: 320
score: 98.83685980902777
patch: result = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , 0 ) ;
rank: 320
score: 98.7293472290039
patch: ++ iter ; * iter ++ ;
rank: 320
score: 98.65079074435764
patch: i ] [ 0 ] = iter ;
rank: 320
score: 98.56651475694444
patch: ++ iter ; iter / * * /
rank: 320
score: 98.52321213942308
patch: Iterator < Object > iter = iter . iterator ( ) ;
rank: 321
score: 99.00520833333333
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val . length ) ;
rank: 321
score: 98.96070498511905
patch: double f CaMeL Val = f CaMeL Val + Fast CaMeL Math . copy CaMeL Of ( x ) ;
rank: 321
score: 98.93645562065973
patch: double [ ] = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 321
score: 98.83676147460938
patch: Iterator < Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ( f CaMeL Val ) ;
rank: 321
score: 98.6507339477539
patch: ++ [ ] iter ; if ;
rank: 321
score: 98.64962429470486
patch: i * * * / ++ iter ;
rank: 321
score: 98.56597345525569
patch: ++ iter ; iter } ++ ; ++ iter ;
rank: 321
score: 98.52261962890626
patch: if ( ++ iter ) { ++ iter ;
rank: 322
score: 99.00456237792969
patch: double f CaMeL Val = Math . copy CaMeL Of ( f CaMeL Val ;
rank: 322
score: 98.95471909466912
patch: double [ ] x 1 = f CaMeL Val . get CaMeL Value ( ) ;
rank: 322
score: 98.83669562088816
patch: return get CaMeL Goal CaMeL Type ( f CaMeL Val ) . get CaMeL Point ( ) ;
rank: 322
score: 98.7279052734375
patch: ++ iter ; while ( true ; )
rank: 322
score: 98.65062604631696
patch: ++ * * * iter ;
rank: 322
score: 98.56572129991319
patch: ++ iter ; ; iter return iter ;
rank: 322
score: 98.52237955729167
patch: ++ iter ; else {
rank: 323
score: 99.0044696514423
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( iter ) ) ;
rank: 323
score: 98.9601818266369
patch: int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , 1 ) ;
rank: 323
score: 98.95436604817708
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = new CaMeL Point CaMeL And CaMeL Direction ( 1 ) ;
rank: 323
score: 98.93583984375
patch: double f CaMeL Val = line . get CaMeL Value ( 0 ) ;
rank: 323
score: 98.83658175998264
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( f CaMeL Val , 0 ) ;
rank: 323
score: 98.72676908052884
patch: return new Point CaMeL Value CaMeL Pair ( start , iter ;
rank: 323
score: 98.56563720703124
patch: ++ iter ; ++ name ; ++ iter ;
rank: 323
score: 98.5223617553711
patch: if ( iter == - 1 )
rank: 324
score: 98.96005588107639
patch: final double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( n ) ;
rank: 324
score: 98.9354717548077
patch: double n = Math . abs ( f CaMeL Val ) ;
rank: 324
score: 98.83598109654018
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair Point CaMeL Value CaMeL Pair )
rank: 324
score: 98.7261734008789
patch: while ( iter <= iter ) {
rank: 324
score: 98.65011596679688
patch: else { return iter ; ; }
rank: 324
score: 98.64853922526042
patch: ++ n ; ++ iter ; iter ;
rank: 324
score: 98.5655517578125
patch: ++ iter ; ++ ++ 1 ; ++ iter ;
rank: 324
score: 98.52217320033482
patch: throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + n + ;
rank: 325
score: 99.00406588040866
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . x 1 ) ;
rank: 325
score: 98.95381496263587
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( f CaMeL Val . get CaMeL Point ( ) ) ;
rank: 325
score: 98.9352139559659
patch: int [ ] x 1 = f CaMeL Val ;
rank: 325
score: 98.83559283088235
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( x , x $NUMBER$ ) ;
rank: 325
score: 98.72609165736607
patch: return new Point CaMeL Value CaMeL Pair ( ++ n , iter ;
rank: 325
score: 98.64980061848958
patch: if ( . is CaMeL Empty ( ) ; break ;
rank: 325
score: 98.64825439453125
patch: / * ++ 1 ; ++ iter ;
rank: 325
score: 98.56377495659723
patch: ++ iter ; ++ iter ; = iter
rank: 326
score: 99.00398763020833
patch: double value = Math . copy CaMeL Of ( f CaMeL Val ) ;
rank: 326
score: 98.95936686197916
patch: int f CaMeL Val = Math . copy CaMeL Of ( direc [
rank: 326
score: 98.95357513427734
patch: final int f CaMeL Val = compute CaMeL Objective CaMeL Value ( 0 ) ;
rank: 326
score: 98.83547973632812
patch: i = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 326
score: 98.72592163085938
patch: ++ iter ; double ++ iter ;
rank: 326
score: 98.64920479910714
patch: if ( iter ; break ;
rank: 326
score: 98.56144205729167
patch: ++ iter ; ++ $STRING$ + iter ;
rank: 326
score: 98.5201885516827
patch: int iter = Math . max ( n , n ) ;
rank: 327
score: 99.00387234157986
patch: d = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , 0 ) ;
rank: 327
score: 98.95933024088542
patch: int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ;
rank: 327
score: 98.93448893229167
patch: int f CaMeL Val [ ] = f CaMeL Val ;
rank: 327
score: 98.83529663085938
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair > direc = 0 ;
rank: 327
score: 98.72568359375
patch: return new Point CaMeL Value CaMeL Pair ( iter , iter ) ; }
rank: 327
score: 98.64920247395834
patch: if ( iter != null || iter . is CaMeL Empty ( ) ;
rank: 327
score: 98.64794921875
patch: ++ iter ; ++ iter ; ++ - 1 ;
rank: 327
score: 98.56138780381944
patch: } ++ iter ; ++ iter ; }
rank: 328
score: 99.00385573814656
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . line . clone ( ) ) ;
rank: 328
score: 98.952294921875
patch: f CaMeL Val = f CaMeL Val . search ( x $NUMBER$ ) ;
rank: 328
score: 98.93387044270834
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = line CaMeL
rank: 328
score: 98.83524576822917
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair > iter = null ;
rank: 328
score: 98.72554154829545
patch: ++ iter ; if ( iter < iter ) {
rank: 328
score: 98.649169921875
patch: int iter = iter . length ;
rank: 328
score: 98.64739990234375
patch: ++ 0 ; ++ iter ; iter ;
rank: 328
score: 98.56114366319444
patch: ++ iter ; iter / / ++ ;
rank: 328
score: 98.51969909667969
patch: ++ iter . start ( ) ;
rank: 329
score: 99.00384928385417
patch: double f CaMeL Val $NUMBER$ = f CaMeL Val + f CaMeL Val ;
rank: 329
score: 98.95131225585938
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair && checker . get CaMeL Value ( ) ;
rank: 329
score: 98.93369547526042
patch: double f CaMeL Val = Math . ( f CaMeL Val , f CaMeL Val ) ;
rank: 329
score: 98.83512660435268
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair
rank: 329
score: 98.72547200520833
patch: return new Point CaMeL Value CaMeL Pair ( x , iter , ; }
rank: 329
score: 98.64913940429688
patch: } if ++ [ 0 ] ;
rank: 329
score: 98.64725748697917
patch: ++ iter ; int iter + 0 ;
rank: 329
score: 98.51969604492187
patch: if ( ++ n < iter . length )
rank: 330
score: 99.00341796875
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( line . get CaMeL Value ( ) ) ;
rank: 330
score: 98.9512451171875
patch: double [ ] iter = f CaMeL Val ;
rank: 330
score: 98.83500162760417
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( x 1 ) ;
rank: 330
score: 98.6478780110677
patch: if ( ! iter . is CaMeL Empty ++ 0 )
rank: 330
score: 98.64711507161458
patch: ++ * ] iter ;
rank: 330
score: 98.55902099609375
patch: ++ iter ; iter / ;
rank: 330
score: 98.51856340680804
patch: try { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ; }
rank: 331
score: 99.00303071120689
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . direc [ 0 ] ) ;
rank: 331
score: 98.83478461371527
patch: result = Math CaMeL Arrays . copy CaMeL Of ( x , f CaMeL Val ) ;
rank: 331
score: 98.72444661458333
patch: ++ iter ; * / * * ;
rank: 331
score: 98.64743041992188
patch: * * * * / } /
rank: 331
score: 98.64703369140625
patch: ++ * ++ iter ; ++ 1 ;
rank: 331
score: 98.55796508789062
patch: ++ n ; ++ iter ; ++ start ;
rank: 331
score: 98.51801147460938
patch: ++ iter ; while ( iter == 1 )
rank: 332
score: 99.00270182291666
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( x , f CaMeL Val ) ) ;
rank: 332
score: 98.95907592773438
patch: int f CaMeL Val = ( f CaMeL Val - f CaMeL Val ) ;
rank: 332
score: 98.950927734375
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = this . get CaMeL Value ( ) ;
rank: 332
score: 98.93309783935547
patch: double [ ] f CaMeL Val = checker . get CaMeL Value ( ) ;
rank: 332
score: 98.83448327105978
patch: return Point CaMeL Value CaMeL Pair . new CaMeL Point CaMeL And CaMeL Direction ( x . clone ( ) ) ;
rank: 332
score: 98.72374471028645
patch: ++ iter * iter ;
rank: 332
score: 98.64696655273437
patch: if ( iter == 0 ; break ; }
rank: 332
score: 98.64687771267361
patch: ++ * ++ iter ; int iter ;
rank: 332
score: 98.55763462611607
patch: ++ iter ; iter * ;
rank: 332
score: 98.5178731282552
patch: j = Math . max ( 0 , n ) ;
rank: 333
score: 99.00259602864584
patch: double f CaMeL Val $NUMBER$ = compute CaMeL Objective CaMeL Value ( ) ;
rank: 333
score: 98.95085991753473
patch: final double [ ] f CaMeL Val = compute CaMeL Objective CaMeL Value ( 0 ) ;
rank: 333
score: 98.93283315805289
patch: double f CaMeL Val = f CaMeL Val ; ++ iter ;
rank: 333
score: 98.83448137555804
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair Point CaMeL Value CaMeL Pair {
rank: 333
score: 98.72303466796875
patch: while ( iter ; ) { ++ iter ;
rank: 333
score: 98.64689636230469
patch: if ( iter == 0 ; }
rank: 333
score: 98.64543999565973
patch: ++ iter ; ++ / * / /
rank: 333
score: 98.55736694335937
patch: ++ iter ; ++ start ; ++ start ;
rank: 333
score: 98.5177001953125
patch: List < String > iter = iter . iterator ( ) ;
rank: 334
score: 99.00221252441406
patch: final double f CaMeL Val = copy CaMeL Of ( f CaMeL Val ) ;
rank: 334
score: 98.95074172247024
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = . get CaMeL Point ( ) ;
rank: 334
score: 98.83447265625
patch: Iterator < Point CaMeL Value CaMeL Pair Point CaMeL Value CaMeL Pair > iter = 0 ;
rank: 334
score: 98.72244966947116
patch: ++ iter ; if ( iter == - 1 ) break ;
rank: 334
score: 98.64689636230469
patch: / * * ; * / }
rank: 334
score: 98.64402262369792
patch: } ++ iter ; if ++ iter ;
rank: 334
score: 98.55692749023437
patch: ++ iter ; ++ iter ; += iter ;
rank: 335
score: 99.00206580528847
patch: int f CaMeL Val = Math . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ) ;
rank: 335
score: 98.9587043313419
patch: int n = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 335
score: 98.95042660361842
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = this . f CaMeL Val ;
rank: 335
score: 98.83437674386161
patch: Iterator < Point CaMeL Value CaMeL Pair ( f CaMeL Val ) ;
rank: 335
score: 98.72119750976563
patch: if ( iter < n ; iter ++ ;
rank: 335
score: 98.64652252197266
patch: else { ++ * $NUMBER$ ; }
rank: 335
score: 98.64247824928977
patch: ++ iter ; ++ iter ; for iter ++ ;
rank: 335
score: 98.55683051215277
patch: ++ iter ; iter / ; * /
rank: 335
score: 98.51490129743304
patch: float n = ++ n ;
rank: 336
score: 99.00204613095238
patch: double f CaMeL Val = Math . copy CaMeL Of ( f CaMeL Val . clone ( ) ) ;
rank: 336
score: 98.93250796669408
patch: double f CaMeL Val $NUMBER$ = Math CaMeL Arrays . copy CaMeL Of ( direc ) ;
rank: 336
score: 98.83433837890625
patch: return get CaMeL Goal CaMeL Type ( f CaMeL Val ) . get CaMeL Value ( ) ; }
rank: 336
score: 98.6461690266927
patch: if ( . is CaMeL Empty ( ) ) break ;
rank: 336
score: 98.55568150111607
patch: ++ iter ; ++ true ;
rank: 336
score: 98.514697265625
patch: if ( ++ n > 0 ) break ;
rank: 337
score: 99.00201125372024
patch: double [ ] f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 337
score: 98.95748098273026
patch: double f CaMeL Val = ( Univariate CaMeL Point CaMeL Value CaMeL Pair ) 0 . 1 ;
rank: 337
score: 98.94947451636905
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair extends Point CaMeL Value CaMeL Pair > checker = null ;
rank: 337
score: 98.93191867404514
patch: final double f CaMeL Val = compute CaMeL Objective CaMeL Value ( int CaMeL Value ) ;
rank: 337
score: 98.83357421875
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair [ ] }
rank: 337
score: 98.72042846679688
patch: if ( iter > 0 ) { ++ iter ; }
rank: 337
score: 98.64576212565105
patch: while ( ! iter . is CaMeL Empty ( ; )
rank: 337
score: 98.55430908203125
patch: ++ iter ; ++ iter ; ++ $NUMBER$ ;
rank: 338
score: 99.0019287109375
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( 0 , f CaMeL Val ) ;
rank: 338
score: 98.83343864889706
patch: int f CaMeL Val = compute CaMeL Objective CaMeL Value ( x , x ) ;
rank: 338
score: 98.7200439453125
patch: return new Point CaMeL Value CaMeL Pair ( ++ iter , x ) ;
rank: 338
score: 98.63817487444196
patch: * * ++ iter ; /
rank: 338
score: 98.55428059895833
patch: ++ iter + iter ;
rank: 339
score: 99.00179349459134
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . direc ) ;
rank: 339
score: 98.8331298828125
patch: return Point CaMeL Value CaMeL Pair . new CaMeL Point CaMeL And CaMeL Direction ( x , ;
rank: 339
score: 98.71971546519886
patch: ++ iter ; / * * ++ iter * /
rank: 339
score: 98.64488874162946
patch: if ( ! iter . is CaMeL Empty ( ; > 0 )
rank: 339
score: 98.63811577690973
patch: ++ iter ; while ++ - iter ;
rank: 339
score: 98.55381081321023
patch: ++ iter ; ++ iter ; } ++ start ;
rank: 339
score: 98.5137430826823
patch: if ( ++ iter )
rank: 340
score: 99.00160435267857
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , guess ) ;
rank: 340
score: 98.95720966045673
patch: double f CaMeL Val = x . search ( 0 ) ;
rank: 340
score: 98.94719848632812
patch: double [ ] f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( direc ) ;
rank: 340
score: 98.93047332763672
patch: double iter = x . to CaMeL String ( ) . clone ( ) ;
rank: 340
score: 98.83270622702206
patch: Iterator < Point CaMeL Value CaMeL Pair , Univariate CaMeL Point CaMeL Value CaMeL Pair >
rank: 340
score: 98.71942138671875
patch: ++ iter ; iter += iter ;
rank: 340
score: 98.64480590820312
patch: synchronized ( . is CaMeL Empty ( ) ; * /
rank: 340
score: 98.63508436414931
patch: / ; ++ iter ; while iter ;
rank: 340
score: 98.55375162760417
patch: ++ iter ; ; iter / / /
rank: 340
score: 98.5135967548077
patch: Iterator < E > iter = iter . iterator ( ) ;
rank: 341
score: 99.0015536221591
patch: final double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( this . f CaMeL Val ) ;
rank: 341
score: 98.95710584852431
patch: double f CaMeL Val = new Univariate CaMeL Point CaMeL Value CaMeL Pair ( 0 ) ;
rank: 341
score: 98.94690755208333
patch: final double iter = f CaMeL Val . get CaMeL Point ( ) ;
rank: 341
score: 98.93039376395089
patch: double [ ] f CaMeL Val = x . clone ( ) ;
rank: 341
score: 98.83267324942129
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . double CaMeL Value ;
rank: 341
score: 98.71884155273438
patch: ++ iter ; * / * * * /
rank: 341
score: 98.64466857910156
patch: return ++ [ 1 ] ; }
rank: 341
score: 98.63502197265625
patch: ++ 1 ; ++ iter ; for iter ;
rank: 341
score: 98.55352783203125
patch: ++ iter ; ++ iter ; try }
rank: 341
score: 98.51275079900569
patch: if ( f CaMeL Val == null ) continue ;
rank: 342
score: 99.001181640625
patch: double f CaMeL Val = ( Univariate CaMeL Point CaMeL Value CaMeL Pair ) checker . get CaMeL Goal CaMeL Type ( ) ;
rank: 342
score: 98.71829986572266
patch: while ( iter ; ; ) {
rank: 342
score: 98.6445068359375
patch: if ( ! iter . is CaMeL Empty ( ; return . length ;
rank: 342
score: 98.63455539279514
patch: ++ iter ; ++ / * iter ;
rank: 342
score: 98.55295817057292
patch: ++ iter = iter ;
rank: 343
score: 99.00077681107955
patch: ++ iter ; double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 343
score: 98.956884765625
patch: ( ( Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > ) {
rank: 343
score: 98.93000030517578
patch: double [ ] f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ,
rank: 343
score: 98.83170166015626
patch: Iterator < Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > direc = 0 ;
rank: 343
score: 98.64437866210938
patch: ++ * * * ; * /
rank: 343
score: 98.63455539279514
patch: / * ; ++ iter ; * /
rank: 343
score: 98.55293104383681
patch: ++ iter ; ++ iter ; else iter
rank: 343
score: 98.51073201497395
patch: throw new Unsupported CaMeL Operation CaMeL Exception ( $STRING$ + ;
rank: 344
score: 99.00077311197917
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( x ;
rank: 344
score: 98.9460216703869
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = new CaMeL Point CaMeL And CaMeL Direction (
rank: 344
score: 98.83124138327206
patch: return new CaMeL Point CaMeL And CaMeL Direction ( f CaMeL Val , 0 ) ;
rank: 344
score: 98.71802867542614
patch: if ( iter < n ) { ++ iter ;
rank: 344
score: 98.64399937220982
patch: if ( ! iter . is CaMeL Empty ++ ) . ; else
rank: 344
score: 98.63453258167614
patch: ++ iter ; ++ iter ; ++ * iter ;
rank: 344
score: 98.55260552300348
patch: ++ iter ; iter ; -- iter ;
rank: 344
score: 98.51056377704327
patch: int iter = iter . iterator ( ) ; ++ iter ;
rank: 345
score: 98.9989901455966
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > < Univariate CaMeL Point CaMeL Value CaMeL Pair > ;
rank: 345
score: 98.95667085193452
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( direc [ 1 ] ) ;
rank: 345
score: 98.94581240699405
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = super . get CaMeL Value ( ) ;
rank: 345
score: 98.92910531850961
patch: double f CaMeL Val = f CaMeL Val [ iter ] ;
rank: 345
score: 98.83120930989584
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair > checker = 0 ;
rank: 345
score: 98.64395141601562
patch: ++ [ ] [ ] ; }
rank: 345
score: 98.63437228732639
patch: else { ++ iter ; ++ iter ;
rank: 345
score: 98.55152476917614
patch: ++ iter ; iter = iter ; ++ iter ;
rank: 345
score: 98.51027134486607
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + ++ n ;
rank: 346
score: 98.95653134300595
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( direc [ n ] ) ;
rank: 346
score: 98.9452734375
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > = Math CaMeL Arrays . copy CaMeL Of ( direc ) ;
rank: 346
score: 98.83101981026786
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > checker = 0 ;
rank: 346
score: 98.71745300292969
patch: ++ iter ; } ++ n ;
rank: 346
score: 98.64391072591145
patch: synchronized ( . is CaMeL Empty ( ) ) { }
rank: 346
score: 98.63353271484375
patch: try { ++ iter ; ++ iter ; }
rank: 346
score: 98.54932861328125
patch: ++ n ; ++ iter ; return iter ;
rank: 346
score: 98.50979178292411
patch: return new Point CaMeL Value CaMeL Pair ( n , x ) ;
rank: 347
score: 98.99891246448864
patch: final double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , x ) ;
rank: 347
score: 98.94518512228261
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > < Point CaMeL Value CaMeL Pair > checker = null ;
rank: 347
score: 98.9285824424342
patch: double [ ] f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( direc ;
rank: 347
score: 98.83099724264706
patch: Integer f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( x ) ;
rank: 347
score: 98.71683349609376
patch: ++ iter ; if ( iter == 0 ;
rank: 347
score: 98.64365931919643
patch: if ( ! iter . is CaMeL Empty ++ ) . max ;
rank: 347
score: 98.63316514756944
patch: / * ] * ; ++ iter ;
rank: 347
score: 98.54930419921875
patch: ++ n ; ++ iter ; ++ n ;
rank: 347
score: 98.50959123883929
patch: if ( ! iter . is CaMeL Empty ( ) ++ n )
rank: 348
score: 98.99871271306819
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , 0 . 0 ) ;
rank: 348
score: 98.95586081112133
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( 0 , 0 ) ;
rank: 348
score: 98.94468470982143
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair > [ ] ;
rank: 348
score: 98.92833455403645
patch: double f CaMeL Val = f CaMeL Val + $NUMBER$ ;
rank: 348
score: 98.83075561523438
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair < Univariate CaMeL Point CaMeL Value CaMeL Pair > }
rank: 348
score: 98.71673583984375
patch: ++ iter ; for ; ; )
rank: 348
score: 98.64344787597656
patch: if ++ [ 1 ] ; }
rank: 348
score: 98.63315158420139
patch: / * ] 1 ; ++ iter ;
rank: 348
score: 98.54869495738636
patch: ++ iter ; else ++ iter ; ++ iter ;
rank: 348
score: 98.50914001464844
patch: float n = iter * iter ;
rank: 349
score: 98.94463752297794
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker ( checker ) ;
rank: 349
score: 98.92822265625
patch: double f CaMeL Val = ( f CaMeL Val * f CaMeL Val ) ;
rank: 349
score: 98.83058518629808
patch: return new CaMeL Point CaMeL And CaMeL Direction ( x ) ;
rank: 349
score: 98.71670968191964
patch: return new Point CaMeL Value CaMeL Pair ( x , iter ; }
rank: 349
score: 98.6429912860577
patch: if ( ! iter . is CaMeL Empty ( this ) ;
rank: 349
score: 98.6329345703125
patch: ++ iter ; ++ * / / /
rank: 349
score: 98.5485506924716
patch: ++ iter ; ++ iter ; else = iter ;
rank: 349
score: 98.50884137834821
patch: return new Point CaMeL Value CaMeL Pair ( ; ++ n ) ;
rank: 350
score: 98.99847881610577
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( ( Univariate CaMeL Point CaMeL Value CaMeL Pair ) checker ) ;
rank: 350
score: 98.92792711759868
patch: final double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ,
rank: 350
score: 98.83027729235198
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( x 1 , f CaMeL Val ) ;
rank: 350
score: 98.71577962239583
patch: ++ iter ; / * * * /
rank: 350
score: 98.64286041259766
patch: ++ * * iter ; / /
rank: 350
score: 98.63165283203125
patch: / * ] iter ; if iter ;
rank: 350
score: 98.54847412109375
patch: ++ iter ; ++ this ; ++ iter ;
rank: 350
score: 98.50840407151442
patch: ++ iter ; throw new Illegal CaMeL Argument CaMeL Exception ; }
rank: 351
score: 98.99785766601562
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > < Point CaMeL Value CaMeL Pair > {
rank: 351
score: 98.95482042100694
patch: int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ,
rank: 351
score: 98.94405110677083
patch: final double [ ] x 1 = f CaMeL Val ;
rank: 351
score: 98.92768940172698
patch: double f CaMeL Val = f CaMeL Val ; int f CaMeL Val = f CaMeL Val ;
rank: 351
score: 98.82994733537946
patch: Math CaMeL Arrays . copy CaMeL Of ( x , iter ) ;
rank: 351
score: 98.71568806966145
patch: ++ iter - $NUMBER$ ;
rank: 351
score: 98.64273834228516
patch: / * ++ iter * / }
rank: 351
score: 98.54819557883523
patch: ++ iter ; ++ iter ; else throw iter ;
rank: 351
score: 98.50828552246094
patch: int n = iter - iter ;
rank: 352
score: 98.99776656539352
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . to CaMeL
rank: 352
score: 98.94404039884868
patch: double [ ] f CaMeL Val = compute CaMeL Objective CaMeL Value ( f CaMeL Val ) ;
rank: 352
score: 98.92746310763889
patch: double [ ] f CaMeL Val = f CaMeL Val . get CaMeL Point ( ) ;
rank: 352
score: 98.8298972800926
patch: Iterator < Point CaMeL Value CaMeL Pair protected Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair (
rank: 352
score: 98.71553955078124
patch: ++ iter ; f CaMeL Val = ; }
rank: 352
score: 98.63070678710938
patch: ++ iter ; ++ * * / iter ;
rank: 352
score: 98.548095703125
patch: ++ iter ; ++ max - iter ;
rank: 353
score: 98.99761962890625
patch: if ( f CaMeL Val < n ) {
rank: 353
score: 98.95466918945313
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x . search ( 0 ) ) ;
rank: 353
score: 98.94399007161458
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = Math CaMeL Arrays . copy CaMeL Of ( x ) ;
rank: 353
score: 98.92721792367789
patch: final double [ ] x = Math CaMeL Arrays . copy CaMeL
rank: 353
score: 98.82948062294408
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Point CaMeL Value CaMeL Pair . get CaMeL
rank: 353
score: 98.71549769810268
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + $STRING$ ) ;
rank: 353
score: 98.64258575439453
patch: i * * * ++ iter ;
rank: 353
score: 98.63057861328124
patch: ++ iter ; try ; ++ iter ; }
rank: 353
score: 98.54808460582386
patch: ++ iter ; ++ iter ; ; iter -- ;
rank: 354
score: 98.99760509672619
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( line . clone ( ) ) ;
rank: 354
score: 98.95375413161058
patch: int iter = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 354
score: 98.9436267671131
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x . get CaMeL Size ( ) ) ;
rank: 354
score: 98.92711684283088
patch: int f CaMeL Val = f CaMeL Val . index CaMeL Of ( 0 ) ;
rank: 354
score: 98.829052734375
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Point CaMeL Value CaMeL Pair . new CaMeL Point CaMeL And CaMeL Direction (
rank: 354
score: 98.71544538225446
patch: return new Point CaMeL Value CaMeL Pair ( start , iter ) ;
rank: 354
score: 98.64251239483173
patch: if ( ! iter . is CaMeL Empty ++ ) ; }
rank: 354
score: 98.63053385416667
patch: ++ * * iter ; ++ iter ;
rank: 354
score: 98.54808213975694
patch: ++ iter ; ++ iter ; ; /
rank: 354
score: 98.50657145182292
patch: pos = Math . max ( n , n ) ;
rank: 355
score: 98.95347595214844
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( direc [
rank: 355
score: 98.94340684678819
patch: Point CaMeL Value CaMeL Pair checker = new Point CaMeL Value CaMeL Pair ( x 1 ,
rank: 355
score: 98.828857421875
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Point CaMeL Value CaMeL Pair ) ;
rank: 355
score: 98.71428087022569
patch: ++ iter ; / * ; * /
rank: 355
score: 98.64244842529297
patch: ++ [ ] += iter ; }
rank: 355
score: 98.63005913628473
patch: / * ++ iter ; * / /
rank: 355
score: 98.54745483398438
patch: ++ iter ; ++ max ; -- iter ;
rank: 355
score: 98.50656362680289
patch: if ( ! iter . is CaMeL Empty ( ) ; ;
rank: 356
score: 98.95347595214844
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ) ; ;
rank: 356
score: 98.94288219105114
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair > checker = null ;
rank: 356
score: 98.92486572265625
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( f CaMeL Val ,
rank: 356
score: 98.82862490699405
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > iter = x ;
rank: 356
score: 98.64235432942708
patch: Enumeration iter = iter . iterator ++ ;
rank: 356
score: 98.62991768973214
patch: try { ++ iter ; ;
rank: 356
score: 98.54709879557292
patch: ++ iter ; ; } ++ iter ;
rank: 356
score: 98.50538635253906
patch: if ( ++ n < iter )
rank: 357
score: 98.95334097055289
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ,
rank: 357
score: 98.94269670758929
patch: double [ ] x 1 ;
rank: 357
score: 98.82802946671195
patch: Iterator < Point CaMeL Value CaMeL Pair protected Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair {
rank: 357
score: 98.71297200520833
patch: ++ iter ; throw new Runtime CaMeL Exception ( ; }
rank: 357
score: 98.64189147949219
patch: * * * / * / }
rank: 357
score: 98.62978786892361
patch: ++ 1 ; ++ * ++ iter ;
rank: 357
score: 98.54672241210938
patch: ++ iter ; ++ start ; return iter ;
rank: 357
score: 98.50513373480902
patch: ++ iter ; while ( false ) {
rank: 358
score: 98.92411804199219
patch: final double f CaMeL Val = Math . clone ( f CaMeL Val ) ;
rank: 358
score: 98.8270263671875
patch: return new CaMeL Point CaMeL And CaMeL Direction ( x 1 , x ) ;
rank: 358
score: 98.64142400568181
patch: else throw new Runtime CaMeL Exception ( $STRING$ ; }
rank: 358
score: 98.62960379464286
patch: ++ iter ; for iter ;
rank: 358
score: 98.5050760904948
patch: int iter = 0 ; while ( iter == n )
rank: 359
score: 98.99652654474431
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair .
rank: 359
score: 98.95313178168402
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( f CaMeL Val ) ; ;
rank: 359
score: 98.94105881911058
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair >> checker ;
rank: 359
score: 98.92407904730902
patch: double f CaMeL Val = new Univariate CaMeL Point CaMeL Value CaMeL Pair ( x 1 ,
rank: 359
score: 98.71284315321181
patch: ++ iter ; if ( iter > ;
rank: 359
score: 98.62896050347223
patch: / * ] iter ; int * /
rank: 359
score: 98.54497736150569
patch: ++ iter ; ++ n ; } ++ iter ;
rank: 360
score: 98.99607747395834
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( direc [ 0 ] ) ) ;
rank: 360
score: 98.953125
patch: double [ ] f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ;
rank: 360
score: 98.94069417317708
patch: double CaMeL Value = f CaMeL Val ;
rank: 360
score: 98.92405941611842
patch: final double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( x 1 ) ;
rank: 360
score: 98.8265380859375
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Point CaMeL Value CaMeL Pair . Math CaMeL Arrays . copy CaMeL Of ( x ) ,
rank: 360
score: 98.7126131924716
patch: ++ iter ; if ( iter < n ) ;
rank: 360
score: 98.62880452473958
patch: if ++ iter ; ++ iter ; ;
rank: 360
score: 98.54423828125
patch: ++ iter ; ++ iter ; break ; }
rank: 360
score: 98.50452599158653
patch: return new Point CaMeL Value CaMeL Pair ( ; ++ iter )
rank: 361
score: 98.99588012695312
patch: final Univariate CaMeL Point CaMeL Value CaMeL Pair < double , Univariate CaMeL Point CaMeL Value CaMeL Pair ;
rank: 361
score: 98.9531005859375
patch: double f CaMeL Val = f CaMeL Val 1 . clone ( ) ;
rank: 361
score: 98.94003441220238
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = get CaMeL Start CaMeL Value ( ) ;
rank: 361
score: 98.92306082589286
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( x 1 ,
rank: 361
score: 98.82652282714844
patch: other = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 361
score: 98.71257672991071
patch: ++ iter ; new Point CaMeL Value CaMeL Pair ( iter , ;
rank: 361
score: 98.64065987723214
patch: if ( iter == null )
rank: 361
score: 98.6283935546875
patch: ++ * ++ iter ; while ++ iter ;
rank: 361
score: 98.54416910807292
patch: ++ iter ; } ++ iter ; else
rank: 361
score: 98.50422807173295
patch: int n = Math . max ( n ) ;
rank: 362
score: 98.99587673611111
patch: d = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) , 0 ) ;
rank: 362
score: 98.95225123355263
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( n , 0 ) ;
rank: 362
score: 98.9398193359375
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = new CaMeL Point CaMeL And CaMeL Direction ( 0 ) ;
rank: 362
score: 98.92303466796875
patch: double x = f CaMeL Val + f CaMeL Val ;
rank: 362
score: 98.82616424560547
patch: return Math CaMeL Arrays . copy CaMeL Of ( x 1 , iter ) ;
rank: 362
score: 98.71250406901042
patch: ++ iter * / / ++ iter ;
rank: 362
score: 98.64040902944711
patch: if ( ! iter . is CaMeL Empty ( ; continue ;
rank: 362
score: 98.62733043323864
patch: ++ iter ; if ++ iter ; ++ iter ;
rank: 362
score: 98.54406127929687
patch: ++ iter ; ++ min ; ++ iter ;
rank: 362
score: 98.50349934895833
patch: if ( f CaMeL Val != null )
rank: 363
score: 98.99586644665948
patch: double f CaMeL Val $NUMBER$ = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ) ;
rank: 363
score: 98.939755859375
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val . get CaMeL Value ( ) ) ;
rank: 363
score: 98.82588958740234
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair > ++ iter = 0 ;
rank: 363
score: 98.7122802734375
patch: return new Point CaMeL Value CaMeL Pair ( 0 , ; }
rank: 363
score: 98.64019775390625
patch: if ( ! iter . is CaMeL Empty ( ; ++ 0 ;
rank: 363
score: 98.54364691840277
patch: ++ iter ; ++ ++ iter ; else
rank: 363
score: 98.5033203125
patch: if ( iter == null ) ++ iter ;
rank: 364
score: 98.99555407072368
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ; }
rank: 364
score: 98.92265319824219
patch: double iter = x . to CaMeL String ( ) . length ( ) ;
rank: 364
score: 98.82588413783482
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Point CaMeL Value CaMeL Pair . line . get CaMeL Goal CaMeL Type ( ) ) ;
rank: 364
score: 98.63982476128473
patch: ++ * * * iter ; * /
rank: 364
score: 98.62717982700893
patch: else * / ++ iter ;
rank: 364
score: 98.5427001953125
patch: ++ iter ; ++ iter ; else * /
rank: 364
score: 98.50312151227679
patch: float n = ++ iter ;
rank: 365
score: 98.995517578125
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . line ) ;
rank: 365
score: 98.93937882133152
patch: Iterator < Point CaMeL Value CaMeL Pair > f CaMeL Val = f CaMeL Val . get CaMeL Value ( ) ;
rank: 365
score: 98.82581438337054
patch: Object f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ,
rank: 365
score: 98.7120590209961
patch: ++ iter * f CaMeL Val ;
rank: 365
score: 98.63980865478516
patch: * * * * * ; /
rank: 365
score: 98.62655300564236
patch: if ++ iter ; ++ - iter ;
rank: 365
score: 98.54248046875
patch: ++ iter ; ++ false ; ++ iter ;
rank: 366
score: 98.92193048650569
patch: f CaMeL Val = f CaMeL Val - iter ;
rank: 366
score: 98.82576497395833
patch: Iterator < Point CaMeL Value CaMeL Pair , Univariate CaMeL Point CaMeL Value CaMeL Pair > iter = 0 ;
rank: 366
score: 98.71183268229167
patch: ++ iter ; if ( iter > 0 ) break ;
rank: 366
score: 98.6397216796875
patch: if ( ! iter . is CaMeL Empty ; return iter . iter ;
rank: 366
score: 98.62651715959821
patch: ++ $NUMBER$ ; ++ 1 ;
rank: 366
score: 98.54180908203125
patch: ++ iter ; ++ iter ; -- 1 ;
rank: 366
score: 98.50180053710938
patch: float n = iter - n ;
rank: 367
score: 98.99478310032895
patch: double f CaMeL Val = Math . copy CaMeL Of ( f CaMeL Val , 1 ) ;
rank: 367
score: 98.93864302201705
patch: f CaMeL Val = f CaMeL Val ; f CaMeL Val = compute CaMeL Objective CaMeL Value ( 0 ) ;
rank: 367
score: 98.9218280498798
patch: final double f CaMeL Val = this . f CaMeL Val ;
rank: 367
score: 98.82566324869792
patch: return get CaMeL Goal CaMeL Type ( ) . get CaMeL Goal CaMeL Type ( ) . get CaMeL Value ( ) ;
rank: 367
score: 98.71134643554687
patch: ++ iter ; while ( ; ; ) {
rank: 367
score: 98.63909149169922
patch: else { / * ; * /
rank: 367
score: 98.62618582589286
patch: ++ 1 ; ++ value ;
rank: 367
score: 98.54140218098958
patch: ++ n ; ++ iter ; / /
rank: 367
score: 98.50079900568181
patch: if ( ! iter . is CaMeL Empty ; )
rank: 368
score: 98.99474676724138
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . f CaMeL Val , 0 ) ;
rank: 368
score: 98.95119018554688
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x . search ( x ) ) ;
rank: 368
score: 98.93853400735294
patch: / * Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = null ;
rank: 368
score: 98.92178344726562
patch: final double f CaMeL Val 1 = f CaMeL Val ;
rank: 368
score: 98.82553100585938
patch: return x . clone ( ) ;
rank: 368
score: 98.71107066761364
patch: ++ iter ; if ( iter == - 1 )
rank: 368
score: 98.6390625
patch: if ( iter == $NUMBER$ ; return iter ;
rank: 368
score: 98.6252108487216
patch: ++ iter ; ++ * * ; ++ iter ;
rank: 368
score: 98.5007793719952
patch: int n = Math . max ( 0 , n ) ;
rank: 369
score: 98.99451214334239
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , 0 . 0 ) ;
rank: 369
score: 98.93832058376736
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( f CaMeL Val , n ) ;
rank: 369
score: 98.92149939903847
patch: double n = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 369
score: 98.82551179108796
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair Point CaMeL Value CaMeL Pair
rank: 369
score: 98.63869803292411
patch: / * ++ * * /
rank: 369
score: 98.62476196289063
patch: / * ] iter * / ++ iter ;
rank: 369
score: 98.53965541294643
patch: ++ iter ; ++ null ;
rank: 369
score: 98.50056762695313
patch: if ( ++ n > 0 ) continue ;
rank: 370
score: 98.99434407552083
patch: ++ true ; f CaMeL Val = f CaMeL Val ;
rank: 370
score: 98.9502685546875
patch: long f CaMeL Val = compute CaMeL Objective CaMeL Value ( 0 ) ;
rank: 370
score: 98.93816583806819
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair extends Univariate CaMeL Point CaMeL Value CaMeL Pair > checker =
rank: 370
score: 98.921337890625
patch: double iter = x . iterator ( ) ;
rank: 370
score: 98.82534555288461
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair > do {
rank: 370
score: 98.71029663085938
patch: ++ iter ; while ( true ) { ++ iter ;
rank: 370
score: 98.63854108537946
patch: return ++ [ 1 ] ;
rank: 370
score: 98.62354871961806
patch: ++ iter ; while iter + 0 ;
rank: 370
score: 98.53927001953124
patch: ++ iter ; ++ iter ; else break ;
rank: 370
score: 98.50013146033653
patch: float n = Math . min ( n , n ) ;
rank: 371
score: 98.99431903545673
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ;
rank: 371
score: 98.92123894942434
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > < Point CaMeL Value CaMeL Pair ;
rank: 371
score: 98.82527669270833
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair >> iter = 0 ;
rank: 371
score: 98.70994215745192
patch: int n = Double . MAX _ VALUE ; ++ n ;
rank: 371
score: 98.6384785970052
patch: if ( ! iter . is CaMeL Empty ++ 1 )
rank: 371
score: 98.62353515625
patch: / * ++ iter ; int iter ;
rank: 371
score: 98.53892299107143
patch: ++ line ; ++ iter ;
rank: 371
score: 98.4997891512784
patch: while ( iter != null && iter == n )
rank: 372
score: 98.9943096454327
patch: int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( x ) ) ;
rank: 372
score: 98.94952751608456
patch: double f CaMeL Val = ( Univariate CaMeL Point CaMeL Value CaMeL Pair ) true ;
rank: 372
score: 98.93796793619792
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = Math CaMeL Arrays . copy CaMeL Of ( n ) ;
rank: 372
score: 98.82518717447917
patch: return compute CaMeL Objective CaMeL Value ( x . clone ( ) ) ;
rank: 372
score: 98.62284545898437
patch: ++ iter ; ++ - iter ; iter ;
rank: 372
score: 98.53790283203125
patch: ++ iter ; ; iter / ++ ;
rank: 373
score: 98.99412434895834
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) , x ) ;
rank: 373
score: 98.94935825892857
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x [
rank: 373
score: 98.93754069010417
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = new CaMeL Point CaMeL And CaMeL Direction ( checker ) ;
rank: 373
score: 98.9205258018092
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = Math CaMeL Arrays . TRUE ;
rank: 373
score: 98.82503255208333
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > }
rank: 373
score: 98.70882161458333
patch: ++ iter ; * iter += iter ;
rank: 373
score: 98.63776397705078
patch: * * * ++ iter ; }
rank: 373
score: 98.62174479166667
patch: if 0 ++ iter ; ++ iter ;
rank: 373
score: 98.49833679199219
patch: buffer . append ( $STRING$ ) ;
rank: 374
score: 98.82498873197116
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ( iter ) ;
rank: 374
score: 98.70803833007812
patch: while ( iter < n ; iter ++ )
rank: 374
score: 98.63739483173077
patch: if ( ! iter . is CaMeL Empty ( 0 ) ;
rank: 374
score: 98.62169300426136
patch: ++ iter ; ++ * * / / iter ;
rank: 374
score: 98.5375244140625
patch: ++ iter ; ++ iter ; -= iter ;
rank: 374
score: 98.49819510323661
patch: try { throw new Illegal CaMeL State CaMeL Exception ( $STRING$ ; }
rank: 375
score: 98.99392700195312
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , x . clone ( ) ) ;
rank: 375
score: 98.93728402944711
patch: double value = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 375
score: 98.82474190848214
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > n = 0 ;
rank: 375
score: 98.70675048828124
patch: if ( iter >= n ) ++ iter ;
rank: 375
score: 98.63739013671875
patch: if ( iter ; break ; }
rank: 375
score: 98.62158203125
patch: finally { ++ iter ; } ++ iter ;
rank: 375
score: 98.537353515625
patch: ++ iter ; ; ++ ++ iter ;
rank: 376
score: 98.99327087402344
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = iter ;
rank: 376
score: 98.92020670572917
patch: int f CaMeL Val = f CaMeL Val ; f CaMeL Val = f CaMeL Val ;
rank: 376
score: 98.8243408203125
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( x 1 , x $NUMBER$ ) ;
rank: 376
score: 98.70651041666666
patch: return new Point CaMeL Value CaMeL Pair ( x , n ) ; }
rank: 376
score: 98.6373062133789
patch: / * * * ++ / /
rank: 376
score: 98.62105712890624
patch: / * ; ++ iter ; ++ iter ;
rank: 376
score: 98.53611537388393
patch: ++ 0 ; ++ n ;
rank: 376
score: 98.49799455915179
patch: throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + ++ n ;
rank: 377
score: 98.99321457435344
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) , n ) ;
rank: 377
score: 98.93693033854167
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( f CaMeL Val ) . clone ( ) ;
rank: 377
score: 98.919921875
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = 1 ;
rank: 377
score: 98.82427368164062
patch: return new Point CaMeL Value CaMeL Pair ( Point CaMeL Value CaMeL Pair . f CaMeL Val ) ;
rank: 377
score: 98.70643199573864
patch: while ( iter < iter ; iter ++ ) {
rank: 377
score: 98.63650512695312
patch: else { * * ; * /
rank: 377
score: 98.62070041232639
patch: ++ iter ; * * ++ iter ;
rank: 377
score: 98.53611061789773
patch: if ++ iter ; ++ iter ; ++ iter ;
rank: 377
score: 98.49795532226562
patch: int iter = 0 ; while ( iter < iter )
rank: 378
score: 98.99302455357143
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( x , f CaMeL Val ) ;
rank: 378
score: 98.94825503700658
patch: double iter = Math CaMeL Arrays . copy CaMeL Of ( direc [ 0 ] ) ;
rank: 378
score: 98.93687220982143
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker . get CaMeL Value ( 0 ) ;
rank: 378
score: 98.82408558238636
patch: return Point CaMeL Value CaMeL Pair . new CaMeL Point CaMeL And CaMeL Direction ( x 1 , x ) ;
rank: 378
score: 98.705859375
patch: ++ iter ; System . arraycopy ( ; ;
rank: 378
score: 98.63643798828124
patch: } return iter ;
rank: 378
score: 98.5361083984375
patch: ++ iter ; iter / / / / /
rank: 378
score: 98.49784633091518
patch: buffer . append ( $STRING$ ) . append ( ++ iter ) ;
rank: 379
score: 98.99266673900463
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . this . x ) ;
rank: 379
score: 98.93679630055146
patch: final double [ ] f CaMeL Val = line . get CaMeL Value ( ) ;
rank: 379
score: 98.82403885690789
patch: Iterator < Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > iter = x ;
rank: 379
score: 98.70534057617188
patch: if ( iter == - 1 ) break ;
rank: 379
score: 98.63638070913461
patch: if ( . is CaMeL Empty ( ) ; ++ iter ;
rank: 379
score: 98.61912231445312
patch: try { ++ iter ; while ++ iter ;
rank: 379
score: 98.49754503038194
patch: ++ iter ; ++ iter ; try {
rank: 380
score: 98.9926424893466
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( (
rank: 380
score: 98.93656005859376
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x $NUMBER$ , f CaMeL Val ) ;
rank: 380
score: 98.91964901194854
patch: String f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( direc ;
rank: 380
score: 98.82384723165761
patch: return Point CaMeL Value CaMeL Pair . new CaMeL Point CaMeL And CaMeL Direction ( x , x , iter ) ;
rank: 380
score: 98.70523410373264
patch: ++ iter ; return ++ iter ; }
rank: 380
score: 98.63633897569444
patch: / * * * ++ ; * /
rank: 380
score: 98.61874389648438
patch: ++ iter ; * * / ++ iter ;
rank: 380
score: 98.53526611328125
patch: ++ iter ; ++ n ; ++ start ;
rank: 380
score: 98.4964599609375
patch: double n = iter * n ;
rank: 381
score: 98.99235704210069
patch: double double f CaMeL Val = compute CaMeL Objective CaMeL Value ( f CaMeL Val ) ;
rank: 381
score: 98.93642290900735
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > direc [ ] ;
rank: 381
score: 98.91942420372597
patch: final double f CaMeL Val = f CaMeL Val - iter ;
rank: 381
score: 98.8234619140625
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( f CaMeL Val , f CaMeL Val ) ;
rank: 381
score: 98.70512390136719
patch: ++ iter ; * / ; ;
rank: 381
score: 98.63496704101563
patch: else { return iter ; } return iter ;
rank: 381
score: 98.61852010091145
patch: ++ iter ; ++ * * / / ++ iter ;
rank: 381
score: 98.53522406684027
patch: ++ iter ; ; ++ iter ; iter
rank: 381
score: 98.49625651041667
patch: ++ iter - iter ; ++ iter ;
rank: 382
score: 98.93641421669408
patch: final double [ ] f CaMeL Val = f CaMeL Val . get CaMeL Point ( ) ;
rank: 382
score: 98.70457356770834
patch: throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + iter ) ; }
rank: 382
score: 98.63446807861328
patch: else { ++ * * iter ;
rank: 382
score: 98.61813015407986
patch: ++ iter ; ++ iter + 0 ;
rank: 382
score: 98.53507690429687
patch: ++ 0 ; ++ iter ; return iter ;
rank: 382
score: 98.49620472301136
patch: if ( iter < n ) { continue ; }
rank: 383
score: 98.93633742559524
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , x $NUMBER$ ) ;
rank: 383
score: 98.8226547241211
patch: result = compute CaMeL Objective CaMeL Value ( x . clone ( ) ) ;
rank: 383
score: 98.70432350852273
patch: while ( iter < n ) { iter ++ ;
rank: 383
score: 98.61803588867187
patch: ++ iter ; try ; ++ iter ; ;
rank: 383
score: 98.53476784446023
patch: ++ iter ; ++ iter ; ; iter ++ ;
rank: 383
score: 98.49616241455078
patch: f CaMeL Val = ++ iter ;
rank: 384
score: 98.99216037326389
patch: double f CaMeL Val = f CaMeL Val - compute CaMeL Objective CaMeL Value ( ) ;
rank: 384
score: 98.94673237047698
patch: int f CaMeL Val = compute CaMeL Objective CaMeL Value ( x , f CaMeL Val ) ;
rank: 384
score: 98.91782633463542
patch: double n = f CaMeL Val + f CaMeL Val ;
rank: 384
score: 98.82224684495192
patch: Iterator < Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ) {
rank: 384
score: 98.70427594866071
patch: ++ iter ; while ( iter > 0 ) { ++ iter ;
rank: 384
score: 98.63394601004464
patch: if ( . is CaMeL Empty ( ) ) . ++ iter ;
rank: 384
score: 98.61717393663194
patch: ++ iter ; ++ - * iter ;
rank: 384
score: 98.53452555338542
patch: ++ iter ; ; iter / * /
rank: 385
score: 98.99192527488425
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . this , x ) ;
rank: 385
score: 98.946728515625
patch: int f CaMeL Val = compute CaMeL Objective CaMeL Value ( $NUMBER$ ) ;
rank: 385
score: 98.93601989746094
patch: Point CaMeL Value CaMeL Pair checker = line . search ( x 1 ) ;
rank: 385
score: 98.91773139105902
patch: double f CaMeL Val = f CaMeL Val - f CaMeL Val - f CaMeL Val ;
rank: 385
score: 98.82205360814145
patch: Iterator < Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > iter = n ;
rank: 385
score: 98.70424582741477
patch: ++ iter ; final Point CaMeL Value CaMeL Pair ;
rank: 385
score: 98.63364083426339
patch: if ( ! iter . is CaMeL Empty ( ; return iter ;
rank: 385
score: 98.61684841579861
patch: else * ++ iter ; while iter ;
rank: 385
score: 98.53403542258523
patch: ++ iter ; ; ++ start ; ++ iter ;
rank: 385
score: 98.495849609375
patch: if ( f CaMeL Val != null ) { ++ iter ;
rank: 386
score: 98.99176580255681
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) . clone ( ) ;
rank: 386
score: 98.93600990032327
patch: Point CaMeL Value CaMeL Pair checker = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( direc ) ) ;
rank: 386
score: 98.91727120535714
patch: double [ ] iter = line . get CaMeL Value ( ) ;
rank: 386
score: 98.8219482421875
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Point CaMeL Value CaMeL Pair . line ) ;
rank: 386
score: 98.7039082845052
patch: return new Point CaMeL Value CaMeL Pair ( ; } ;
rank: 386
score: 98.63360595703125
patch: if ( ! iter . is CaMeL Empty ; * /
rank: 386
score: 98.6168212890625
patch: ++ 0 ; ++ 1 ;
rank: 386
score: 98.53362482244319
patch: ++ ++ 1 ; ++ iter ; ++ iter ;
rank: 386
score: 98.49535369873047
patch: if ( ++ n >= iter )
rank: 387
score: 98.9914971713362
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( direc [ 0 ] ) ) ;
rank: 387
score: 98.935693359375
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = Math CaMeL Arrays . copy CaMeL Of ( x 1 ) ;
rank: 387
score: 98.8216616981908
patch: Iterator < Point CaMeL Value CaMeL Pair < Univariate CaMeL Point CaMeL Value CaMeL Pair > ++ ;
rank: 387
score: 98.70389811197917
patch: ++ iter ; * ;
rank: 387
score: 98.6321533203125
patch: if ( . is CaMeL Empty ( ) )
rank: 387
score: 98.53357543945313
patch: ++ 0 ; ++ iter ; ++ start ;
rank: 387
score: 98.49496895926339
patch: sb . append ( $STRING$ ) . append ( iter + $STRING$ ;
rank: 388
score: 98.99142982219827
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . x , f CaMeL Val ) ;
rank: 388
score: 98.94649047851563
patch: double [ ] x = $NUMBER$ . 0 ;
rank: 388
score: 98.93543090820313
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > < Point CaMeL Value CaMeL Pair > checker ;
rank: 388
score: 98.91685267857143
patch: double [ ] x = line . get CaMeL Point ( ) ;
rank: 388
score: 98.82157175164474
patch: return new Point CaMeL Value CaMeL Pair ( Math CaMeL Arrays . copy CaMeL Of ( x ,
rank: 388
score: 98.63201904296875
patch: * * * * / / }
rank: 388
score: 98.6165771484375
patch: i * ++ ; iter * / /
rank: 388
score: 98.53327772352431
patch: ++ new = iter ; ++ iter ;
rank: 388
score: 98.49483816964286
patch: if ( f CaMeL Val != null && f CaMeL Val . ;
rank: 389
score: 98.99120415581598
patch: ++ iter ; double f CaMeL Val ;
rank: 389
score: 98.94571533203126
patch: ( ( Univariate CaMeL Point CaMeL Value CaMeL Pair ) checker ) . get CaMeL Point ( ) ;
rank: 389
score: 98.93539428710938
patch: stop = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 389
score: 98.91619466145833
patch: double f CaMeL Val = f CaMeL Val - f CaMeL Val ; final
rank: 389
score: 98.82135331003289
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > do {
rank: 389
score: 98.61644151475694
patch: ++ * ++ iter ; iter * /
rank: 389
score: 98.53326970880681
patch: ++ iter ; ++ iter ; while iter ++ ;
rank: 389
score: 98.49413384331598
patch: if ( ++ n > 1 ) {
rank: 390
score: 98.99106233016305
patch: double f CaMeL Val = Math . copy CaMeL Of ( f CaMeL Val ) . get CaMeL Value ( ) ;
rank: 390
score: 98.9159164428711
patch: final double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x 1 ,
rank: 390
score: 98.82115760216347
patch: ret = new CaMeL Point CaMeL And CaMeL Direction ( x ,
rank: 390
score: 98.702490234375
patch: return new Point CaMeL Value CaMeL Pair ( iter , x , n ;
rank: 390
score: 98.63165283203125
patch: / * * ++ * * ;
rank: 390
score: 98.53308715820313
patch: ++ 1 ; ++ iter ; return iter ;
rank: 390
score: 98.49391004774306
patch: ++ iter + 1 ; ++ iter ;
rank: 391
score: 98.93500366210938
patch: final double CaMeL Value = f CaMeL Val ;
rank: 391
score: 98.91561550564236
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( f CaMeL Val ) ; final
rank: 391
score: 98.82068359375
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > ++ ;
rank: 391
score: 98.70203653971355
patch: ++ iter ; while ( iter < iter ) { ;
rank: 391
score: 98.63164411272321
patch: if ( ! iter . is CaMeL Empty ( ; - 0 ;
rank: 391
score: 98.61575927734376
patch: ++ * ++ iter ; if ++ iter ;
rank: 391
score: 98.53160400390625
patch: ++ n ; ++ start ; ++ iter ;
rank: 391
score: 98.4938631924716
patch: if ( ++ n > 0 ) ++ iter ;
rank: 392
score: 98.99080078125
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . false ) ;
rank: 392
score: 98.94381103515624
patch: int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( direc , 0 ) ;
rank: 392
score: 98.93478393554688
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair <= Point CaMeL Value CaMeL Pair > checker ;
rank: 392
score: 98.91546630859375
patch: double [ ] f CaMeL Val = Math CaMeL Arrays . copy CaMeL
rank: 392
score: 98.8206298828125
patch: return new Point CaMeL Value CaMeL Pair ( Point CaMeL Value CaMeL Pair . x , iter ) ;
rank: 392
score: 98.70196533203125
patch: ++ iter ; while ( iter > 0 )
rank: 392
score: 98.63134765625
patch: / * * / * / }
rank: 392
score: 98.615234375
patch: ++ iter ; int iter = 0 ;
rank: 392
score: 98.53104654947917
patch: ++ iter ; ++ iter ; * / ++ iter ;
rank: 392
score: 98.4933330829327
patch: ++ iter ; throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$
rank: 393
score: 98.98987833658855
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ] ) ;
rank: 393
score: 98.9347265625
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( Math CaMeL Arrays . copy CaMeL Of ( direc ) ) ;
rank: 393
score: 98.8203125
patch: Iterator < Point CaMeL Value CaMeL Pair protected Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair
rank: 393
score: 98.63117009943181
patch: if ( iter == null ; return iter ; ;
rank: 393
score: 98.530908203125
patch: ++ iter ; ++ iter ; iter / /
rank: 394
score: 98.9343731219952
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = new CaMeL Point CaMeL And CaMeL Direction ( f CaMeL Val ) ;
rank: 394
score: 98.91499467329545
patch: double f CaMeL Val = f CaMeL Val $NUMBER$ ;
rank: 394
score: 98.82002766927083
patch: y = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 394
score: 98.70150146484374
patch: ++ iter ; if ( iter >= n )
rank: 394
score: 98.63069661458333
patch: * * * * * / * /
rank: 394
score: 98.61452229817708
patch: else ++ iter ; iter * * /
rank: 394
score: 98.48886108398438
patch: sb . append ( $STRING$ ) . append ( iter )
rank: 395
score: 98.989755859375
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . true ) ;
rank: 395
score: 98.943115234375
patch: int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , x ;
rank: 395
score: 98.93376358695652
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( f CaMeL Val ) . get CaMeL Value ( ) ;
rank: 395
score: 98.91486002604167
patch: final double f CaMeL Val += f CaMeL Val - f CaMeL Val ;
rank: 395
score: 98.8199821920956
patch: return new Point CaMeL Value CaMeL Pair ( Point CaMeL Value CaMeL Pair . line CaMeL
rank: 395
score: 98.70076293945313
patch: if ( iter == - 1 ) continue ;
rank: 395
score: 98.63066864013672
patch: * * * * / * ;
rank: 395
score: 98.61447143554688
patch: ++ iter ; * / if ++ iter ;
rank: 395
score: 98.53074137369792
patch: ++ iter ; ++ iter + max ;
rank: 395
score: 98.48882293701172
patch: if ( ++ n > 1 ;
rank: 396
score: 98.94252115885416
patch: double [ ] x 1 = f CaMeL Val . f CaMeL Val ;
rank: 396
score: 98.93311709449405
patch: int f CaMeL Val = compute CaMeL Objective CaMeL Value ( x . get CaMeL Point ( ) ) ;
rank: 396
score: 98.91445583767361
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x . search ( x ,
rank: 396
score: 98.819912109375
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair = 1 ;
rank: 396
score: 98.70067749023437
patch: if ( iter < n ) return null ;
rank: 396
score: 98.63034292367789
patch: else { throw new Runtime CaMeL Exception ( $STRING$ ) ; }
rank: 396
score: 98.61381022135417
patch: * * ++ iter ; ++ iter ;
rank: 396
score: 98.53071424696181
patch: ++ iter ; ++ iter ; try /
rank: 396
score: 98.4887225811298
patch: int iter = Math . min ( iter , n ) ;
rank: 397
score: 98.9891357421875
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 397
score: 98.9421630859375
patch: int f CaMeL Val = f CaMeL Val . search ( x ) ;
rank: 397
score: 98.91372341579861
patch: final double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( iter ) ;
rank: 397
score: 98.81962076822917
patch: b = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 397
score: 98.7002461751302
patch: ++ iter ; if ( iter <= n ) break ;
rank: 397
score: 98.61314086914062
patch: ++ iter ; ++ iter ; int value ;
rank: 397
score: 98.53032769097223
patch: ++ iter ; ++ start ; / /
rank: 398
score: 98.942138671875
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( direc [ 0 ] ;
rank: 398
score: 98.93209499782986
patch: double [ ] f CaMeL Val $NUMBER$ = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 398
score: 98.91346232096355
patch: byte [ ] f CaMeL Val = f CaMeL Val ;
rank: 398
score: 98.81959228515625
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Point CaMeL Value CaMeL Pair . this ) ;
rank: 398
score: 98.70003509521484
patch: ++ iter ; double iter ++ ;
rank: 398
score: 98.62876892089844
patch: * * * ; * / }
rank: 398
score: 98.61311479048295
patch: ++ iter ; ++ * * / int iter ;
rank: 398
score: 98.53031782670455
patch: ++ start ; ++ iter ; } ++ iter ;
rank: 398
score: 98.488037109375
patch: while ( iter >= n )
rank: 399
score: 98.98877892127403
patch: double value = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ) ;
rank: 399
score: 98.94202241443452
patch: int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , $NUMBER$ ) ;
rank: 399
score: 98.93160878057066
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = checker . get CaMeL Goal CaMeL Type ( ) ;
rank: 399
score: 98.91330973307292
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair ;
rank: 399
score: 98.8195865028783
patch: long f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 399
score: 98.69998604910714
patch: ++ iter ; while ( iter < n ; ++ iter ) {
rank: 399
score: 98.62819602272727
patch: Set < ? > iter = iter . iter ;
rank: 399
score: 98.61292860243056
patch: i * ++ ; / * / /
rank: 399
score: 98.53023952907986
patch: ++ n ; ++ iter ; break ;
rank: 400
score: 98.98874337332589
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . get ( x ) ) ;
rank: 400
score: 98.93134014423077
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ) ;
rank: 400
score: 98.91294352213542
patch: int f CaMeL Val = f CaMeL Val . index CaMeL Of ( x 1 ) ;
rank: 400
score: 98.81954956054688
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair > }
rank: 400
score: 98.62765066964286
patch: if ( ! iter . is CaMeL Empty ( ) ) * ;
rank: 400
score: 98.61278686523437
patch: if 0 ; ++ iter ; ++ iter ;
rank: 400
score: 98.52992078993056
patch: ++ iter ; ++ max ; / /
rank: 400
score: 98.48641967773438
patch: try { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$
rank: 401
score: 98.9886005108173
patch: final double f CaMeL Val = line . clone ( ) ;
rank: 401
score: 98.94127400716145
patch: int x = f CaMeL Val + f CaMeL Val ;
rank: 401
score: 98.81944783528645
patch: return new Point CaMeL Value CaMeL Pair ( Point CaMeL Value CaMeL Pair . get CaMeL Goal CaMeL Type ( ) ) ;
rank: 401
score: 98.69987349076705
patch: ++ iter ; * / * ++ iter * /
rank: 401
score: 98.62723541259766
patch: else { ++ * 1 ; }
rank: 401
score: 98.61223008897569
patch: ++ * ++ iter ; ++ * /
rank: 401
score: 98.5299072265625
patch: ++ iter ; } ++ iter ; }
rank: 402
score: 98.93050808376736
patch: final double [ ] x = Math CaMeL Arrays . copy CaMeL Of ( x ) ;
rank: 402
score: 98.91245930989584
patch: double iter = Math CaMeL Arrays . copy CaMeL Of ( iter ) ;
rank: 402
score: 98.81934756324405
patch: Iterator < Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > ++ ;
rank: 402
score: 98.62704467773438
patch: if ( iter ; * * /
rank: 402
score: 98.61186387803819
patch: / * ] iter ; iter * /
rank: 402
score: 98.528076171875
patch: ++ iter ; ++ iter ; if iter -- ;
rank: 402
score: 98.48635629507211
patch: try { throw new Illegal CaMeL Argument CaMeL Exception ( ) ;
rank: 403
score: 98.94110107421875
patch: if ( f CaMeL Val >= f CaMeL Val ) {
rank: 403
score: 98.91242218017578
patch: double [ ] f CaMeL Val = line . get CaMeL Point ( ) ;
rank: 403
score: 98.81895751953125
patch: return Point CaMeL Value CaMeL Pair . new CaMeL Point CaMeL And CaMeL Direction ( x , x ,
rank: 403
score: 98.698095703125
patch: return new Point CaMeL Value CaMeL Pair ( x ) . ++ ; }
rank: 403
score: 98.62698800223214
patch: while ( ! iter . is CaMeL Empty ( ; ) . ;
rank: 403
score: 98.61141628689236
patch: / ; ++ iter ; int iter ;
rank: 403
score: 98.52804129464286
patch: ++ 1 ; ++ n ;
rank: 403
score: 98.48558213975694
patch: while ( iter < iter . length )
rank: 404
score: 98.9883563701923
patch: double f CaMeL Val 1 = x . clone ( ) ;
rank: 404
score: 98.94088406032986
patch: double [ ] x = Math CaMeL Arrays . copy CaMeL Of ( direc ) ;
rank: 404
score: 98.91238168569711
patch: final double f CaMeL Val = compute CaMeL Objective CaMeL Value (
rank: 404
score: 98.81815011160714
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( x 1 ,
rank: 404
score: 98.69772774832589
patch: ++ iter ; double iter = Double . parse CaMeL Double ( ;
rank: 404
score: 98.62553575303819
patch: else { * * * / } }
rank: 404
score: 98.61109754774306
patch: ++ iter ; else * int iter ;
rank: 404
score: 98.52780490451389
patch: / ; ++ iter ; -- iter ;
rank: 404
score: 98.48538912259616
patch: ++ iter ; } return new Point CaMeL Value CaMeL Pair ;
rank: 405
score: 98.9293800636574
patch: double CaMeL Value = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , compute CaMeL Objective CaMeL Value ( x ) ) ;
rank: 405
score: 98.91212565104166
patch: int f CaMeL Val = compute CaMeL Objective CaMeL Value ( x 1 ,
rank: 405
score: 98.81810845269098
patch: y = Math CaMeL Arrays . copy CaMeL Of ( x . clone ( ) ) ;
rank: 405
score: 98.69727672230114
patch: while ( iter >= 0 ) { ++ iter ;
rank: 405
score: 98.61092122395833
patch: ++ * ++ iter ; synchronized iter ;
rank: 405
score: 98.52748616536458
patch: ++ iter ; iter ; return iter ;
rank: 405
score: 98.4850565592448
patch: ++ iter ; while ( iter . ; ++ iter )
rank: 406
score: 98.98727596507354
patch: double f CaMeL Val = Math . copy CaMeL Of ( double CaMeL Value ) ;
rank: 406
score: 98.94072409237133
patch: double [ ] x = Math CaMeL Arrays . copy CaMeL Of ( direc [
rank: 406
score: 98.92839704241071
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = checker . get CaMeL Point ( ) ;
rank: 406
score: 98.91184303977273
patch: int double f CaMeL Val = f CaMeL Val ;
rank: 406
score: 98.81800034466912
patch: return Math CaMeL Arrays . copy CaMeL Of ( x , f CaMeL Val ) ;
rank: 406
score: 98.69700520833334
patch: ++ iter ; return new Point CaMeL Value CaMeL Pair ( x ; }
rank: 406
score: 98.62468927556819
patch: if ( iter != 0 ; return iter ; }
rank: 406
score: 98.60984293619792
patch: ++ iter ; try ; int * /
rank: 406
score: 98.52724783761161
patch: ++ iter ; ++ min ;
rank: 407
score: 98.98711947737068
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . ( f CaMeL Val ) ) ;
rank: 407
score: 98.94054457720588
patch: if ( f CaMeL Val . length < f CaMeL Val . length ) { {
rank: 407
score: 98.92839612458882
patch: final Univariate CaMeL Point CaMeL Value CaMeL Pair checker = line . search ( x 1 ) ;
rank: 407
score: 98.91099717881944
patch: final double f CaMeL Val = f CaMeL Val . get CaMeL Value ( 0 ) ;
rank: 407
score: 98.81797572544643
patch: int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( x , f CaMeL Val ) ;
rank: 407
score: 98.69595336914062
patch: if ( iter < iter ) { ++ iter ; }
rank: 407
score: 98.6246337890625
patch: i ] [ 0 ] = 0 ; }
rank: 407
score: 98.60953097873264
patch: else ++ iter ; if ++ iter ;
rank: 407
score: 98.52713623046876
patch: ++ 1 ; ++ iter ; ++ start ;
rank: 407
score: 98.4839200106534
patch: iter = iter . iterator ( ) ; try {
rank: 408
score: 98.98710575810185
patch: d = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , 0 ) ) ;
rank: 408
score: 98.94034830729167
patch: int f CaMeL Val = Math . copy CaMeL Of ( f CaMeL Val , f CaMeL Val ) ;
rank: 408
score: 98.91088104248047
patch: double [ ] f CaMeL Val = x . get CaMeL Size ( ) ;
rank: 408
score: 98.81788545496323
patch: Iterator < Point CaMeL Value CaMeL Pair > iter = x . iterator ( ) ;
rank: 408
score: 98.62397984095982
patch: if ( ! iter . is CaMeL Empty ++ && ) . ;
rank: 408
score: 98.60949028862848
patch: ++ iter ; ; / * / /
rank: 408
score: 98.52678765190973
patch: ++ iter ; ++ iter ; } /
rank: 408
score: 98.4838397686298
patch: double n = Math . max ( n , n ) ;
rank: 409
score: 98.98643909801136
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > < Univariate CaMeL Point CaMeL Value CaMeL Pair > {
rank: 409
score: 98.94017118566177
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x , 1 ) ;
rank: 409
score: 98.92774658203125
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x 1 , f CaMeL Val ) ;
rank: 409
score: 98.90937805175781
patch: double f CaMeL Val = null ;
rank: 409
score: 98.81756591796875
patch: v = Math CaMeL Arrays . copy CaMeL Of ( x . clone ( ) ) ;
rank: 409
score: 98.695849609375
patch: while ( true ; ) { ++ iter ;
rank: 409
score: 98.62386067708333
patch: ++ [ ] iter ; ++ iter ;
rank: 409
score: 98.60908813476563
patch: ++ iter ; try { ++ iter ; }
rank: 409
score: 98.525830078125
patch: ++ iter ; ++ iter ; iter * ;
rank: 409
score: 98.48328247070313
patch: synchronized ( ++ iter ) { ++ iter ;
rank: 410
score: 98.93961958451705
patch: double [ ] x 1 = 0 . 1 ;
rank: 410
score: 98.92692057291667
patch: f CaMeL Val = f CaMeL Val ; f CaMeL Val = f CaMeL Val . clone ( ) ;
rank: 410
score: 98.81754847935268
patch: Iterator < Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > ++ iter ;
rank: 410
score: 98.695556640625
patch: return new Point CaMeL Value CaMeL Pair ( this , iter , ;
rank: 410
score: 98.62357003348214
patch: if ( ! iter . is CaMeL Empty ( ) ; iter ;
rank: 410
score: 98.60838487413194
patch: ++ * - iter ; ++ iter ;
rank: 410
score: 98.52490912543402
patch: / ; ++ iter ; ++ start ;
rank: 410
score: 98.48325602213542
patch: int iter = 1 ; while ( iter < n )
rank: 411
score: 98.9862393465909
patch: final int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , 0 ) ;
rank: 411
score: 98.93952026367188
patch: double f CaMeL Val = 0 . 1 ;
rank: 411
score: 98.90869140625
patch: double [ ] f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( direc [
rank: 411
score: 98.81744063527961
patch: Iterator < Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair >
rank: 411
score: 98.6953876201923
patch: ++ iter ; while ( iter < n ) ++ iter ;
rank: 411
score: 98.62320963541667
patch: if ( ! iter . is CaMeL Empty ( ) ; throw null ;
rank: 411
score: 98.60835404829545
patch: / * ] iter ; * / ++ iter ;
rank: 411
score: 98.52463989257812
patch: ++ iter ; iter
rank: 411
score: 98.48316192626953
patch: ++ iter ; while ( false )
rank: 412
score: 98.98592122395833
patch: double f CaMeL Val 1 = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val $NUMBER$ ) ;
rank: 412
score: 98.92635091145833
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( f CaMeL Val , ) ;
rank: 412
score: 98.90857611762152
patch: double ++ iter = f CaMeL Val ;
rank: 412
score: 98.8173297384511
patch: return Point CaMeL Value CaMeL Pair . new CaMeL Point CaMeL And CaMeL Direction ( f CaMeL Val , x ) ;
rank: 412
score: 98.69529506138393
patch: return new Point CaMeL Value CaMeL Pair ( iter , ++ iter ;
rank: 412
score: 98.62287055121527
patch: if ( iter == null ; continue ;
rank: 412
score: 98.60824924045139
patch: ++ iter ; / ; int iter ;
rank: 412
score: 98.52294921875
patch: ++ iter ; ++ this + iter ;
rank: 412
score: 98.48313395182292
patch: try { ++ n ;
rank: 413
score: 98.9391202059659
patch: if ( f CaMeL Val > f CaMeL Val )
rank: 413
score: 98.92635091145833
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( direc ) ) ;
rank: 413
score: 98.81705474853516
patch: ret = new CaMeL Point CaMeL And CaMeL Direction ( x , x ) ;
rank: 413
score: 98.69526890345982
patch: ++ iter ; throw new Runtime CaMeL Exception ( $STRING$ ) ; }
rank: 413
score: 98.62286931818181
patch: if ( iter == 0 ) return iter ; }
rank: 413
score: 98.60824584960938
patch: ++ iter ; ++ 1 ; for iter ;
rank: 413
score: 98.52290482954545
patch: ++ iter ; ++ iter ; -- iter ; ;
rank: 413
score: 98.48289489746094
patch: if ( ++ n != 0 )
rank: 414
score: 98.98527018229167
patch: double f CaMeL Val = 0 ; int f CaMeL Val = 0 ;
rank: 414
score: 98.93894606370192
patch: int x = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 414
score: 98.90815286075367
patch: final double [ ] x = Math CaMeL Arrays . copy CaMeL Of ( x ;
rank: 414
score: 98.81683756510417
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( x , x ,
rank: 414
score: 98.6943588256836
patch: ++ iter ; double iter = ;
rank: 414
score: 98.62265353732639
patch: / * * * * / * /
rank: 414
score: 98.60781860351562
patch: / * ++ ++ iter ; ++ iter ;
rank: 414
score: 98.48196176382211
patch: ++ iter ; if ( iter != null ) ++ iter ;
rank: 415
score: 98.98517477101294
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , n ) ) ;
rank: 415
score: 98.93891834077381
patch: int f CaMeL Val = f CaMeL Val + Fast CaMeL Math . copy CaMeL Of ( x ) ;
rank: 415
score: 98.9255603608631
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x . search ( x $NUMBER$ ) ) ;
rank: 415
score: 98.90792643229166
patch: double f CaMeL Val = f CaMeL Val - * f CaMeL Val ;
rank: 415
score: 98.81681060791016
patch: return Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ; }
rank: 415
score: 98.69394753196023
patch: ++ iter ; if ( iter != - 1 )
rank: 415
score: 98.62227172851563
patch: if ( iter == null ; return ; }
rank: 415
score: 98.60753716362848
patch: ++ * * * / ++ iter ;
rank: 415
score: 98.52247450086806
patch: ++ iter ; iter / = iter ;
rank: 415
score: 98.48048706054688
patch: x [ iter ] [ n ] = ;
rank: 416
score: 98.98517315204327
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( n ) ) ;
rank: 416
score: 98.92533569335937
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = new Convergence CaMeL Checker ( ) ;
rank: 416
score: 98.81672748766448
patch: Iterator < Point CaMeL Value CaMeL Pair protected Univariate CaMeL Point CaMeL Value CaMeL Pair > do {
rank: 416
score: 98.69276012073864
patch: ++ iter ; System . arraycopy ( x , ;
rank: 416
score: 98.62207970252403
patch: if ( ! iter . is CaMeL Empty ( 1 ) ;
rank: 416
score: 98.60660807291667
patch: ++ * ] iter ; ++ * /
rank: 416
score: 98.52195046164773
patch: ++ iter ; ++ iter ; return iter ; ;
rank: 416
score: 98.48023223876953
patch: try { iter = ++ iter ;
rank: 417
score: 98.92530581825658
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( f CaMeL Val , 1 ) ;
rank: 417
score: 98.81671142578125
patch: s = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 417
score: 98.62164306640625
patch: / * * * * / }
rank: 417
score: 98.60625348772321
patch: ++ iter ; if iter ;
rank: 417
score: 98.52166748046875
patch: ++ iter ; ++ iter ; } iter ;
rank: 418
score: 98.9251349954044
patch: final double [ ] f CaMeL Val = f CaMeL Val . clone ( ) ;
rank: 418
score: 98.81667608963816
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Point CaMeL Value CaMeL Pair . ) ;
rank: 418
score: 98.62147739955357
patch: if ( ! iter . is CaMeL Empty ( ; - 0 )
rank: 418
score: 98.60584605823864
patch: ++ iter ; / * * / ++ iter ;
rank: 418
score: 98.52067057291667
patch: ++ iter ; ++ iter ; / / = iter ;
rank: 418
score: 98.47714233398438
patch: int n = iter . index CaMeL Of ( $STRING$ )
rank: 419
score: 98.98455179148706
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) , 1 ) ;
rank: 419
score: 98.93717651367187
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , 0 ;
rank: 419
score: 98.92495727539062
patch: final double f CaMeL Val = compute CaMeL Objective CaMeL Value ( f CaMeL Val . get CaMeL Value ( ) ) ;
rank: 419
score: 98.90678967927632
patch: final double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ;
rank: 419
score: 98.81643837376645
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Point CaMeL Value CaMeL Pair . 1 ;
rank: 419
score: 98.69217258029514
patch: if ( iter > 0 ) break ;
rank: 419
score: 98.62132917131696
patch: else { return null ; }
rank: 419
score: 98.60549587673611
patch: ++ iter ; / * ++ iter ;
rank: 419
score: 98.52064819335938
patch: ++ iter ; ++ $NUMBER$ ; ++ iter ;
rank: 419
score: 98.47638617621527
patch: if ( ++ n > iter ) {
rank: 420
score: 98.9843505859375
patch: double f CaMeL Val = double CaMeL Value ( f CaMeL Val ) ;
rank: 420
score: 98.93710506663604
patch: double f CaMeL Val = ( Univariate CaMeL Point CaMeL Value CaMeL Pair ) x ;
rank: 420
score: 98.90675659179688
patch: double [ ] f CaMeL Val = null ;
rank: 420
score: 98.8163174715909
patch: return ( Point CaMeL Value CaMeL Pair ) Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 420
score: 98.69208318536931
patch: ++ iter ; while ( true ) ++ iter ;
rank: 420
score: 98.6212158203125
patch: if ( iter < iter ; * /
rank: 420
score: 98.60494656032986
patch: ++ iter ; * * * / /
rank: 420
score: 98.52040405273438
patch: ++ n ; ++ n ; ++ iter ;
rank: 420
score: 98.47635591947116
patch: ++ iter ; throw new Illegal CaMeL State CaMeL Exception ; }
rank: 421
score: 98.93617350260416
patch: int x = Math . copy CaMeL Of ( f CaMeL Val ) ;
rank: 421
score: 98.924619140625
patch: double f CaMeL Val = f CaMeL Val . search ( Math CaMeL Arrays . copy CaMeL Of ( direc ) ) ;
rank: 421
score: 98.90623372395834
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker ++ ;
rank: 421
score: 98.81612723214286
patch: int f CaMeL Val = line . get CaMeL Value ( ) ;
rank: 421
score: 98.69166148792614
patch: if ( iter >= n ) { ++ iter ;
rank: 421
score: 98.62113952636719
patch: / * * / ++ * /
rank: 421
score: 98.6043701171875
patch: ++ 1 ++ iter ;
rank: 421
score: 98.51953803168402
patch: ++ iter ; ++ iter ; / }
rank: 421
score: 98.47572678786058
patch: ++ iter ; throw new Illegal CaMeL State CaMeL Exception ( $STRING$
rank: 422
score: 98.98400297619048
patch: int f CaMeL Val = Math . copy CaMeL Of ( f CaMeL Val ) . clone ( ) ;
rank: 422
score: 98.92333984375
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x . get CaMeL Type ( ) ) ;
rank: 422
score: 98.90574735753677
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = checker . get CaMeL
rank: 422
score: 98.81574041193181
patch: [ ] f CaMeL Val = f CaMeL Val ;
rank: 422
score: 98.69145063920455
patch: ++ iter ; while ( ; ) ++ iter ;
rank: 422
score: 98.62113189697266
patch: i * * * * / /
rank: 422
score: 98.60228814019098
patch: ++ iter ; ++ iter ; for (
rank: 422
score: 98.5192642211914
patch: ++ $NUMBER$ ;
rank: 422
score: 98.47554154829545
patch: iter = iter . iterator ( ) ; while ;
rank: 423
score: 98.935595703125
patch: int f CaMeL Val = Math . abs ( 0 . 0 ) ;
rank: 423
score: 98.92297973632813
patch: double [ ] x 1 = x 1 ;
rank: 423
score: 98.90509033203125
patch: final double x $NUMBER$ = f CaMeL Val ;
rank: 423
score: 98.8156982421875
patch: return new Point CaMeL Value CaMeL Pair ( Point CaMeL Value CaMeL Pair . x , x ) ;
rank: 423
score: 98.6913592998798
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; ;
rank: 423
score: 98.62094116210938
patch: if ( ! iter . is CaMeL Empty ++ $NUMBER$ )
rank: 423
score: 98.60194905598958
patch: ++ iter ; / / * / /
rank: 423
score: 98.51919894748264
patch: else ; ++ iter ; ++ iter ;
rank: 423
score: 98.47533569335937
patch: if ( ++ n == 0 ) break ;
rank: 424
score: 98.98383123224431
patch: ++ iter ; int f CaMeL Val = 0 ;
rank: 424
score: 98.93547227647569
patch: f CaMeL Val = Math . copy CaMeL Of ( x , f CaMeL Val ) ;
rank: 424
score: 98.92282339242789
patch: double [ ] x 1 = guess . clone ( ) ;
rank: 424
score: 98.90457956414474
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = checker . get CaMeL Goal CaMeL
rank: 424
score: 98.81568321814903
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ( checker ) ;
rank: 424
score: 98.69100952148438
patch: ++ iter ; if ( iter >= n ;
rank: 424
score: 98.62093098958333
patch: if ( iter > 0 ; * /
rank: 424
score: 98.60175115411931
patch: ++ iter ; ++ * * / return iter ;
rank: 424
score: 98.51849365234375
patch: ++ name ; ++ iter ; ++ iter ;
rank: 424
score: 98.47459411621094
patch: if ( ++ n == 1 )
rank: 425
score: 98.98379411368535
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . get CaMeL Point ( ) ) ;
rank: 425
score: 98.815380859375
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > ++ iter ;
rank: 425
score: 98.690966796875
patch: ++ iter ; if ( ! iter . is CaMeL Empty ( ) ;
rank: 425
score: 98.61977713448661
patch: if ( iter != 0 ;
rank: 425
score: 98.60160522460937
patch: ++ 1 ; ++ iter ; while iter ;
rank: 425
score: 98.47458902994792
patch: int n = 0 ; while ( iter < n )
rank: 426
score: 98.98376012731481
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . line . x ) ;
rank: 426
score: 98.92249474158653
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( ( Univariate CaMeL Point CaMeL Value CaMeL Pair ) f CaMeL Val ) ;
rank: 426
score: 98.81523694490132
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Point CaMeL Value CaMeL Pair . line CaMeL
rank: 426
score: 98.6195297241211
patch: / * * ++ * ; /
rank: 426
score: 98.60126287286931
patch: ++ iter ; ++ iter ; int iter ++ ;
rank: 426
score: 98.51822335379464
patch: ++ n ; ++ 1 ;
rank: 427
score: 98.98322088068181
patch: double f CaMeL Val = Math . copy CaMeL Of ( compute CaMeL Objective CaMeL Value ( x ) ) ;
rank: 427
score: 98.93499145507812
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( direc . 0 ) ;
rank: 427
score: 98.92227172851562
patch: final int x 1 = f CaMeL Val ;
rank: 427
score: 98.9042460123698
patch: double f CaMeL Val = x . read ( ) ;
rank: 427
score: 98.81522914341518
patch: Iterator < Point CaMeL Value CaMeL Pair > iter = x 1 ;
rank: 427
score: 98.61934988839286
patch: / * * * ; /
rank: 427
score: 98.60096324573864
patch: ++ iter ; ++ iter ; ++ x iter ;
rank: 427
score: 98.51753743489583
patch: ++ iter ; iter / * ; /
rank: 427
score: 98.47423553466797
patch: int n = iter + 1 ;
rank: 428
score: 98.92220052083333
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , x 1 ) ;
rank: 428
score: 98.81515682444854
patch: result = Math CaMeL Arrays . copy CaMeL Of ( direc . 0 ) ;
rank: 428
score: 98.69019571940105
patch: while ( iter < n ) { ++ iter ; }
rank: 428
score: 98.61917114257812
patch: while ( ! iter . is CaMeL Empty ++ ) ;
rank: 428
score: 98.60068184988839
patch: ++ * ++ iter ; ;
rank: 428
score: 98.51691351996527
patch: iter ; ++ 0 ; ++ iter ;
rank: 428
score: 98.47420560396634
patch: Iterator iter = iter . iterator ( ) ; ++ n ;
rank: 429
score: 98.98305257161458
patch: ++ iter ; double f CaMeL Val = Univariate CaMeL Point CaMeL Value CaMeL Pair . get CaMeL Value ( x ) ;
rank: 429
score: 98.93467802159927
patch: double f CaMeL Val = ( Univariate CaMeL Point CaMeL Value CaMeL Pair ) $NUMBER$ ;
rank: 429
score: 98.92207668138587
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = new CaMeL Point CaMeL And CaMeL Direction ( } ;
rank: 429
score: 98.90342610677084
patch: double f CaMeL Val = x . get CaMeL Point ( x ) ;
rank: 429
score: 98.81513977050781
patch: rs = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 429
score: 98.61874389648438
patch: ++ 0 ; if ++ iter ;
rank: 429
score: 98.60055881076389
patch: ++ iter ; iter ; / * /
rank: 429
score: 98.51676802201705
patch: iter ++ ; ++ iter ; } ++ iter ;
rank: 430
score: 98.98285590277777
patch: d = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) , x ) ;
rank: 430
score: 98.934619140625
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( Math CaMeL Arrays . copy CaMeL Of (
rank: 430
score: 98.9215777853261
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = get CaMeL Point . get CaMeL Value ( ) ;
rank: 430
score: 98.81503693953805
patch: return new Point CaMeL Value CaMeL Pair ( Point CaMeL Value CaMeL Pair . new CaMeL Point CaMeL And CaMeL Direction (
rank: 430
score: 98.61871337890625
patch: else { break ; } }
rank: 430
score: 98.60044352213542
patch: ++ iter ; else iter * * /
rank: 430
score: 98.51654663085938
patch: ++ iter ; ++ iter ; / / }
rank: 430
score: 98.473876953125
patch: if ( ! iter . contains ( x ) ;
rank: 431
score: 98.92119891826923
patch: double f CaMeL Val = f CaMeL Val . search ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ) ;
rank: 431
score: 98.81475830078125
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair [ ] > ++ iter ;
rank: 431
score: 98.68927556818181
patch: ++ iter ; while ( iter <= iter ) {
rank: 431
score: 98.61826869419643
patch: if ( ! iter . is CaMeL Empty ( ; ) continue ;
rank: 431
score: 98.51603560014205
patch: ++ iter ; ++ iter ; } iter -- ;
rank: 431
score: 98.47362670898437
patch: throw new Unsupported CaMeL Operation CaMeL Exception ( )
rank: 432
score: 98.98208472842262
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , true ) ;
rank: 432
score: 98.93292557565789
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( [ 0 ] ) ;
rank: 432
score: 98.92039088199013
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = guess . clone ( ) ;
rank: 432
score: 98.90279447115384
patch: double f CaMeL Val = f CaMeL Val - x 1 ;
rank: 432
score: 98.81455365349265
patch: return new Point CaMeL Value CaMeL Pair ( Point CaMeL Value CaMeL Pair . get CaMeL
rank: 432
score: 98.68893432617188
patch: if ( iter <= n ) ++ iter ;
rank: 432
score: 98.61821153428819
patch: / * * * ++ * * /
rank: 432
score: 98.59895155164931
patch: / * ++ iter ; / / /
rank: 432
score: 98.51520330255681
patch: ++ 0 ; ; ++ iter ; ++ iter ;
rank: 432
score: 98.47359525240384
patch: int iter = Math . min ( n , n ) ;
rank: 433
score: 98.9820556640625
patch: double f CaMeL Val = Univariate CaMeL Point CaMeL Value CaMeL Pair . get CaMeL Point ( x 1 ) ;
rank: 433
score: 98.93256971571181
patch: double [ ] x 1 = Math CaMeL Arrays . copy CaMeL Of ( x ) ;
rank: 433
score: 98.9202129657452
patch: final double iter = line . get CaMeL Value ( ) ;
rank: 433
score: 98.81424289279514
patch: ret = Math CaMeL Arrays . copy CaMeL Of ( x . clone ( ) ) ;
rank: 433
score: 98.68888092041016
patch: ++ iter ; return ++ iter ;
rank: 433
score: 98.61792755126953
patch: * * * * / / /
rank: 433
score: 98.59877522786458
patch: this . ++ iter ; ++ iter ; ++ iter ;
rank: 433
score: 98.51507568359375
patch: ++ start ; ++ start ;
rank: 433
score: 98.47320556640625
patch: if ( iter < iter )
rank: 434
score: 98.9818699048913
patch: double f CaMeL Val = f CaMeL Val - Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 434
score: 98.93198649088542
patch: int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( x 1 ) ;
rank: 434
score: 98.920166015625
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > < Point CaMeL Value CaMeL Pair > checker =
rank: 434
score: 98.90196317784927
patch: final double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( x ;
rank: 434
score: 98.81406860351562
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair < Univariate CaMeL Point CaMeL Value CaMeL Pair > ;
rank: 434
score: 98.61774359809027
patch: if ( iter == 0 ; * /
rank: 434
score: 98.59860229492188
patch: ++ * ++ iter ; iter ; * /
rank: 434
score: 98.51499430338542
patch: ++ iter ; iter if ++ ; ;
rank: 434
score: 98.472900390625
patch: ++ n - iter ;
rank: 435
score: 98.98186383928571
patch: final Univariate CaMeL Point CaMeL Value CaMeL Pair < double , Univariate CaMeL Point CaMeL Value CaMeL Pair > {
rank: 435
score: 98.90191180889423
patch: final double f CaMeL Val = f CaMeL Val - 1 ;
rank: 435
score: 98.8139404296875
patch: Iterator < Point CaMeL Value CaMeL Pair protected Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair
rank: 435
score: 98.68851725260417
patch: ++ iter ; new Point CaMeL Value CaMeL Pair [ ]
rank: 435
score: 98.61640014648438
patch: ++ [ ] iter ; } ++ iter ;
rank: 435
score: 98.59857177734375
patch: ++ iter ; ++ 1 ; iter * /
rank: 435
score: 98.51463487413194
patch: ++ iter ; ++ max + iter ;
rank: 435
score: 98.4717684659091
patch: Iterator iter = iter . iterator ( ) ; ;
rank: 436
score: 98.981728515625
patch: ++ iter ; double f CaMeL Val = Univariate CaMeL Point CaMeL Value CaMeL Pair . line . get CaMeL Value ( ) ;
rank: 436
score: 98.91928335336539
patch: f CaMeL Val = x . search ( x 1 ) ;
rank: 436
score: 98.90147298177084
patch: double [ ] x 1 = line . get CaMeL Value ( ) ;
rank: 436
score: 98.8139289407169
patch: return new CaMeL Point CaMeL And CaMeL Direction ( f CaMeL Val , x ) ;
rank: 436
score: 98.68844401041666
patch: return new Point CaMeL Value CaMeL Pair ( ++ iter , x ; }
rank: 436
score: 98.61605631510416
patch: while ( ! iter . is CaMeL Empty ( ) ) return iter ;
rank: 436
score: 98.59786648220486
patch: / * ] iter ; int 1 ;
rank: 436
score: 98.51441650390625
patch: ++ iter ; ++ iter ; catch iter ;
rank: 437
score: 98.98170166015625
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( this . direc ) ;
rank: 437
score: 98.930419921875
patch: double f CaMeL Val = 0 - f CaMeL Val ;
rank: 437
score: 98.91903686523438
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = Math CaMeL Arrays . copy CaMeL Of ( iter ) ;
rank: 437
score: 98.90144348144531
patch: final double f CaMeL Val = compute CaMeL Objective CaMeL Value ( start ) ;
rank: 437
score: 98.81358119419643
patch: result = compute CaMeL Objective CaMeL Value ( x , x ) ;
rank: 437
score: 98.6156005859375
patch: while ( ! iter . is CaMeL Empty ( ) ; return iter ;
rank: 437
score: 98.59660508897569
patch: ++ * * ++ iter ; / /
rank: 437
score: 98.51410590277777
patch: ++ iter ; ++ iter ; else else
rank: 438
score: 98.98165893554688
patch: final double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val . clone ( ) ) ;
rank: 438
score: 98.93033854166667
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( [ f CaMeL Val ] ) ;
rank: 438
score: 98.9181795987216
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair extends Point CaMeL Value CaMeL Pair > checker = true ;
rank: 438
score: 98.90107727050781
patch: double f CaMeL Val = 1 ;
rank: 438
score: 98.81339518229167
patch: return new CaMeL Point CaMeL And CaMeL Direction ( f CaMeL Val , x $NUMBER$ ) ;
rank: 438
score: 98.68782182173295
patch: ++ iter ; while ( iter >= 0 ) {
rank: 438
score: 98.61542510986328
patch: else { / * * * /
rank: 438
score: 98.59644232855902
patch: else * ++ iter ; ++ * /
rank: 438
score: 98.51408168247768
patch: ++ super ; ++ iter ;
rank: 438
score: 98.47095947265625
patch: if ( ++ n == 0 ) continue ;
rank: 439
score: 98.93024758731617
patch: int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( guess ) ;
rank: 439
score: 98.9008056640625
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x 1 [
rank: 439
score: 98.813232421875
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > ++ n ;
rank: 439
score: 98.68766566685268
patch: return new Point CaMeL Value CaMeL Pair ( iter , x ; }
rank: 439
score: 98.61540985107422
patch: try { ++ iter ; * /
rank: 439
score: 98.5959805575284
patch: ++ iter ; ++ * - iter ; iter ;
rank: 439
score: 98.51343451605902
patch: ++ 0 ; ++ iter ; / /
rank: 439
score: 98.47077941894531
patch: float iter = iter - iter ;
rank: 440
score: 98.91684194711539
patch: double CaMeL Value = f CaMeL Val + f CaMeL Val ;
rank: 440
score: 98.90012721011513
patch: final double f CaMeL Val = compute CaMeL Objective CaMeL Value ( Math CaMeL Arrays . copy CaMeL
rank: 440
score: 98.81314750339673
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > double CaMeL Value = 0 ;
rank: 440
score: 98.61522674560547
patch: else { ++ * ; * /
rank: 440
score: 98.59596946022727
patch: ++ iter ; ++ * ++ iter ; iter ;
rank: 440
score: 98.51329956054687
patch: ++ iter ; iter * ; ++ iter ;
rank: 440
score: 98.470703125
patch: pos = Math . max ( iter , n ) ;
rank: 441
score: 98.93021886488971
patch: final double f CaMeL Val = Math . copy CaMeL Of ( direc ) ;
rank: 441
score: 98.916259765625
patch: final Univariate CaMeL Point CaMeL Value CaMeL Pair checker = line . get CaMeL Value ( ) . get CaMeL Value ( ) ;
rank: 441
score: 98.8992919921875
patch: final double start = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 441
score: 98.81311487268519
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ( x 1 ) ;
rank: 441
score: 98.61444963727679
patch: if ( ! iter . is CaMeL Empty ( ) ) * /
rank: 441
score: 98.59578450520833
patch: / * ++ ++ iter ; * /
rank: 441
score: 98.512451171875
patch: ++ iter + 0 ; ++ iter ;
rank: 442
score: 98.93008422851562
patch: int f CaMeL Val = f CaMeL Val + 1 ;
rank: 442
score: 98.91609330610795
patch: f CaMeL Val = guess . clone ( ) ;
rank: 442
score: 98.89874945746527
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > < Point CaMeL Value CaMeL Pair
rank: 442
score: 98.81310504415761
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > int CaMeL Value = 0 ;
rank: 442
score: 98.68716866629464
patch: return new Point CaMeL Value CaMeL Pair ( x , ++ iter ;
rank: 442
score: 98.6143569946289
patch: if ; * * * / /
rank: 442
score: 98.59555392795139
patch: ++ iter ; ++ 1 ; * /
rank: 442
score: 98.51231079101562
patch: ++ iter ; ++ iter ; ; * /
rank: 443
score: 98.98095703125
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . line . search ( x ) ) ;
rank: 443
score: 98.93003540039062
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , 1 ;
rank: 443
score: 98.916015625
patch: double [ ] iter = Math CaMeL Arrays . copy CaMeL Of ( direc ) ;
rank: 443
score: 98.8986328125
patch: x f CaMeL Val = f CaMeL Val ;
rank: 443
score: 98.81282043457031
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair ( f CaMeL Val ) ;
rank: 443
score: 98.687060546875
patch: ++ iter ; if ( iter != 0 ;
rank: 443
score: 98.61429595947266
patch: if ; * * * / }
rank: 443
score: 98.59528459821429
patch: iter * / ++ iter ;
rank: 443
score: 98.5121182528409
patch: ++ iter ; ; iter ++ ; ++ iter ;
rank: 444
score: 98.98072265625
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . class ) ;
rank: 444
score: 98.92943657769098
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( direc [ 0
rank: 444
score: 98.9159923735119
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = line . search ( x 1 ) ;
rank: 444
score: 98.812578125
patch: Iterator < Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ;
rank: 444
score: 98.68697415865384
patch: ++ iter ; if ( iter == - 1 ) continue ;
rank: 444
score: 98.61414930555556
patch: else { iter += iter ; } }
rank: 444
score: 98.59498180042614
patch: ++ iter ; ++ - 1 ; ++ iter ;
rank: 444
score: 98.51210327148438
patch: ++ iter ; ++ Math ; ++ iter ;
rank: 444
score: 98.46962483723958
patch: iter = iter . iterator ( ) ; ++ n ;
rank: 445
score: 98.979619140625
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) . get CaMeL Point ( ) ;
rank: 445
score: 98.92838781020221
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( max ) ;
rank: 445
score: 98.89774816176471
patch: String f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( direc [
rank: 445
score: 98.81251808449075
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > iter = null ;
rank: 445
score: 98.68693403764205
patch: ++ iter ; while ( iter != - 1 )
rank: 445
score: 98.61361083984374
patch: return iter [ 0 ] [ 0 ] ;
rank: 445
score: 98.59468587239583
patch: ++ * ++ iter ; for iter ;
rank: 445
score: 98.51201036241319
patch: ++ iter ; ++ if ++ iter ;
rank: 445
score: 98.46925862630208
patch: ++ iter ; while ( iter ) {
rank: 446
score: 98.97960815429687
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val $NUMBER$ ) ;
rank: 446
score: 98.91429307725694
patch: double [ ] f CaMeL Val = compute CaMeL Objective CaMeL Value ( x $NUMBER$ ) ;
rank: 446
score: 98.89773898654514
patch: double f CaMeL Val = f CaMeL Val . get CaMeL Value ( x 1 ) ;
rank: 446
score: 98.81246948242188
patch: r = new CaMeL Point CaMeL And CaMeL Direction ( f CaMeL Val ) ;
rank: 446
score: 98.686767578125
patch: ++ iter ; if ( iter != null ) { ++ iter ;
rank: 446
score: 98.61351667131696
patch: if ( ! iter . is CaMeL Empty ( ) ; while ;
rank: 446
score: 98.59449598524306
patch: / * ] iter ; / / /
rank: 446
score: 98.51188354492187
patch: ++ length ; ++ iter ; ++ iter ;
rank: 447
score: 98.97901746961806
patch: double f CaMeL Val = f CaMeL Val ; double f CaMeL Val $NUMBER$ = 0 ;
rank: 447
score: 98.92702122738487
patch: double [ ] f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( x ) ;
rank: 447
score: 98.91346958705357
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker . get CaMeL Value ( x ) ;
rank: 447
score: 98.8124491373698
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ] {
rank: 447
score: 98.68629807692308
patch: ++ iter ; throw new Runtime CaMeL Exception ( $STRING$ ; }
rank: 447
score: 98.61293247767857
patch: if ( ! iter . is CaMeL Empty ( ) ; throw ;
rank: 447
score: 98.59445529513889
patch: ++ iter ; * * int iter ;
rank: 447
score: 98.51180691189236
patch: ++ iter ; ++ iter + start ;
rank: 448
score: 98.92645874023438
patch: int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( direc . x ) ;
rank: 448
score: 98.89708709716797
patch: int f CaMeL Val = f CaMeL Val ; f CaMeL Val = 0 ;
rank: 448
score: 98.81241048177084
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair > iter = 1 ;
rank: 448
score: 98.68606770833334
patch: if ( iter != null && iter . is CaMeL Empty ( ) )
rank: 448
score: 98.61280822753906
patch: / * * * ++ iter /
rank: 448
score: 98.59431762695313
patch: / * ] ++ iter ; int iter ;
rank: 448
score: 98.51166449652777
patch: ++ iter ; ++ iter ; while ;
rank: 448
score: 98.46824645996094
patch: final int iter = ++ iter ;
rank: 449
score: 98.97892680921052
patch: double f CaMeL Val = Math . copy CaMeL Of ( f CaMeL Val , $NUMBER$ ) ;
rank: 449
score: 98.926416015625
patch: double f CaMeL Val = f CaMeL Val . search ( Math CaMeL Arrays . copy CaMeL Of (
rank: 449
score: 98.89695434570312
patch: double [ ] n = f CaMeL Val ;
rank: 449
score: 98.812255859375
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( x , x 1 ) ;
rank: 449
score: 98.61273193359375
patch: / * * ++ * * * /
rank: 449
score: 98.59328206380208
patch: ++ iter ; break ; if iter ;
rank: 449
score: 98.51164899553571
patch: ++ iter ; ; iter ;
rank: 450
score: 98.92567952473958
patch: double [ ] x = this . f CaMeL Val ;
rank: 450
score: 98.9106381064967
patch: Point CaMeL Value CaMeL Pair checker = new Point CaMeL Value CaMeL Pair ( x 1 ) ;
rank: 450
score: 98.89671834309895
patch: double [ ] x = Math CaMeL Arrays . copy CaMeL
rank: 450
score: 98.81213960193452
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > iter = line .
rank: 450
score: 98.6855712890625
patch: ++ iter ; if ( iter < n ) { ++ iter ; }
rank: 450
score: 98.61266326904297
patch: ++ * iter ; / * /
rank: 450
score: 98.59326171875
patch: else ; ++ iter ; while iter ;
rank: 450
score: 98.51115278764205
patch: ++ iter ; ++ iter ; -- ++ iter ;
rank: 450
score: 98.46700032552083
patch: float iter = 0 ; while ( iter < n )
rank: 451
score: 98.978759765625
patch: double f CaMeL Val = Univariate CaMeL Point CaMeL Value CaMeL Pair . get ( x ) ;
rank: 451
score: 98.91041056315105
patch: f CaMeL Val = x . search ( x ) ;
rank: 451
score: 98.89657253689236
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x f CaMeL Val ) ;
rank: 451
score: 98.81202189127605
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair > ;
rank: 451
score: 98.68550248579545
patch: ++ iter ; if ( iter != - 1 ;
rank: 451
score: 98.61265869140625
patch: else { if ++ iter ; break ; }
rank: 451
score: 98.59276234019886
patch: ++ iter ; try ; ++ iter ; iter ;
rank: 451
score: 98.51071506076389
patch: ++ new ++ ; ++ iter ; }
rank: 452
score: 98.97784893329327
patch: ++ iter ; double f CaMeL Val = Univariate CaMeL Point CaMeL Value CaMeL Pair . compute CaMeL Objective CaMeL Value ( x ) ;
rank: 452
score: 98.8964131673177
patch: double iter = line . get CaMeL Point ( ) ;
rank: 452
score: 98.81189727783203
patch: Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , 0 ) ;
rank: 452
score: 98.68492024739584
patch: throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + n ) ; }
rank: 452
score: 98.61260986328125
patch: if ( ! iter . is CaMeL Empty ( ) ; } }
rank: 452
score: 98.59246826171875
patch: ++ iter ; ++ * ; * /
rank: 452
score: 98.51054077148437
patch: ++ 0 ; ++ start ; ++ iter ;
rank: 453
score: 98.9775454872533
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > < Point CaMeL Value CaMeL Pair > ;
rank: 453
score: 98.92484537760417
patch: double f CaMeL Val = f CaMeL Val + Fast CaMeL Math . copy CaMeL Of (
rank: 453
score: 98.91025612571023
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair extends Point CaMeL Value CaMeL Pair > checker = false ;
rank: 453
score: 98.896240234375
patch: double [ ] f CaMeL Val = x . to CaMeL String ( ) ;
rank: 453
score: 98.81174830386513
patch: Iterator < Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > checker = 0 ;
rank: 453
score: 98.68452758789063
patch: while ( iter < iter ) ++ iter ;
rank: 453
score: 98.6124267578125
patch: while ( ! iter . is CaMeL Empty ++ ) return iter ;
rank: 453
score: 98.59218924386161
patch: else ++ iter ; break ;
rank: 453
score: 98.51002197265625
patch: ++ iter ; ; ++ iter ; break ;
rank: 454
score: 98.97730431189903
patch: ++ iter ; double f CaMeL Val = 1 . 0 ;
rank: 454
score: 98.89616124770221
patch: int f CaMeL Val = compute CaMeL Objective CaMeL Value ( x , iter ) ;
rank: 454
score: 98.81174723307292
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Point CaMeL Value CaMeL Pair . x . clone ( ) ) ;
rank: 454
score: 98.68430739182692
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + $STRING$ ;
rank: 454
score: 98.61234537760417
patch: if ( ! iter . is CaMeL Empty ( ) ; return ; }
rank: 454
score: 98.59194607204861
patch: ++ iter ; iter * * ; /
rank: 454
score: 98.50932173295455
patch: } iter ++ ; ++ iter ; ++ iter ;
rank: 454
score: 98.46558837890625
patch: ++ iter ; for ( ; ; ) {
rank: 455
score: 98.97728135850694
patch: int f CaMeL Val $NUMBER$ = compute CaMeL Objective CaMeL Value ( f CaMeL Val ) ;
rank: 455
score: 98.92430355674342
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( x . search ( x . get CaMeL
rank: 455
score: 98.90970284598214
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair > direc ;
rank: 455
score: 98.8117038892663
patch: return Point CaMeL Value CaMeL Pair . new CaMeL Point CaMeL And CaMeL Direction ( x 1 , x $NUMBER$ ) ;
rank: 455
score: 98.61207580566406
patch: ++ iter ; * * / /
rank: 455
score: 98.59154595269098
patch: else * ++ iter ; iter * /
rank: 455
score: 98.50889369419643
patch: ++ out ; ++ iter ;
rank: 455
score: 98.46474202473958
patch: final int n = iter * n ;
rank: 456
score: 98.97724066840277
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > < Point CaMeL Value CaMeL Pair >
rank: 456
score: 98.92333374023437
patch: final double f CaMeL Val = f CaMeL Val : compute CaMeL Objective CaMeL Value ( x ) ;
rank: 456
score: 98.90949813179348
patch: f CaMeL Val = f CaMeL Val ; f CaMeL Val = f CaMeL Val . get CaMeL Point ( ) ;
rank: 456
score: 98.8957160500919
patch: double f CaMeL Val = f CaMeL Val ; double f CaMeL Val = 1 ;
rank: 456
score: 98.81163787841797
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair > iter = x 1 ;
rank: 456
score: 98.61187133789062
patch: else { ++ iter ; } return iter ;
rank: 456
score: 98.59047154017857
patch: value ++ ; ++ iter ;
rank: 456
score: 98.50841267903645
patch: ++ iter ; ++ iter ; } ++ iter ; }
rank: 456
score: 98.46426391601562
patch: pos = Math . min ( 0 , n ) ;
rank: 457
score: 98.97722833806819
patch: ++ true ; double f CaMeL Val = 0 ;
rank: 457
score: 98.90939170435855
patch: double iter = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , 0 ) ;
rank: 457
score: 98.81121826171875
patch: Iterator < Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair
rank: 457
score: 98.68330522017045
patch: while ( iter <= iter ) { ++ iter ;
rank: 457
score: 98.61185709635417
patch: else { * * * * ; }
rank: 457
score: 98.59033813476563
patch: ++ iter ; ++ * * ++ * /
rank: 457
score: 98.50801595052083
patch: ++ iter ; ++ iter ; ++ iter ; break ;
rank: 458
score: 98.97720540364584
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , x ) ) ;
rank: 458
score: 98.92266167534723
patch: if ( f CaMeL Val == null )
rank: 458
score: 98.90910993303571
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x . search ( x 1 ) ) ;
rank: 458
score: 98.89408874511719
patch: final double f CaMeL Val = compute CaMeL Objective CaMeL Value ( true ) ;
rank: 458
score: 98.81120469835069
patch: s = Math CaMeL Arrays . copy CaMeL Of ( x . clone ( ) ) ;
rank: 458
score: 98.68301391601562
patch: ++ iter - f CaMeL Val ;
rank: 458
score: 98.61175537109375
patch: if ( ! iter . is CaMeL Empty ++ ++ ;
rank: 458
score: 98.59027777777777
patch: ++ iter ; ++ * * / ;
rank: 458
score: 98.50717995383523
patch: ++ iter ; ++ iter ; iter = iter ;
rank: 458
score: 98.46318359375
patch: try { Thread . sleep ( $NUMBER$ ) ;
rank: 459
score: 98.90890066964286
patch: double iter = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , f CaMeL Val ) ;
rank: 459
score: 98.89331665039063
patch: int n = f CaMeL Val . length ;
rank: 459
score: 98.61141531808036
patch: if ( ! iter . is CaMeL Empty iter ) return null ;
rank: 459
score: 98.5899169921875
patch: if iter ; ++ iter ; ++ iter ;
rank: 459
score: 98.50672607421875
patch: ++ 1 ; ++ start ; ++ iter ;
rank: 459
score: 98.46239471435547
patch: ++ iter ; while ( iter ;
rank: 460
score: 98.97712053571429
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( direc [ x ] ) ;
rank: 460
score: 98.92113037109375
patch: double f CaMeL Val = new Univariate CaMeL Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair
rank: 460
score: 98.90863591974431
patch: i = f CaMeL Val . clone ( ) ;
rank: 460
score: 98.893310546875
patch: f CaMeL Val = f CaMeL Val [ iter ] ;
rank: 460
score: 98.81114366319444
patch: Iterator < Point CaMeL Value CaMeL Pair , Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > iter = 0 ;
rank: 460
score: 98.68271891276042
patch: if ( iter >= n ) { ++ iter ; }
rank: 460
score: 98.61136627197266
patch: i * * * * / }
rank: 460
score: 98.58964399857955
patch: ++ iter ; ++ iter ; while ++ 1 ;
rank: 460
score: 98.50666155133929
patch: ++ iter ; iter break ;
rank: 460
score: 98.46155724158653
patch: int n = Math . max ( n , iter ) ;
rank: 461
score: 98.97711181640625
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . get ( n ) ) ;
rank: 461
score: 98.92107543945312
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ; }
rank: 461
score: 98.90813337053571
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = line . get CaMeL Size ( ) ;
rank: 461
score: 98.81102159288194
patch: value = Math CaMeL Arrays . copy CaMeL Of ( x . clone ( ) ) ;
rank: 461
score: 98.68190511067708
patch: return new Point CaMeL Value CaMeL Pair ( x [ ;
rank: 461
score: 98.61129150390624
patch: ++ * * * * / ++ iter ;
rank: 461
score: 98.50661399147727
patch: iter else ++ ; ++ iter ; ++ iter ;
rank: 461
score: 98.46146647135417
patch: if ( iter != null ) break ;
rank: 462
score: 98.97710626775569
patch: double f CaMeL Val $NUMBER$ = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , 0 ) ;
rank: 462
score: 98.9206478721217
patch: double f CaMeL Val = Math . copy CaMeL Of ( direc [ 0 ] ) ;
rank: 462
score: 98.90802556818181
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker . get CaMeL Value ( x $NUMBER$ ) ;
rank: 462
score: 98.81064860026042
patch: found = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 462
score: 98.68162434895834
patch: return new Point CaMeL Value CaMeL Pair ( x [ iter ] ) ;
rank: 462
score: 98.61094970703125
patch: Object iter = iter . length ; while ;
rank: 462
score: 98.50642700195313
patch: ++ iter ; iter ++ ; -- iter ;
rank: 463
score: 98.92045084635417
patch: double [ ] f CaMeL Val = 1 . 1 ;
rank: 463
score: 98.90797776442308
patch: double [ ] x $NUMBER$ = x . clone ( ) ;
rank: 463
score: 98.89279174804688
patch: final int f CaMeL Val $NUMBER$ = f CaMeL Val ;
rank: 463
score: 98.810458984375
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Point CaMeL Value CaMeL Pair . x 1 , f CaMeL Val ) ;
rank: 463
score: 98.68128662109375
patch: ++ iter ; * / / ++ iter ;
rank: 463
score: 98.61094665527344
patch: ++ iter ; * * / }
rank: 463
score: 98.58763427734375
patch: if ++ iter ; ++ iter ; iter ;
rank: 463
score: 98.50504760742187
patch: ++ iter ; ++ n ; return iter ;
rank: 463
score: 98.4608662923177
patch: try { throw new Illegal CaMeL State CaMeL Exception ( $STRING$
rank: 464
score: 98.9767433449074
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val . to CaMeL
rank: 464
score: 98.92002650669643
patch: int f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ) . get CaMeL Value ( ) ;
rank: 464
score: 98.90779622395833
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = new CaMeL Point CaMeL And CaMeL Direction ( line ) ;
rank: 464
score: 98.89258530560662
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = this . x ;
rank: 464
score: 98.81027088994566
patch: return Point CaMeL Value CaMeL Pair . new CaMeL Point CaMeL And CaMeL Direction ( x , x , x ) ;
rank: 464
score: 98.68108367919922
patch: ++ iter ; int iter = ;
rank: 464
score: 98.61007690429688
patch: else { * * * * / } }
rank: 464
score: 98.58761257595486
patch: i * ++ ; ++ * * /
rank: 464
score: 98.50487263997395
patch: ++ iter ; ++ iter ; if iter = iter ;
rank: 464
score: 98.46072387695312
patch: try { throw new Illegal CaMeL Argument CaMeL Exception ; }
rank: 465
score: 98.90747680664063
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( f CaMeL Val , x $NUMBER$ ) ;
rank: 465
score: 98.89234161376953
patch: final double f CaMeL Val = compute CaMeL Objective CaMeL Value ( false ) ;
rank: 465
score: 98.81020972842262
patch: Iterator < Point CaMeL Value CaMeL Pair protected Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair {
rank: 465
score: 98.6809833233173
patch: ++ iter ; if ( iter > 0 ) ++ iter ;
rank: 465
score: 98.60927170973558
patch: if ( ! iter . is CaMeL Empty ( $NUMBER$ ) ;
rank: 465
score: 98.58678327287946
patch: ++ iter ; synchronized iter ;
rank: 465
score: 98.504638671875
patch: ++ iter ; ++ iter ; iter break ;
rank: 465
score: 98.460693359375
patch: while ( true ) { ;
rank: 466
score: 98.97628784179688
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( ! f CaMeL Val ) ;
rank: 466
score: 98.90678267045455
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair extends Univariate CaMeL Point CaMeL Value CaMeL Pair [ ] ;
rank: 466
score: 98.89209747314453
patch: final double f CaMeL Val = compute CaMeL Objective CaMeL Value ( iter ) ;
rank: 466
score: 98.81015014648438
patch: int iter = f CaMeL Val ;
rank: 466
score: 98.68016706194196
patch: ++ iter ; while ( iter >= n ) { ++ iter ;
rank: 466
score: 98.60919189453125
patch: if ( ! iter . is CaMeL Empty ++ ) return false ;
rank: 466
score: 98.50444684709821
patch: throw iter ; ++ iter ;
rank: 466
score: 98.46063232421875
patch: if ( ++ n <= 0 )
rank: 467
score: 98.90650523792614
patch: final double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x . get CaMeL Point ( ) ) ;
rank: 467
score: 98.89202880859375
patch: final double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( x 1 ,
rank: 467
score: 98.81011962890625
patch: value = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 467
score: 98.67941284179688
patch: ++ iter - 1 [ iter ] . length ; }
rank: 467
score: 98.60891384548611
patch: * * * * * ; * /
rank: 467
score: 98.58635864257812
patch: ++ iter ; else * / ++ iter ;
rank: 468
score: 98.97614156788794
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val . length ) ) ;
rank: 468
score: 98.9181640625
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ; else
rank: 468
score: 98.90626953125
patch: Point CaMeL Value CaMeL Pair checker = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , f CaMeL Val ) ;
rank: 468
score: 98.89089626736111
patch: double [ ] f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL
rank: 468
score: 98.81009928385417
patch: return Point CaMeL Value CaMeL Pair . new CaMeL Point CaMeL And CaMeL Direction ( f CaMeL Val , x $NUMBER$ ) ;
rank: 468
score: 98.67793412642045
patch: ++ iter ; if ( iter <= n ) {
rank: 468
score: 98.60882568359375
patch: if ( iter == null ; * * /
rank: 468
score: 98.58599175347223
patch: / * * ++ iter * / /
rank: 468
score: 98.50431315104167
patch: / ; ++ iter ; ++ iter ; ++ iter ;
rank: 468
score: 98.46012878417969
patch: int n = iter * iter ;
rank: 469
score: 98.97610789331897
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , 1 ) ) ;
rank: 469
score: 98.90598462975544
patch: Iterator < Point CaMeL Value CaMeL Pair > f CaMeL Val = f CaMeL Val . get CaMeL Point ( ) ;
rank: 469
score: 98.89070892333984
patch: double f CaMeL Val $NUMBER$ = f CaMeL Val - f CaMeL Val $NUMBER$ ;
rank: 469
score: 98.81008676382211
patch: return new Point CaMeL Value CaMeL Pair ( Point CaMeL Value CaMeL Pair . Math CaMeL Arrays . copy CaMeL Of ( x ) ,
rank: 469
score: 98.67774793836806
patch: if ( iter <= n ) continue ;
rank: 469
score: 98.60835266113281
patch: } if ( iter == 0 ;
rank: 469
score: 98.58577473958333
patch: ++ iter ; iter ; ++ * /
rank: 469
score: 98.50314331054688
patch: ++ $NUMBER$ ; ++ iter ; -- iter ;
rank: 469
score: 98.45916193181819
patch: ++ iter ; if ( iter != 0 ) {
rank: 470
score: 98.91797485351563
patch: double [ ] x = 0 . 1 ;
rank: 470
score: 98.90572415865384
patch: final double length = f CaMeL Val . clone ( ) ;
rank: 470
score: 98.89065212673611
patch: final double start = f CaMeL Val ;
rank: 470
score: 98.80979322350544
patch: return new Point CaMeL Value CaMeL Pair ( Point CaMeL Value CaMeL Pair . x 1 , f CaMeL Val ) ;
rank: 470
score: 98.67765299479167
patch: return new Point CaMeL Value CaMeL Pair ( x , n , ; }
rank: 470
score: 98.60826110839844
patch: if ; * * * ; /
rank: 470
score: 98.50313720703124
patch: ++ iter ; iter / ; -- iter ;
rank: 470
score: 98.4586690266927
patch: final ; ++ iter ;
rank: 471
score: 98.97588058997844
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , $NUMBER$ ) ) ;
rank: 471
score: 98.90535481770833
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > ! checker . get CaMeL Value ( ) ;
rank: 471
score: 98.80966073495371
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair = get CaMeL Point CaMeL
rank: 471
score: 98.67759352463942
patch: ++ iter ; return new Point CaMeL Value CaMeL Pair ( )
rank: 471
score: 98.608154296875
patch: if ( ! iter . is CaMeL Empty ( ; - $NUMBER$ ;
rank: 471
score: 98.5853271484375
patch: ++ iter ; if iter ; ++ iter ;
rank: 471
score: 98.5030517578125
patch: ++ iter ; ++ iter ; * ++ iter ;
rank: 471
score: 98.45767211914062
patch: strbuff . append ( $STRING$ ) ;
rank: 472
score: 98.97586624710648
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( x 1 ) ) ;
rank: 472
score: 98.90478515625
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x + f CaMeL Val ) ;
rank: 472
score: 98.88985501802884
patch: final double f CaMeL Val = f CaMeL Val : 0 ;
rank: 472
score: 98.80962456597223
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair >> iter = 0 ;
rank: 472
score: 98.67755596454327
patch: int n = Integer . parse CaMeL Int ( iter ) ;
rank: 472
score: 98.60791015625
patch: ++ * * * * iter /
rank: 472
score: 98.58510335286458
patch: ++ iter ; ++ iter ; System . arraycopy iter ;
rank: 472
score: 98.50291137695312
patch: ++ Math ; ++ iter ; ++ iter ;
rank: 472
score: 98.45716271033653
patch: throw new Unsupported CaMeL Operation CaMeL Exception ( $STRING$ + ; }
rank: 473
score: 98.97571563720703
patch: if ( ! compute CaMeL Objective CaMeL Value ( f CaMeL Val ) ) {
rank: 473
score: 98.90465369591347
patch: final double [ ] x = guess . clone ( ) ;
rank: 473
score: 98.8895975748698
patch: double f CaMeL Val = Math . MAX _ VALUE ;
rank: 473
score: 98.8095703125
patch: return get CaMeL Goal CaMeL Type ( f CaMeL Val ) ;
rank: 473
score: 98.58474392361111
patch: ++ iter ; ++ * * ++ ;
rank: 473
score: 98.50248579545455
patch: ++ iter ; ++ iter ; ; throw iter ;
rank: 473
score: 98.456787109375
patch: if ( ! iter . is CaMeL Empty ( ; ; )
rank: 474
score: 98.97537796585648
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) , (
rank: 474
score: 98.91681780133929
patch: int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , n ) ;
rank: 474
score: 98.90429077148437
patch: double CaMeL Value = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , 0 ) ;
rank: 474
score: 98.8894904641544
patch: double [ ] f CaMeL Val = compute CaMeL Objective CaMeL Value ( n ) ;
rank: 474
score: 98.80950927734375
patch: found = Math CaMeL Arrays . copy CaMeL Of ( x ) ;
rank: 474
score: 98.60770089285714
patch: else { n ++ ; }
rank: 474
score: 98.501953125
patch: ++ iter ; ++ iter ; ++ name ;
rank: 474
score: 98.45650024414063
patch: if ( iter < n ) ++ n ;
rank: 475
score: 98.97522786458333
patch: int f CaMeL Val $NUMBER$ = f CaMeL Val - f CaMeL Val ;
rank: 475
score: 98.90406558388158
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair extends Point CaMeL Value CaMeL Pair $NUMBER$ ;
rank: 475
score: 98.88946533203125
patch: int f CaMeL Val = f CaMeL Val - max ;
rank: 475
score: 98.80948215060764
patch: [ ] f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( x ) ;
rank: 475
score: 98.67655029296876
patch: ++ iter ; / * * * * /
rank: 475
score: 98.60744222005208
patch: if ( iter == 0 ; break ;
rank: 475
score: 98.58424595424107
patch: -- iter ; ++ iter ;
rank: 475
score: 98.5016756924716
patch: ++ iter ; ++ start ; ++ iter ; }
rank: 475
score: 98.45626395089286
patch: n ++ ; ++ n ;
rank: 476
score: 98.97491924579327
patch: double f CaMeL Val $NUMBER$ = line . clone ( ) ;
rank: 476
score: 98.9158047762784
patch: double f CaMeL Val = - 1 . 0 ;
rank: 476
score: 98.90366908482143
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair extends Univariate CaMeL Point CaMeL Value CaMeL Pair $NUMBER$ ;
rank: 476
score: 98.88912963867188
patch: double iter = f CaMeL Val . iter ( ) ;
rank: 476
score: 98.80946451822916
patch: result = compute CaMeL Objective CaMeL Value ( x $NUMBER$ , x ) ;
rank: 476
score: 98.67594770951705
patch: ++ iter ; System . arraycopy ( ++ iter ;
rank: 476
score: 98.60736553485577
patch: if ( ! iter . is CaMeL Empty ; return iter ;
rank: 476
score: 98.584228515625
patch: ++ iter ; ++ * * ; * /
rank: 476
score: 98.50113351004464
patch: ++ iter ; ; / /
rank: 476
score: 98.45552062988281
patch: ++ iter ; while ( iter )
rank: 477
score: 98.97489848889802
patch: if ( f CaMeL Val < compute CaMeL Objective CaMeL Value ( f CaMeL Val ) ) {
rank: 477
score: 98.91563197544643
patch: int f CaMeL Val = compute CaMeL Objective CaMeL Value ( f CaMeL Val , f CaMeL Val ) ;
rank: 477
score: 98.903173828125
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = line . search ( x ) ;
rank: 477
score: 98.88899500229779
patch: final Univariate CaMeL Point CaMeL Value CaMeL Pair line = Math CaMeL Arrays . copy CaMeL
rank: 477
score: 98.80903894761029
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( x 1 , x ) ;
rank: 477
score: 98.67576090494792
patch: ++ iter ; / * * iter ;
rank: 477
score: 98.60726492745536
patch: if ( ! iter . is CaMeL Empty ++ ; ++ iter ;
rank: 477
score: 98.58348931206598
patch: ++ iter ; int * int iter ;
rank: 477
score: 98.50104314630681
patch: ++ 1 ; ; ++ iter ; ++ iter ;
rank: 478
score: 98.974755859375
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . get ( f CaMeL Val ) ) ;
rank: 478
score: 98.91512044270833
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ) . get CaMeL Point ( ) ;
rank: 478
score: 98.9022725423177
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( ( Univariate CaMeL Point CaMeL Value CaMeL Pair ) x ) ;
rank: 478
score: 98.88895909926471
patch: double f CaMeL Val = new Univariate CaMeL Point CaMeL Value CaMeL Pair ( x ;
rank: 478
score: 98.80897013346355
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair do {
rank: 478
score: 98.67575412326389
patch: ++ iter ; double iter = iter ;
rank: 478
score: 98.60714721679688
patch: / * * / / * /
rank: 478
score: 98.58291286892361
patch: ++ iter ; / * * ; /
rank: 478
score: 98.50058815696023
patch: ++ iter ; iter / -- ; ++ iter ;
rank: 479
score: 98.97454833984375
patch: d = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( (
rank: 479
score: 98.91482543945312
patch: double [ ] f CaMeL Val = $NUMBER$ . 0 ;
rank: 479
score: 98.90163167317708
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( Fast CaMeL Math . abs ( f CaMeL Val ) ) ;
rank: 479
score: 98.88889031661184
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( direc 1 ) ;
rank: 479
score: 98.80838775634766
patch: Iterator < Point CaMeL Value CaMeL Pair Point CaMeL Value CaMeL Pair > ++ ;
rank: 479
score: 98.67494201660156
patch: if ( iter >= iter ) {
rank: 479
score: 98.60682678222656
patch: / * ; * * / }
rank: 479
score: 98.500048828125
patch: ++ iter ; ++ iter ; else ; iter
rank: 479
score: 98.45415649414062
patch: iter = iter . iterator ( ) ; ;
rank: 480
score: 98.91481526692708
patch: double [ ] f CaMeL Val = 0 . 1 ;
rank: 480
score: 98.88882266773896
patch: final double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ) ; final
rank: 480
score: 98.80814361572266
patch: { double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 480
score: 98.6741943359375
patch: ++ iter ; while ( iter ; ) ++ iter ;
rank: 480
score: 98.60626220703125
patch: else { * * * / / }
rank: 480
score: 98.58203735351563
patch: ++ iter ; ++ - 1 ; iter ;
rank: 480
score: 98.49955444335937
patch: ++ iter ; ++ iter ; ++ false ;
rank: 480
score: 98.45407104492188
patch: int n = iter ; while ( iter < n )
rank: 481
score: 98.97419343171296
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ,
rank: 481
score: 98.91421669407895
patch: double f CaMeL Val = ( Univariate CaMeL Point CaMeL Value CaMeL Pair ) checker . line ;
rank: 481
score: 98.90118408203125
patch: final double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x , f CaMeL Val ) ;
rank: 481
score: 98.8887430826823
patch: double [ ] x = Math . MAX _ VALUE ;
rank: 481
score: 98.80810546875
patch: tmp = compute CaMeL Objective CaMeL Value ( x $NUMBER$ ) ;
rank: 481
score: 98.67418561662946
patch: int n = Integer . parse CaMeL Int ( ++ n ) ;
rank: 481
score: 98.60610961914062
patch: / * = iter * 0 ;
rank: 481
score: 98.58193969726562
patch: else * ++ iter ;
rank: 481
score: 98.49946899414063
patch: return iter ; ++ iter ; ++ iter ;
rank: 481
score: 98.45384803185097
patch: int iter = Math . max ( 0 , n ) ;
rank: 482
score: 98.97398792613636
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , x 1 ) ;
rank: 482
score: 98.88858795166016
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x , x ,
rank: 482
score: 98.80799696180556
patch: Iterator < Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > ++ ;
rank: 482
score: 98.60588073730469
patch: / * * ; / * /
rank: 482
score: 98.58140055338542
patch: else if ++ iter ;
rank: 482
score: 98.49943403764205
patch: ++ iter ; ; iter -- ; ++ iter ;
rank: 482
score: 98.45381986177884
patch: int iter = iter ; while ( iter < n ) {
rank: 483
score: 98.97390747070312
patch: ( ( Point CaMeL Value CaMeL Pair ) checker ) .
rank: 483
score: 98.91385048314145
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( direc [ ) ;
rank: 483
score: 98.90092540922619
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = line . to CaMeL String ( ) ;
rank: 483
score: 98.80793592664931
patch: r = Math CaMeL Arrays . copy CaMeL Of ( x . clone ( ) ) ;
rank: 483
score: 98.67350463867187
patch: ++ iter ; this . ++ iter ; }
rank: 483
score: 98.60580105251736
patch: i ] [ 0 ] = 0 ;
rank: 483
score: 98.5812479654948
patch: / ] ++ iter ;
rank: 483
score: 98.49885697798295
patch: ++ iter ; ++ x 1 ; ++ iter ;
rank: 483
score: 98.4534403483073
patch: int iter = iter ; while ( iter == n )
rank: 484
score: 98.97388537176724
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) , guess ) ;
rank: 484
score: 98.90086780894886
patch: double x 1 [ ] = f CaMeL Val ;
rank: 484
score: 98.88740370008681
patch: final int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( direc ;
rank: 484
score: 98.80765380859376
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair Point CaMeL Value CaMeL Pair > iter = 0 ;
rank: 484
score: 98.60542805989583
patch: if ( ! iter . is CaMeL Empty ++ ++ )
rank: 484
score: 98.58091517857143
patch: ++ min ; ++ iter ;
rank: 484
score: 98.49882289341518
patch: ++ n ; ++ max ;
rank: 484
score: 98.4534200032552
patch: ++ iter ; System . exit ( 0 ) ; }
rank: 485
score: 98.97365993923611
patch: if ( ! f CaMeL Val ) {
rank: 485
score: 98.91361083984376
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , guess ;
rank: 485
score: 98.90066293569711
patch: final double iter = x . get CaMeL Value ( ) ;
rank: 485
score: 98.88734436035156
patch: double f CaMeL Val $NUMBER$ = f CaMeL Val + f CaMeL Val $NUMBER$ ;
rank: 485
score: 98.80762881324405
patch: return Point CaMeL Value CaMeL Pair . new CaMeL Point CaMeL And CaMeL Direction ( x , 0 ) ;
rank: 485
score: 98.67274693080357
patch: ++ iter ; while ( iter <= n ) { ++ iter ;
rank: 485
score: 98.60491473858173
patch: if ( ! iter . is CaMeL Empty iter ( ) ;
rank: 485
score: 98.58064100477431
patch: ++ iter ; try ; iter * /
rank: 485
score: 98.49837036132813
patch: ++ iter ; ++ iter ; } / ;
rank: 485
score: 98.45339965820312
patch: while ( ! ++ n ) {
rank: 486
score: 98.91231079101563
patch: double [ ] x 1 = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 486
score: 98.9005878155048
patch: final double f CaMeL Val = value . clone ( ) ;
rank: 486
score: 98.88667805989583
patch: double [ ] x = Math CaMeL Arrays . copy CaMeL Of ( x 1 ) ;
rank: 486
score: 98.80759006076389
patch: return Math CaMeL Arrays . copy CaMeL Of ( x 1 , f CaMeL Val ) ;
rank: 486
score: 98.67256673177083
patch: return new Point CaMeL Value CaMeL Pair ( iter , iter , ; }
rank: 486
score: 98.60430908203125
patch: if ( . is CaMeL Empty ( ) ) ; }
rank: 486
score: 98.58062189275569
patch: ++ 1 ; ++ iter ; if ++ iter ;
rank: 486
score: 98.4983243075284
patch: ++ iter ; ++ iter ; } iter ++ ;
rank: 486
score: 98.45276750837054
patch: Iterator iter = ++ n ;
rank: 487
score: 98.97360755657327
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) , $NUMBER$ ) ;
rank: 487
score: 98.80741373697917
patch: return new Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ( f CaMeL Val , f CaMeL Val ) ;
rank: 487
score: 98.67242431640625
patch: return new Point CaMeL Value CaMeL Pair ( x , n ; }
rank: 487
score: 98.60394897460938
patch: / * * * * / ++ iter ;
rank: 487
score: 98.57996215820313
patch: ++ iter ; ++ * * iter ; /
rank: 487
score: 98.49796142578126
patch: ++ iter ; ++ max ; return iter ;
rank: 488
score: 98.97355143229167
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( 0 , f CaMeL Val ) ;
rank: 488
score: 98.91156005859375
patch: double f CaMeL Val = x . search ( x ;
rank: 488
score: 98.90048363095238
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = x . get CaMeL Point ( ) ;
rank: 488
score: 98.88639009915866
patch: double iter = Math . abs ( 0 . 0 ) ;
rank: 488
score: 98.80740356445312
patch: p = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 488
score: 98.6720703125
patch: int n = Integer . parse CaMeL Int ( iter , n ) ;
rank: 488
score: 98.60393415178571
patch: ++ iter ; if ; }
rank: 488
score: 98.57903180803571
patch: * * / ++ iter ;
rank: 488
score: 98.49752371651786
patch: ++ new ; ++ iter ;
rank: 488
score: 98.4516092936198
patch: if ( ! iter . contains ( x 1 ) )
rank: 489
score: 98.97347412109374
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , 1 ) ;
rank: 489
score: 98.90023099459134
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 489
score: 98.80739524147727
patch: return Point CaMeL Value CaMeL Pair . new CaMeL Point CaMeL And CaMeL Direction ( x , x $NUMBER$ ) ;
rank: 489
score: 98.67195268110795
patch: ++ iter ; while ( iter ; ; ) {
rank: 489
score: 98.603759765625
patch: while ( ! iter . is CaMeL Empty ( ; ) {
rank: 489
score: 98.5787353515625
patch: ++ iter ; ++ iter ; ++ * ++ iter ;
rank: 489
score: 98.49711390904018
patch: ++ iter ; ++ line ;
rank: 489
score: 98.45105852399554
patch: n ++ ; ++ iter ;
rank: 490
score: 98.91146240234374
patch: double f CaMeL Val = 1 . 1 ;
rank: 490
score: 98.88603772615132
patch: final double f CaMeL Val = f CaMeL Val ; f CaMeL Val = f CaMeL Val ;
rank: 490
score: 98.80724566915761
patch: Iterator < Point CaMeL Value CaMeL Pair protected Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair )
rank: 490
score: 98.67177327473958
patch: return new Point CaMeL Value CaMeL Pair ( ++ iter )
rank: 490
score: 98.60275268554688
patch: else { * * / * /
rank: 490
score: 98.57832554408482
patch: try { ++ - iter ;
rank: 490
score: 98.49697043678977
patch: ++ -- iter ; ++ iter ; ++ iter ;
rank: 490
score: 98.45058030348558
patch: ++ iter ; if ( iter == null ) return null ;
rank: 491
score: 98.90007990056819
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , x $NUMBER$ ) ;
rank: 491
score: 98.88601202713816
patch: double [ ] x 1 = Math CaMeL Arrays . copy CaMeL Of ( x 1 ) ;
rank: 491
score: 98.80676721643519
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair [ ] ++ iter ;
rank: 491
score: 98.6717020670573
patch: if ( iter < n ) { ++ n ; }
rank: 491
score: 98.60263400607639
patch: / * * * * ; * /
rank: 491
score: 98.578173828125
patch: / * ++ iter * / ++ iter ;
rank: 491
score: 98.49659312855114
patch: ++ iter ; ++ iter ; iter return iter ;
rank: 492
score: 98.97319946289062
patch: final double f CaMeL Val = f CaMeL Val - compute CaMeL Objective CaMeL Value ( x ) ;
rank: 492
score: 98.91118774414062
patch: int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ; ;
rank: 492
score: 98.89989217122395
patch: final Univariate CaMeL Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair > f CaMeL Val = f CaMeL Val ;
rank: 492
score: 98.885986328125
patch: double f CaMeL Val = f CaMeL Val - ( 0 . 0 ) ;
rank: 492
score: 98.80672781808036
patch: if ( ! f CaMeL Val . is CaMeL Empty ( ) )
rank: 492
score: 98.67058454241071
patch: return new Point CaMeL Value CaMeL Pair ( iter , x , ;
rank: 492
score: 98.60245768229167
patch: Iterator iter = iter . iterator ++ ; ++ iter ;
rank: 492
score: 98.49627130681819
patch: ++ $NUMBER$ ; ++ iter ; } ++ iter ;
rank: 492
score: 98.45008544921875
patch: ++ n ; while ( iter < n )
rank: 493
score: 98.89981783353366
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair > . Point CaMeL Value CaMeL Pair $NUMBER$ ;
rank: 493
score: 98.80640587439903
patch: r = compute CaMeL Objective CaMeL Value ( x $NUMBER$ ) ;
rank: 493
score: 98.67056039663461
patch: ++ iter ; if ( iter < iter ) ++ iter ;
rank: 493
score: 98.6024502840909
patch: Iterator < Integer > iter = iter . iterator ;
rank: 493
score: 98.5748779296875
patch: ++ iter ; iter ; if ++ 1 ;
rank: 493
score: 98.4958740234375
patch: ++ iter ; ; ++ iter ; iter ;
rank: 494
score: 98.97299081307871
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 494
score: 98.91069103422619
patch: double f CaMeL Val = ( Univariate CaMeL Point CaMeL Value CaMeL Pair ) checker . get CaMeL Point CaMeL
rank: 494
score: 98.89980597245066
patch: double f CaMeL Val = f CaMeL Val - compute CaMeL Objective CaMeL Value ( 0 ) ;
rank: 494
score: 98.88547877261513
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = Math CaMeL Arrays . to CaMeL
rank: 494
score: 98.80610926011029
patch: return new CaMeL Point CaMeL And CaMeL Direction ( x 1 , x $NUMBER$ ) ;
rank: 494
score: 98.67047588641827
patch: return new Point CaMeL Value CaMeL Pair ( n , iter ;
rank: 494
score: 98.60218811035156
patch: ++ [ ] iter ; } }
rank: 494
score: 98.57429722377232
patch: iter * ; ++ iter ;
rank: 494
score: 98.49506170099431
patch: ++ iter ; ; ++ max ; ++ iter ;
rank: 494
score: 98.44976806640625
patch: float iter = iter * n ;
rank: 495
score: 98.97292751736111
patch: double f CaMeL Val 1 = 0 ;
rank: 495
score: 98.91045178865132
patch: int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( n , 0 ) ;
rank: 495
score: 98.8994777513587
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = line . get CaMeL Goal CaMeL Type ( ) ;
rank: 495
score: 98.8853759765625
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x , start ) ;
rank: 495
score: 98.8060811360677
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair > {
rank: 495
score: 98.60205841064453
patch: ++ * * * * * /
rank: 495
score: 98.57406616210938
patch: ++ iter ; ++ iter ; ++ * * iter ;
rank: 495
score: 98.49498291015625
patch: ++ iter ; ; / / = iter ;
rank: 495
score: 98.44879828559027
patch: while ( iter ++ >= n ) {
rank: 496
score: 98.9728759765625
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) , x $NUMBER$ ) ;
rank: 496
score: 98.91023763020833
patch: int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( direc [ n ] ) ;
rank: 496
score: 98.80586322985198
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair > ++ ;
rank: 496
score: 98.67028045654297
patch: ++ iter ? $NUMBER$ : $NUMBER$ ;
rank: 496
score: 98.60121459960938
patch: ++ [ ] iter ; } = iter ;
rank: 496
score: 98.57323109019886
patch: / * ] iter ; / / * / /
rank: 496
score: 98.49492853338069
patch: ++ iter ; ++ iter ; iter * ++ ;
rank: 496
score: 98.44870827414773
patch: while ( iter != null && iter < n )
rank: 497
score: 98.97264783135776
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( x [ 0 ] ) ) ;
rank: 497
score: 98.8990145596591
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( x , f CaMeL Val . clone ( ) ) ;
rank: 497
score: 98.88511827256944
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = this . direc ;
rank: 497
score: 98.66829740084134
patch: ++ iter ; while ( iter ; ) { ++ iter ;
rank: 497
score: 98.6011962890625
patch: / * * * ; / }
rank: 497
score: 98.57294311523438
patch: ++ iter ; / * / ++ iter ;
rank: 497
score: 98.49468383789062
patch: ++ iter ; } if iter = iter ;
rank: 497
score: 98.4479092684659
patch: if ( ++ n > 0 ) ++ n ;
rank: 498
score: 98.97236772017045
patch: while ( iter < direc . length ) {
rank: 498
score: 98.91016235351563
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , $NUMBER$ ;
rank: 498
score: 98.8989490327381
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( x 1 , f CaMeL Val ) ;
rank: 498
score: 98.8848876953125
patch: double f CaMeL Val = f CaMeL Val ; f CaMeL Val = x ;
rank: 498
score: 98.80547223772321
patch: Iterator < Point CaMeL Value CaMeL Pair Point CaMeL Value CaMeL Pair >
rank: 498
score: 98.60077459161931
patch: else { if ++ * 0 . 0 ; }
rank: 498
score: 98.57244262695312
patch: / * * ++ * / ++ iter ;
rank: 498
score: 98.49461780894886
patch: ++ iter ; ++ - iter ; ++ iter ;
rank: 498
score: 98.44789475661058
patch: if ( iter == null || iter . length > n )
rank: 499
score: 98.89873798076923
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair * ;
rank: 499
score: 98.88485557154605
patch: int f CaMeL Val = f CaMeL Val ; int f CaMeL Val = f CaMeL Val ;
rank: 499
score: 98.805458984375
patch: result = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ) ;
rank: 499
score: 98.66764692826705
patch: ++ iter ; while ( iter == iter ) {
rank: 499
score: 98.49451904296875
patch: ++ iter ; ++ start ; ++ n ;
rank: 499
score: 98.44767761230469
patch: final int n = ++ n ;
rank: 500
score: 98.97207462086396
patch: ++ iter ; double f CaMeL Val = Univariate CaMeL Point CaMeL Value CaMeL Pair ;
rank: 500
score: 98.8984883626302
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair extends Univariate CaMeL Point CaMeL Value CaMeL Pair > checker = true ;
rank: 500
score: 98.88455200195312
patch: final double f CaMeL Val = f CaMeL Val ) ;
rank: 500
score: 98.80536358173077
patch: return new Point CaMeL Value CaMeL Pair ( Point CaMeL Value CaMeL Pair . Math CaMeL Arrays . copy CaMeL Of ( x 1 ,
rank: 500
score: 98.60017395019531
patch: else { iter += 0 ; }
rank: 500
score: 98.49411843039773
patch: ++ iter ; ++ iter ; / = iter ;
rank: 500
score: 98.44736938476562
patch: while ( iter != null ) ++ iter ;
rank: 501
score: 98.9720703125
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . get CaMeL Point ( x ) ) ;
rank: 501
score: 98.90971447172619
patch: int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( direc [ 1 ] ) ;
rank: 501
score: 98.80536358173077
patch: return new Point CaMeL Value CaMeL Pair ( Point CaMeL Value CaMeL Pair . new CaMeL Point CaMeL And CaMeL Direction ( x , ;
rank: 501
score: 98.66742815290179
patch: ++ iter * ++ iter ;
rank: 501
score: 98.59996032714844
patch: if ; * * * * /
rank: 501
score: 98.57113211495536
patch: else { ++ iter ; ;
rank: 501
score: 98.49337158203124
patch: ++ iter ; ++ iter ; iter ; iter
rank: 501
score: 98.44686185396634
patch: final int iter = 0 ; while ( iter < n )
rank: 502
score: 98.97205946180556
patch: ++ n ; double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 502
score: 98.90955200195313
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x . search ( $STRING$ ) ) ;
rank: 502
score: 98.89783824573864
patch: final double [ ] f CaMeL Val = 0 ;
rank: 502
score: 98.88275505514706
patch: double [ ] iter = Math CaMeL Arrays . copy CaMeL Of ( iter ) ;
rank: 502
score: 98.80530802408855
patch: c = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 502
score: 98.66735026041667
patch: Iterator < Point CaMeL Value CaMeL Pair > iterator = iter . iterator ;
rank: 502
score: 98.59965515136719
patch: ++ * * * iter / }
rank: 502
score: 98.5710957845052
patch: ++ iter ; try ;
rank: 502
score: 98.492431640625
patch: ++ max ; ++ start ;
rank: 502
score: 98.44679768880208
patch: buffer . append ( $STRING$ ) . append ( iter )
rank: 503
score: 98.97157866379311
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val . n ) ) ;
rank: 503
score: 98.9095458984375
patch: double f CaMeL Val = ( Univariate CaMeL Point CaMeL Value CaMeL Pair ) checker . line CaMeL
rank: 503
score: 98.88180721507354
patch: double f CaMeL Val = f CaMeL Val ; double f CaMeL Val = null ;
rank: 503
score: 98.80482421875
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ++ iter ;
rank: 503
score: 98.66722954644098
patch: ++ iter ; x [ iter ] ;
rank: 503
score: 98.57081909179688
patch: ++ iter ; ++ * * * / /
rank: 503
score: 98.4912442294034
patch: ++ iter ; ++ iter ; ++ iter ; iter
rank: 503
score: 98.44677734375
patch: while ( iter <= n )
rank: 504
score: 98.90899658203125
patch: final double f CaMeL Val = f CaMeL Val + compute CaMeL Objective CaMeL Value ( x ) ;
rank: 504
score: 98.88100857204861
patch: final double f CaMeL Val = compute CaMeL Objective CaMeL Value ( float CaMeL Value ) ;
rank: 504
score: 98.8047607421875
patch: Iterator <= Univariate CaMeL Point CaMeL Value CaMeL Pair > iter = 0 ;
rank: 504
score: 98.6671475497159
patch: if ( iter < n ) { break ; }
rank: 504
score: 98.59959581163194
patch: else { ++ * 0 . 0 ;
rank: 504
score: 98.49124145507812
patch: ++ iter ; ++ max ; ++ start ;
rank: 505
score: 98.9711052389706
patch: ++ iter ; f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 505
score: 98.90876116071429
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ) . to CaMeL String ( ) ;
rank: 505
score: 98.8971698467548
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( }
rank: 505
score: 98.88095272288604
patch: final double [ ] f CaMeL Val = x . get CaMeL Point ( ) ;
rank: 505
score: 98.80435035342262
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Point CaMeL Value CaMeL Pair . get CaMeL Point CaMeL
rank: 505
score: 98.66699896918402
patch: ++ iter ; * / * / ;
rank: 505
score: 98.59959581163194
patch: if ( iter == 0 ; return ;
rank: 505
score: 98.56962446732955
patch: ++ iter ; iter ; / * * / /
rank: 505
score: 98.49113246372768
patch: ++ iter ; ++ Math ;
rank: 505
score: 98.44614821213942
patch: return new Point CaMeL Value CaMeL Pair ( n , x ;
rank: 506
score: 98.97055233226104
patch: if ( f CaMeL Val < compute CaMeL Objective CaMeL Value ( x ) ) {
rank: 506
score: 98.89708862304687
patch: d = f CaMeL Val ; f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 506
score: 98.88071160567434
patch: double f CaMeL Val = new Univariate CaMeL Point CaMeL Value CaMeL Pair ( x 1 ) ;
rank: 506
score: 98.80431547619048
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Math CaMeL Arrays . copy CaMeL Of ( x ,
rank: 506
score: 98.66631469726562
patch: ++ iter ; / * * * * ;
rank: 506
score: 98.59941101074219
patch: * * * * * ; }
rank: 506
score: 98.56910051618304
patch: / iter ; ++ iter ;
rank: 506
score: 98.491015625
patch: ++ iter ; iter * / = iter ;
rank: 506
score: 98.44596099853516
patch: while ( iter ++ >= n )
rank: 507
score: 98.97051532451923
patch: final int f CaMeL Val = x . clone ( ) ;
rank: 507
score: 98.9086405436198
patch: if ( f CaMeL Val <= f CaMeL Val ) {
rank: 507
score: 98.88044289981617
patch: double f CaMeL Val = f CaMeL Val ; double f CaMeL Val = x ;
rank: 507
score: 98.80401611328125
patch: return new Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ( x ) ;
rank: 507
score: 98.6656494140625
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + ++ n ) ;
rank: 507
score: 98.5992660522461
patch: ++ * iter ; * * /
rank: 507
score: 98.56901245117187
patch: ++ * ++ iter ; ++ - iter ;
rank: 507
score: 98.49026489257812
patch: ++ iter ; ++ iter ; = start ;
rank: 508
score: 98.97031430844908
patch: d = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , x ) ) ;
rank: 508
score: 98.90852864583333
patch: int f CaMeL Val = f CaMeL Val + $NUMBER$ ;
rank: 508
score: 98.8967529296875
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair > checker =
rank: 508
score: 98.80397542317708
patch: n = Math CaMeL Arrays . copy CaMeL Of ( x . clone ( ) ) ;
rank: 508
score: 98.59907836914063
patch: if ( iter == null ; return null ;
rank: 508
score: 98.56807250976563
patch: / ; ++ iter ; if ++ iter ;
rank: 508
score: 98.49015669389205
patch: ++ iter ; ++ iter ; throw iter ; }
rank: 508
score: 98.44522094726562
patch: pos = Math . min ( n , n ) ;
rank: 509
score: 98.90841064453124
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ] ) ;
rank: 509
score: 98.89658813476562
patch: ++ f CaMeL Val ; double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 509
score: 98.87994939630681
patch: final double f CaMeL Val = relative CaMeL Threshold ;
rank: 509
score: 98.80392937911184
patch: return new Point CaMeL Value CaMeL Pair ( Point CaMeL Value CaMeL Pair . get CaMeL Point CaMeL
rank: 509
score: 98.66550699869792
patch: ++ iter ; return new Point CaMeL Value CaMeL Pair (
rank: 509
score: 98.59880828857422
patch: i * * * * ; /
rank: 509
score: 98.56732732599431
patch: ++ iter ; iter ; * / ++ iter ;
rank: 509
score: 98.48970249720982
patch: ++ iterator ; ++ iter ;
rank: 509
score: 98.44441441127232
patch: Iterator iter = ++ iter ;
rank: 510
score: 98.90822347005208
patch: if ( f CaMeL Val . length < n ) {
rank: 510
score: 98.89603097098214
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = line . search ( x $NUMBER$ ) ;
rank: 510
score: 98.8039020040761
patch: Iterator < Point CaMeL Value CaMeL Pair , Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair >
rank: 510
score: 98.665283203125
patch: ++ iter ; / * * * ; /
rank: 510
score: 98.59868621826172
patch: * * * ; * * /
rank: 510
score: 98.5667236328125
patch: / * ] iter ; / * / /
rank: 510
score: 98.4442889873798
patch: throw new Runtime CaMeL Exception ( $STRING$ + ++ iter ) ;
rank: 511
score: 98.96975708007812
patch: if ( checker instanceof Point CaMeL Value CaMeL Pair ) {
rank: 511
score: 98.9076919555664
patch: double f CaMeL Val = $NUMBER$ ;
rank: 511
score: 98.87943761488971
patch: double [ ] x = Math CaMeL Arrays . copy CaMeL Of ( x 1 ,
rank: 511
score: 98.80387609145221
patch: v = Math CaMeL Arrays . copy CaMeL Of ( direc . 0 ) ;
rank: 511
score: 98.6652323404948
patch: ++ iter >= 0 ;
rank: 511
score: 98.59822591145833
patch: else { if ++ iter ; * /
rank: 511
score: 98.44382731119792
patch: if ( iter != null ) continue ;
rank: 512
score: 98.96967107599431
patch: final double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( direc [ 0 ] ) ;
rank: 512
score: 98.90625
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , ;
rank: 512
score: 98.89568359375
patch: double iter = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( direc ) ) ;
rank: 512
score: 98.87926528033088
patch: int f CaMeL Val = f CaMeL Val ; int f CaMeL Val = 0 ;
rank: 512
score: 98.80335998535156
patch: other = new CaMeL Point CaMeL And CaMeL Direction ( f CaMeL Val ) ;
rank: 512
score: 98.66482979910714
patch: ++ iter ; if ( iter > 0 ) { ++ iter ;
rank: 512
score: 98.59780051491477
patch: if ( ! iter . contains ( iter ) )
rank: 512
score: 98.56607491629464
patch: / * ] iter * ;
rank: 512
score: 98.48924909319196
patch: ++ iter ; ; * /
rank: 512
score: 98.4435565655048
patch: Point CaMeL Value CaMeL Pair ; if ( iter != null )
rank: 513
score: 98.96962327223558
patch: if ( f CaMeL Val < f CaMeL Val ) { {
rank: 513
score: 98.89564005533855
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = new CaMeL Point CaMeL And CaMeL Direction ( x 1 ,
rank: 513
score: 98.8790347450658
patch: double f CaMeL Val = new Univariate CaMeL Point CaMeL Value CaMeL Pair ( f CaMeL Val ,
rank: 513
score: 98.8031005859375
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( checker . get CaMeL Value ( ) ) ;
rank: 513
score: 98.66475423177083
patch: ++ iter ; } return new Point CaMeL Value CaMeL Pair ( x ;
rank: 513
score: 98.5977450284091
patch: if ( iter == 0 ) return null ; }
rank: 513
score: 98.5660400390625
patch: ++ * ++ iter ; ++ iter ; ;
rank: 513
score: 98.4890625
patch: ++ iter ; iter = iter + iter ;
rank: 513
score: 98.44349365234375
patch: y [ iter ] [ n ] = ;
rank: 514
score: 98.96902781519397
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . get CaMeL Size ( ) ) ;
rank: 514
score: 98.89545147235577
patch: double x 1 = f CaMeL Val . clone ( ) ;
rank: 514
score: 98.80303664434524
patch: Iterator < Point CaMeL Value CaMeL Pair protected Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair )
rank: 514
score: 98.66331481933594
patch: ++ iter - 1 * iter ;
rank: 514
score: 98.59684448242187
patch: * * * * * / ++ iter ;
rank: 514
score: 98.5654296875
patch: / * ++ iter ; * / ++ iter ;
rank: 514
score: 98.48824055989583
patch: ++ iter ; ++ iter ; else / ++ iter ;
rank: 515
score: 98.96869106950432
patch: double f CaMeL Val = Math . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . this . get CaMeL Value ( ) ) ;
rank: 515
score: 98.90592233758224
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x . search ( ) ) ;
rank: 515
score: 98.87832406850961
patch: double f CaMeL Val = f CaMeL Val + x 1 ;
rank: 515
score: 98.8029052734375
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair > iter = line .
rank: 515
score: 98.59603881835938
patch: * * * * * / /
rank: 515
score: 98.56502859933036
patch: i * ++ ; break ;
rank: 515
score: 98.48799272017045
patch: ++ iter ; ++ iter ; ++ start ; }
rank: 515
score: 98.44315592447917
patch: int n = iter ; while ( n < n )
rank: 516
score: 98.96868218315973
patch: final double value = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 516
score: 98.9055408296131
patch: double f CaMeL Val = ( Univariate CaMeL Point CaMeL Value CaMeL Pair ) checker . clone ( ) ;
rank: 516
score: 98.8947509765625
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = . get CaMeL Value ( ) ;
rank: 516
score: 98.87647162543402
patch: double [ ] f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( x ;
rank: 516
score: 98.80265045166016
patch: Node f CaMeL Val = f CaMeL Val . get CaMeL Point ( ) ;
rank: 516
score: 98.6632792154948
patch: ++ iter ; ; ;
rank: 516
score: 98.59525299072266
patch: / * * / * * /
rank: 516
score: 98.564892578125
patch: ++ iter ; int * / ++ iter ;
rank: 516
score: 98.4876200358073
patch: ++ iter ; ++ iter ; else ; ++ iter ;
rank: 516
score: 98.44264729817708
patch: j = Math . max ( iter , iter ) ;
rank: 517
score: 98.9686279296875
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , ) ) ;
rank: 517
score: 98.89450073242188
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( f CaMeL Val , x 1 ) ;
rank: 517
score: 98.87576293945312
patch: double f CaMeL Val = f CaMeL Val . length ;
rank: 517
score: 98.80256453804348
patch: Iterator < Point CaMeL Value CaMeL Pair protected Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ;
rank: 517
score: 98.66324462890626
patch: ++ iter ; / * * ; * /
rank: 517
score: 98.59469265407986
patch: ++ < 0 ? 0 : 0 ;
rank: 517
score: 98.5648701985677
patch: / * ] iter ;
rank: 517
score: 98.48690795898438
patch: ++ iter ; ++ iter ; ++ * ;
rank: 518
score: 98.96815892269737
patch: int f CaMeL Val = compute CaMeL Objective CaMeL Value ( f CaMeL Val , x ) ;
rank: 518
score: 98.89403279622395
patch: final double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , f CaMeL Val ) ;
rank: 518
score: 98.87545437282986
patch: double f CaMeL Val $NUMBER$ = Math CaMeL Arrays . copy CaMeL Of ( direc ;
rank: 518
score: 98.80251953125
patch: return Point CaMeL Value CaMeL Pair . new CaMeL Point CaMeL And CaMeL Direction ( x , x , f CaMeL Val ) ;
rank: 518
score: 98.66302083333333
patch: ++ iter ; return new Point CaMeL Value CaMeL Pair ( iter ) ;
rank: 518
score: 98.59459092881944
patch: ++ [ ] [ ] = iter ;
rank: 518
score: 98.5646240234375
patch: ++ iter ; ++ 1 ; int iter ;
rank: 518
score: 98.48638916015625
patch: iter ++ ;
rank: 518
score: 98.44249471028645
patch: int iter = iter ; while ( iter != null )
rank: 519
score: 98.90371469350961
patch: int f CaMeL Val = f CaMeL Val [ 0 ] ;
rank: 519
score: 98.89328835227273
patch: f CaMeL Val = line . clone ( ) ;
rank: 519
score: 98.87528722426471
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = get CaMeL Start CaMeL
rank: 519
score: 98.80236098345588
patch: Iterator < Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > do {
rank: 519
score: 98.66297496448864
patch: ++ iter ; while ( iter < n ; )
rank: 519
score: 98.59455108642578
patch: ++ * * * ++ * /
rank: 519
score: 98.56441824776786
patch: ++ iter ; int * /
rank: 519
score: 98.48627263849431
patch: / iter ++ ; ++ iter ; ++ iter ;
rank: 519
score: 98.44196319580078
patch: int n = iter + iter ;
rank: 520
score: 98.9028087797619
patch: double f CaMeL Val = ( Univariate CaMeL Point CaMeL Value CaMeL Pair ) x . clone ( ) ;
rank: 520
score: 98.89307702105978
patch: f CaMeL Val = f CaMeL Val ; f CaMeL Val = compute CaMeL Objective CaMeL Value ( x $NUMBER$ ) ;
rank: 520
score: 98.87510770909927
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = Math CaMeL Arrays .
rank: 520
score: 98.80210524338942
patch: return compute CaMeL Objective CaMeL Value ( x , x ) ;
rank: 520
score: 98.66277204241071
patch: return new Point CaMeL Value CaMeL Pair ( x [ n ] ;
rank: 520
score: 98.59440104166667
patch: if ( ! iter . is CaMeL Empty ++ null ;
rank: 520
score: 98.48586203835227
patch: ++ iter ; ++ ++ start ; ++ iter ;
rank: 520
score: 98.44163682725694
patch: switch ( n ) { case 1 :
rank: 521
score: 98.96735491071429
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val . n ) ;
rank: 521
score: 98.90110270182292
patch: ++ [ ] f CaMeL Val = f CaMeL Val ;
rank: 521
score: 98.89266967773438
patch: double [ ] x = x . clone ( ) ;
rank: 521
score: 98.8748715049342
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( f CaMeL Val , iter ) ;
rank: 521
score: 98.802021484375
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair = get CaMeL
rank: 521
score: 98.59439849853516
patch: / * ++ * * ; /
rank: 521
score: 98.5630215731534
patch: ++ iter ; ++ iter ; ++ case iter ;
rank: 521
score: 98.48583374023437
patch: ++ iter ; ++ true ; ++ iter ;
rank: 521
score: 98.44157270951705
patch: Iterator iter = iter . iterator ( ) ; }
rank: 522
score: 98.89235617897727
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker . get CaMeL Value ( x 1 ) ;
rank: 522
score: 98.87484130859374
patch: float f CaMeL Val = f CaMeL Val ;
rank: 522
score: 98.80187270220588
patch: result = Math CaMeL Arrays . copy CaMeL Of ( direc , 0 ) ;
rank: 522
score: 98.661181640625
patch: return new Point CaMeL Value CaMeL Pair ( iter , iter , x ;
rank: 522
score: 98.59371512276786
patch: ++ * ++ iter ; }
rank: 522
score: 98.56279962713069
patch: ++ iter ; ++ iter ; if ++ 1 ;
rank: 522
score: 98.44149780273438
patch: if ( ++ n > 0 ) { ++ iter ;
rank: 523
score: 98.96695963541667
patch: double f CaMeL Val = Univariate CaMeL Point CaMeL Value CaMeL Pair ( f CaMeL Val , 0 ) ;
rank: 523
score: 98.90028889973958
patch: double [ ] x = line . f CaMeL Val ;
rank: 523
score: 98.89231178977273
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x $NUMBER$ . get CaMeL Value ( ) ) ;
rank: 523
score: 98.8746696920956
patch: double f CaMeL Val = new Univariate CaMeL Point CaMeL Value CaMeL Pair ( x ,
rank: 523
score: 98.80187049278847
patch: return new CaMeL Point CaMeL And CaMeL Direction ( new CaMeL Point CaMeL And CaMeL Direction ( x , f CaMeL Val ) ) ;
rank: 523
score: 98.66074829101562
patch: ++ iter ; if ( ; ++ iter ;
rank: 523
score: 98.59337768554687
patch: ++ [ ] iter ; } return iter ;
rank: 523
score: 98.48565673828125
patch: ++ $NUMBER$ ; ++ start ;
rank: 523
score: 98.44133649553571
patch: final int n = iter ;
rank: 524
score: 98.90023803710938
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( x , f CaMeL Val , 0 ) ;
rank: 524
score: 98.89227849786931
patch: f CaMeL Val = x . clone ( ) ;
rank: 524
score: 98.80167643229167
patch: result = Math CaMeL Arrays . copy CaMeL Of ( direc ) ;
rank: 524
score: 98.66060965401786
patch: ++ iter ; return new Point CaMeL Value CaMeL Pair ( ) ;
rank: 524
score: 98.59242078993056
patch: / * * ++ * / * /
rank: 524
score: 98.56114612926136
patch: ++ iter ; ++ 1 ; if ++ iter ;
rank: 524
score: 98.48548235212054
patch: } iter ; ++ iter ;
rank: 525
score: 98.966552734375
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ) ; ;
rank: 525
score: 98.89195421006944
patch: int x 1 = f CaMeL Val ;
rank: 525
score: 98.87244669596355
patch: int f CaMeL Val = f CaMeL Val . length ;
rank: 525
score: 98.80166286892361
patch: tmp = new CaMeL Point CaMeL And CaMeL Direction ( x , f CaMeL Val ) ;
rank: 525
score: 98.66059221540179
patch: throw new Runtime CaMeL Exception ( $STRING$ ) ; } ++ iter ;
rank: 525
score: 98.59214274088542
patch: else { * * * / * /
rank: 525
score: 98.56032104492188
patch: ++ 1 ; ++ iter ; ++ 1 ;
rank: 525
score: 98.48528442382812
patch: ++ iter ; ++ iter ; ; / /
rank: 525
score: 98.44092906605114
patch: x [ iter ] [ n ] = iter ;
rank: 526
score: 98.89148888221153
patch: final double [ ] x . get CaMeL Value ( ) ;
rank: 526
score: 98.87224872295673
patch: final double f CaMeL Val = f CaMeL Val - n ;
rank: 526
score: 98.801611328125
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ( ) ;
rank: 526
score: 98.66053989955357
patch: while ( iter < n ; iter ++ ) { ++ iter ;
rank: 526
score: 98.59172058105469
patch: } else { if ++ iter ;
rank: 526
score: 98.560302734375
patch: ++ 1 ; ++ 0 ;
rank: 526
score: 98.48521728515625
patch: ++ iter ; ++ iter ; ++ line ;
rank: 526
score: 98.44058837890626
patch: ++ iter ; if ( iter <= n )
rank: 527
score: 98.96566336495536
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( ( Univariate CaMeL Point CaMeL Value CaMeL Pair ) f CaMeL Val ) ;
rank: 527
score: 98.89148530505952
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = this . get CaMeL Point ( ) ;
rank: 527
score: 98.80154418945312
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair iter = 0 ;
rank: 527
score: 98.66042654854911
patch: return new Point CaMeL Value CaMeL Pair ( start , iter , ;
rank: 527
score: 98.59120396205357
patch: / * * * / /
rank: 527
score: 98.5595947265625
patch: else { ++ iter ; if ++ iter ;
rank: 527
score: 98.48482666015624
patch: ++ start ; ++ iter ; -- iter ;
rank: 527
score: 98.44045003255208
patch: ++ iter ; if ( f CaMeL Val != 0 )
rank: 528
score: 98.96517207704741
patch: double f CaMeL Val = Math . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . new CaMeL Point CaMeL And CaMeL Direction ( {
rank: 528
score: 98.8997802734375
patch: double f CaMeL Val = - f CaMeL Val ;
rank: 528
score: 98.89146071213942
patch: final double [ ] x = line . clone ( ) ;
rank: 528
score: 98.87195434570313
patch: double [ ] 0 = f CaMeL Val ;
rank: 528
score: 98.80124240451389
patch: ret = new CaMeL Point CaMeL And CaMeL Direction ( x . clone ( ) ) ;
rank: 528
score: 98.66039225260417
patch: return new Point CaMeL Value CaMeL Pair ( x , iter , iter ;
rank: 528
score: 98.59105682373047
patch: else { iter -- ; } }
rank: 528
score: 98.55930397727273
patch: ++ * ] iter ; * / ++ iter ;
rank: 528
score: 98.48481889204545
patch: ++ iter ; ; ++ n ; ++ iter ;
rank: 528
score: 98.43984549386161
patch: f CaMeL Val = iter ;
rank: 529
score: 98.96513928865132
patch: ++ iter ; double f CaMeL Val = Univariate CaMeL Point CaMeL Value CaMeL Pair . n ;
rank: 529
score: 98.89126188858695
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( f CaMeL Val ) . get CaMeL Point ( ) ;
rank: 529
score: 98.8010612936581
patch: tmp = Math CaMeL Arrays . copy CaMeL Of ( direc . 0 ) ;
rank: 529
score: 98.66027069091797
patch: ++ iter ; int n = ;
rank: 529
score: 98.5909423828125
patch: / * * / * /
rank: 529
score: 98.55819091796874
patch: / * ] * * / ++ iter ;
rank: 529
score: 98.48344116210937
patch: ++ iter ; iter * / -- iter ;
rank: 529
score: 98.43964979383681
patch: ++ n ; while ( true ) {
rank: 530
score: 98.96463448660714
patch: double f CaMeL Val = Math . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . get CaMeL Value ( x ) ) ;
rank: 530
score: 98.8710873252467
patch: double f CaMeL Val = Math . abs ( f CaMeL Val ) . clone ( ) ;
rank: 530
score: 98.80094909667969
patch: b = new CaMeL Point CaMeL And CaMeL Direction ( f CaMeL Val ) ;
rank: 530
score: 98.6598388671875
patch: return new Point CaMeL Value CaMeL Pair ( ++ n ) . ++ ;
rank: 530
score: 98.59089799360795
patch: Iterator < ? > iter = iter . iterator ;
rank: 530
score: 98.55790492466518
patch: ++ iter ; else break ;
rank: 530
score: 98.48334295099431
patch: ++ iter ; ; ++ iter ; return iter ;
rank: 530
score: 98.43940873579545
patch: ++ iter ; else if ( iter != null )
rank: 531
score: 98.96417867726294
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( ! Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ) ;
rank: 531
score: 98.89052327473958
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair extends Univariate CaMeL Point CaMeL Value CaMeL Pair > checker = false ;
rank: 531
score: 98.8707608309659
patch: double f CaMeL Val = ! f CaMeL Val ;
rank: 531
score: 98.80082370923913
patch: Iterator < Point CaMeL Value CaMeL Pair , Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ;
rank: 531
score: 98.6598369891827
patch: ++ iter ; while ( iter < n ; ++ iter )
rank: 531
score: 98.59058380126953
patch: else { * * * ; }
rank: 531
score: 98.55761108398437
patch: ++ iter ; ++ iter ; int 1 ;
rank: 531
score: 98.48295288085937
patch: ++ iter ; ++ null ; ++ iter ;
rank: 531
score: 98.43819851345486
patch: switch ( iter ) { ++ iter ;
rank: 532
score: 98.89843139648437
patch: int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ; {
rank: 532
score: 98.87054443359375
patch: final double f CaMeL Val = f CaMeL Val $NUMBER$ ;
rank: 532
score: 98.80064697265625
patch: Iterator < Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > iter = x 1 ;
rank: 532
score: 98.65970552884616
patch: return new Point CaMeL Value CaMeL Pair ( 0 , iter ;
rank: 532
score: 98.59010314941406
patch: ++ iter ; for ; ; ;
rank: 532
score: 98.557373046875
patch: ++ iter ; ++ - - - 1 ;
rank: 532
score: 98.482861328125
patch: ++ 0 ; ++ iter ; ++ n ;
rank: 533
score: 98.96311442057292
patch: double f CaMeL Val = 0 * f CaMeL Val ;
rank: 533
score: 98.89826311383929
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( Math CaMeL Arrays . copy CaMeL Of ( [
rank: 533
score: 98.89024769176136
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair && f CaMeL Val . get CaMeL Value ( ) ;
rank: 533
score: 98.8703677528783
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = line . search ( x ,
rank: 533
score: 98.80061479048295
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > direc = guess ;
rank: 533
score: 98.65943060980902
patch: if ( iter < iter ) continue ;
rank: 533
score: 98.59002685546875
patch: else { ++ [ 1 ] ; }
rank: 533
score: 98.55691528320312
patch: ++ 0 ; ++ iter ; for iter ;
rank: 533
score: 98.48277587890625
patch: ++ iter ; ++ iter ; / iter ;
rank: 533
score: 98.43764241536458
patch: int iter = iter ;
rank: 534
score: 98.88943917410714
patch: final double [ ] f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( direc ) ;
rank: 534
score: 98.86974158653847
patch: final double f CaMeL Val = guess . clone ( ) ;
rank: 534
score: 98.80049272017045
patch: return Point CaMeL Value CaMeL Pair . new CaMeL Point CaMeL And CaMeL Direction ( x , x 1 ) ;
rank: 534
score: 98.65897993607955
patch: throw new Runtime CaMeL Exception ( $STRING$ + ; }
rank: 534
score: 98.58966827392578
patch: / * * iter ; * /
rank: 534
score: 98.5563720703125
patch: ++ 1 ; ++ iter ; iter * /
rank: 534
score: 98.48274369673295
patch: ++ 1 ; ++ iter ; ++ iter ; }
rank: 534
score: 98.43692016601562
patch: if ( iter != null ) ++ n ;
rank: 535
score: 98.9626232328869
patch: final Univariate CaMeL Point CaMeL Value CaMeL Pair < double , Univariate CaMeL Point CaMeL Value CaMeL Pair ] ;
rank: 535
score: 98.8974609375
patch: f CaMeL Val = x . search ( 0 ) ;
rank: 535
score: 98.88923445991848
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = this . get CaMeL Start CaMeL Value ( ) ;
rank: 535
score: 98.80007595486111
patch: return new Point CaMeL Value CaMeL Pair ( Point CaMeL Value CaMeL Pair . 1 ) ;
rank: 535
score: 98.65879469651442
patch: return new Point CaMeL Value CaMeL Pair ( 0 , x ;
rank: 535
score: 98.58954467773438
patch: if ( iter == 1 ; return iter ;
rank: 535
score: 98.55610795454545
patch: ++ iter ; ++ iter ; ++ * * ;
rank: 535
score: 98.48264857700893
patch: ++ iter ; ++ stop ;
rank: 535
score: 98.43582492404514
patch: while ( false ) { ++ n ;
rank: 536
score: 98.96217698317308
patch: if ( f CaMeL Val ( f CaMeL Val ) ) {
rank: 536
score: 98.89678664434524
patch: double f CaMeL Val = f CaMeL Val . search ( Math CaMeL Arrays . copy CaMeL Of ( [
rank: 536
score: 98.8890850360577
patch: f CaMeL Val = line . search ( x $NUMBER$ ) ;
rank: 536
score: 98.86691766036184
patch: double [ ] f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( n ) ;
rank: 536
score: 98.80003138950893
patch: ret = compute CaMeL Objective CaMeL Value ( f CaMeL Val ) ;
rank: 536
score: 98.65872802734376
patch: ++ iter ; * / ; ++ iter ;
rank: 536
score: 98.58931477864583
patch: / * ++ * * / * /
rank: 536
score: 98.55608258928571
patch: / * / ++ iter ;
rank: 536
score: 98.4826327237216
patch: ++ iter ; iter * / / ++ iter ;
rank: 536
score: 98.43466186523438
patch: ++ iter ; if ( n > 0 )
rank: 537
score: 98.89670817057292
patch: int f CaMeL Val = this . f CaMeL Val ;
rank: 537
score: 98.8885967548077
patch: final int iter = f CaMeL Val . clone ( ) ;
rank: 537
score: 98.86685180664062
patch: double [ ] f CaMeL Val = x ;
rank: 537
score: 98.79977651742789
patch: return new Point CaMeL Value CaMeL Pair ( x 1 ) ;
rank: 537
score: 98.65852864583333
patch: ++ iter ; * ; ++ iter ;
rank: 537
score: 98.58902587890626
patch: if ( iter != null ; break ; }
rank: 537
score: 98.55601917613636
patch: / * * * * / / ++ iter ;
rank: 537
score: 98.48218994140625
patch: ++ iter ; ++ iter ; iter / ;
rank: 537
score: 98.4336649576823
patch: ++ iter ; System . exit ( 1 ) ; }
rank: 538
score: 98.96180635340073
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( false ) ;
rank: 538
score: 98.89515904017857
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , direc ) ;
rank: 538
score: 98.88843712439903
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , f CaMeL Val . clone ( ) ) ;
rank: 538
score: 98.86597789417614
patch: double iter = Math . abs ( iter ) ;
rank: 538
score: 98.79959810697116
patch: state = compute CaMeL Objective CaMeL Value ( x $NUMBER$ ) ;
rank: 538
score: 98.65748814174107
patch: ++ iter ; while ( iter == n ) { ++ iter ;
rank: 538
score: 98.5889892578125
patch: * * * * * ++ ;
rank: 538
score: 98.55556233723958
patch: ++ ++ ] iter ;
rank: 538
score: 98.48206676136364
patch: ++ 0 ; ++ iter ; ++ iter ; }
rank: 538
score: 98.43344455295139
patch: ++ iter ; if ( ++ iter )
rank: 539
score: 98.96178588867187
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , $NUMBER$ ) ;
rank: 539
score: 98.89485307173295
patch: final double f CaMeL Val = $NUMBER$ . 0 ;
rank: 539
score: 98.88814290364583
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = new CaMeL Point CaMeL And CaMeL Direction ( n ) ;
rank: 539
score: 98.86430053710937
patch: Object [ ] x = f CaMeL Val ;
rank: 539
score: 98.79944299768519
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair < Univariate CaMeL Point CaMeL Value CaMeL Pair > do {
rank: 539
score: 98.65746198381696
patch: return new Point CaMeL Value CaMeL Pair ( iter , x . ;
rank: 539
score: 98.58836780894886
patch: ++ [ ] iter = iter . length ; }
rank: 539
score: 98.55459594726562
patch: ++ iter ; iter ; int - * /
rank: 539
score: 98.48201127485795
patch: ++ iter ; iter / / / = iter ;
rank: 539
score: 98.43272399902344
patch: if ( ++ iter != 0 )
rank: 540
score: 98.96112530048077
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( ( Univariate CaMeL Point CaMeL Value CaMeL Pair ) x ) ;
rank: 540
score: 98.89415564903847
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( [
rank: 540
score: 98.88805042613636
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = line . get CaMeL Value ( 0 ) ;
rank: 540
score: 98.8636962890625
patch: double [ ] f CaMeL Val = 1 ;
rank: 540
score: 98.7994384765625
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Point CaMeL Value CaMeL Pair . x , x ) ;
rank: 540
score: 98.65730424360795
patch: ++ iter ; while ( iter >= iter ) {
rank: 540
score: 98.58810085720486
patch: / * * * / / * /
rank: 540
score: 98.55453491210938
patch: ++ iter ; / * * / / ++ iter ;
rank: 540
score: 98.4818115234375
patch: ++ iter ; ++ iter ; ++ n ; }
rank: 540
score: 98.43149820963542
patch: j = Math . min ( n , n ) ;
rank: 541
score: 98.96085902622768
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( x , x ) ) ;
rank: 541
score: 98.89231520432692
patch: int f CaMeL Val = ( int ) f CaMeL Val ;
rank: 541
score: 98.88766479492188
patch: double f CaMeL Val = do CaMeL Optimize ( ) ;
rank: 541
score: 98.86316680908203
patch: double f CaMeL Val = x ;
rank: 541
score: 98.79924460018383
patch: Iterator < Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > iter = 0 ;
rank: 541
score: 98.656982421875
patch: ++ iter ; * / while ;
rank: 541
score: 98.58788045247395
patch: if ( ! iter . is CaMeL Empty ( iter ;
rank: 541
score: 98.55397338867188
patch: ++ iter ; try { ++ iter ; ;
rank: 541
score: 98.47984822591145
patch: ++ iter ; ++ iter ; / * ++ iter ;
rank: 541
score: 98.43144989013672
patch: int iter = n - iter ;
rank: 542
score: 98.96080280172414
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . f CaMeL Val , x ) ;
rank: 542
score: 98.89173473011364
patch: if ( f CaMeL Val == f CaMeL Val )
rank: 542
score: 98.88737269810268
patch: final double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( direc ) ) ;
rank: 542
score: 98.86285955255681
patch: int f CaMeL Val = f CaMeL Val ) ;
rank: 542
score: 98.79916561351104
patch: Iterator < Point CaMeL Value CaMeL Pair protected Point CaMeL Value CaMeL Pair > ++ ;
rank: 542
score: 98.65685221354167
patch: ++ iter ; return new Point CaMeL Value CaMeL Pair ( iter ; }
rank: 542
score: 98.58782958984375
patch: if ( . is CaMeL Empty ( ) ) return ;
rank: 542
score: 98.55369984019886
patch: ++ iter ; ++ * * * / iter ;
rank: 542
score: 98.47930353338069
patch: ++ iter ; iter ++ ; } ++ iter ;
rank: 543
score: 98.8916485126202
patch: double x = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 543
score: 98.88687246817129
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = . new CaMeL Point CaMeL And CaMeL Direction ( x 1 ) ;
rank: 543
score: 98.86223810369319
patch: double [ ] x = f CaMeL Val ; final
rank: 543
score: 98.79916381835938
patch: rs = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 543
score: 98.65656127929688
patch: ++ iter ; / * ; ++ iter ;
rank: 543
score: 98.58708844866071
patch: * * * ; * /
rank: 543
score: 98.55330033735795
patch: ++ iter ; iter * * / ++ iter ;
rank: 543
score: 98.477783203125
patch: ++ iter ; ; ++ iter ; iter ++ ;
rank: 544
score: 98.89039248511905
patch: double f CaMeL Val = ( Univariate CaMeL Point CaMeL Value CaMeL Pair ) checker . get CaMeL Goal CaMeL
rank: 544
score: 98.86214192708333
patch: int f CaMeL Val = f CaMeL Val - x ;
rank: 544
score: 98.7990234375
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > iter = x . clone ( ) ;
rank: 544
score: 98.65651157924107
patch: ++ iter - 1 * /
rank: 544
score: 98.5869649251302
patch: if ( ! iter . is CaMeL Empty ++ ) )
rank: 544
score: 98.5531982421875
patch: try { ++ iter ; if ++ iter ;
rank: 544
score: 98.4770840731534
patch: ++ iter ; ++ iter ; / * iter ;
rank: 544
score: 98.42955932617187
patch: ++ iter ; while ( n < n )
rank: 545
score: 98.96033296130952
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of (
rank: 545
score: 98.88983832465277
patch: if ( f CaMeL Val == 0 )
rank: 545
score: 98.88678448016827
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair > . Point CaMeL Value CaMeL Pair * ;
rank: 545
score: 98.86142985026042
patch: if ( n < f CaMeL Val . length ) {
rank: 545
score: 98.79894002278645
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ++ ;
rank: 545
score: 98.65639426491477
patch: ++ iter ; while ( iter > 0 ; )
rank: 545
score: 98.58642578125
patch: if ( ! iter . is CaMeL Empty ++ true )
rank: 545
score: 98.47690651633523
patch: ++ iter ; ++ n ; ; ++ iter ;
rank: 545
score: 98.42864435369319
patch: while ( iter != null ) { ++ n ;
rank: 546
score: 98.96027483258929
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val . x ) ;
rank: 546
score: 98.88922674005681
patch: final double f CaMeL Val = 0 . 1 ;
rank: 546
score: 98.86123657226562
patch: if ( 0 < f CaMeL Val . length ) {
rank: 546
score: 98.79860276442308
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair [ ] ) {
rank: 546
score: 98.6562255859375
patch: ++ iter ; * / * iter ++ ;
rank: 546
score: 98.58611188616071
patch: * * * * / }
rank: 546
score: 98.55181884765625
patch: / * ] * / / ++ iter ;
rank: 546
score: 98.4763692220052
patch: ++ iter ; ++ iter ; / ; ++ iter ;
rank: 546
score: 98.42863325639205
patch: while ( iter != null && iter != n )
rank: 547
score: 98.9597500887784
patch: double double f CaMeL Val = f CaMeL Val ;
rank: 547
score: 98.88572095788044
patch: Point CaMeL Value CaMeL Pair checker = new Point CaMeL Value CaMeL Pair ( x 1 , f CaMeL Val ) ;
rank: 547
score: 98.79859561011905
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair , Point CaMeL Value CaMeL Pair > iter = 0 ;
rank: 547
score: 98.65572684151786
patch: ++ iter ; int n = Double . parse CaMeL Double ( ;
rank: 547
score: 98.585791015625
patch: int iter = iter . length ; while ;
rank: 547
score: 98.55174037388393
patch: / ; ++ iter ; ;
rank: 547
score: 98.47597434303977
patch: ++ iter ; ++ new ++ ; ++ iter ;
rank: 547
score: 98.428466796875
patch: j = iter + 1 ;
rank: 548
score: 98.9595947265625
patch: double f CaMeL Val = Math . abs ( x . clone ( ) ) ;
rank: 548
score: 98.8892110188802
patch: if ( f CaMeL Val . length == 0 ) {
rank: 548
score: 98.85748291015625
patch: double f CaMeL Val = f CaMeL Val -
rank: 548
score: 98.7985309103261
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair < Univariate CaMeL Point CaMeL Value CaMeL Pair < double [ ] >
rank: 548
score: 98.65554373604911
patch: ++ iter ; int iter = Double . parse CaMeL Int ( ;
rank: 548
score: 98.58559348366477
patch: if ( iter > 0 ; return iter ; }
rank: 548
score: 98.5514803799716
patch: ++ iter ; ++ 1 ; ++ - iter ;
rank: 548
score: 98.47575239701705
patch: ++ iter ; ++ iter ; / / / /
rank: 548
score: 98.42828369140625
patch: int iter = iter + iter ;
rank: 549
score: 98.95936414930556
patch: double f CaMeL Val = Math . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . line . clone ( ) ) ;
rank: 549
score: 98.88895089285714
patch: int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , $STRING$ ) ;
rank: 549
score: 98.85716552734375
patch: double f CaMeL Val -= f CaMeL Val ;
rank: 549
score: 98.79823213465073
patch: long f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( x ) ;
rank: 549
score: 98.65550401475694
patch: ++ iter ; if ( iter != ;
rank: 549
score: 98.58548990885417
patch: else { ++ * iter ; * /
rank: 549
score: 98.55137416294643
patch: ++ iter ; break ; ;
rank: 549
score: 98.47571910511364
patch: ++ iter ; ++ iter ; iter / * /
rank: 549
score: 98.42811889648438
patch: x [ iter ] [ iter ] = ;
rank: 550
score: 98.95924595424107
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) , ) ;
rank: 550
score: 98.8885830965909
patch: double [ ] x 1 = $NUMBER$ . 0 ;
rank: 550
score: 98.88462890625
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val . get CaMeL Point ( ) ) ;
rank: 550
score: 98.85665189302884
patch: final double [ ] f CaMeL Val += f CaMeL Val ;
rank: 550
score: 98.79815673828125
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ] ;
rank: 550
score: 98.58543701171875
patch: ++ * iter ;
rank: 550
score: 98.55072021484375
patch: ++ iter ; ++ iter ; ++ * / iter ;
rank: 550
score: 98.47491455078125
patch: ++ iter ; ++ iter ; / / ++ iter ;
rank: 550
score: 98.42780095880681
patch: ++ n ; while ( iter != null ) {
rank: 551
score: 98.888427734375
patch: if ( f CaMeL Val . length > 0 ) {
rank: 551
score: 98.88424549932066
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker . get CaMeL Value ( f CaMeL Val ) ;
rank: 551
score: 98.79802594866071
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > iter = 1 ;
rank: 551
score: 98.65467180524554
patch: return new Point CaMeL Value CaMeL Pair ( x , ++ n ;
rank: 551
score: 98.58530495383523
patch: if ( iter == $NUMBER$ ; return iter ; }
rank: 551
score: 98.55054820667614
patch: ++ iter ; try ; int iter = iter ;
rank: 551
score: 98.47489420572917
patch: ++ iter ; ; ++ iter ; } ++ iter ;
rank: 551
score: 98.42765502929687
patch: x [ 0 ] [ n ] = ;
rank: 552
score: 98.959130859375
patch: ++ iter ; double f CaMeL Val = line . clone ( ) ;
rank: 552
score: 98.88370768229167
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = Math CaMeL Arrays . abs ( f CaMeL Val ) ;
rank: 552
score: 98.85535888671875
patch: double [ ] start = f CaMeL Val ;
rank: 552
score: 98.79798380533855
patch: Symbol goal = get CaMeL Goal CaMeL Type ( ) ;
rank: 552
score: 98.65441022600446
patch: return new Point CaMeL Value CaMeL Pair ( iter , ++ n ;
rank: 552
score: 98.58493477957589
patch: ++ * * iter ; /
rank: 552
score: 98.55037841796874
patch: ++ iter ; ++ iter ; for iter {
rank: 552
score: 98.42756652832031
patch: float n = iter + iter ;
rank: 553
score: 98.95896753771552
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . this , f CaMeL Val ) ;
rank: 553
score: 98.8878173828125
patch: int f CaMeL Val = x . search ( 0 ) ;
rank: 553
score: 98.8834737141927
patch: f CaMeL Val = f CaMeL Val ; f CaMeL Val = compute CaMeL Objective CaMeL Value ( f CaMeL Val ) ;
rank: 553
score: 98.8551025390625
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair ] ,
rank: 553
score: 98.79766167534723
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Math CaMeL Arrays . copy CaMeL Of ( x ) , f CaMeL Val ) ;
rank: 553
score: 98.65425248579545
patch: ++ iter ; if ( ++ iter < n ;
rank: 553
score: 98.58487548828126
patch: ++ * * * * / iter ; }
rank: 553
score: 98.55025809151786
patch: ++ iter ; int 1 ;
rank: 553
score: 98.42635345458984
patch: ++ n ; ++ n ; ;
rank: 554
score: 98.9589210792824
patch: double f CaMeL Val $NUMBER$ = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ;
rank: 554
score: 98.88280639648437
patch: double [ ] x 1 = x $NUMBER$ ;
rank: 554
score: 98.8545633951823
patch: double f CaMeL Val = f CaMeL Val + x ;
rank: 554
score: 98.7975212545956
patch: [ ] f CaMeL Val = compute CaMeL Objective CaMeL Value ( x $NUMBER$ ) ;
rank: 554
score: 98.65364583333333
patch: throw new Illegal CaMeL Argument CaMeL Exception ( ) ; } ++ iter ;
rank: 554
score: 98.58484996448864
patch: if ( iter == iter ; return iter ; }
rank: 554
score: 98.47394353693181
patch: ++ iter ; ++ iter ; ++ iter ; try
rank: 554
score: 98.42628479003906
patch: int iter = iter * iter ;
rank: 555
score: 98.95880126953125
patch: double f CaMeL Val = clone . clone ( ) ;
rank: 555
score: 98.88707914806548
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val + 0 ) ;
rank: 555
score: 98.85430908203125
patch: double iter = x . to CaMeL String ( ) ;
rank: 555
score: 98.79744466145833
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( x 1 , x 1 ) ;
rank: 555
score: 98.65362548828125
patch: Iterator < Point CaMeL Value CaMeL Pair > iterator = iterator . ;
rank: 555
score: 98.58479817708333
patch: else ++ iter ; }
rank: 555
score: 98.5496337890625
patch: ++ iter ; ++ iter ; synchronized iter ;
rank: 555
score: 98.47346635298295
patch: ++ iter ; ; -- iter ; ++ iter ;
rank: 555
score: 98.4261474609375
patch: state = ++ iter ;
rank: 556
score: 98.95828951322116
patch: double f CaMeL Val = copy CaMeL Of ( x ) ;
rank: 556
score: 98.88700561523437
patch: double [ ] x = 1 . 1 ;
rank: 556
score: 98.88186778192934
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = Math CaMeL Arrays . copy CaMeL Of ( Math ;
rank: 556
score: 98.852685546875
patch: double iter = line . iterator ( ) ;
rank: 556
score: 98.79734375
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair < Univariate CaMeL Point CaMeL Value CaMeL Pair >>
rank: 556
score: 98.653564453125
patch: return new Point CaMeL Value CaMeL Pair ( iter , x . ; }
rank: 556
score: 98.54958670479911
patch: ++ iter ; int value ;
rank: 556
score: 98.47196742466518
patch: ++ iter ; ++ x ;
rank: 557
score: 98.95823386863425
patch: final double f CaMeL Val = Math . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ) ;
rank: 557
score: 98.8809481534091
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( x 1 , f CaMeL Val ) ;
rank: 557
score: 98.8526102701823
patch: double [ ] x 1 = f CaMeL Val ; final
rank: 557
score: 98.79723539806548
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair >> iter = 0 ;
rank: 557
score: 98.65338541666667
patch: return new Point CaMeL Value CaMeL Pair ( ++ n , ++ iter ;
rank: 557
score: 98.58425467354911
patch: / * ++ ; * /
rank: 557
score: 98.54908098493304
patch: / ; ++ ++ iter ;
rank: 557
score: 98.4716796875
patch: ++ iter ; ++ iter ; } if iter ;
rank: 557
score: 98.42509765625
patch: switch ( iter ) { case - 1 :
rank: 558
score: 98.95804268973214
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) . x ;
rank: 558
score: 98.8864513578869
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , direc [
rank: 558
score: 98.88060413707386
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > < Point CaMeL Value CaMeL Pair > checker = null ;
rank: 558
score: 98.85252967247597
patch: final double f CaMeL Val = f CaMeL Val + 0 ;
rank: 558
score: 98.79711196001838
patch: result = Math CaMeL Arrays . copy CaMeL Of ( direc . x ) ;
rank: 558
score: 98.58333333333333
patch: / * * * ++ iter * /
rank: 558
score: 98.54886474609376
patch: else { ++ iter ; while ++ iter ;
rank: 558
score: 98.47022501627605
patch: ++ iter ; ++ iter ; ++ iter = iter ;
rank: 559
score: 98.95775257457386
patch: double f CaMeL Val = 0 ; ++ iter ;
rank: 559
score: 98.88599650065105
patch: double f CaMeL Val = $NUMBER$ - f CaMeL Val ;
rank: 559
score: 98.88056098090277
patch: final int iter = f CaMeL Val ;
rank: 559
score: 98.85088641826923
patch: int n = Math . abs ( f CaMeL Val ) ;
rank: 559
score: 98.79694733796296
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . x = 0 ;
rank: 559
score: 98.65271809895833
patch: ++ iter ; return new Point CaMeL Value CaMeL Pair ( n , ;
rank: 559
score: 98.58219401041667
patch: ++ [ ] iter ; if ; }
rank: 559
score: 98.54859008789063
patch: ++ iter ; ++ iter ; int * ;
rank: 559
score: 98.46992631392045
patch: ++ iter ; ++ iter + ; ++ iter ;
rank: 560
score: 98.95694673978366
patch: if ( f CaMeL Val > f CaMeL Val ) { {
rank: 560
score: 98.88539475661058
patch: double f CaMeL Val = f CaMeL Val + direc ;
rank: 560
score: 98.87973854758523
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( x 1 . get CaMeL Value ( ) ) ;
rank: 560
score: 98.85080788352273
patch: double f CaMeL Val = f CaMeL Val - ;
rank: 560
score: 98.79685465494792
patch: Iterator < Point CaMeL Value CaMeL Pair protected Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ) {
rank: 560
score: 98.65259602864583
patch: ++ iter ; new Point CaMeL Value CaMeL Pair [ ] . ++ ;
rank: 560
score: 98.58203125
patch: if ( iter == null ) return iter ;
rank: 560
score: 98.54849243164062
patch: ++ iter ; ++ * int ++ iter ;
rank: 560
score: 98.46958414713542
patch: ++ iter ; ++ iter ; else } ++ iter ;
rank: 560
score: 98.42397054036458
patch: int iter = 0 ; while ( iter != 0 )
rank: 561
score: 98.95664469401042
patch: if ( goal instanceof Point CaMeL Value CaMeL Pair ) {
rank: 561
score: 98.85049203725961
patch: final double f CaMeL Val = f CaMeL Val - $NUMBER$ ;
rank: 561
score: 98.79649593955592
patch: Iterator < Point CaMeL Value CaMeL Pair , Univariate CaMeL Point CaMeL Value CaMeL Pair > ++ ;
rank: 561
score: 98.6525634765625
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + n , $STRING$ ;
rank: 561
score: 98.5817538174716
patch: if ( iter < 0 ) return iter ; }
rank: 561
score: 98.5473299893466
patch: ++ iter ; ++ * / ; ++ iter ;
rank: 561
score: 98.46886097301136
patch: / ++ iter ; ++ iter ; ++ iter ;
rank: 562
score: 98.8851318359375
patch: if ( 0 < f CaMeL Val ) {
rank: 562
score: 98.87943209134616
patch: final double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val . get CaMeL Value ( ) ) ;
rank: 562
score: 98.84995339133523
patch: double f CaMeL Val = f CaMeL Val ; ;
rank: 562
score: 98.79634021577381
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > iter = x .
rank: 562
score: 98.65241156684027
patch: ++ iter ; if ( ++ n ;
rank: 562
score: 98.58109537760417
patch: Iterator iter = iter . iterator iter ;
rank: 562
score: 98.54722086588542
patch: ++ iter ; ++ * * * / ++ iter ;
rank: 562
score: 98.46856134588069
patch: ++ 0 ; ++ iter ; ; ++ iter ;
rank: 562
score: 98.42359161376953
patch: if ( ++ n < n )
rank: 563
score: 98.88492838541667
patch: final double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( direc , 0 ) ;
rank: 563
score: 98.87910970052083
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( ( Point CaMeL Value CaMeL Pair ) f CaMeL Val ) ;
rank: 563
score: 98.84975022536058
patch: double [ ] double f CaMeL Val = f CaMeL Val ;
rank: 563
score: 98.79632568359375
patch: return new Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ( x , iter ) ;
rank: 563
score: 98.65231323242188
patch: ++ iter ; float f CaMeL Val = ;
rank: 563
score: 98.58095296223958
patch: i ] [ 0 ] ++ ; }
rank: 563
score: 98.54664916992188
patch: ++ iter ; ++ 1 ; ++ * /
rank: 563
score: 98.467529296875
patch: ++ iter ; ++ iter ; try ++ iter ;
rank: 563
score: 98.42333984375
patch: ++ iter ; if ( iter != null ) break ;
rank: 564
score: 98.95636858258929
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . get ( 0 ) ) ;
rank: 564
score: 98.88370768229167
patch: double f CaMeL Val = f CaMeL Val + Fast CaMeL Math . copy CaMeL Of ( 0 ) ;
rank: 564
score: 98.878681640625
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair && Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 564
score: 98.84932767427884
patch: int f CaMeL Val = f CaMeL Val [ iter ] ;
rank: 564
score: 98.79616873604911
patch: tmp = Math CaMeL Arrays . copy CaMeL Of ( x ) ;
rank: 564
score: 98.6522549715909
patch: while ( iter ; ; ) { ++ iter ;
rank: 564
score: 98.58056640625
patch: if ( ! iter . is CaMeL Empty ++ false )
rank: 564
score: 98.5464111328125
patch: ++ * * ++ iter ; iter * /
rank: 564
score: 98.46690784801136
patch: ++ iter ; ++ 1 ; } ++ iter ;
rank: 564
score: 98.423046875
patch: if ( ! ++ n ) ++ iter ;
rank: 565
score: 98.95597330729167
patch: final double f CaMeL Val = Math . abs ( f CaMeL Val ;
rank: 565
score: 98.8815205891927
patch: double f CaMeL Val = f CaMeL Val * 0 ;
rank: 565
score: 98.84832085503473
patch: final int x = f CaMeL Val ;
rank: 565
score: 98.79609760485198
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Point CaMeL Value CaMeL Pair . x ,
rank: 565
score: 98.65184437144886
patch: ++ iter ; if ( iter >= iter ) {
rank: 565
score: 98.58050537109375
patch: if ( iter > 0 ; return iter ;
rank: 565
score: 98.54617745535714
patch: ++ ++ iter ; iter ;
rank: 565
score: 98.46666370738636
patch: ++ n ; ++ iter ; ; ++ iter ;
rank: 565
score: 98.42298473011364
patch: throw new Unsupported CaMeL Operation CaMeL Exception ( $STRING$ )
rank: 566
score: 98.95596516927084
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = iter ;
rank: 566
score: 98.88125610351562
patch: int f CaMeL Val = new double [ n ] ;
rank: 566
score: 98.87815259850544
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = new CaMeL Point CaMeL And CaMeL Direction * checker ;
rank: 566
score: 98.7958984375
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair < Univariate CaMeL Point CaMeL Value CaMeL Pair > {
rank: 566
score: 98.65177408854167
patch: ++ iter ] [ 0 ] = ;
rank: 566
score: 98.54564319957386
patch: ++ iter ; ++ iter ; for iter ; ;
rank: 566
score: 98.4663973721591
patch: ++ 1 ; ++ iter ; ; ++ iter ;
rank: 567
score: 98.8458251953125
patch: double f CaMeL Val = f CaMeL Val . value ;
rank: 567
score: 98.79579072840073
patch: entry = get CaMeL Goal CaMeL Type ( ) . get CaMeL Value ( ) ;
rank: 567
score: 98.65160193810097
patch: if ( iter != null && iter . iter != null )
rank: 567
score: 98.57931179470486
patch: / * * * ; ++ * /
rank: 567
score: 98.54527698863636
patch: ++ iter ; ++ iter ; int * * /
rank: 567
score: 98.46600896661931
patch: ++ iter ; ++ iter ; } ++ 1 ;
rank: 567
score: 98.4217020670573
patch: if ( iter != null ) { n ++ ; }
rank: 568
score: 98.95495024181548
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > < Univariate CaMeL Point CaMeL Value CaMeL Pair >
rank: 568
score: 98.87928355823864
patch: if ( f CaMeL Val >= f CaMeL Val )
rank: 568
score: 98.87659801136364
patch: final double f CaMeL Val = compute CaMeL Objective CaMeL Value ( f CaMeL Val , f CaMeL Val ) ;
rank: 568
score: 98.84456787109374
patch: double iter = f CaMeL Val - iter ;
rank: 568
score: 98.79555838448661
patch: return new CaMeL Point CaMeL And CaMeL Direction ( x , x ,
rank: 568
score: 98.65159912109375
patch: ++ iter ; if ( iter <= n ;
rank: 568
score: 98.57929021661931
patch: if ( iter == null ; return ++ iter ;
rank: 568
score: 98.54497680664062
patch: ++ iter ; int 1 = iter 1 ;
rank: 568
score: 98.46580921519886
patch: ++ iter ; ; ++ 1 ; ++ iter ;
rank: 568
score: 98.4212646484375
patch: ++ iter ; if ( true )
rank: 569
score: 98.95479329427083
patch: f CaMeL Val = 0 ; f CaMeL Val = f CaMeL Val ;
rank: 569
score: 98.87577311197917
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = new CaMeL Point CaMeL And CaMeL Direction ( guess ) ;
rank: 569
score: 98.84401633522727
patch: double [ ] start 1 = f CaMeL Val ;
rank: 569
score: 98.79545261548913
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair < Univariate CaMeL Point CaMeL Value CaMeL Pair > iter = n ;
rank: 569
score: 98.65132141113281
patch: for ( ; ; ) { ;
rank: 569
score: 98.54487748579545
patch: ++ 1 ; ++ iter ; while ++ iter ;
rank: 569
score: 98.42047119140625
patch: for ( ; ; )
rank: 570
score: 98.87899780273438
patch: double [ ] x = compute CaMeL Objective CaMeL Value (
rank: 570
score: 98.87575120192308
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = . new CaMeL Point CaMeL And CaMeL Direction ( 0 ) ;
rank: 570
score: 98.8438251201923
patch: int f CaMeL Val = f CaMeL Val ; ++ iter ;
rank: 570
score: 98.79544771634616
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Point CaMeL Value CaMeL Pair . line . get CaMeL Point ( ) ) ;
rank: 570
score: 98.6512451171875
patch: ++ iter ; / * * ++ * /
rank: 570
score: 98.46537272135417
patch: ++ iter ; ; if ++ iter ; ++ iter ;
rank: 570
score: 98.4204330444336
patch: float n = iter / iter ;
rank: 571
score: 98.95384114583334
patch: final int f CaMeL Val = compute CaMeL Objective CaMeL Value ( ) ;
rank: 571
score: 98.8756854717548
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = . new CaMeL Point CaMeL And CaMeL Direction ( 1 ) ;
rank: 571
score: 98.8428955078125
patch: final int f CaMeL Val = f CaMeL Val 1 ;
rank: 571
score: 98.79491170247395
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > ;
rank: 571
score: 98.65113118489583
patch: return new Point CaMeL Value CaMeL Pair ( iter , iter , iter ;
rank: 571
score: 98.57772488064236
patch: else { if ++ * iter ; }
rank: 571
score: 98.5445556640625
patch: ++ iter ; ++ iter ; iter * * /
rank: 571
score: 98.4643887606534
patch: ++ n ; ; ++ iter ; ++ iter ;
rank: 571
score: 98.42025756835938
patch: ++ n ; if ( iter != null )
rank: 572
score: 98.95347086588542
patch: double f CaMeL Val = $NUMBER$ * f CaMeL Val ;
rank: 572
score: 98.8756612141927
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > = Math CaMeL Arrays . copy CaMeL Of ( guess ) ;
rank: 572
score: 98.87510329026442
patch: double iter = Math . copy CaMeL Of ( direc [
rank: 572
score: 98.84224243164063
patch: double iter = x . trim ( ) ;
rank: 572
score: 98.79474235983456
patch: r = Math CaMeL Arrays . copy CaMeL Of ( direc . 0 ) ;
rank: 572
score: 98.65105794270833
patch: return new Point CaMeL Value CaMeL Pair ( ++ iter , ++ iter ;
rank: 572
score: 98.57750786675348
patch: ++ < 0 ? 0 : iter ;
rank: 572
score: 98.54404518821023
patch: i * ++ ; ++ iter ; ++ iter ;
rank: 572
score: 98.46384499289773
patch: ++ iter ; ++ iter ; iter } ++ ;
rank: 572
score: 98.4201416015625
patch: if ( ++ n > 1 ) break ;
rank: 573
score: 98.87440185546875
patch: double [ ] f CaMeL Val = $NUMBER$ ;
rank: 573
score: 98.87392578125
patch: double iter = value . clone ( ) ;
rank: 573
score: 98.84210759943181
patch: double int f CaMeL Val = f CaMeL Val ;
rank: 573
score: 98.79473517922794
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . double CaMeL Value ( ) ;
rank: 573
score: 98.65093122209821
patch: return new Point CaMeL Value CaMeL Pair ( this , ++ iter ;
rank: 573
score: 98.57672729492188
patch: if ( iter == 0 ; return false ;
rank: 573
score: 98.54374476841518
patch: ] iter ; ++ iter ;
rank: 573
score: 98.4635009765625
patch: ++ iter ; ++ iter ; -- iter ; iter ;
rank: 574
score: 98.87330211292614
patch: double f CaMeL Val = 0 1 . 0 ;
rank: 574
score: 98.87308756510417
patch: double x $NUMBER$ = f CaMeL Val ;
rank: 574
score: 98.84047288161058
patch: final double f CaMeL Val [ ] = f CaMeL Val ;
rank: 574
score: 98.79441324869792
patch: body = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 574
score: 98.65070452008929
patch: ++ iter ; if ; ;
rank: 574
score: 98.575732421875
patch: ++ * * iter ; } ++ iter ;
rank: 574
score: 98.4633456143466
patch: ++ iter ; ++ ++ iter ; -- iter ;
rank: 574
score: 98.41878255208333
patch: j = Math . min ( iter , n ) ;
rank: 575
score: 98.9519930752841
patch: ++ int f CaMeL Val = f CaMeL Val ;
rank: 575
score: 98.87287703804348
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > < Point CaMeL Value CaMeL Pair > checker = true ;
rank: 575
score: 98.84024047851562
patch: double f CaMeL Val = f CaMeL Val - length ;
rank: 575
score: 98.79440646701389
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > {
rank: 575
score: 98.65036010742188
patch: while ( iter < n ) { ++ iter ; ;
rank: 575
score: 98.57571847098214
patch: / * ; * * /
rank: 575
score: 98.54341634114583
patch: else ; ++ iter ;
rank: 575
score: 98.46251331676136
patch: ++ iter ; ++ iter ; iter ++ ; }
rank: 575
score: 98.41810191761364
patch: int n = iter . index CaMeL Of ( ;
rank: 576
score: 98.95131548713235
patch: double f CaMeL Val [ ] = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 576
score: 98.87273615056819
patch: final double f CaMeL Val = compute CaMeL Objective CaMeL Value ( f CaMeL Val . clone ( ) ) ;
rank: 576
score: 98.87179565429688
patch: int x = f CaMeL Val ;
rank: 576
score: 98.79436577690973
patch: tmp = Math CaMeL Arrays . copy CaMeL Of ( direc [ 0 ] ) ;
rank: 576
score: 98.64991590711806
patch: ++ iter - $NUMBER$ ; ++ iter ;
rank: 576
score: 98.57531060112848
patch: / * * ++ iter * * /
rank: 576
score: 98.543017578125
patch: ++ 1 ; ++ iter ; int iter ;
rank: 576
score: 98.4622469815341
patch: ++ iter ; ++ start ; ; ++ iter ;
rank: 576
score: 98.41806640625
patch: ++ iter ; if ( iter == 1 )
rank: 577
score: 98.87269083658855
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = Math CaMeL Arrays . copy CaMeL Of ( true ) ;
rank: 577
score: 98.86994018554688
patch: double [ ] x = guess . x ;
rank: 577
score: 98.8385009765625
patch: double [ ] x = Math CaMeL Arrays . TRUE ;
rank: 577
score: 98.79407755533855
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ( x . clone ( ) ) ;
rank: 577
score: 98.64974772135416
patch: ++ iter ; return new Point CaMeL Value CaMeL Pair ( this , ;
rank: 577
score: 98.57467312282986
patch: if ( iter == 0 ; / ;
rank: 577
score: 98.54111328125
patch: ++ 1 ; ++ 1 ; ++ iter ;
rank: 577
score: 98.46195845170455
patch: ++ iter ; ++ max ; } ++ iter ;
rank: 578
score: 98.87262517755681
patch: final int f CaMeL Val = compute CaMeL Objective CaMeL Value ( x . get CaMeL Value ( ) ) ;
rank: 578
score: 98.86697387695312
patch: double [ ] x = guess ;
rank: 578
score: 98.83635711669922
patch: int n = f CaMeL Val ;
rank: 578
score: 98.79400079900569
patch: return ( Point CaMeL Value CaMeL Pair ) Math CaMeL Arrays . copy CaMeL Of ( x , iter ) ;
rank: 578
score: 98.574560546875
patch: if ( iter == iter ; break ; }
rank: 578
score: 98.53989955357143
patch: else { ++ - iter ;
rank: 578
score: 98.4617587002841
patch: ++ iter ; while ++ iter ; ++ iter ;
rank: 578
score: 98.41713460286458
patch: key = ++ iter ;
rank: 579
score: 98.94852388822116
patch: for ( double f CaMeL Val : f CaMeL Val ) {
rank: 579
score: 98.8721211751302
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = Math CaMeL Arrays . copy CaMeL Of ( value ) ;
rank: 579
score: 98.83609008789062
patch: double f CaMeL Val += f CaMeL Val - 0 ;
rank: 579
score: 98.79393659319196
patch: return compute CaMeL Objective CaMeL Value ( x 1 , x ) ;
rank: 579
score: 98.64967176649306
patch: ++ iter - n ; ++ iter ;
rank: 579
score: 98.5742431640625
patch: * * * * * ; ++ iter ;
rank: 579
score: 98.53969900948661
patch: i * ; ++ 1 ;
rank: 579
score: 98.46109008789062
patch: ++ iter ; ++ iter ; ++ iter ; } iter
rank: 579
score: 98.41704767400569
patch: result = new double [ n ] [ ] ;
rank: 580
score: 98.87191877693965
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = new CaMeL Point CaMeL And CaMeL Direction ( x 1 , f CaMeL Val ) ;
rank: 580
score: 98.8360595703125
patch: final double x = f CaMeL Val + f CaMeL Val ;
rank: 580
score: 98.79385036892361
patch: return new CaMeL Point CaMeL And CaMeL Direction ( new CaMeL Point CaMeL And CaMeL Direction (
rank: 580
score: 98.64905463324652
patch: ++ iter ; * / * iter ;
rank: 580
score: 98.57271321614583
patch: else { if ++ iter ; } }
rank: 580
score: 98.5393798828125
patch: / * ] ++ iter ; ++ * /
rank: 580
score: 98.41627086292614
patch: ++ iter ; try { f CaMeL Val = ;
rank: 581
score: 98.8717928799716
patch: final double [ ] f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 581
score: 98.8624267578125
patch: double iter = compute CaMeL Objective CaMeL Value ( 0 ) ;
rank: 581
score: 98.83543904622395
patch: double f CaMeL Val = f CaMeL Val + n ;
rank: 581
score: 98.64893798828125
patch: if ( iter < ; iter ++ ) {
rank: 581
score: 98.57155936104911
patch: else { ++ $NUMBER$ ; }
rank: 581
score: 98.53920288085938
patch: else * ++ iter ; if ++ iter ;
rank: 581
score: 98.4607821377841
patch: ++ n ; ++ iter ; ++ iter ; }
rank: 581
score: 98.41473943536931
patch: if ( iter < n ) { ++ n ;
rank: 582
score: 98.87117826021634
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , compute CaMeL Objective CaMeL Value ( ) ) ;
rank: 582
score: 98.86220296223958
patch: double f CaMeL Val = ( 0 . 0 ) ;
rank: 582
score: 98.83541165865384
patch: double [ ] int f CaMeL Val = f CaMeL Val ;
rank: 582
score: 98.79357147216797
patch: Object f CaMeL Val = compute CaMeL Objective CaMeL Value ( x 1 ) ;
rank: 582
score: 98.64874877929688
patch: ++ iter ; * / * * * ;
rank: 582
score: 98.53909737723214
patch: / * ] ++ * /
rank: 582
score: 98.46012369791667
patch: ++ iter ; ++ iter ; break ; ++ iter ;
rank: 582
score: 98.41452026367188
patch: int iter = 0 ; while ( iter <= n )
rank: 583
score: 98.94751818426724
patch: double f CaMeL Val = Math . copy CaMeL Of ( Univariate CaMeL Point CaMeL Value CaMeL Pair . line . get CaMeL Point ( ) ) ;
rank: 583
score: 98.87116033380681
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair extends Univariate CaMeL Point CaMeL Value CaMeL Pair >> checker ;
rank: 583
score: 98.8616434733073
patch: double [ ] x = Math . copy CaMeL Of (
rank: 583
score: 98.83434041341145
patch: double f CaMeL Val = x . search ( x ,
rank: 583
score: 98.79348887567934
patch: return Point CaMeL Value CaMeL Pair . new CaMeL Point CaMeL And CaMeL Direction ( x 1 , x 1 ) ;
rank: 583
score: 98.64857313368056
patch: ++ iter * * / ++ iter ;
rank: 583
score: 98.57075805664063
patch: if ( n == 0 ; return iter ;
rank: 583
score: 98.53872680664062
patch: else * ++ iter ; while ++ iter ;
rank: 583
score: 98.45905095880681
patch: ++ iter ; ++ iter ; iter throw iter ;
rank: 583
score: 98.41446940104167
patch: int iter = iter ; ++ iter ;
rank: 584
score: 98.946044921875
patch: double f CaMeL Val = Univariate CaMeL Point CaMeL Value CaMeL Pair ;
rank: 584
score: 98.87038167317708
patch: double [ ] iter = guess . clone ( ) ;
rank: 584
score: 98.85931951349431
patch: double [ ] x 1 = 1 . 1 ;
rank: 584
score: 98.79348520132211
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair do = 0 ;
rank: 584
score: 98.6483154296875
patch: return ++ iter ; }
rank: 584
score: 98.57047729492187
patch: if ++ iter ;
rank: 584
score: 98.53872680664062
patch: / * ++ ++ * / ++ iter ;
rank: 584
score: 98.45815207741477
patch: iter } ++ ; ++ iter ; ++ iter ;
rank: 584
score: 98.41446533203126
patch: ++ n ; while ( iter != null )
rank: 585
score: 98.87013938210227
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair <= Point CaMeL Value CaMeL Pair > checker = null ;
rank: 585
score: 98.85698908025569
patch: i = f CaMeL Val + f CaMeL Val ;
rank: 585
score: 98.79345703125
patch: Iterator < Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair >
rank: 585
score: 98.64825908954327
patch: ++ iter ; throw new Runtime CaMeL Exception ( ) ; }
rank: 585
score: 98.5677734375
patch: ++ [ ] [ ] iter = iter ;
rank: 585
score: 98.5386962890625
patch: ++ iter ; ++ * * ++ * / /
rank: 585
score: 98.45792388916016
patch: ++ max ;
rank: 585
score: 98.41358531605114
patch: if ( ++ n > 1 ) ++ iter ;
rank: 586
score: 98.85658772786458
patch: double f CaMeL Val 1 = f CaMeL Val $NUMBER$ ;
rank: 586
score: 98.7933682528409
patch: return converged . get CaMeL Value ( ) ; }
rank: 586
score: 98.6480379971591
patch: final int iter = x . iterator ( ) ;
rank: 586
score: 98.56769670758929
patch: / * * * / }
rank: 586
score: 98.53696114676339
patch: ++ iter ; else * /
rank: 586
score: 98.41336059570312
patch: while ( iter >= iter ) {
rank: 587
score: 98.94378255208333
patch: d = f CaMeL Val ; f CaMeL Val = f CaMeL Val ;
rank: 587
score: 98.8681003736413
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = new CaMeL Point CaMeL And CaMeL Direction ( x ,
rank: 587
score: 98.79311651932566
patch: Iterator < Point CaMeL Value CaMeL Pair protected Univariate CaMeL Point CaMeL Value CaMeL Pair > ++ ;
rank: 587
score: 98.53680974786931
patch: ++ iter ; ++ iter ; ++ * / /
rank: 587
score: 98.4569979580966
patch: ++ iter ; ++ iter ; / return iter ;
rank: 587
score: 98.41311645507812
patch: if ( iter == 0 ) return null ;
rank: 588
score: 98.94368198939732
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) , (
rank: 588
score: 98.86795043945312
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = Math CaMeL Arrays . copy CaMeL Of ( 0 ) ;
rank: 588
score: 98.85487874348958
patch: int f CaMeL Val = compute CaMeL Objective CaMeL Value (
rank: 588
score: 98.79299029181985
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair > iter = f CaMeL Val ;
rank: 588
score: 98.64791434151786
patch: ++ iter ; return new ;
rank: 588
score: 98.56706407335069
patch: * * * * * / iter ;
rank: 588
score: 98.53638916015625
patch: ++ iter ; else
rank: 588
score: 98.45671735491071
patch: ++ iter ; ++ length ;
rank: 588
score: 98.41263580322266
patch: ++ n ; while ( true )
rank: 589
score: 98.86742146809895
patch: double f CaMeL Val = f CaMeL Val . x ;
rank: 589
score: 98.85435180664062
patch: double f CaMeL Val = $NUMBER$ . 1 ;
rank: 589
score: 98.7927017211914
patch: return new CaMeL Point CaMeL And CaMeL Direction ( f CaMeL Val ) ; }
rank: 589
score: 98.64780680338542
patch: ++ iter ; while ( iter != - 1 ) {
rank: 589
score: 98.56681315104167
patch: ++ * * * * iter ; }
rank: 589
score: 98.53623268821023
patch: / * ] iter ; / * * / /
rank: 589
score: 98.4549893465909
patch: ++ iter ; ++ iter ; } ++ n ;
rank: 590
score: 98.94322858537946
patch: final double f CaMeL Val $NUMBER$ = x . clone ( ) ;
rank: 590
score: 98.8671366373698
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = Math CaMeL Arrays . copy CaMeL Of ( list ) ;
rank: 590
score: 98.8507412997159
patch: f CaMeL Val = new double [ n ] ;
rank: 590
score: 98.83079020182292
patch: double f CaMeL Val = f CaMeL Val - start ;
rank: 590
score: 98.79266826923077
patch: return new CaMeL Point CaMeL And CaMeL Direction ( x , ;
rank: 590
score: 98.5665791829427
patch: / * ; * /
rank: 590
score: 98.53586647727273
patch: ++ iter ; ++ 1 ; ++ iter ; }
rank: 590
score: 98.41139914772727
patch: Iterator iter = iter . iterator ( ) ; else
rank: 591
score: 98.943115234375
patch: ++ iter ; double f CaMeL Val = f CaMeL Val - 0 ;
rank: 591
score: 98.8499422940341
patch: delta = f CaMeL Val + f CaMeL Val ;
rank: 591
score: 98.83002178485577
patch: int f CaMeL Val = f CaMeL Val - x 1 ;
rank: 591
score: 98.79239908854167
patch: Iterator < Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > double CaMeL Value = 0 ;
rank: 591
score: 98.64771379743304
patch: ++ iter ; return new Point CaMeL Value CaMeL Pair ( new ;
rank: 591
score: 98.56622869318181
patch: if ( iter == null ; return null ; }
rank: 591
score: 98.53583318536931
patch: ++ * * / ++ iter ; ++ iter ;
rank: 591
score: 98.45355834960938
patch: ++ new ++ ;
rank: 591
score: 98.41102091471355
patch: ++ iter ; f CaMeL Val = iter * n ;
rank: 592
score: 98.94297572544643
patch: d = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) , x 1 ) ;
rank: 592
score: 98.86587524414062
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = new CaMeL Point CaMeL And CaMeL Direction [ n ] ;
rank: 592
score: 98.82997436523438
patch: final double [ ] = f CaMeL Val ;
rank: 592
score: 98.792275390625
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair < Univariate CaMeL Point CaMeL Value CaMeL Pair )
rank: 592
score: 98.64762878417969
patch: if ( iter > n ) {
rank: 592
score: 98.56616889105902
patch: / * * * * ++ * /
rank: 592
score: 98.53567504882812
patch: i * ++ ; / * * / /
rank: 592
score: 98.45342462713069
patch: ++ iter ; ++ iter ; / * iter /
rank: 592
score: 98.41019694010417
patch: if ( n == 0 ) continue ;
rank: 593
score: 98.94202473958333
patch: double f CaMeL Val ; double f CaMeL Val = f CaMeL Val ;
rank: 593
score: 98.86576021634616
patch: final Point CaMeL Value CaMeL Pair checker = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , f CaMeL Val ) ;
rank: 593
score: 98.79215140964673
patch: Iterator < Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair > ++ ;
rank: 593
score: 98.6473858173077
patch: ++ iter ; if ( iter == 0 ) ++ iter ;
rank: 593
score: 98.56605113636364
patch: if ( iter == null && iter == null ;
rank: 593
score: 98.53553355823864
patch: ++ iter ; ++ - - iter ; iter ;
rank: 593
score: 98.45338023792614
patch: ++ iter ++ ; ++ iter ; ++ iter ;
rank: 593
score: 98.40969848632812
patch: int iter = iter + 1 ;
rank: 594
score: 98.94200032552084
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( (
rank: 594
score: 98.86534534801136
patch: final double iter = line . clone ( ) ;
rank: 594
score: 98.84477095170455
patch: if ( f CaMeL Val <= f CaMeL Val )
rank: 594
score: 98.8295654296875
patch: double [ ] 1 = f CaMeL Val ;
rank: 594
score: 98.7921142578125
patch: return line . get CaMeL Value ( ) ; }
rank: 594
score: 98.64731667258523
patch: ++ iter ; ; double f CaMeL Val = ;
rank: 594
score: 98.56467692057292
patch: else { * * ++ iter ; }
rank: 594
score: 98.5354891690341
patch: / * ] iter * / / ++ iter ;
rank: 594
score: 98.45305841619319
patch: ++ iter ; ++ iter ; return ++ iter ;
rank: 594
score: 98.40920188210227
patch: ++ iter ; ; while ( iter != null )
rank: 595
score: 98.94082641601562
patch: double f CaMeL Val = Math . clone ( ) ;
rank: 595
score: 98.8651835123698
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = Math CaMeL Arrays . copy CaMeL Of ( line ) ;
rank: 595
score: 98.64708658854167
patch: throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + iter + $STRING$ ;
rank: 595
score: 98.56438530815973
patch: ++ * * * ++ iter ; }
rank: 595
score: 98.5350341796875
patch: ++ iter ; ++ * * ; / ++ iter ;
rank: 595
score: 98.45298073508523
patch: ++ - 1 ; ++ iter ; ++ iter ;
rank: 596
score: 98.94073016826923
patch: i ++ ; double f CaMeL Val = f CaMeL Val ;
rank: 596
score: 98.86490885416667
patch: double f CaMeL Val = x . search ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ) ;
rank: 596
score: 98.84398304332386
patch: final double f CaMeL Val = 1 . 1 ;
rank: 596
score: 98.8294921875
patch: if ( n < f CaMeL Val ) {
rank: 596
score: 98.79173060825893
patch: return new Point CaMeL Value CaMeL Pair ( x 1 , x ,
rank: 596
score: 98.64708600725446
patch: ++ iter ; return new Point CaMeL Value CaMeL Pair ( ; ;
rank: 596
score: 98.5633056640625
patch: / * * * * ; ++ iter ;
rank: 596
score: 98.53439331054688
patch: ++ iter ; ++ 1 ; ++ value ;
rank: 596
score: 98.45013982599431
patch: ++ iter ; ++ n ; ++ iter ; }
rank: 596
score: 98.40863037109375
patch: ++ iter ; String name = ++ iter ;
rank: 597
score: 98.82948996803977
patch: double direc [ ] = f CaMeL Val ;
rank: 597
score: 98.79160670230263
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( f CaMeL Val , x $NUMBER$ ) ;
rank: 597
score: 98.56327601841518
patch: if ( iter == 0 )
rank: 597
score: 98.53431285511364
patch: ++ iter ; ++ iter ; ++ while iter ;
rank: 597
score: 98.44843401227679
patch: ++ iter ; ++ list ;
rank: 597
score: 98.4081319173177
patch: j = Math . min ( 0 , n ) ;
rank: 598
score: 98.86452318274456
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > < Point CaMeL Value CaMeL Pair > checker = false ;
rank: 598
score: 98.84149932861328
patch: double [ ] x = null ;
rank: 598
score: 98.82932692307692
patch: double iter = Math . iterator ( f CaMeL Val ) ;
rank: 598
score: 98.79146484375
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair >= iter ;
rank: 598
score: 98.64674595424107
patch: return new Point CaMeL Value CaMeL Pair ( ++ n - 1 ;
rank: 598
score: 98.56313069661458
patch: ++ iter ; if ++ iter ; }
rank: 598
score: 98.53412420099431
patch: ++ iter ; ++ * * * * / /
rank: 598
score: 98.4479092684659
patch: return iter ; ; ++ iter ; ++ iter ;
rank: 598
score: 98.4076904296875
patch: ++ iter ; if ( iter > 1 )
rank: 599
score: 98.86417643229167
patch: final double f CaMeL Val = compute CaMeL Objective CaMeL Value ( f CaMeL Val . get CaMeL Point ( ) ) ;
rank: 599
score: 98.82908121744792
patch: double f CaMeL Val = - 1 ;
rank: 599
score: 98.79136305588942
patch: return compute CaMeL Objective CaMeL Value ( x , iter ) ;
rank: 599
score: 98.64629657451923
patch: int n = Integer . parse CaMeL Int ( x ) ;
rank: 599
score: 98.5337646484375
patch: ++ * / ++ iter ; iter * /
rank: 599
score: 98.44695490056819
patch: ++ iter ; ++ ++ n ; ++ iter ;
rank: 599
score: 98.4071044921875
patch: int n = iter ;
rank: 600
score: 98.8633449388587
patch: Point CaMeL Value CaMeL Pair checker = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , 0 ) ;
rank: 600
score: 98.83959350585937
patch: ++ [ ] x = f CaMeL Val ;
rank: 600
score: 98.7908935546875
patch: return ( Point CaMeL Value CaMeL Pair ) get CaMeL Goal CaMeL Type ( ) ;
rank: 600
score: 98.64620971679688
patch: ++ iter ; double x [ ] [ ] = ;
rank: 600
score: 98.56203206380208
patch: if ; * * * / * /
rank: 600
score: 98.53359375
patch: / * ] ++ iter ; if iter ;
rank: 600
score: 98.44585626775569
patch: ++ iter ; ++ iter ; } ++ max ;
rank: 600
score: 98.40704900568181
patch: y [ iter ] [ n ] = iter ;
rank: 601
score: 98.93666585286458
patch: double f CaMeL Val = guess . length ( ) ;
rank: 601
score: 98.8281982421875
patch: double iter = f CaMeL Val : 0 ;
rank: 601
score: 98.7908935546875
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > iter = x 1 ;
rank: 601
score: 98.64619584517045
patch: while ( iter >= iter ) { ++ iter ;
rank: 601
score: 98.5618896484375
patch: if ( iter > 0 ; break ;
rank: 601
score: 98.53262939453126
patch: ++ iter ; ++ * * - iter ;
rank: 601
score: 98.44526890345982
patch: ++ n ; ++ 0 ;
rank: 601
score: 98.40697224934895
patch: ++ iter ; System . exit ( $NUMBER$ ) ; }
rank: 602
score: 98.86191813151042
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( x . get CaMeL Value ( ) . clone ( ) ) ;
rank: 602
score: 98.83634185791016
patch: int f CaMeL Val = $NUMBER$ ;
rank: 602
score: 98.79083806818181
patch: return Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) . get CaMeL Value ( ) ; }
rank: 602
score: 98.64600965711806
patch: for ( ; ; ) ++ iter ;
rank: 602
score: 98.56181640625
patch: synchronized ( . is CaMeL Empty ( ) )
rank: 602
score: 98.53255615234374
patch: ++ value ; ++ iter ; for iter ;
rank: 602
score: 98.44419167258523
patch: ++ iter ; ++ iter ; * -- iter ;
rank: 602
score: 98.406884765625
patch: if ( ++ iter == 0 ) break ;
rank: 603
score: 98.861689453125
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = Math CaMeL Arrays . copy CaMeL Of ( n 1 ) ;
rank: 603
score: 98.82505446213942
patch: double x = Math . abs ( f CaMeL Val ) ;
rank: 603
score: 98.790771484375
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair 1 ;
rank: 603
score: 98.64558628627232
patch: return new Point CaMeL Value CaMeL Pair ( this , iter ) ;
rank: 603
score: 98.55999200994319
patch: while ( ! iter . is CaMeL Empty ++ ;
rank: 603
score: 98.44410289417614
patch: ++ iter ; } ++ start ; ++ iter ;
rank: 603
score: 98.40681966145833
patch: if ( n == 0 ) break ;
rank: 604
score: 98.93316650390625
patch: if ( f CaMeL Val > $NUMBER$ ) {
rank: 604
score: 98.834375
patch: double [ ] x = guess . 0 ;
rank: 604
score: 98.82480093149039
patch: final double f CaMeL Val = Math CaMeL Arrays . copy CaMeL
rank: 604
score: 98.79051208496094
patch: return new Point CaMeL Value CaMeL Pair ( x 1 , x $NUMBER$ ) ;
rank: 604
score: 98.64549560546875
patch: ++ iter ; while ( true ) { ;
rank: 604
score: 98.55912475585937
patch: * * * * / } ++ iter ;
rank: 604
score: 98.53201293945312
patch: ++ iter ; ++ iter ; int * ++ iter ;
rank: 604
score: 98.44337047230114
patch: ++ start ; ++ iter ; ++ iter ; }
rank: 604
score: 98.40669468470982
patch: ++ iter ; for ; )
rank: 605
score: 98.86124393857759
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , f CaMeL Val ) ) ;
rank: 605
score: 98.83355034722223
patch: double f CaMeL Val = - 0 ;
rank: 605
score: 98.82424926757812
patch: double f CaMeL Val = Math . abs ( x ;
rank: 605
score: 98.79037314967105
patch: Iterator < Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > n = 0 ;
rank: 605
score: 98.64521789550781
patch: ++ iter ; while ( false ;
rank: 605
score: 98.55861206054688
patch: ++ [ ] [ ] = iter ; }
rank: 605
score: 98.53139038085938
patch: / * ] iter ; / / * /
rank: 605
score: 98.44334827769886
patch: ++ iter ; ; iter * / ++ iter ;
rank: 605
score: 98.40663655598958
patch: final int iter = iter * n ;
rank: 606
score: 98.9305928548177
patch: double f CaMeL Val = 1 * f CaMeL Val ;
rank: 606
score: 98.8611476732337
patch: f CaMeL Val = f CaMeL Val ; f CaMeL Val = compute CaMeL Objective CaMeL Value ( x 1 ) ;
rank: 606
score: 98.83247514204545
patch: double f CaMeL Val = f CaMeL Val ; else
rank: 606
score: 98.79030890213816
patch: return new Univariate CaMeL Point CaMeL Value CaMeL Pair ( x 1 , f CaMeL Val ) ;
rank: 606
score: 98.64519708806819
patch: ++ iter ; while ( iter == 0 ) {
rank: 606
score: 98.55664740668402
patch: / * * ; ++ iter ; }
rank: 606
score: 98.52958540482955
patch: / * ] iter = iter ; ++ iter ;
rank: 606
score: 98.44293767755681
patch: ++ iter ; ++ iter ; ++ throw iter ;
rank: 606
score: 98.4065673828125
patch: ++ n ; while ( iter == n )
rank: 607
score: 98.86071246603261
patch: double f CaMeL Val = x . search ( Math CaMeL Arrays . copy CaMeL Of ( direc ) ) ;
rank: 607
score: 98.83181762695312
patch: int x = 0 ;
rank: 607
score: 98.82406005859374
patch: double iter [ ] = f CaMeL Val ;
rank: 607
score: 98.78992229959239
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > iter = f CaMeL Val ;
rank: 607
score: 98.64479370117188
patch: ++ iter ; * / ++ iter * /
rank: 607
score: 98.52943004261364
patch: ++ iter ; ++ * * / if iter ;
rank: 607
score: 98.44249378551136
patch: ++ ++ iter ; ++ start ; ++ iter ;
rank: 607
score: 98.40599229600694
patch: if ( ++ n != 0 ) {
rank: 608
score: 98.86051078464673
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = line . get CaMeL Value ( x $NUMBER$ ) ;
rank: 608
score: 98.8240254720052
patch: double f CaMeL Val = f CaMeL Val + iter ;
rank: 608
score: 98.7897720336914
patch: return compute CaMeL Objective CaMeL Value ( x 1 , f CaMeL Val ) ;
rank: 608
score: 98.6443758877841
patch: ++ iter ; if ( iter == - 1 ;
rank: 608
score: 98.55525037977431
patch: if ( iter > iter ; * /
rank: 608
score: 98.5292635830966
patch: ++ value ; ++ iter ; if ++ iter ;
rank: 608
score: 98.44240500710227
patch: ++ iter ; ++ ++ max ; ++ iter ;
rank: 608
score: 98.40568033854167
patch: if ( ++ iter ) ++ iter ;
rank: 609
score: 98.92902080829327
patch: int f CaMeL Val $NUMBER$ = x . clone ( ) ;
rank: 609
score: 98.85930926983173
patch: final double f CaMeL Val = compute CaMeL Objective CaMeL Value ( Math CaMeL Arrays . copy CaMeL Of ( direc ) ) ;
rank: 609
score: 98.789638671875
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > do {
rank: 609
score: 98.64421735491071
patch: ++ iter ; if ( iter == - 1 ) ++ iter ;
rank: 609
score: 98.554443359375
patch: if ; ++ iter ;
rank: 609
score: 98.52918701171875
patch: ++ iter ; ++ iter ; ++ out ;
rank: 609
score: 98.40518951416016
patch: ++ n ; ++ n ; }
rank: 610
score: 98.92879231770833
patch: ++ iter ; double f CaMeL Val 1 = 0 ;
rank: 610
score: 98.85924275716145
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > = Math CaMeL Arrays . copy CaMeL Of ( x ) ;
rank: 610
score: 98.82842254638672
patch: double [ ] x = $NUMBER$ ;
rank: 610
score: 98.8228290264423
patch: double f CaMeL Val = f CaMeL Val - - 0 ;
rank: 610
score: 98.644140625
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + $STRING$ ) ; }
rank: 610
score: 98.55438842773438
patch: if ( iter < 0 ; return iter ;
rank: 610
score: 98.52904663085937
patch: try { ++ iter ; ++ iter ; ;
rank: 610
score: 98.44200550426136
patch: ++ iter ; ++ iter ; try -- iter ;
rank: 610
score: 98.40487331814236
patch: assert iter < n ; iter ++ )
rank: 611
score: 98.85904947916667
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = new CaMeL Point CaMeL And CaMeL Direction ( $NUMBER$ ) ;
rank: 611
score: 98.82760620117188
patch: double iter = 1 . 0 ;
rank: 611
score: 98.8213223544034
patch: double f CaMeL Val = f CaMeL Val - }
rank: 611
score: 98.78958740234376
patch: return new Point CaMeL Value CaMeL Pair ( Point CaMeL Value CaMeL Pair . 1 , x ) ;
rank: 611
score: 98.64412689208984
patch: ++ iter * / * * ;
rank: 611
score: 98.55410427517361
patch: / * * * ; * * /
rank: 611
score: 98.52901000976563
patch: ++ 1 ; ++ iter ; int * /
rank: 611
score: 98.441650390625
patch: ++ iter ; ; ++ iter ; while iter ;
rank: 611
score: 98.4047622680664
patch: if ( ++ n >= 0 )
rank: 612
score: 98.85868503736413
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val + f CaMeL Val ) ;
rank: 612
score: 98.78950639204545
patch: if ( f CaMeL Val > 0 . 0 )
rank: 612
score: 98.64405110677083
patch: ++ iter ; if ( iter > 0 ) { ++ iter ; }
rank: 612
score: 98.5537353515625
patch: else throw new Runtime CaMeL Exception ( $STRING$ ;
rank: 612
score: 98.52876420454545
patch: this . ++ iter ; ++ iter ; iter ;
rank: 612
score: 98.4415283203125
patch: ++ iter ; ; ++ iter ; ++ 1 ;
rank: 613
score: 98.9265645345052
patch: if ( f CaMeL Val > 1 . 0 ) {
rank: 613
score: 98.8579571063702
patch: int f CaMeL Val = compute CaMeL Objective CaMeL Value ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ) ;
rank: 613
score: 98.82438151041667
patch: int [ ] x 1 = 0 ;
rank: 613
score: 98.8171053799716
patch: int f CaMeL Val = f CaMeL Val $NUMBER$ ;
rank: 613
score: 98.789345703125
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ) ;
rank: 613
score: 98.6439208984375
patch: while ( ; ) ++ iter ;
rank: 613
score: 98.55344460227273
patch: throw new Runtime CaMeL Exception ( $STRING$ + $NUMBER$ ;
rank: 613
score: 98.52874755859375
patch: ++ iter ; ++ * * / break ;
rank: 613
score: 98.44151960100446
patch: for ++ ; ++ iter ;
rank: 613
score: 98.404345703125
patch: if ( iter < n ; iter ++ )
rank: 614
score: 98.92564174107143
patch: d = Math CaMeL Arrays . copy CaMeL Of ( x ) ;
rank: 614
score: 98.85741126019022
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > ! checker . get CaMeL Goal CaMeL Type ( ) ;
rank: 614
score: 98.8153963955966
patch: int f CaMeL Val = f CaMeL Val ; final
rank: 614
score: 98.789013671875
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair = null ;
rank: 614
score: 98.64389038085938
patch: ++ iter ; if ( iter >= n ) break ;
rank: 614
score: 98.55329725477431
patch: if ( iter == iter ; * /
rank: 614
score: 98.5286532315341
patch: / * ++ iter ; / * * / /
rank: 614
score: 98.44049627130681
patch: ++ - iter ; ++ iter ; ++ iter ;
rank: 614
score: 98.40366617838542
patch: while ( ++ n > 0 ) {
rank: 615
score: 98.85687725360577
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( Fast CaMeL Math . copy CaMeL Of ( f CaMeL Val ) ) ;
rank: 615
score: 98.82429809570313
patch: x [ 0 ] = f CaMeL Val ;
rank: 615
score: 98.7889404296875
patch: Math CaMeL Arrays . copy CaMeL Of ( x ) ;
rank: 615
score: 98.6437255859375
patch: return new Point CaMeL Value CaMeL Pair ( ++ iter , iter ) ;
rank: 615
score: 98.44044078480114
patch: ++ iter ; ++ iter ; / throw iter ;
rank: 615
score: 98.40362548828125
patch: ++ n ; if ( iter < n )
rank: 616
score: 98.8568623860677
patch: d = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , f CaMeL Val . clone ( ) ) ;
rank: 616
score: 98.81987847222223
patch: int f CaMeL Val = - 1 ;
rank: 616
score: 98.8119384765625
patch: double iter = iter . iterator ( ) ;
rank: 616
score: 98.78892606847427
patch: return new CaMeL Point CaMeL And CaMeL Direction ( x , x , x ) ;
rank: 616
score: 98.6435791015625
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + iter , $STRING$ ;
rank: 616
score: 98.55252075195312
patch: if ( iter == null ; * / }
rank: 616
score: 98.52706909179688
patch: / * ] iter ; ++ - * /
rank: 616
score: 98.44032981178977
patch: ++ iter ; ; ++ iter ; ++ start ;
rank: 616
score: 98.40313720703125
patch: ++ iter ; } return new ;
rank: 617
score: 98.92182268415179
patch: double f CaMeL Val = Math . copy CaMeL Of ( x ;
rank: 617
score: 98.85628255208333
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = new CaMeL Point CaMeL And CaMeL Direction ( $STRING$ ) ;
rank: 617
score: 98.81136067708333
patch: final int n = f CaMeL Val ;
rank: 617
score: 98.78840637207031
patch: long f CaMeL Val = compute CaMeL Objective CaMeL Value ( x 1 ) ;
rank: 617
score: 98.6425537109375
patch: return new Point CaMeL Value CaMeL Pair ( iter , x , ; }
rank: 617
score: 98.552197265625
patch: if ( ! iter . is CaMeL Empty )
rank: 617
score: 98.5262959798177
patch: ++ iter ; ++ iter ; ++ * - iter ;
rank: 617
score: 98.43980823863636
patch: ++ iter ; iter * ++ ; ++ iter ;
rank: 617
score: 98.40303548177083
patch: int n = ++ n - iter ;
rank: 618
score: 98.81620649857955
patch: double f CaMeL Val = $NUMBER$ 1 . 0 ;
rank: 618
score: 98.80889892578125
patch: double start = f CaMeL Val ;
rank: 618
score: 98.78828568892045
patch: return Point CaMeL Value CaMeL Pair . new CaMeL Point CaMeL And CaMeL Direction ( f CaMeL Val ) ; }
rank: 618
score: 98.64247824928977
patch: if ( iter == - 1 ) ++ iter ;
rank: 618
score: 98.55215115017361
patch: / * * * / ++ iter /
rank: 618
score: 98.52606756036931
patch: ++ iter ; ++ 1 ; ++ iter ; ;
rank: 618
score: 98.4395419034091
patch: ++ iter ; ++ iter ; iter / / /
rank: 618
score: 98.40289306640625
patch: ++ iter ; while ( iter >= 0 )
rank: 619
score: 98.91987609863281
patch: if ( iter == null ) {
rank: 619
score: 98.85578719429348
patch: Point CaMeL Value CaMeL Pair checker = Math CaMeL Arrays . copy CaMeL Of ( direc [ 0 ] ) ;
rank: 619
score: 98.8086669921875
patch: double iter = line . length ( ) ;
rank: 619
score: 98.78826032366071
patch: Iterator < Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > int CaMeL Value = 0 ;
rank: 619
score: 98.55199584960937
patch: / * ++ * * / ++ iter ;
rank: 619
score: 98.52592329545455
patch: / * ++ iter ; / / * / /
rank: 619
score: 98.43784401633523
patch: ++ iter ; ++ iter ; else iter ++ ;
rank: 619
score: 98.40238647460937
patch: if ( ++ iter == 0 ) continue ;
rank: 620
score: 98.91956176757813
patch: while ( iter < f CaMeL Val ) {
rank: 620
score: 98.85565185546875
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( f CaMeL Val , f CaMeL Val . clone ( ) ) ;
rank: 620
score: 98.81505584716797
patch: int f CaMeL Val = 1 ;
rank: 620
score: 98.80782741970486
patch: final double f CaMeL Val = null ;
rank: 620
score: 98.7881591796875
patch: return ( Point CaMeL Value CaMeL Pair ) checker . get CaMeL Goal CaMeL
rank: 620
score: 98.64162868923611
patch: ++ iter ; if ( iter == ;
rank: 620
score: 98.55179443359376
patch: / * * * / } ++ iter ;
rank: 620
score: 98.52549235026042
patch: ++ iter ; ++ iter ; ++ * int iter ;
rank: 620
score: 98.43475341796875
patch: if iter * 0 ;
rank: 620
score: 98.40205522017045
patch: if ( ! iter . equals ( x ) )
rank: 621
score: 98.91859788161058
patch: ++ iter ; long f CaMeL Val = f CaMeL Val ;
rank: 621
score: 98.855556640625
patch: int f CaMeL Val = compute CaMeL Objective CaMeL Value ( Math CaMeL Arrays . copy CaMeL Of ( direc ) ) ;
rank: 621
score: 98.81499633789062
patch: float [ ] x = f CaMeL Val ;
rank: 621
score: 98.80735473632812
patch: int f CaMeL Val = relative CaMeL Threshold ;
rank: 621
score: 98.78812081473214
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > iter = true ;
rank: 621
score: 98.64138357979911
patch: return new Point CaMeL Value CaMeL Pair ( x , ; } ;
rank: 621
score: 98.55131022135417
patch: / * ; * * / * /
rank: 621
score: 98.524755859375
patch: ++ iter ; ++ 1 ; int * /
rank: 621
score: 98.43311656605114
patch: ++ max ++ ; ++ iter ; ++ iter ;
rank: 621
score: 98.40200805664062
patch: if ( ++ iter == 0 )
rank: 622
score: 98.8555438701923
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = Math CaMeL Arrays . copy CaMeL Of ( relative CaMeL Threshold ) ;
rank: 622
score: 98.81298217773437
patch: double [ ] x = $NUMBER$ . 1 ;
rank: 622
score: 98.80564371744792
patch: double [ ] x 1 = x ;
rank: 622
score: 98.78810716711956
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair }
rank: 622
score: 98.641357421875
patch: return new Point CaMeL Value CaMeL Pair ( ++ n )
rank: 622
score: 98.55042114257813
patch: if ( iter == null ; / * /
rank: 622
score: 98.52442626953125
patch: / * ; ++ iter ; int iter ;
rank: 622
score: 98.43159623579545
patch: ++ iter ; iter = iter ; -- iter ;
rank: 622
score: 98.40193176269531
patch: while ( iter != ; ) {
rank: 623
score: 98.91700439453125
patch: final double f CaMeL Val 1 = 0 ;
rank: 623
score: 98.85545935997597
patch: double CaMeL Value = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , f CaMeL Val . clone ( ) ) ;
rank: 623
score: 98.640869140625
patch: ++ iter ; return new Point CaMeL Value CaMeL Pair ( 0 , ;
rank: 623
score: 98.5503173828125
patch: if ( iter == 0 ; return ; }
rank: 623
score: 98.52424760298295
patch: ++ iter ; ++ iter ; ++ * / ;
rank: 623
score: 98.431396484375
patch: ++ iter ; ++ / * / ++ iter ;
rank: 623
score: 98.40069580078125
patch: ++ iter ; if ( n < n )
rank: 624
score: 98.91517991286058
patch: ++ iter ; double f CaMeL Val += f CaMeL Val ;
rank: 624
score: 98.85532633463542
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = Math CaMeL Arrays . copy CaMeL Of ( direc ;
rank: 624
score: 98.80953369140624
patch: double f CaMeL Val += 0 . 0 ;
rank: 624
score: 98.805322265625
patch: final Convergence CaMeL Checker < double [ ] ;
rank: 624
score: 98.55006103515625
patch: if ( iter < 0 ; break ; }
rank: 624
score: 98.52311567826705
patch: ++ iter ; ++ iter ; ; if iter ;
rank: 624
score: 98.43006480823864
patch: ++ start ; ++ iter ; ; ++ iter ;
rank: 624
score: 98.40064586292614
patch: if ( ! ++ n ) { ++ iter ;
rank: 625
score: 98.9143399325284
patch: if ( iter < direc . length ) {
rank: 625
score: 98.85515625
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = new CaMeL Point CaMeL And CaMeL Direction ( x $NUMBER$ ) ;
rank: 625
score: 98.80940551757813
patch: int iter = x . clone ( ) ;
rank: 625
score: 98.80526123046874
patch: final double n 1 = f CaMeL Val ;
rank: 625
score: 98.7877734375
patch: Iterator < Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair {
rank: 625
score: 98.64065551757812
patch: ++ iter * * /
rank: 625
score: 98.55001491970486
patch: / * * ++ * * / }
rank: 625
score: 98.52251586914062
patch: ++ $NUMBER$ ; ++ iter ; for iter ;
rank: 625
score: 98.42593819754464
patch: iter ; iter if ++ ;
rank: 625
score: 98.40029471261161
patch: n -- ; ++ n ;
rank: 626
score: 98.85474571814903
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair > . Point CaMeL Value CaMeL Pair -- ;
rank: 626
score: 98.808837890625
patch: if ( 0 < f CaMeL Val )
rank: 626
score: 98.80448774857955
patch: f CaMeL Val = f CaMeL Val - 0 ;
rank: 626
score: 98.78773257606908
patch: return ( Point CaMeL Value CaMeL Pair ) new CaMeL Point CaMeL And CaMeL Direction ( x ,
rank: 626
score: 98.63937174479166
patch: int n = Integer . parse CaMeL Int ( iter , iter ) ;
rank: 626
score: 98.52234996448864
patch: ++ iter ; ++ value ; ++ - iter ;
rank: 627
score: 98.91316731770833
patch: d = Math . abs ( f CaMeL Val ) ;
rank: 627
score: 98.8546612079327
patch: final double iter = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( direc ) ) ;
rank: 627
score: 98.80635375976563
patch: int [ ] f CaMeL Val = 0 ;
rank: 627
score: 98.80362955729167
patch: final double length = f CaMeL Val ;
rank: 627
score: 98.78770228794643
patch: Iterator < Point CaMeL Value CaMeL Pair protected Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair >
rank: 627
score: 98.63898383246527
patch: ++ iter ; / * * ; ;
rank: 627
score: 98.54923095703126
patch: if ( iter == null ; / * ;
rank: 627
score: 98.52197265625
patch: ++ iter ; ++ * * ++ ++ iter ;
rank: 627
score: 98.422119140625
patch: ++ 0 ; iter ++ ;
rank: 627
score: 98.39864349365234
patch: while ( ++ n > 0 )
rank: 628
score: 98.8542989095052
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = new CaMeL Point CaMeL And CaMeL Direction ( this ) ;
rank: 628
score: 98.80608367919922
patch: int [ ] x = 0 ;
rank: 628
score: 98.78769100413604
patch: state = get CaMeL Goal CaMeL Type ( ) . get CaMeL Value ( ) ;
rank: 628
score: 98.63898315429688
patch: ++ iter ; * / ++ iter ; ;
rank: 628
score: 98.54908447265625
patch: synchronized ( . is CaMeL Empty ( ) ;
rank: 628
score: 98.52193603515624
patch: / * ++ iter ; / * / /
rank: 628
score: 98.42152622767857
patch: ++ iter ; iter / *
rank: 628
score: 98.39856828962054
patch: pos = iter + 1 ;
rank: 629
score: 98.85396902901786
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = . new CaMeL Point CaMeL And CaMeL Direction ( f CaMeL Val ) ;
rank: 629
score: 98.80588600852273
patch: double f CaMeL Val = f CaMeL Val ++ ;
rank: 629
score: 98.80280151367188
patch: double [ ] x += f CaMeL Val ;
rank: 629
score: 98.78758544921875
patch: return get CaMeL Goal CaMeL Type ( ) ;
rank: 629
score: 98.63888784555289
patch: ++ iter ; if ( iter < n ) return null ;
rank: 629
score: 98.54880099826389
patch: else { if ( iter == 0 ;
rank: 629
score: 98.5218505859375
patch: ++ iter ; ++ iter ; / * * / /
rank: 630
score: 98.80232747395833
patch: double n = 0 ;
rank: 630
score: 98.78732479319854
patch: return new Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ( x ,
rank: 630
score: 98.63863118489583
patch: ++ iter ; if ( iter <= n ) continue ;
rank: 630
score: 98.54847412109375
patch: else { if ++ * 0 . 0 ;
rank: 630
score: 98.52184448242187
patch: int iter ; ++ iter ; while iter ;
rank: 630
score: 98.41875348772321
patch: ++ 1 ; iter ++ ;
rank: 630
score: 98.39814897017045
patch: while ( n < n ) { ++ iter ;
rank: 631
score: 98.90869140625
patch: ++ iter ; double f CaMeL Val = 1 ;
rank: 631
score: 98.85364190463362
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = Math CaMeL Arrays . copy CaMeL Of ( x 1 , f CaMeL Val ) ;
rank: 631
score: 98.8031338778409
patch: double f CaMeL Val = f CaMeL Val ; {
rank: 631
score: 98.80095079210069
patch: int ++ iter = f CaMeL Val ;
rank: 631
score: 98.78720703125
patch: return ( Point CaMeL Value CaMeL Pair ) checker . get CaMeL Goal CaMeL Type ( ) . get CaMeL Value ( ) ;
rank: 631
score: 98.54838053385417
patch: else { / * * * / }
rank: 631
score: 98.5217618075284
patch: / * ] iter ; / / / / /
rank: 632
score: 98.90863037109375
patch: int f CaMeL Val = guess . length ( ) ;
rank: 632
score: 98.85326171875
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > = Math CaMeL Arrays . copy CaMeL Of ( x 1 ) ;
rank: 632
score: 98.80228881835937
patch: double f CaMeL Val = Math . 1 ;
rank: 632
score: 98.80047607421875
patch: final double ++ iter = f CaMeL Val ;
rank: 632
score: 98.78720238095238
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Point CaMeL Value CaMeL Pair . line . get CaMeL
rank: 632
score: 98.63824462890625
patch: ++ iter ; f CaMeL Val = new double [ iter ] ;
rank: 632
score: 98.54836697048611
patch: / * * / ++ iter * /
rank: 632
score: 98.5201416015625
patch: ++ iter ; ++ iter ; iter ; int iter ;
rank: 632
score: 98.41689627511161
patch: ++ $NUMBER$ ; ++ n ;
rank: 632
score: 98.3965087890625
patch: if ( iter < iter . length ) {
rank: 633
score: 98.90822531960227
patch: ++ iter ; double f CaMeL Val = null ;
rank: 633
score: 98.85312906901042
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair && checker . get CaMeL Value ( ) . clone ( ) ;
rank: 633
score: 98.78716681985294
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair > int CaMeL Value = 0 ;
rank: 633
score: 98.548193359375
patch: i * * * * / ++ iter ;
rank: 633
score: 98.51985307173295
patch: / * * * * * / ++ iter ;
rank: 633
score: 98.39641462053571
patch: n -- ; ++ iter ;
rank: 634
score: 98.90448467548077
patch: double f CaMeL Val $NUMBER$ = f CaMeL Val - 0 ;
rank: 634
score: 98.85275390625
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( Math CaMeL Arrays . copy CaMeL Of ( relative CaMeL Threshold ) ) ;
rank: 634
score: 98.80063698508523
patch: double < f CaMeL Val = f CaMeL Val ;
rank: 634
score: 98.79929896763393
patch: final double n = 0 ;
rank: 634
score: 98.787021484375
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair = x ;
rank: 634
score: 98.637939453125
patch: ++ iter ; ; if ; ++ iter ;
rank: 634
score: 98.54814995659723
patch: if ( . equals ( iter ) )
rank: 634
score: 98.51958673650569
patch: ++ iter ; iter ; * / int iter ;
rank: 634
score: 98.41503034319196
patch: ++ start ; ++ n ;
rank: 634
score: 98.39555358886719
patch: float [ ] [ ] ++ ;
rank: 635
score: 98.90336303710937
patch: final int f CaMeL Val $NUMBER$ = 0 ;
rank: 635
score: 98.85174560546875
patch: final int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , f CaMeL Val ) ;
rank: 635
score: 98.80031331380208
patch: double [ ] x 1 = null ;
rank: 635
score: 98.7988037109375
patch: double iter = f CaMeL Val . 0 ;
rank: 635
score: 98.78687959558823
patch: return new Point CaMeL Value CaMeL Pair ( Math CaMeL Arrays . copy CaMeL Of (
rank: 635
score: 98.63787841796875
patch: ++ iter ; return new Point CaMeL Value CaMeL Pair ( x )
rank: 635
score: 98.54776611328126
patch: ++ * iter ; } if ++ iter ;
rank: 635
score: 98.51807750355114
patch: / * ] ++ iter ; if ++ iter ;
rank: 635
score: 98.41367594401042
patch: iter iter if ++ ;
rank: 635
score: 98.39530726841518
patch: while ( iter == iter )
rank: 636
score: 98.7866719563802
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > {
rank: 636
score: 98.63722922585227
patch: ++ iter ; / * ; ++ iter * /
rank: 636
score: 98.54732259114583
patch: while ( iter == 0 ; * /
rank: 636
score: 98.51781116832386
patch: / * ++ iter * / / ++ iter ;
rank: 636
score: 98.41228376116071
patch: iter ++ ; ++ n ;
rank: 636
score: 98.39500122070312
patch: x [ 0 ] [ iter ] = ;
rank: 637
score: 98.85108439127605
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = Math CaMeL Arrays . copy CaMeL Of ( $NUMBER$ ) ;
rank: 637
score: 98.79981825086806
patch: final double f CaMeL Val = $NUMBER$ ;
rank: 637
score: 98.79325561523437
patch: short f CaMeL Val = f CaMeL Val ;
rank: 637
score: 98.78624052159927
patch: long f CaMeL Val = compute CaMeL Objective CaMeL Value ( x , x ) ;
rank: 637
score: 98.63656412760416
patch: throw new Unsupported CaMeL Operation CaMeL Exception ( $STRING$ + iter ) ; }
rank: 637
score: 98.54710557725694
patch: if ( iter == null ; * ;
rank: 637
score: 98.51720081676136
patch: / * ] iter ; / * / / /
rank: 637
score: 98.408935546875
patch: / ; iter if ++ ;
rank: 637
score: 98.3949462890625
patch: if ( ++ n > 1 ) continue ;
rank: 638
score: 98.90079956054687
patch: if ( f CaMeL Val > 1 ) {
rank: 638
score: 98.85091552734374
patch: final f CaMeL Val = f CaMeL Val ;
rank: 638
score: 98.7918368252841
patch: double [ ] x 1 = x . get CaMeL
rank: 638
score: 98.7859598795573
patch: return ( Point CaMeL Value CaMeL Pair ) new CaMeL Point CaMeL And CaMeL Direction ( x , f CaMeL Val ) ;
rank: 638
score: 98.63634144176136
patch: ++ iter ; if ( iter < n || ;
rank: 638
score: 98.54566539417614
patch: } if ( iter != null ; return iter ;
rank: 638
score: 98.51706949869792
patch: ++ iter ; ++ iter ; int * / iter ;
rank: 638
score: 98.4086405436198
patch: ++ iter ; } iter
rank: 638
score: 98.3945821126302
patch: cl = ++ iter ;
rank: 639
score: 98.89987417367789
patch: ++ iterator ; double f CaMeL Val = f CaMeL Val ;
rank: 639
score: 98.85081263950893
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = new CaMeL Point CaMeL And CaMeL Direction ( x , f CaMeL Val ) ;
rank: 639
score: 98.7986572265625
patch: double [ ] x = Math . 1 ;
rank: 639
score: 98.79158528645833
patch: final double value = f CaMeL Val ;
rank: 639
score: 98.78574090254934
patch: int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( x , iter ) ;
rank: 639
score: 98.63633897569444
patch: ++ iter ; if ( iter ; }
rank: 639
score: 98.54524739583333
patch: ++ * * * * iter ; /
rank: 639
score: 98.5167569247159
patch: i * ++ ; / * / ++ iter ;
rank: 639
score: 98.40365164620536
patch: ++ iter ; iter System ;
rank: 640
score: 98.89895395132211
patch: ++ 1 ; double f CaMeL Val = f CaMeL Val ;
rank: 640
score: 98.850322265625
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( Math CaMeL Arrays . copy CaMeL Of ( x 1 ) ) ;
rank: 640
score: 98.79367065429688
patch: double [ ] x = Math . 0 ;
rank: 640
score: 98.78536224365234
patch: return new CaMeL Point CaMeL And CaMeL Direction ( x , x $NUMBER$ ) ;
rank: 640
score: 98.6363016764323
patch: ++ iter ; while ( iter >= n ) { ;
rank: 640
score: 98.54475911458333
patch: else { iter = iter . length ;
rank: 640
score: 98.51674582741477
patch: / * ++ ++ iter * / ++ iter ;
rank: 641
score: 98.8982684795673
patch: final double f CaMeL Val $NUMBER$ = f CaMeL Val $NUMBER$ ;
rank: 641
score: 98.84998575846355
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = new CaMeL Point CaMeL And CaMeL Direction ( true ) ;
rank: 641
score: 98.79276899857955
patch: float [ ] x 1 = f CaMeL Val ;
rank: 641
score: 98.78859456380208
patch: final double f CaMeL Val = 1 ;
rank: 641
score: 98.78527113970588
patch: synchronized ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ) {
rank: 641
score: 98.63621303013393
patch: return new Point CaMeL Value CaMeL Pair ( iter , ; } ;
rank: 641
score: 98.51640181107955
patch: ++ iter ; ++ * * ++ - iter ;
rank: 641
score: 98.40334065755208
patch: ++ ( ++ iter ;
rank: 641
score: 98.3933993252841
patch: int iter = ; while ( iter < n )
rank: 642
score: 98.89734903971355
patch: if ( f CaMeL Val - f CaMeL Val ) {
rank: 642
score: 98.84942626953125
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = Math CaMeL Arrays . copy CaMeL Of ( 1 ) ;
rank: 642
score: 98.79213645241477
patch: if ( f CaMeL Val . length < n )
rank: 642
score: 98.7879638671875
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair ;
rank: 642
score: 98.78517150878906
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( x , 0 ) ;
rank: 642
score: 98.63605346679688
patch: ++ iter ; if ( n > 0 ;
rank: 642
score: 98.54426713423295
patch: else { ++ * 0 . 0 ; } }
rank: 642
score: 98.39337158203125
patch: iter = ++ iter ;
rank: 643
score: 98.89641723632812
patch: if ( x . clone ( ) ) {
rank: 643
score: 98.849365234375
patch: double iter = x . search ( x $NUMBER$ ) ;
rank: 643
score: 98.7877685546875
patch: double [ ] $NUMBER$ = f CaMeL Val ;
rank: 643
score: 98.7850341796875
patch: Iterator < Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair > ++ ;
rank: 643
score: 98.63587297712054
patch: ++ iter ; new Point CaMeL Value CaMeL Pair [ ] = ;
rank: 643
score: 98.54424370659723
patch: ++ * * * * / * /
rank: 643
score: 98.51571044921874
patch: / * ] ++ iter ; / * /
rank: 643
score: 98.39954485212054
patch: ++ iter ; ++ continue ;
rank: 643
score: 98.39311079545455
patch: if ( ++ n < iter . length ) {
rank: 644
score: 98.8961932842548
patch: ++ iter ; Object f CaMeL Val = f CaMeL Val ;
rank: 644
score: 98.7870849609375
patch: int f CaMeL Val = 1 . 0 ;
rank: 644
score: 98.78494083180146
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair , Point CaMeL Value CaMeL Pair >
rank: 644
score: 98.63563121448864
patch: while ( iter < n ) { if ( ;
rank: 644
score: 98.54399956597223
patch: else { ++ * iter ; } }
rank: 644
score: 98.515380859375
patch: ++ iter ; ++ iter ; / * / /
rank: 644
score: 98.397216796875
patch: if iter = iter ;
rank: 644
score: 98.39308675130208
patch: synchronized ( this ) {
rank: 645
score: 98.84716796875
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val . clone ( ) ) ) ;
rank: 645
score: 98.78678755326705
patch: double iter = x . search ( 0 ) ;
rank: 645
score: 98.78487955729166
patch: return compute CaMeL Objective CaMeL Value ( x , f CaMeL Val ) ;
rank: 645
score: 98.78485870361328
patch: if ( n < n ) {
rank: 645
score: 98.63526068793402
patch: ++ iter ; do { ++ iter ;
rank: 645
score: 98.54399278428819
patch: else { if ; * * / }
rank: 645
score: 98.5151034268466
patch: ++ iter ; ++ * / ++ iter ; ;
rank: 645
score: 98.39281463623047
patch: if ( ++ n == iter )
rank: 646
score: 98.7848259420956
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair )
rank: 646
score: 98.78326416015625
patch: double [ ] x 1 = line CaMeL
rank: 646
score: 98.63520951704545
patch: ++ iter ; while ( iter != null ; )
rank: 646
score: 98.543701171875
patch: * * * / * /
rank: 646
score: 98.51455078125
patch: ++ 1 ; ++ iter ; ++ * /
rank: 646
score: 98.392724609375
patch: while ( iter != null ) { try {
rank: 646
score: 98.39168003627232
patch: iter ++ ; ++ start ;
rank: 647
score: 98.8935302734375
patch: if ( iter < f CaMeL Val ) {
rank: 647
score: 98.84557088216145
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > = Math CaMeL Arrays . copy CaMeL Of ( n ) ;
rank: 647
score: 98.78461100260417
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair > iter = true ;
rank: 647
score: 98.78185424804687
patch: int f CaMeL Val = 0 . 0 ;
rank: 647
score: 98.78172718394886
patch: double [ ] n 1 = f CaMeL Val ;
rank: 647
score: 98.63487752278645
patch: ++ iter ; System . arraycopy ( ++ iter , ;
rank: 647
score: 98.54326837713069
patch: if ( iter == null || iter == null ;
rank: 647
score: 98.51453746448864
patch: ++ iter ; ++ * / int iter ++ ;
rank: 647
score: 98.39258922230114
patch: if ( iter == null ) { continue ; }
rank: 647
score: 98.39033726283482
patch: ++ max ; ++ n ;
rank: 648
score: 98.8920389811198
patch: while ( iter < f CaMeL Val . length ) {
rank: 648
score: 98.844482421875
patch: double x $NUMBER$ [ ] = f CaMeL Val ;
rank: 648
score: 98.78456333705357
patch: result = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( x ,
rank: 648
score: 98.77926296657986
patch: double [ ] = f CaMeL Val ;
rank: 648
score: 98.54293484157986
patch: if ( iter < 1 ; * /
rank: 648
score: 98.5140713778409
patch: ++ iter ; ++ iter ; / * * /
rank: 648
score: 98.39207874644886
patch: ++ iter ; ; if ( iter != null )
rank: 648
score: 98.38986642020089
patch: ++ iter ; iter ; iter
rank: 649
score: 98.84424700055804
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , compute CaMeL Objective CaMeL Value ( x $NUMBER$ ) ) ;
rank: 649
score: 98.78445870535714
patch: Iterator < Point CaMeL Value CaMeL Pair extends Univariate CaMeL Point CaMeL Value CaMeL Pair > iter = 0 ;
rank: 649
score: 98.78134494357639
patch: double f CaMeL Val = - $NUMBER$ ;
rank: 649
score: 98.7783447265625
patch: double [ ] x = Math . TRUE ;
rank: 649
score: 98.63468424479167
patch: while ( iter >= n ) { ;
rank: 649
score: 98.54215087890626
patch: else { ++ iter ; } ++ iter ;
rank: 649
score: 98.5138916015625
patch: ++ iter ; ++ * ++ iter ; ;
rank: 649
score: 98.39201216264205
patch: if ( ! ++ iter ) { ++ iter ;
rank: 649
score: 98.38510131835938
patch: ++ ++ 1 ;
rank: 650
score: 98.84407552083333
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = Math CaMeL Arrays . copy CaMeL Of ( min ) ;
rank: 650
score: 98.7841567993164
patch: o = new CaMeL Point CaMeL And CaMeL Direction ( f CaMeL Val ) ;
rank: 650
score: 98.7767333984375
patch: double iter = guess . iter ( ) ;
rank: 650
score: 98.77523193359374
patch: if ( 0 <= f CaMeL Val ) {
rank: 650
score: 98.63456895616319
patch: if ( iter >= n ) break ;
rank: 650
score: 98.54213645241477
patch: if ( iter != null ) return iter ; }
rank: 650
score: 98.5137606534091
patch: ++ iter ; ++ * * int ++ iter ;
rank: 650
score: 98.39162868923611
patch: ++ iter ; synchronized ( this ) {
rank: 650
score: 98.38323102678571
patch: ++ iter ; ++ super ;
rank: 651
score: 98.843955078125
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = Math CaMeL Arrays . copy CaMeL Of ( x $NUMBER$ ) ;
rank: 651
score: 98.78406343005952
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > iter = guess ;
rank: 651
score: 98.77616577148437
patch: final double start 1 = f CaMeL Val ;
rank: 651
score: 98.63449532645089
patch: ++ iter ; int n = Double . parse CaMeL Int ( ;
rank: 651
score: 98.54069213867187
patch: if ( iter != iter ; return iter ;
rank: 651
score: 98.51357421875
patch: ++ iter ; ++ 1 ; while iter ;
rank: 651
score: 98.39131164550781
patch: if ( ++ n == 0 ;
rank: 651
score: 98.38249860491071
patch: ++ break ; ++ iter ;
rank: 652
score: 98.88629150390625
patch: int f CaMeL Val $NUMBER$ = 0 ;
rank: 652
score: 98.84370478877315
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , compute CaMeL Objective CaMeL Value ( 0 ) ) ;
rank: 652
score: 98.78397993607955
patch: entry = get CaMeL Goal CaMeL Type ( ) ;
rank: 652
score: 98.77471313476562
patch: double iter = f CaMeL Val - 0 ;
rank: 652
score: 98.6343282063802
patch: ++ iter ; if ( iter > 0 ) continue ;
rank: 652
score: 98.54015435112848
patch: / * * * / iter * /
rank: 652
score: 98.51277299360795
patch: ++ iter ; ++ iter ; int * ++ ;
rank: 652
score: 98.39115905761719
patch: float iter = iter - n ;
rank: 652
score: 98.38134765625
patch: ++ iter ; iter ; ;
rank: 653
score: 98.78390342310855
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair > iter = x . iterator ( ) ;
rank: 653
score: 98.7744473544034
patch: final double f CaMeL Val = f CaMeL Val -
rank: 653
score: 98.63376089242789
patch: ++ iter ; if ( iter >= n ) ++ iter ;
rank: 653
score: 98.53986206054688
patch: else { iter * * * * / }
rank: 653
score: 98.51195179332386
patch: ++ * * ++ iter ; / ++ iter ;
rank: 653
score: 98.39081573486328
patch: while ( iter != 0 ) {
rank: 653
score: 98.36824544270833
patch: break ; ++ iter ;
rank: 654
score: 98.88451038707386
patch: double f CaMeL Val = 0 . ( ) ;
rank: 654
score: 98.84256685697116
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val + f CaMeL Val . clone ( ) ) ;
rank: 654
score: 98.7837422688802
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Point CaMeL Value CaMeL Pair . get CaMeL Point ( ) ) ;
rank: 654
score: 98.63363037109374
patch: ++ iter ; x [ iter ] = ;
rank: 654
score: 98.53985040838069
patch: if ( iter == null && iter == 0 ;
rank: 654
score: 98.51146240234375
patch: ++ iter ; int iter ; ++ iter ;
rank: 654
score: 98.39031304253473
patch: int iter = 0 ; ++ iter ;
rank: 654
score: 98.36488037109375
patch: return iter ; ;
rank: 655
score: 98.84226481119792
patch: Point CaMeL Value CaMeL Pair checker = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , x $NUMBER$ ) ;
rank: 655
score: 98.7832275390625
patch: Iterator < Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > ++ iter = 0 ;
rank: 655
score: 98.77390747070312
patch: final double n $NUMBER$ = f CaMeL Val ;
rank: 655
score: 98.77290482954545
patch: double [ ] x 1 = $NUMBER$ . 1 ;
rank: 655
score: 98.63352457682292
patch: Iterator < Integer > iter = iter . iterator ( ;
rank: 655
score: 98.53981236049107
patch: if ( iter == $NUMBER$ ;
rank: 655
score: 98.5110595703125
patch: ++ iter ; ++ * * int iter ;
rank: 655
score: 98.38704427083333
patch: input = ++ n ;
rank: 655
score: 98.35861206054688
patch: ++ - iter ;
rank: 656
score: 98.88384540264423
patch: double f CaMeL Val $NUMBER$ = f CaMeL Val + 0 ;
rank: 656
score: 98.84127371651786
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( Math CaMeL Arrays . copy CaMeL Of ( direc . clone ( ) ) ) ;
rank: 656
score: 98.78315873579545
patch: Iterator < Point CaMeL Value CaMeL Pair protected Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ) {
rank: 656
score: 98.77229614257813
patch: double iter = f CaMeL Val . iter ;
rank: 656
score: 98.77191716974431
patch: double [ ] x $NUMBER$ = 0 . 0 ;
rank: 656
score: 98.63351236979166
patch: return new Point CaMeL Value CaMeL Pair ( iter , ++ n ) ;
rank: 656
score: 98.53961181640625
patch: / * ; * / ++ iter ;
rank: 656
score: 98.51056518554688
patch: ++ iter ; iter * * ; * /
rank: 656
score: 98.38701629638672
patch: double n = iter - iter ;
rank: 656
score: 98.34780883789062
patch: ++ iter ; ++ ;
rank: 657
score: 98.88363882211539
patch: double f CaMeL Val $NUMBER$ [ ] = f CaMeL Val ;
rank: 657
score: 98.8396484375
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair > . Point CaMeL Value CaMeL Pair ;
rank: 657
score: 98.78307524181548
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( compute CaMeL Objective CaMeL Value ( x ) ) ;
rank: 657
score: 98.77210828993056
patch: final double f CaMeL Val = x ;
rank: 657
score: 98.77017822265626
patch: double [ ] f CaMeL Val = false ;
rank: 657
score: 98.63341471354167
patch: ++ iter ; return new Point CaMeL Value CaMeL Pair ( ; } ;
rank: 657
score: 98.53924560546875
patch: else { iter * * * / } }
rank: 657
score: 98.51039817116477
patch: / * ++ iter ; / / / / /
rank: 657
score: 98.38594818115234
patch: ++ iter ; switch ( iter )
rank: 657
score: 98.34712727864583
patch: ++ iter ; iter /
rank: 658
score: 98.8393085186298
patch: double iter = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ) ;
rank: 658
score: 98.77109596946023
patch: final int [ ] x = f CaMeL Val ;
rank: 658
score: 98.76991577148438
patch: double f CaMeL Val = Math . 0 ;
rank: 658
score: 98.53908962673611
patch: * * * * * / * ;
rank: 658
score: 98.34264373779297
patch: iter ; iter
rank: 659
score: 98.8782071200284
patch: ++ n ; double f CaMeL Val = 0 ;
rank: 659
score: 98.83921595982143
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = Math CaMeL Arrays . copy CaMeL Of ( direc [ 0 ] ) ;
rank: 659
score: 98.78282877604167
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair > iter = $NUMBER$ ;
rank: 659
score: 98.769775390625
patch: double iter = f CaMeL Val + 0 ;
rank: 659
score: 98.63270399305556
patch: double x [ ] [ ] = ;
rank: 659
score: 98.53894721137152
patch: else { iter * * / } }
rank: 659
score: 98.50996537642045
patch: ++ iter ; iter ; * * * / /
rank: 659
score: 98.34224446614583
patch: ++ iter + 0 ;
rank: 660
score: 98.8777364095052
patch: int f CaMeL Val $NUMBER$ = f CaMeL Val $NUMBER$ ;
rank: 660
score: 98.83902994791667
patch: double f CaMeL Val = compute CaMeL Objective CaMeL Value ( Math CaMeL Arrays . copy CaMeL Of ( n ) ) ;
rank: 660
score: 98.7827785326087
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair , Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ;
rank: 660
score: 98.7689541903409
patch: int [ ] x $NUMBER$ = f CaMeL Val ;
rank: 660
score: 98.63245442708333
patch: return new Point CaMeL Value CaMeL Pair ( this , iter , x ;
rank: 660
score: 98.53854806082589
patch: ++ iter ; } if ;
rank: 660
score: 98.50994318181819
patch: ++ iter ; * * * / ++ iter ;
rank: 660
score: 98.38441685267857
patch: while ( n < n )
rank: 661
score: 98.87601412259616
patch: double f CaMeL Val = ( double ) f CaMeL Val ;
rank: 661
score: 98.83866743607955
patch: final double [ ] f CaMeL Val = null ;
rank: 661
score: 98.78243679470486
patch: return new Univariate CaMeL Point CaMeL Value CaMeL Pair ( x , f CaMeL Val ) ;
rank: 661
score: 98.76663818359376
patch: if ( 0 == f CaMeL Val ) {
rank: 661
score: 98.6323575106534
patch: ++ iter ; * / * * ++ iter ;
rank: 661
score: 98.53843383789062
patch: / * * * / / ++ iter ;
rank: 661
score: 98.50974731445312
patch: ++ iter ; try { iter ; * /
rank: 661
score: 98.38294328962054
patch: final int iter = 0 ;
rank: 662
score: 98.87532865084134
patch: final int f CaMeL Val = f CaMeL Val - 0 ;
rank: 662
score: 98.78198960248162
patch: Object f CaMeL Val = compute CaMeL Objective CaMeL Value ( x , x ) ;
rank: 662
score: 98.76695556640625
patch: double iter = x . read ( ) ;
rank: 662
score: 98.76640625
patch: double [ ] f CaMeL Val = true ;
rank: 662
score: 98.63163248697917
patch: throw new Illegal CaMeL Argument CaMeL Exception ( ) ; } ++ n ;
rank: 662
score: 98.53766741071429
patch: ++ * * ; * /
rank: 662
score: 98.50911254882813
patch: / * ] ++ iter ; iter * /
rank: 662
score: 98.3829345703125
patch: float n = iter ;
rank: 662
score: 98.33300170898437
patch: ++ -- iter ;
rank: 663
score: 98.875244140625
patch: double f CaMeL Val = do CaMeL Optimize ( x ) ;
rank: 663
score: 98.78193102384868
patch: Iterator < Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > iter = guess ;
rank: 663
score: 98.76218872070312
patch: final double f CaMeL Val = - 1 ;
rank: 663
score: 98.63148082386364
patch: if ( iter < iter ) { ++ iter ;
rank: 663
score: 98.53765869140625
patch: else { iter * * /
rank: 663
score: 98.50864479758523
patch: ++ iter ; / * * * * / /
rank: 663
score: 98.38265652126736
patch: final int iter = iter - n ;
rank: 663
score: 98.3314717610677
patch: ++ ++ ++ iter ;
rank: 664
score: 98.87465413411458
patch: if ( f CaMeL Val $NUMBER$ - f CaMeL Val ;
rank: 664
score: 98.83699174360795
patch: final double [ ] iter = f CaMeL Val ;
rank: 664
score: 98.78188747829861
patch: x = Math CaMeL Arrays . copy CaMeL Of ( x . clone ( ) ) ;
rank: 664
score: 98.76662375710227
patch: double iter = f CaMeL Val [ iter ] ;
rank: 664
score: 98.76116943359375
patch: long f CaMeL Val = 0 ;
rank: 664
score: 98.6311368075284
patch: ++ iter ; if ( iter > 0 ) ;
rank: 664
score: 98.53718705610795
patch: Set < ? > iter = iter . min ;
rank: 664
score: 98.38252088758681
patch: ++ iter ; else if ( iter ;
rank: 664
score: 98.32765706380208
patch: return iter ; ; ;
rank: 665
score: 98.87417367788461
patch: double f CaMeL Val = 0 ; while ( true ) {
rank: 665
score: 98.83678747106481
patch: final double f CaMeL Val = compute CaMeL Objective CaMeL Value ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ) ;
rank: 665
score: 98.78184442934783
patch: return new Point CaMeL Value CaMeL Pair ( Math CaMeL Arrays . copy CaMeL Of ( x ) , iter ) ;
rank: 665
score: 98.76315307617188
patch: Integer f CaMeL Val = f CaMeL Val ;
rank: 665
score: 98.76028781467014
patch: double [ ] x = direc ;
rank: 665
score: 98.63102213541667
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + n ) ; ;
rank: 665
score: 98.536767578125
patch: else { if ++ [ 0 ] ; }
rank: 665
score: 98.5077237215909
patch: ++ iter ; iter * * * * / /
rank: 665
score: 98.37940809461806
patch: final int iter = iter - iter ;
rank: 665
score: 98.32001342773438
patch: ++ - 1 ;
rank: 666
score: 98.87330118815105
patch: double f CaMeL Val = compute CaMeL Value ( ) ;
rank: 666
score: 98.83556019176136
patch: final double [ ] x 1 = x 1 ;
rank: 666
score: 98.78164190995066
patch: return Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , f CaMeL Val ) ;
rank: 666
score: 98.76007080078125
patch: ++ f CaMeL Val ;
rank: 666
score: 98.6309814453125
patch: ++ iter ; Point CaMeL Value CaMeL Pair iter = iter . ;
rank: 666
score: 98.53641086154514
patch: * * * * ++ iter ; }
rank: 666
score: 98.50750177556819
patch: ++ iter ; ++ iter ; System . out ;
rank: 666
score: 98.31521606445312
patch: ++ $NUMBER$ + iter ;
rank: 667
score: 98.78151448567708
patch: iter = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 667
score: 98.759228515625
patch: if ( f CaMeL Val == $NUMBER$ ) {
rank: 667
score: 98.63080388849431
patch: ++ iter ; int iter = x . length ;
rank: 667
score: 98.53624810112848
patch: / * * * ++ / * /
rank: 667
score: 98.50673828125
patch: ++ iter ; int iter ; int * /
rank: 667
score: 98.37853325737848
patch: if ( iter < iter . length )
rank: 667
score: 98.31471761067708
patch: iter ;
rank: 668
score: 98.78134553328805
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair < Univariate CaMeL Point CaMeL Value CaMeL Pair >> iter = 0 ;
rank: 668
score: 98.6307842548077
patch: return new Point CaMeL Value CaMeL Pair ( iter , ; ;
rank: 668
score: 98.50672496448864
patch: ++ iter ; ++ iter ; for ++ 1 ;
rank: 668
score: 98.30474853515625
patch: ++ iter ; ; else
rank: 669
score: 98.87143776633523
patch: ++ iter ; double f CaMeL Val = false ;
rank: 669
score: 98.83472583912037
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair > . Point CaMeL Value CaMeL Pair > checker ;
rank: 669
score: 98.78127872242646
patch: o = Math CaMeL Arrays . copy CaMeL Of ( direc . 0 ) ;
rank: 669
score: 98.76119559151786
patch: final double iter = 0 ;
rank: 669
score: 98.75807883522727
patch: x 1 [ 0 ] = f CaMeL Val ;
rank: 669
score: 98.63075474330357
patch: ++ iter ; if ( iter < n ) { ++ iter ;
rank: 669
score: 98.53536551339286
patch: * * ++ iter ; }
rank: 669
score: 98.50665283203125
patch: ++ iter ; ++ iter ; ++ $STRING$ ;
rank: 669
score: 98.30352783203125
patch: * ; ++ iter ;
rank: 670
score: 98.83426219019397
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , Math CaMeL Arrays . copy CaMeL Of ( x ) ) ;
rank: 670
score: 98.78127219460227
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Point CaMeL Value CaMeL Pair . x , iter ) ;
rank: 670
score: 98.76095920138889
patch: double n 1 = f CaMeL Val ;
rank: 670
score: 98.75426567925348
patch: double [ ] x 1 = $NUMBER$ ;
rank: 670
score: 98.63059895833334
patch: ++ iter ; while ( iter < n ) { ++ iter ; }
rank: 670
score: 98.53485785590277
patch: * * * * / iter * /
rank: 670
score: 98.5062255859375
patch: ++ iter ; ++ iter ; iter ; ++ iter ;
rank: 670
score: 98.30316162109375
patch: ++ ; = iter ;
rank: 671
score: 98.87024864783653
patch: ++ true ; int f CaMeL Val = f CaMeL Val ;
rank: 671
score: 98.83397498497597
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = new CaMeL Point CaMeL And CaMeL Direction ( relative CaMeL Threshold ) ;
rank: 671
score: 98.78119451349431
patch: return Point CaMeL Value CaMeL Pair . new CaMeL Point CaMeL And CaMeL Direction ( f CaMeL Val , ) ;
rank: 671
score: 98.76090698242187
patch: if ( n < relative CaMeL Threshold ) {
rank: 671
score: 98.53462049696181
patch: / * * * / ++ * /
rank: 671
score: 98.50621337890625
patch: ++ iter ; ++ iter ; int * *
rank: 672
score: 98.86988414417614
patch: double f CaMeL Val = 1 . ( ) ;
rank: 672
score: 98.83396629050925
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , 0 ) ) ;
rank: 672
score: 98.7810391512784
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Point CaMeL Value CaMeL Pair . 1 . 0 ) ;
rank: 672
score: 98.75283203125
patch: final double f CaMeL Val = - 0 ;
rank: 672
score: 98.62992640904018
patch: Iterator < Point CaMeL Value CaMeL Pair > iter = this . ;
rank: 672
score: 98.53408474392361
patch: / * * * ; / * /
rank: 672
score: 98.50567016601562
patch: ++ iter ; ++ * ; int iter ;
rank: 672
score: 98.36098225911458
patch: input = ++ iter ;
rank: 672
score: 98.29173278808594
patch: ++ $STRING$ ;
rank: 673
score: 98.86914825439453
patch: if ( goal != null ) {
rank: 673
score: 98.78081916360294
patch: return Math CaMeL Arrays . copy CaMeL Of ( direc [ iter ] ) ;
rank: 673
score: 98.7591323852539
patch: double length = f CaMeL Val ;
rank: 673
score: 98.75223999023437
patch: long [ ] x = f CaMeL Val ;
rank: 673
score: 98.62977294921875
patch: ++ iter ; while ( iter ; ) ;
rank: 673
score: 98.53318568638393
patch: else { ++ x ; }
rank: 673
score: 98.5056485262784
patch: ++ iter ; int 1 = iter - 1 ;
rank: 673
score: 98.35406494140625
patch: f CaMeL Val = ;
rank: 674
score: 98.83350548377403
patch: double CaMeL Value = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , compute CaMeL Objective CaMeL Value ( ) ) ;
rank: 674
score: 98.78066677517361
patch: return ( Point CaMeL Value CaMeL Pair ) checker . get CaMeL Point ( ) ; }
rank: 674
score: 98.75184326171875
patch: double f CaMeL Val = 0 : 0 ;
rank: 674
score: 98.62974964488636
patch: while ( iter < iter ) { iter ++ ;
rank: 674
score: 98.53316243489583
patch: try { iter = iter . iter ;
rank: 674
score: 98.50542658025569
patch: ++ iter ; ++ iter ; for iter ; }
rank: 674
score: 98.34600830078125
patch: if ( iter >= n )
rank: 674
score: 98.27695719401042
patch: iter ; ++ 0 ;
rank: 675
score: 98.78056255139802
patch: Iterator < Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > iter = x .
rank: 675
score: 98.75755726207386
patch: double [ ] x 1 += f CaMeL Val ;
rank: 675
score: 98.7482666015625
patch: if ( n <= f CaMeL Val ) {
rank: 675
score: 98.62946428571429
patch: return new Point CaMeL Value CaMeL Pair ( n , iter ) ;
rank: 675
score: 98.53300258091518
patch: ++ ++ [ ] ; }
rank: 675
score: 98.5053955078125
patch: ++ iter ; ++ * * ; / /
rank: 675
score: 98.34239705403645
patch: c = ++ iter ;
rank: 675
score: 98.2670389811198
patch: ++ iter ; iter }
rank: 676
score: 98.86630483774039
patch: if ( f CaMeL Val $NUMBER$ - f CaMeL Val $NUMBER$ ;
rank: 676
score: 98.780517578125
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( new CaMeL Point CaMeL And CaMeL Direction ( x ,
rank: 676
score: 98.75677490234375
patch: double f CaMeL Val = Math . TRUE ;
rank: 676
score: 98.62945963541667
patch: return new Point CaMeL Value CaMeL Pair ( ++ n , ++ n ;
rank: 676
score: 98.53261108398438
patch: if ( iter == 0 ; ++ iter ;
rank: 676
score: 98.50537109375
patch: / * ] ++ iter ; int * /
rank: 676
score: 98.2613016764323
patch: ++ new = iter ;
rank: 677
score: 98.86629544771634
patch: ++ iter ; double f CaMeL Val - f CaMeL Val ;
rank: 677
score: 98.83065682870371
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = new CaMeL Point CaMeL And CaMeL Direction . get CaMeL Value ( ) ;
rank: 677
score: 98.78029913651316
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair > iter = line . iterator ( ) ;
rank: 677
score: 98.75510864257812
patch: double x = f CaMeL Val : 0 ;
rank: 677
score: 98.62938514122597
patch: ++ iter ; if ( iter <= n ) ++ iter ;
rank: 677
score: 98.53249782986111
patch: if ( [ 0 ] == null ;
rank: 677
score: 98.50515747070312
patch: ++ iter ; ++ iter ; try ; ++ iter ;
rank: 677
score: 98.33873639787946
patch: pos ++ ; ++ n ;
rank: 677
score: 98.25266520182292
patch: if iter = 0 ;
rank: 678
score: 98.865966796875
patch: double f CaMeL Val = Math . clone ( x ) ;
rank: 678
score: 98.829619140625
patch: final Point CaMeL Value CaMeL Pair checker = Math CaMeL Arrays . copy CaMeL Of ( direc . clone ( ) ) ;
rank: 678
score: 98.78021240234375
patch: Iterator < Point CaMeL Value CaMeL Pair protected Univariate CaMeL Point CaMeL Value CaMeL Pair > iterator ( )
rank: 678
score: 98.75370788574219
patch: double iter = relative CaMeL Threshold ;
rank: 678
score: 98.74469672309027
patch: int f CaMeL Val = - $NUMBER$ ;
rank: 678
score: 98.62933819110577
patch: return new Point CaMeL Value CaMeL Pair ( iter , x )
rank: 678
score: 98.53217107599431
patch: if ( iter == null ; while ; * /
rank: 678
score: 98.50452270507813
patch: ++ 1 ; ++ iter ; if iter ;
rank: 678
score: 98.33079310825893
patch: int n = - 1 ;
rank: 679
score: 98.86577899639423
patch: double f CaMeL Val ; double f CaMeL Val = 0 ;
rank: 679
score: 98.82958984375
patch: final double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val . get CaMeL Point ( ) ) ;
rank: 679
score: 98.7802097486413
patch: Iterator < Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > iter = x . clone ( ) ;
rank: 679
score: 98.75308227539062
patch: double iter = f CaMeL Val . length ;
rank: 679
score: 98.62922014508929
patch: ++ iter ; while ( iter < n ; iter ++ ) {
rank: 679
score: 98.53203125
patch: else { ( ++ * 0 . 0 ;
rank: 679
score: 98.50445556640625
patch: ++ iter ; while iter ; while iter ;
rank: 679
score: 98.33033098493304
patch: pos ++ ; ++ iter ;
rank: 679
score: 98.24639892578125
patch: ++ iter ; else ;
rank: 680
score: 98.86538461538461
patch: ++ iter ; double f CaMeL Val = 0 . 1 ;
rank: 680
score: 98.8294208233173
patch: final Point CaMeL Value CaMeL Pair checker = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val . clone ( ) ) ;
rank: 680
score: 98.7798713235294
patch: return new CaMeL Point CaMeL And CaMeL Direction ( x , x , iter ) ;
rank: 680
score: 98.7521084872159
patch: double [ ] x ( f CaMeL Val ) ;
rank: 680
score: 98.53159790039062
patch: / * * ; * / ++ iter ;
rank: 680
score: 98.5040995279948
patch: / * * * * * / / ++ iter ;
rank: 680
score: 98.33021763392857
patch: double n = ++ iter ;
rank: 681
score: 98.82911095252403
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair > . Point CaMeL Value CaMeL Pair 1 ;
rank: 681
score: 98.77914089626736
patch: return Math CaMeL Arrays . copy CaMeL Of ( direc . x , iter ) ;
rank: 681
score: 98.75114302201705
patch: double [ ] x = f CaMeL Val 1 ;
rank: 681
score: 98.74095153808594
patch: double [ ] x = 1 ;
rank: 681
score: 98.6291015625
patch: return new Point CaMeL Value CaMeL Pair ( iter , ++ iter ; }
rank: 681
score: 98.53144666883681
patch: else { if ; ++ iter ; }
rank: 681
score: 98.50399169921874
patch: ++ iter ; ++ * * / / /
rank: 681
score: 98.32991536458333
patch: result = ++ iter ;
rank: 681
score: 98.2411600748698
patch: iter ; ++ n ;
rank: 682
score: 98.8641826923077
patch: ++ iter ; double f CaMeL Val = $NUMBER$ . 0 ;
rank: 682
score: 98.82860423900463
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair > . Point CaMeL Value CaMeL Pair [ ] ;
rank: 682
score: 98.77912248883929
patch: Integer f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( x , f CaMeL Val ) ;
rank: 682
score: 98.73993530273438
patch: if ( f CaMeL Val != 0 ) {
rank: 682
score: 98.62909807477679
patch: return new Point CaMeL Value CaMeL Pair ( start , n ) ;
rank: 682
score: 98.53084309895833
patch: / * * * / * * /
rank: 682
score: 98.50377308238636
patch: ++ iter ; ++ iter ; int * / /
rank: 682
score: 98.32771519252232
patch: double n = ++ n ;
rank: 682
score: 98.2381083170573
patch: ++ max = iter ;
rank: 683
score: 98.82786729600694
patch: double [ ] x 1 = 1 ;
rank: 683
score: 98.77910299862133
patch: Iterator < Point CaMeL Value CaMeL Pair extends Univariate CaMeL Point CaMeL Value CaMeL Pair >
rank: 683
score: 98.748291015625
patch: double x [ ] = f CaMeL Val ;
rank: 683
score: 98.62897406684027
patch: if ( iter < ; iter ++ ;
rank: 683
score: 98.53059895833333
patch: / * * * * / iter ;
rank: 683
score: 98.50302956321023
patch: ++ iter ; ++ iter ; int * * ;
rank: 683
score: 98.32408796037946
patch: j = iter + iter ;
rank: 683
score: 98.2377217610677
patch: ++ max * iter ;
rank: 684
score: 98.82781512920673
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair && f CaMeL Val . get CaMeL Value ( ) . clone ( ) ;
rank: 684
score: 98.77894422743056
patch: result = x . clone ( ) ;
rank: 684
score: 98.73360188802083
patch: if ( n < f CaMeL Val )
rank: 684
score: 98.62872992621527
patch: ++ iter ; while ( ++ iter ;
rank: 684
score: 98.53048366970486
patch: if ( iter < 0 ; * ;
rank: 684
score: 98.50242309570312
patch: ++ * ++ iter ; iter * * /
rank: 684
score: 98.32183837890625
patch: synchronized ( ++ iter ) {
rank: 684
score: 98.23436482747395
patch: ++ iter + max ;
rank: 685
score: 98.8616943359375
patch: double f CaMeL Val = compute CaMeL Value ( x ) ;
rank: 685
score: 98.82762562144886
patch: final double iter = x . clone ( ) ;
rank: 685
score: 98.77887321920956
patch: r = Math CaMeL Arrays . copy CaMeL Of ( direc , 0 ) ;
rank: 685
score: 98.747119140625
patch: double [ ] guess = f CaMeL Val ;
rank: 685
score: 98.62865339006696
patch: ++ iter ; while ( iter < n ) { iter ++ ;
rank: 685
score: 98.53028564453125
patch: if ( iter == null ) throw null ;
rank: 685
score: 98.50181884765625
patch: ++ iter ; iter ; * ; * /
rank: 685
score: 98.32119750976562
patch: ++ iter ; continue ;
rank: 685
score: 98.23209635416667
patch: ++ * = iter ;
rank: 686
score: 98.82590060763889
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) , 0 ) ;
rank: 686
score: 98.77877807617188
patch: long f CaMeL Val = x . clone ( ) ;
rank: 686
score: 98.7458984375
patch: double [ ] max = f CaMeL Val ;
rank: 686
score: 98.7187271118164
patch: double [ ] x 1 = (
rank: 686
score: 98.53013780381944
patch: else { iter += iter ; * /
rank: 686
score: 98.50075461647727
patch: ++ iter ; ++ * * / * iter ;
rank: 686
score: 98.3200174967448
patch: t = ++ iter ;
rank: 686
score: 98.23045857747395
patch: ++ iter ; iter iter
rank: 687
score: 98.859375
patch: ++ iter ; double iter = f CaMeL Val ;
rank: 687
score: 98.82575334821429
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , f CaMeL Val . to CaMeL String ( ) ) ;
rank: 687
score: 98.71749877929688
patch: double x = 0 . 0 ;
rank: 687
score: 98.62827555338542
patch: ++ iter ; ; if ( ! ;
rank: 687
score: 98.5290283203125
patch: if ( iter == 0 ) return iter ;
rank: 687
score: 98.50062144886364
patch: ++ iter ; ++ * - iter ; break ;
rank: 687
score: 98.31618826729911
patch: j = iter - iter ;
rank: 687
score: 98.22799682617188
patch: ++ iter + n ;
rank: 688
score: 98.82453125
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val . to CaMeL
rank: 688
score: 98.77859933035714
patch: Iterator < Point CaMeL Value CaMeL Pair protected Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ;
rank: 688
score: 98.74533081054688
patch: double [ ] f CaMeL Val = line ;
rank: 688
score: 98.71580505371094
patch: int f CaMeL Val = null ;
rank: 688
score: 98.62811279296875
patch: ++ iter ; new Point CaMeL Value CaMeL Pair ( ++ iter ;
rank: 688
score: 98.52864583333333
patch: ++ * * * * / iter /
rank: 688
score: 98.5001220703125
patch: / * ] iter ; / * / ++ iter ;
rank: 688
score: 98.31177629743304
patch: pos = iter + iter ;
rank: 688
score: 98.22686767578125
patch: / ; iter ++ ;
rank: 689
score: 98.82272338867188
patch: double [ ] x . clone ( ) ;
rank: 689
score: 98.77821044921875
patch: return Point CaMeL Value CaMeL Pair . new CaMeL Point CaMeL And CaMeL Direction ( x , ) ;
rank: 689
score: 98.74406602647569
patch: double [ ] x $NUMBER$ = 0 ;
rank: 689
score: 98.71556854248047
patch: double f CaMeL Val = true ;
rank: 689
score: 98.62802956321023
patch: ++ iter ; while ( iter <= n ) ;
rank: 689
score: 98.52842881944444
patch: / * * * * ++ ; /
rank: 689
score: 98.49962361653645
patch: / * ] ++ iter ; * / ++ iter ;
rank: 689
score: 98.22610473632812
patch: ++ iter + start ;
rank: 690
score: 98.85442504882812
patch: ++ iter ; f CaMeL Val = 0 ;
rank: 690
score: 98.82258744673295
patch: double [ ] [ ] x 1 = 0 ;
rank: 690
score: 98.77751079358552
patch: Long f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ;
rank: 690
score: 98.7120361328125
patch: f CaMeL Val = 0 ;
rank: 690
score: 98.62758963448661
patch: return new Point CaMeL Value CaMeL Pair ( 0 , iter , ;
rank: 690
score: 98.5283203125
patch: else ; return iter ; }
rank: 690
score: 98.49958939985795
patch: ++ iter ; ++ iter ; int - iter ;
rank: 690
score: 98.3099365234375
patch: p = ++ iter ;
rank: 690
score: 98.22149658203125
patch: iter iter ++ ;
rank: 691
score: 98.82227466724537
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = Math CaMeL Arrays . copy CaMeL Of ( direc , 0 ) ;
rank: 691
score: 98.7773946126302
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ( x , f CaMeL Val ) ;
rank: 691
score: 98.74053344726562
patch: double f CaMeL Val [ ] = 0 ;
rank: 691
score: 98.62737482244319
patch: while ( iter < iter ) { ++ n ;
rank: 691
score: 98.52821044921875
patch: else { * * * * / / }
rank: 691
score: 98.4994784268466
patch: ++ iter ; ++ iter ; while iter ; ;
rank: 691
score: 98.3026123046875
patch: for ; ; ) {
rank: 691
score: 98.21636962890625
patch: if ++ ++ iter ;
rank: 692
score: 98.85354614257812
patch: final Univariate CaMeL Point CaMeL Value CaMeL Pair < double ,
rank: 692
score: 98.82163783482143
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = new CaMeL Point CaMeL And CaMeL Direction ( x . clone ( ) ) ;
rank: 692
score: 98.7770931846217
patch: Iterator < Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > iter = 1 ;
rank: 692
score: 98.71028355189732
patch: double f CaMeL Val = (
rank: 692
score: 98.62721470424107
patch: return new Point CaMeL Value CaMeL Pair ( iter , iter ; }
rank: 692
score: 98.52812056107955
patch: Set < Object > iter = iter . max ;
rank: 692
score: 98.49884588068181
patch: ++ iter ; iter ; int iter = iter ;
rank: 692
score: 98.20404052734375
patch: ++ null ;
rank: 693
score: 98.85132945667614
patch: ++ iter ; double f CaMeL Val = $NUMBER$ ;
rank: 693
score: 98.77690972222223
patch: r = Math CaMeL Arrays . copy CaMeL Of ( direc [ 0 ] ) ;
rank: 693
score: 98.70992702907986
patch: double iter = - f CaMeL Val ;
rank: 693
score: 98.62693434495192
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ; } ;
rank: 693
score: 98.52786865234376
patch: else { * * * / * / }
rank: 693
score: 98.4984463778409
patch: / * * ++ * / / ++ iter ;
rank: 694
score: 98.77656824448529
patch: tmp = Math CaMeL Arrays . copy CaMeL Of ( direc , 0 ) ;
rank: 694
score: 98.7393798828125
patch: double n = f CaMeL Val : 0 ;
rank: 694
score: 98.62691921657986
patch: ++ iter * / * * * /
rank: 694
score: 98.52725558810764
patch: if ( iter == null && false ;
rank: 694
score: 98.49668190696023
patch: / * ] ++ iter ; / * / /
rank: 694
score: 98.29881940569196
patch: ++ iter ; else if ;
rank: 695
score: 98.84685724431819
patch: int f CaMeL Val 1 = f CaMeL Val ;
rank: 695
score: 98.77647908528645
patch: o = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 695
score: 98.73929172092014
patch: final double [ ] x = 0 ;
rank: 695
score: 98.70738220214844
patch: double f CaMeL Val = false ;
rank: 695
score: 98.62610802283653
patch: return new Point CaMeL Value CaMeL Pair ( this , x ;
rank: 695
score: 98.49640447443181
patch: if ++ iter ; ++ 1 ; ++ iter ;
rank: 695
score: 98.29705810546875
patch: while ( iter == 0 )
rank: 695
score: 98.1977030436198
patch: ++ $STRING$ + iter ;
rank: 696
score: 98.81683819110577
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = . new CaMeL Point CaMeL And CaMeL Direction ( x 1 ,
rank: 696
score: 98.77599566915761
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair , Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair >
rank: 696
score: 98.7073745727539
patch: double [ ] iter = 0 ;
rank: 696
score: 98.62608235677084
patch: return new Point CaMeL Value CaMeL Pair ( iter , ++ n ; }
rank: 696
score: 98.52693006727431
patch: * * * * ; ++ * /
rank: 696
score: 98.29045758928571
patch: if ( ! ++ n ;
rank: 696
score: 98.19596354166667
patch: ++ iter ; iter else
rank: 697
score: 98.77599516369048
patch: return new Point CaMeL Value CaMeL Pair ( Point CaMeL Value CaMeL Pair . x 1 , iter ) ;
rank: 697
score: 98.73788452148438
patch: double f CaMeL Val = n ;
rank: 697
score: 98.69978162977431
patch: double f CaMeL Val = direc ;
rank: 697
score: 98.62523304332386
patch: if ( iter < iter ; iter ++ ) {
rank: 697
score: 98.52658420138889
patch: else { * * * * / /
rank: 697
score: 98.4947509765625
patch: / * * ++ iter * / ++ iter ;
rank: 697
score: 98.2903340657552
patch: ++ n - n ;
rank: 697
score: 98.19491577148438
patch: ++ - ++ iter ;
rank: 698
score: 98.81650954026442
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair && Math CaMeL Arrays . copy CaMeL Of ( direc ) <= 0 ;
rank: 698
score: 98.77581232244319
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > iter = - 1 ;
rank: 698
score: 98.73655482700893
patch: double ++ iter = 0 ;
rank: 698
score: 98.62498372395834
patch: return new Point CaMeL Value CaMeL Pair ( ++ n , x ) ;
rank: 698
score: 98.52518310546876
patch: else { * * * * / } /
rank: 698
score: 98.49384099786931
patch: ++ iter ; ++ iter ; ; int iter ;
rank: 698
score: 98.28956095377605
patch: final int n = ;
rank: 698
score: 98.1930440266927
patch: ++ ; ++ start ;
rank: 699
score: 98.77573464133523
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair )
rank: 699
score: 98.73623046875
patch: f CaMeL Val = f CaMeL Val 1 ;
rank: 699
score: 98.69779459635417
patch: double f CaMeL Val = 0 ; {
rank: 699
score: 98.624609375
patch: ++ iter ; while ( true ; ) {
rank: 699
score: 98.52459038628473
patch: else { iter * * * ; }
rank: 699
score: 98.49306418678977
patch: ++ iter ; if ++ 1 ; ++ iter ;
rank: 699
score: 98.19277954101562
patch: if iter * ; /
rank: 700
score: 98.81438078703704
patch: double CaMeL Value = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , compute CaMeL Objective CaMeL Value ( 0 ) ) ;
rank: 700
score: 98.77557663690476
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > iter = $NUMBER$ ;
rank: 700
score: 98.73525390625
patch: else f CaMeL Val = f CaMeL Val ;
rank: 700
score: 98.62427978515625
patch: ++ iter >= 0 && iter < n ;
rank: 700
score: 98.5245694247159
patch: ++ [ ] iter ; } if ++ iter ;
rank: 700
score: 98.49169921875
patch: / * ++ iter ; / * / ++ iter ;
rank: 700
score: 98.28792317708333
patch: p = ++ n ;
rank: 700
score: 98.19272867838542
patch: ++ iter ; iter *
rank: 701
score: 98.77547200520833
patch: Iterator < Point CaMeL Value CaMeL Pair )
rank: 701
score: 98.73370361328125
patch: final double x = f CaMeL Val ; final
rank: 701
score: 98.68674045138889
patch: int f CaMeL Val = - 0 ;
rank: 701
score: 98.6242342862216
patch: ++ iter ; if ( iter > n ) {
rank: 701
score: 98.52450900607639
patch: * * * * ; * * /
rank: 701
score: 98.49103338068181
patch: ++ * ++ iter ; try { ++ iter ;
rank: 701
score: 98.28781563895089
patch: if ( iter >= iter )
rank: 701
score: 98.19080607096355
patch: ++ 1 + iter ;
rank: 702
score: 98.81368314302884
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( Math CaMeL Arrays . copy CaMeL Of ( direc ) , 0 ) ;
rank: 702
score: 98.77543131510417
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > direc = f CaMeL Val ;
rank: 702
score: 98.62396647135417
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + iter ) ; ;
rank: 702
score: 98.52351518110795
patch: if ( iter == 1 ; return iter ; }
rank: 702
score: 98.4894131747159
patch: ++ * ++ iter ; ++ iter ; iter ;
rank: 702
score: 98.28734741210937
patch: float n = ;
rank: 702
score: 98.19015502929688
patch: iter ; ++ start ;
rank: 703
score: 98.84089799360795
patch: final int iter = x . clone ( ) ;
rank: 703
score: 98.81353290264423
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = new CaMeL Point CaMeL And CaMeL Direction ( x , clone ) ;
rank: 703
score: 98.77540418836806
patch: Iterator < Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > ++ iter ;
rank: 703
score: 98.7302490234375
patch: int f CaMeL Val = f CaMeL Val -
rank: 703
score: 98.68421088324652
patch: if ( 0 <= f CaMeL Val )
rank: 703
score: 98.52277166193181
patch: if ( iter == null ; return ++ $NUMBER$ ;
rank: 703
score: 98.48928000710227
patch: ++ iter ; ++ 1 ; ++ * * /
rank: 703
score: 98.28724161783855
patch: final int iter = ;
rank: 703
score: 98.18747965494792
patch: ++ iter ; ; try
rank: 704
score: 98.83915571732955
patch: double f CaMeL Val $NUMBER$ = 0 . 0 ;
rank: 704
score: 98.81314791165866
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair > . Point CaMeL Value CaMeL Pair checker ;
rank: 704
score: 98.77535400390624
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Point CaMeL Value CaMeL Pair . $NUMBER$ ) ;
rank: 704
score: 98.72955322265625
patch: boolean stop = $NUMBER$ * f CaMeL Val ;
rank: 704
score: 98.68377685546875
patch: f CaMeL Val = 1 . 0 ;
rank: 704
score: 98.62289864676339
patch: return new Point CaMeL Value CaMeL Pair ( ; } ++ iter ;
rank: 704
score: 98.52264404296875
patch: if ( iter ; * ; * /
rank: 704
score: 98.48876953125
patch: ++ iter ; ++ iter ; while iter iter ;
rank: 704
score: 98.2871826171875
patch: while ( false )
rank: 704
score: 98.18581136067708
patch: / ; ++ n ;
rank: 705
score: 98.83875732421875
patch: if ( f CaMeL Val < $NUMBER$ ) {
rank: 705
score: 98.81303349247685
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair && Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) <= 0 ;
rank: 705
score: 98.77477309283088
patch: Object f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( x ) ;
rank: 705
score: 98.72874620225694
patch: double start 1 = f CaMeL Val ;
rank: 705
score: 98.68157958984375
patch: double iter = 0 . 0 ;
rank: 705
score: 98.62257486979166
patch: throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + n + $STRING$ ;
rank: 705
score: 98.52263047960069
patch: if ; * * * ; * /
rank: 705
score: 98.48773748224431
patch: ++ iter ; ++ * * ++ * iter ;
rank: 705
score: 98.28652518136161
patch: if ( iter > 0 )
rank: 705
score: 98.18278503417969
patch: ++ this ;
rank: 706
score: 98.83746892755681
patch: ++ iter ; double f CaMeL Val = true ;
rank: 706
score: 98.77445845170455
patch: return ( Point CaMeL Value CaMeL Pair ) new CaMeL Point CaMeL And CaMeL Direction ( x , x ) ;
rank: 706
score: 98.72809448242188
patch: double [ ] min = f CaMeL Val ;
rank: 706
score: 98.68121337890625
patch: double [ ] x = x ;
rank: 706
score: 98.62217494419643
patch: ++ iter * / * ;
rank: 706
score: 98.52215576171875
patch: / * ++ * /
rank: 706
score: 98.48705037434895
patch: ++ iter ; try ; ++ iter ; ++ iter ;
rank: 706
score: 98.28627232142857
patch: f CaMeL Val += iter ;
rank: 706
score: 98.18062337239583
patch: ++ 1 ; iter ;
rank: 707
score: 98.832568359375
patch: ++ iter ; double f CaMeL Val $NUMBER$ ;
rank: 707
score: 98.81158916766827
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = new CaMeL Point CaMeL And CaMeL Direction ( x , x ) ;
rank: 707
score: 98.77437097886029
patch: return new CaMeL Point CaMeL And CaMeL Direction ( x 1 , x 1 ) ;
rank: 707
score: 98.68012830946181
patch: f CaMeL Val += f CaMeL Val ;
rank: 707
score: 98.6219815340909
patch: if ( iter >= iter ) { ++ iter ;
rank: 707
score: 98.52157253689236
patch: * * * * * ++ * /
rank: 707
score: 98.48681640625
patch: ++ iter ; ++ iter ; ++ 1 ; ;
rank: 707
score: 98.28551228841145
patch: f CaMeL Val ++ ;
rank: 707
score: 98.18046061197917
patch: / ; ++ start ;
rank: 708
score: 98.81093186598558
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val + f CaMeL Val , f CaMeL Val ) ;
rank: 708
score: 98.77435980902777
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair > }
rank: 708
score: 98.72344360351562
patch: double [ ] length = f CaMeL Val ;
rank: 708
score: 98.67962646484375
patch: if ( n > 0 ) {
rank: 708
score: 98.62167358398438
patch: while ( iter < n ; iter ++ ; ) {
rank: 708
score: 98.52140590122768
patch: else { ++ max ; }
rank: 708
score: 98.48676091974431
patch: ++ iter ; ++ 1 ; iter * * /
rank: 708
score: 98.17905680338542
patch: ++ $NUMBER$ = iter ;
rank: 709
score: 98.83039994673295
patch: ++ iter ; double f CaMeL Val = $STRING$ ;
rank: 709
score: 98.81068772536058
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = . new CaMeL Point CaMeL And CaMeL Direction ( line ) ;
rank: 709
score: 98.77401968149039
patch: res = compute CaMeL Objective CaMeL Value ( x $NUMBER$ ) ;
rank: 709
score: 98.62117513020833
patch: return new Point CaMeL Value CaMeL Pair ( iter , ++ iter ) ;
rank: 709
score: 98.52063666449652
patch: if ( iter == iter ; break ;
rank: 709
score: 98.48572887073864
patch: ++ iter ; ++ * * ; * / /
rank: 710
score: 98.82069091796875
patch: double f CaMeL Val $NUMBER$ $NUMBER$ = 0 ;
rank: 710
score: 98.67456732855902
patch: double [ ] f CaMeL Val ++ ;
rank: 710
score: 98.62107340494792
patch: if ( iter <= n ) { ++ iter ; }
rank: 710
score: 98.52044677734375
patch: ++ * * * * / iter ; /
rank: 710
score: 98.48565118963069
patch: ++ iter ; ++ value ; ++ iter ; }
rank: 710
score: 98.28312465122768
patch: while ( ! ++ iter )
rank: 710
score: 98.17604573567708
patch: ++ new ++ ; ;
rank: 711
score: 98.80984061104911
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , x $NUMBER$ ) ) ;
rank: 711
score: 98.77380981445313
patch: result = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , f CaMeL Val ) ;
rank: 711
score: 98.71835327148438
patch: int f CaMeL Val = x ;
rank: 711
score: 98.52037896050348
patch: / * * ; * / * /
rank: 711
score: 98.48515181107955
patch: ++ iter ; ++ iter ; iter ; * /
rank: 711
score: 98.28189522879464
patch: while ( ! ++ n )
rank: 711
score: 98.17594401041667
patch: / ; ++ 0 ;
rank: 712
score: 98.80964006696429
patch: final Point CaMeL Value CaMeL Pair checker = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( direc ;
rank: 712
score: 98.77353922526042
patch: result = new Point CaMeL Value CaMeL Pair ( x 1 , f CaMeL Val ) ;
rank: 712
score: 98.71800537109375
patch: X f CaMeL Val = f CaMeL Val ;
rank: 712
score: 98.67288208007812
patch: double f CaMeL Val = $STRING$ ;
rank: 712
score: 98.62066243489583
patch: ++ iter ; return new Point CaMeL Value CaMeL Pair ( ) ; }
rank: 712
score: 98.51957397460937
patch: if ( iter == null ) break ; }
rank: 712
score: 98.48506303267045
patch: ++ iter ; ++ iter ; } int iter ;
rank: 712
score: 98.28125
patch: while ( false ) { ;
rank: 712
score: 98.17531331380208
patch: ++ iter ; ; /
rank: 713
score: 98.820068359375
patch: ++ iter ; double iter = 0 ;
rank: 713
score: 98.80845424107143
patch: double CaMeL Value = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , compute CaMeL Objective CaMeL Value ( x $NUMBER$ ) ) ;
rank: 713
score: 98.77346962376645
patch: result = Math CaMeL Arrays . copy CaMeL Of ( x 1 , f CaMeL Val ) ;
rank: 713
score: 98.67250279017857
patch: i = f CaMeL Val ;
rank: 713
score: 98.6206298828125
patch: ++ iter ; throw new Runtime CaMeL Exception ( $STRING$ + iter ) ;
rank: 713
score: 98.51791817801339
patch: else { ++ out ; }
rank: 713
score: 98.4831210049716
patch: ++ iter ; ++ - iter ; if iter ;
rank: 713
score: 98.17142740885417
patch: ++ 0 ; iter ;
rank: 714
score: 98.81795654296874
patch: double n = x . clone ( ) ;
rank: 714
score: 98.80810546875
patch: Point CaMeL Value CaMeL Pair checker = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( direc ) ;
rank: 714
score: 98.7734375
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ]
rank: 714
score: 98.7162109375
patch: double f CaMeL Val = n - 1 ;
rank: 714
score: 98.67237854003906
patch: double [ ] x = $STRING$ ;
rank: 714
score: 98.62062766335227
patch: ++ iter ; for ( ; ; ; ) {
rank: 714
score: 98.51738947088069
patch: if ( iter == null ; / * * /
rank: 714
score: 98.4828592936198
patch: ++ iter ; ++ iter ; System . out . ;
rank: 714
score: 98.279541015625
patch: Iterator < ; ++ iter )
rank: 715
score: 98.81456409801136
patch: if ( direc . length > 0 ) {
rank: 715
score: 98.80807834201389
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair extends Point CaMeL Value CaMeL Pair > checker = new Convergence CaMeL Checker ( ) ;
rank: 715
score: 98.77325148809524
patch: return new Point CaMeL Value CaMeL Pair ( Point CaMeL Value CaMeL Pair . x 1 , x ) ;
rank: 715
score: 98.71204833984375
patch: int length = f CaMeL Val . length ;
rank: 715
score: 98.66767713758681
patch: f CaMeL Val = 0 . 0 ;
rank: 715
score: 98.62034505208334
patch: return new Point CaMeL Value CaMeL Pair ( ++ n , iter ) ;
rank: 715
score: 98.51737758091518
patch: ++ * * * * /
rank: 715
score: 98.48281028053977
patch: ++ iter ; iter * * / int iter ;
rank: 715
score: 98.2792256673177
patch: f CaMeL Val -- ;
rank: 715
score: 98.16414388020833
patch: ++ ++ iter ; ;
rank: 716
score: 98.80801827566964
patch: Point CaMeL Value CaMeL Pair checker = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( guess ) ) ;
rank: 716
score: 98.7730712890625
patch: v = Math CaMeL Arrays . copy CaMeL Of ( direc [ 0 ] ) ;
rank: 716
score: 98.711083984375
patch: double x 1 = f CaMeL Val 1 ;
rank: 716
score: 98.66748725043402
patch: int f CaMeL Val = 0 ; {
rank: 716
score: 98.62022986778847
patch: return new Point CaMeL Value CaMeL Pair ( x [ ; }
rank: 716
score: 98.4816385904948
patch: ++ iter ; ++ iter ; ; if ++ iter ;
rank: 716
score: 98.27820841471355
patch: c = ++ n ;
rank: 716
score: 98.16382853190105
patch: ++ iter ; ++ iter
rank: 717
score: 98.77304909446023
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Point CaMeL Value CaMeL Pair . 0 , x ) ;
rank: 717
score: 98.62022181919643
patch: return new Point CaMeL Value CaMeL Pair ( ++ n , n ;
rank: 717
score: 98.5164462002841
patch: Set < Object > iter = iter . start ;
rank: 717
score: 98.48136393229167
patch: ++ iter ; ++ iter ; ++ value ; iter ;
rank: 717
score: 98.27528599330357
patch: pos = iter - iter ;
rank: 717
score: 98.16343180338542
patch: long iter = iter ;
rank: 718
score: 98.80963134765625
patch: if ( f CaMeL Val == $STRING$ ) {
rank: 718
score: 98.80618051382211
patch: double f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . abs ( f CaMeL Val ) ) ;
rank: 718
score: 98.7729259672619
patch: return Point CaMeL Value CaMeL Pair . new CaMeL Point CaMeL And CaMeL Direction ( x , n ) ;
rank: 718
score: 98.70829264322917
patch: double iter 1 = f CaMeL Val ;
rank: 718
score: 98.66259002685547
patch: if ( n == 0 ) {
rank: 718
score: 98.62009102957589
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + x ) ;
rank: 718
score: 98.51632351345486
patch: / * * ++ * * / /
rank: 718
score: 98.48058064778645
patch: / * ++ iter ;
rank: 718
score: 98.27506801060268
patch: ++ iter ; } else {
rank: 718
score: 98.1632792154948
patch: ++ max + iter ;
rank: 719
score: 98.80608661358173
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = Math CaMeL Arrays . value CaMeL Of ( f CaMeL Val ) ;
rank: 719
score: 98.77289373224431
patch: return compute CaMeL Objective CaMeL Value ( start ) ;
rank: 719
score: 98.66173553466797
patch: double [ ] x = true ;
rank: 719
score: 98.61981756036931
patch: ++ iter ; / * ++ iter ; * /
rank: 719
score: 98.51582845052083
patch: try { ++ iter ; } catch ;
rank: 719
score: 98.4805575284091
patch: ++ iter ; ++ iter ; ++ break ; ;
rank: 719
score: 98.27369907924107
patch: j = iter - 1 ;
rank: 719
score: 98.1615702311198
patch: ++ ( ++ 0 ;
rank: 720
score: 98.80697021484374
patch: if ( f CaMeL Val > iter ) {
rank: 720
score: 98.77283653846153
patch: return compute CaMeL Objective CaMeL Value ( x $NUMBER$ ) ; }
rank: 720
score: 98.5157470703125
patch: / * * * * / * ;
rank: 720
score: 98.48008219401042
patch: ++ iter ; ++ iter ; int * int iter ;
rank: 720
score: 98.27335902622768
patch: ++ n ; return iter ;
rank: 720
score: 98.1615702311198
patch: ++ iter ; / /
rank: 721
score: 98.80602416992187
patch: ++ true ; f CaMeL Val = 0 ;
rank: 721
score: 98.80559172453704
patch: Point CaMeL Value CaMeL Pair checker = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( direc [
rank: 721
score: 98.77278645833333
patch: return ( Point CaMeL Value CaMeL Pair ) checker . get CaMeL Point ( x ) ;
rank: 721
score: 98.70367431640625
patch: double [ ] x = line ;
rank: 721
score: 98.65857696533203
patch: double iter = 1 . 1 ;
rank: 721
score: 98.61913045247395
patch: while ( iter < iter ; iter ++ ) { ;
rank: 721
score: 98.51532854352679
patch: * * * ++ iter ;
rank: 721
score: 98.27329508463542
patch: state = ++ n ;
rank: 721
score: 98.15928141276042
patch: if iter * 1 ;
rank: 722
score: 98.80537109375
patch: double f CaMeL Val *= f CaMeL Val ;
rank: 722
score: 98.80490451388889
patch: Point CaMeL Value CaMeL Pair checker = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( direc ;
rank: 722
score: 98.77263077445652
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair )
rank: 722
score: 98.65789116753473
patch: final double x = 0 . 0 ;
rank: 722
score: 98.61908513849431
patch: if ( iter != - 1 ) ++ iter ;
rank: 722
score: 98.51518110795455
patch: if ( iter == null ; return ++ 1 ;
rank: 722
score: 98.47900390625
patch: ++ iter ; ++ * * / for iter ;
rank: 722
score: 98.27211216517857
patch: pos = iter * n ;
rank: 722
score: 98.159033203125
patch: / iter ++ ;
rank: 723
score: 98.804833984375
patch: final double [ ] x 1 = x ;
rank: 723
score: 98.80445014105902
patch: if ( true ) { ++ iter ;
rank: 723
score: 98.77258978949652
patch: return new Point CaMeL Value CaMeL Pair ( Point CaMeL Value CaMeL Pair . this ) ;
rank: 723
score: 98.70210774739583
patch: final double 0 = f CaMeL Val ;
rank: 723
score: 98.65480041503906
patch: double x = 1 . 0 ;
rank: 723
score: 98.6189297762784
patch: ++ iter ; / * * * iter * /
rank: 723
score: 98.51500108506944
patch: if ( iter == null ) return ;
rank: 723
score: 98.47878196022727
patch: ++ iter ; iter ; * / if iter ;
rank: 723
score: 98.27143205915179
patch: ++ iter ; ; try {
rank: 723
score: 98.15402221679688
patch: logger ; ++ iter ;
rank: 724
score: 98.798486328125
patch: double value = x . clone ( ) ;
rank: 724
score: 98.77239379882812
patch: return Point CaMeL Value CaMeL Pair . new CaMeL Point CaMeL And CaMeL Direction ( x 1 ) ;
rank: 724
score: 98.70016479492188
patch: double iter = guess . length ;
rank: 724
score: 98.6189208984375
patch: ++ iter ; throw new Runtime CaMeL Exception ( $STRING$ + n ) ;
rank: 724
score: 98.51426478794643
patch: else ++ iter ; * /
rank: 724
score: 98.47776100852273
patch: ++ 1 ; ++ iter ; ++ iter ; ;
rank: 724
score: 98.27140590122768
patch: while ( ++ iter ) {
rank: 724
score: 98.15068359375
patch: / ++ iter ;
rank: 725
score: 98.79710083007812
patch: if ( f CaMeL Val >= n ) {
rank: 725
score: 98.77217824835526
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Math CaMeL Arrays . copy CaMeL Of (
rank: 725
score: 98.6536865234375
patch: int x 1 = 0 ;
rank: 725
score: 98.61884416852679
patch: ++ iter ; while ( iter >= 0 ) { ++ iter ;
rank: 725
score: 98.51233782087054
patch: ++ * * * ; /
rank: 725
score: 98.47660319010417
patch: ++ iter ; ++ iter ; iter ; if iter ;
rank: 725
score: 98.26988874162946
patch: final int iter = 1 ;
rank: 725
score: 98.15031433105469
patch: ++ true ;
rank: 726
score: 98.80374581473214
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , 0 ) ;
rank: 726
score: 98.77180989583333
patch: return new Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ( x 1 , iter ) ;
rank: 726
score: 98.65311686197917
patch: double f CaMeL Val = 0 1 ;
rank: 726
score: 98.61856282552084
patch: return new Point CaMeL Value CaMeL Pair ( x , x . length ;
rank: 726
score: 98.474365234375
patch: ++ iter ; ++ * / ++ iter ; }
rank: 726
score: 98.26749877929687
patch: if ( ! ;
rank: 727
score: 98.80263846261161
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( Math CaMeL Arrays . copy CaMeL Of ( x 1 , f CaMeL Val ) ) ;
rank: 727
score: 98.79444469105114
patch: int f CaMeL Val = 0 ; ++ iter ;
rank: 727
score: 98.77159534801136
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Point CaMeL Value CaMeL Pair . 1 , x ) ;
rank: 727
score: 98.65296088324652
patch: if ( x < f CaMeL Val )
rank: 727
score: 98.61802571614584
patch: return new Point CaMeL Value CaMeL Pair ( start , iter ) ; }
rank: 727
score: 98.51216634114583
patch: if ( iter != 0 ; break ;
rank: 727
score: 98.47337757457386
patch: / * * ++ * * / ++ iter ;
rank: 727
score: 98.26251220703125
patch: float iter = ++ iter ;
rank: 727
score: 98.14366658528645
patch: ++ ; ++ max ;
rank: 728
score: 98.80235460069444
patch: double [ ] [ ] x 1 ;
rank: 728
score: 98.77158425071023
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair > direc = x ;
rank: 728
score: 98.61777907151442
patch: ++ iter ; if ( iter < n ; ++ iter ;
rank: 728
score: 98.51201714409723
patch: if ( iter < 0 ; / ;
rank: 728
score: 98.4717684659091
patch: ++ iter ; ++ * * ++ iter ; ;
rank: 728
score: 98.2548828125
patch: int iter = ++ n ;
rank: 728
score: 98.1427714029948
patch: ++ iter ; ; *
rank: 729
score: 98.80105154854911
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair > . Point CaMeL Value CaMeL Pair > direc ;
rank: 729
score: 98.77125854492188
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ( checker ) ;
rank: 729
score: 98.65163845486111
patch: if ( 0 == f CaMeL Val )
rank: 729
score: 98.61770833333334
patch: ++ iter ; if ( iter != null ) { ++ iter ; }
rank: 729
score: 98.51198323567708
patch: / * * * ++ * * ;
rank: 729
score: 98.47138006036931
patch: ++ iter ; ++ iter ; ++ break ; }
rank: 729
score: 98.25399780273438
patch: style = ++ iter ;
rank: 729
score: 98.1386210123698
patch: iter iter = iter ;
rank: 730
score: 98.79925537109375
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair > . Point CaMeL Value CaMeL Pair ( x ) ;
rank: 730
score: 98.77086385091145
patch: other = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 730
score: 98.68712615966797
patch: double value = f CaMeL Val ;
rank: 730
score: 98.65098571777344
patch: double [ ] x = false ;
rank: 730
score: 98.6171875
patch: ++ iter ; / * * iter iter * /
rank: 730
score: 98.51184953962054
patch: * * * * ; }
rank: 730
score: 98.47093616832386
patch: ++ iter ; ++ * * iter ; iter ;
rank: 730
score: 98.25394112723214
patch: ++ iter - iter ; ;
rank: 730
score: 98.13772583007812
patch: } ++ ++ iter ;
rank: 731
score: 98.79877263849431
patch: final double [ ] x . clone ( ) ;
rank: 731
score: 98.79294655539773
patch: double f CaMeL Val $NUMBER$ [ ] = 0 ;
rank: 731
score: 98.64887237548828
patch: double iter = $NUMBER$ . 0 ;
rank: 731
score: 98.61703927176339
patch: throw new Runtime CaMeL Exception ( $STRING$ ) ; } ++ n ;
rank: 731
score: 98.5118408203125
patch: else { for ; * /
rank: 731
score: 98.46947132457386
patch: ++ iter ; ++ iter ; ++ * / }
rank: 731
score: 98.25334821428571
patch: f CaMeL Val -= iter ;
rank: 731
score: 98.13728841145833
patch: ++ ; ++ 0 ;
rank: 732
score: 98.7984619140625
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = . new CaMeL Point CaMeL And CaMeL Direction ( relative CaMeL Threshold ) ;
rank: 732
score: 98.77040608723958
patch: result = compute CaMeL Objective CaMeL Value ( x $NUMBER$ ,
rank: 732
score: 98.64834255642361
patch: double [ ] x 1 = $STRING$ ;
rank: 732
score: 98.61622203480114
patch: ++ iter ; if ( iter > iter ) {
rank: 732
score: 98.51182725694444
patch: / * * * ++ * / }
rank: 732
score: 98.4689608487216
patch: / * ++ iter ; / * / / /
rank: 732
score: 98.25272914341518
patch: j = iter * n ;
rank: 732
score: 98.13721720377605
patch: ++ * ++ 0 ;
rank: 733
score: 98.79815673828125
patch: Point CaMeL Value CaMeL Pair checker = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( checker ) ) ;
rank: 733
score: 98.79047185724431
patch: double x $NUMBER$ = x . clone ( ) ;
rank: 733
score: 98.77034912109374
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair ( x ) ;
rank: 733
score: 98.67379324776786
patch: int ++ iter = 0 ;
rank: 733
score: 98.64707946777344
patch: int x = 1 . 0 ;
rank: 733
score: 98.61602783203125
patch: ++ iter ; f CaMeL Val = new double [ n ] ;
rank: 733
score: 98.51179334852431
patch: / * * / * / * /
rank: 733
score: 98.46647135416667
patch: ++ iter ; ++ 1 ; ++ * ++ iter ;
rank: 733
score: 98.25223795572917
patch: if ( ++ n ;
rank: 733
score: 98.13629150390625
patch: ++ iter ; iter try
rank: 734
score: 98.79789677372685
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair > . Point CaMeL Value CaMeL Pair * * ;
rank: 734
score: 98.78582208806819
patch: ++ iter ; double f CaMeL Val = x ;
rank: 734
score: 98.7703167459239
patch: return Point CaMeL Value CaMeL Pair . new CaMeL Point CaMeL And CaMeL Direction ( x , iter , 0 ) ;
rank: 734
score: 98.6156005859375
patch: ++ iter ; while ( iter >= n ) ;
rank: 734
score: 98.5115966796875
patch: else { return false ; }
rank: 734
score: 98.4662753018466
patch: ++ 1 ; ++ iter ; for ++ iter ;
rank: 734
score: 98.251953125
patch: ++ iter ( ) ;
rank: 734
score: 98.13516235351562
patch: ++ iter ; ; }
rank: 735
score: 98.79766845703125
patch: final int x $NUMBER$ = f CaMeL Val ;
rank: 735
score: 98.78482666015626
patch: if ( f CaMeL Val < 1 ) {
rank: 735
score: 98.7702105978261
patch: return new Point CaMeL Value CaMeL Pair ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) ) ;
rank: 735
score: 98.66680908203125
patch: int x $NUMBER$ = f CaMeL Val ;
rank: 735
score: 98.61552211216518
patch: ++ iter ; new Point CaMeL Value CaMeL Pair ( ++ n ;
rank: 735
score: 98.51158311631944
patch: if ( iter < 0 ) break ;
rank: 735
score: 98.46608479817708
patch: i ; ++ iter ;
rank: 735
score: 98.24720982142857
patch: while ( iter >= iter )
rank: 735
score: 98.12705078125
patch: ; ++ iter ;
rank: 736
score: 98.79756469726563
patch: int iter = guess . clone ( ) ;
rank: 736
score: 98.77016813858695
patch: Iterator < Point CaMeL Value CaMeL Pair , Univariate CaMeL Point CaMeL Value CaMeL Pair . double CaMeL Value ( ) ;
rank: 736
score: 98.66448974609375
patch: double -- iter = f CaMeL Val ;
rank: 736
score: 98.64550103081598
patch: if ( n <= f CaMeL Val )
rank: 736
score: 98.61551339285714
patch: ++ iter ; throw new Runtime CaMeL Exception ( $STRING$ + iter ;
rank: 736
score: 98.51142713758681
patch: / * ++ * * * * /
rank: 736
score: 98.46480712890624
patch: int iter ++ ;
rank: 736
score: 98.24710083007812
patch: j = ++ iter ;
rank: 736
score: 98.11729736328125
patch: if iter ++ ;
rank: 737
score: 98.78413696289063
patch: double f CaMeL Val $NUMBER$ 1 = 0 ;
rank: 737
score: 98.77005343967014
patch: Iterator < Point CaMeL Value CaMeL Pair < Univariate CaMeL Point CaMeL Value CaMeL Pair > }
rank: 737
score: 98.64543999565973
patch: double [ ] x 1 = true ;
rank: 737
score: 98.61487630208333
patch: int n = Integer . parse CaMeL Int ( x , n ) ;
rank: 737
score: 98.51089913504464
patch: ++ * 0 . 0 ;
rank: 737
score: 98.46341959635417
patch: ++ iter ; if iter + iter ; ++ iter ;
rank: 737
score: 98.24676513671875
patch: ++ n ; try {
rank: 737
score: 98.11236572265625
patch: / ; iter
rank: 738
score: 98.76967210036058
patch: Iterator < Point CaMeL Value CaMeL Pair > n = 0 ;
rank: 738
score: 98.64536539713542
patch: double [ ] x 1 = false ;
rank: 738
score: 98.6148681640625
patch: ++ iter ; if ( iter < n && ;
rank: 738
score: 98.46312459309895
patch: / * ] iter ; / / / / / /
rank: 738
score: 98.11034545898437
patch: } iter ++ ;
rank: 739
score: 98.79700816761364
patch: int x 1 [ ] = f CaMeL Val ;
rank: 739
score: 98.76870388454861
patch: list = new CaMeL Point CaMeL And CaMeL Direction ( x , f CaMeL Val ) ;
rank: 739
score: 98.66174994574652
patch: double n $NUMBER$ = f CaMeL Val ;
rank: 739
score: 98.51014055524554
patch: if ++ [ 1 ] ;
rank: 739
score: 98.46229137073864
patch: ++ iter ; ++ iter ; iter * / /
rank: 739
score: 98.24554443359375
patch: key = ++ n ;
rank: 739
score: 98.10350952148437
patch: iter else ++ ;
rank: 740
score: 98.76820439877717
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair < Univariate CaMeL Point CaMeL Value CaMeL Pair > iter = null ;
rank: 740
score: 98.6588134765625
patch: Convergence CaMeL Checker < double [ ] ;
rank: 740
score: 98.64147271050348
patch: double [ ] f CaMeL Val = (
rank: 740
score: 98.614208984375
patch: return new Point CaMeL Value CaMeL Pair ( x , ++ n ) ;
rank: 740
score: 98.5100830078125
patch: if ( iter < 0 ) return iter ;
rank: 740
score: 98.4617919921875
patch: else * ++ iter ; / * * / /
rank: 740
score: 98.24396623883929
patch: ++ iter [ iter ] ;
rank: 740
score: 98.09371948242188
patch: ++ n ; ;
rank: 741
score: 98.79595392400569
patch: d = line . search ( x $NUMBER$ ) ;
rank: 741
score: 98.76780007102273
patch: int f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( x 1 , f CaMeL Val ) ;
rank: 741
score: 98.63981410435268
patch: double f CaMeL Val ++ ;
rank: 741
score: 98.5097412109375
patch: / * * /
rank: 741
score: 98.46120198567708
patch: / * ; ++ iter ; * / ++ iter ;
rank: 741
score: 98.23956298828125
patch: r = ++ iter ;
rank: 741
score: 98.09158325195312
patch: ++ Math ;
rank: 742
score: 98.79567173549107
patch: final Point CaMeL Value CaMeL Pair checker = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( direc [
rank: 742
score: 98.76768275669643
patch: return new CaMeL Point CaMeL And CaMeL Direction ( new CaMeL Point CaMeL And CaMeL Direction ( x 1 ,
rank: 742
score: 98.65565321180556
patch: final double f CaMeL Val = n ;
rank: 742
score: 98.61419208233173
patch: ++ iter ; if ( iter == null ) ++ iter ;
rank: 742
score: 98.5096102627841
patch: else { break ; } } if ++ iter ;
rank: 742
score: 98.46115112304688
patch: / ++ ++ iter ;
rank: 742
score: 98.23927815755208
patch: float iter = iter ;
rank: 742
score: 98.08184814453125
patch: iter iter
rank: 743
score: 98.76767985026042
patch: retval = compute CaMeL Objective CaMeL Value ( x ) ;
rank: 743
score: 98.65420193142361
patch: final double max = f CaMeL Val ;
rank: 743
score: 98.63261413574219
patch: float f CaMeL Val = 0 ;
rank: 743
score: 98.61341145833333
patch: return new Point CaMeL Value CaMeL Pair ( ++ iter , iter ; }
rank: 743
score: 98.50960083007813
patch: / * * / * / ++ iter ;
rank: 743
score: 98.4608487215909
patch: ++ iter ; ++ * * * ++ iter ;
rank: 743
score: 98.23780168805804
patch: synchronized ( ++ n ) {
rank: 743
score: 98.0699951171875
patch: ++ ++ n ;
rank: 744
score: 98.7674091045673
patch: Iterator < Univariate CaMeL Point CaMeL Value CaMeL Pair > iter ;
rank: 744
score: 98.65343560112848
patch: final double name = f CaMeL Val ;
rank: 744
score: 98.62642124720982
patch: double [ ] x = (
rank: 744
score: 98.61337716238839
patch: return new Point CaMeL Value CaMeL Pair ( ; } ++ n ;
rank: 744
score: 98.509521484375
patch: / * * ; ++ * * /
rank: 744
score: 98.4599276455966
patch: ++ * ] iter ; * / int iter ;
rank: 744
score: 98.23700823102679
patch: if ( iter <= n )
rank: 744
score: 98.06669616699219
patch: throw iter ;
rank: 745
score: 98.79372829861111
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , n ) ) ;
rank: 745
score: 98.76927601207386
patch: i ++ ; double f CaMeL Val = 0 ;
rank: 745
score: 98.7672809103261
patch: return new Point CaMeL Value CaMeL Pair ( Math CaMeL Arrays . copy CaMeL Of ( x ) , x ) ;
rank: 745
score: 98.61337716238839
patch: ++ iter ; while ( iter != 0 ) { ++ iter ;
rank: 745
score: 98.509521484375
patch: else { / * * / / }
rank: 745
score: 98.45906205610795
patch: ++ iter ; ++ value ; ++ iter ; ;
rank: 745
score: 98.23638916015625
patch: pos = - 1 ;
rank: 745
score: 98.05522918701172
patch: ++ name ;
rank: 746
score: 98.7674893465909
patch: if ( f CaMeL Val > - 1 ) {
rank: 746
score: 98.76621942934783
patch: Iterator < Point CaMeL Value CaMeL Pair , Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair )
rank: 746
score: 98.6474609375
patch: final int start = f CaMeL Val ;
rank: 746
score: 98.62171088324652
patch: int f CaMeL Val = direc ;
rank: 746
score: 98.61318734975961
patch: long start = Double . MAX _ VALUE ; if ( ;
rank: 746
score: 98.50880940755208
patch: else { if ; iter ++ ; }
rank: 746
score: 98.45875133167614
patch: ++ iter ; iter ; / / * / /
rank: 746
score: 98.2347412109375
patch: if ( n < n )
rank: 746
score: 98.04505920410156
patch: ++ list ;
rank: 747
score: 98.79295131138393
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair > . Point CaMeL Value CaMeL Pair ( x 1 ,
rank: 747
score: 98.7662109375
patch: if ( f CaMeL Val >= 0 ) {
rank: 747
score: 98.76600713315217
patch: Iterator < Point CaMeL Value CaMeL Pair protected Univariate CaMeL Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair >
rank: 747
score: 98.64641655815973
patch: double iter = f CaMeL Val ) ;
rank: 747
score: 98.61475372314453
patch: double [ ] f CaMeL Val ;
rank: 747
score: 98.61284845525569
patch: ++ iter ; / * * * * * /
rank: 747
score: 98.50863647460938
patch: / * * * ; / ++ iter ;
rank: 747
score: 98.4581298828125
patch: ++ iter ; if iter + 0 ; ++ iter ;
rank: 747
score: 98.23316301618304
patch: ++ iter ; try { ;
rank: 747
score: 98.04335327148438
patch: ++ ! iter ;
rank: 748
score: 98.76596467391305
patch: result = new CaMeL Point CaMeL And CaMeL Direction ( Point CaMeL Value CaMeL Pair . line . search ( x ,
rank: 748
score: 98.76414794921875
patch: double f CaMeL Val - f CaMeL Val ;
rank: 748
score: 98.64493815104167
patch: double start = 0 ;
rank: 748
score: 98.61264870383523
patch: ++ iter ; * / * * * * /
rank: 748
score: 98.50859375
patch: else { iter += iter + iter ; }
rank: 748
score: 98.45789683948864
patch: ++ iter ; ++ iter ; int iter ; }
rank: 748
score: 98.23169962565105
patch: ++ n + 1 ;
rank: 748
score: 98.03623962402344
patch: iter iter ;
rank: 749
score: 98.79214041573661
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) , x $NUMBER$ ) ;
rank: 749
score: 98.76582475142045
patch: return new Point CaMeL Value CaMeL Pair ( Point CaMeL Value CaMeL Pair . 1 , f CaMeL Val ) ;
rank: 749
score: 98.7637451171875
patch: double f CaMeL Val 1 1 = 0 ;
rank: 749
score: 98.61241048177084
patch: ++ iter ; throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + ;
rank: 749
score: 98.60670471191406
patch: int f CaMeL Val = true ;
rank: 749
score: 98.50819227430556
patch: ++ * * * * ; * /
rank: 749
score: 98.457275390625
patch: / * ++ ++ * / / ++ iter ;
rank: 749
score: 98.23128255208333
patch: clazz = ++ iter ;
rank: 749
score: 98.03434448242187
patch: ++ 0 ; ;
rank: 750
score: 98.79123360770089
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , x 1 ) ) ;
rank: 750
score: 98.76090864701705
patch: Iterator < Point CaMeL Value CaMeL Pair . Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair > }
rank: 750
score: 98.6120849609375
patch: ++ iter ; double f CaMeL Val = Double . parse CaMeL Double ;
rank: 750
score: 98.507568359375
patch: if ( iter < n ; * /
rank: 750
score: 98.23043387276786
patch: if ( ! ++ iter ;
rank: 750
score: 98.03202056884766
patch: if iter ;
rank: 751
score: 98.79106083622685
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( Math CaMeL Arrays . copy CaMeL Of ( direc [ 0 ] ) ) ;
rank: 751
score: 98.76295776367188
patch: double f CaMeL Val 1 $NUMBER$ = 0 ;
rank: 751
score: 98.61160278320312
patch: ++ iter ; if ( iter < $NUMBER$ ) break ;
rank: 751
score: 98.60140991210938
patch: double [ ] start = 0 ;
rank: 751
score: 98.50750054253473
patch: * * * * / / * /
rank: 751
score: 98.45705344460227
patch: ++ * ++ iter ; * / int iter ;
rank: 751
score: 98.23008510044643
patch: pos = iter - 1 ;
rank: 751
score: 98.028564453125
patch: throw iter ; ;
rank: 752
score: 98.79021661931819
patch: double iter = x . search ( x ) ;
rank: 752
score: 98.75452880859375
patch: Node f CaMeL Val = f CaMeL Val ;
rank: 752
score: 98.6115966796875
patch: ++ iter ; while ( iter < n ; ++ iter ) { ;
rank: 752
score: 98.50724653764205
patch: if ( iter == 0 ; return false ; }
rank: 752
score: 98.4569979580966
patch: ++ iter ; ++ iter ; int - 1 ;
rank: 753
score: 98.7897616299716
patch: d = line . search ( x 1 ) ;
rank: 753
score: 98.75994262695312
patch: double max = x . clone ( ) ;
rank: 753
score: 98.74815063476562
patch: check CaMeL Parameters ( f CaMeL Val ) ;
rank: 753
score: 98.63770887586806
patch: final double 1 = f CaMeL Val ;
rank: 753
score: 98.59883335658482
patch: double x 1 = 0 ;
rank: 753
score: 98.45615456321023
patch: / * ] iter ; / / / * /
rank: 753
score: 98.22913469587054
patch: ++ iter ; ; if ;
rank: 753
score: 98.01343994140625
patch: iter } ++ ;
rank: 754
score: 98.78964120370371
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = . new CaMeL Point CaMeL And CaMeL Direction ( x $NUMBER$ ) ;
rank: 754
score: 98.75901285807292
patch: double double f CaMeL Val = 0 ;
rank: 754
score: 98.74565294053819
patch: iter = x . clone ( ) ;
rank: 754
score: 98.6111328125
patch: return new Point CaMeL Value CaMeL Pair ( ++ iter , iter , ;
rank: 754
score: 98.59400177001953
patch: final double f CaMeL Val ++ ;
rank: 754
score: 98.5069580078125
patch: } { if ++ iter ;
rank: 754
score: 98.45576615767045
patch: ++ value ; ++ iter ; ++ iter ; ;
rank: 754
score: 98.22823079427083
patch: cl = ++ n ;
rank: 754
score: 98.01204223632813
patch: ++ 1 ; ;
rank: 755
score: 98.73369806463069
patch: Iterator < Point CaMeL Value CaMeL Pair > do {
rank: 755
score: 98.61080932617188
patch: ++ iter ; f CaMeL Val [ n ] = ;
rank: 755
score: 98.506884765625
patch: else { iter * * * / } /
rank: 755
score: 98.45538330078125
patch: / * * ++ * * / / ++ iter ;
rank: 755
score: 98.22796630859375
patch: ++ n ; if ( ;
rank: 755
score: 97.99769287109375
patch: ++ max ++ ;
rank: 756
score: 98.6314926147461
patch: double f CaMeL Val = line ;
rank: 756
score: 98.58907645089286
patch: if ( n == 0 )
rank: 756
score: 98.50684950086806
patch: if ( [ 0 ] != null ;
rank: 756
score: 98.4547452059659
patch: ++ iter ; ++ * * ; / iter ;
rank: 756
score: 97.99327392578125
patch: ++ -- 1 ;
rank: 757
score: 98.74990844726562
patch: double f CaMeL Val = 0 - 0 ;
rank: 757
score: 98.63134765625
patch: int start = f CaMeL Val ;
rank: 757
score: 98.6104736328125
patch: throw new Runtime CaMeL Exception ( $STRING$ + n ; }
rank: 757
score: 98.58795166015625
patch: int [ ] x = guess ;
rank: 757
score: 98.50680541992188
patch: else { * * * * * / }
rank: 757
score: 98.2264912923177
patch: ++ iter * n ;
rank: 757
score: 97.99295654296876
patch: ++ < iter ;
rank: 758
score: 98.74989624023438
patch: double f CaMeL Val = search . length ;
rank: 758
score: 98.72446511008523
patch: Iterator < Point CaMeL Value CaMeL Pair > -- ;
rank: 758
score: 98.63007269965277
patch: final double f CaMeL Val = false ;
rank: 758
score: 98.6100323016827
patch: return new Point CaMeL Value CaMeL Pair ( x , ; ;
rank: 758
score: 98.58568572998047
patch: double [ ] 0 = 0 ;
rank: 758
score: 98.50654820033482
patch: * * * * ; /
rank: 758
score: 98.45450846354167
patch: / * ++ iter ; ++ iter ; ++ iter ;
rank: 758
score: 98.2250264485677
patch: pos = ++ iter ;
rank: 758
score: 97.98990478515626
patch: ++ ++ 0 ;
rank: 759
score: 98.78681291852679
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = Math CaMeL Arrays . copy CaMeL Of ( direc [ iter ] ) ;
rank: 759
score: 98.74962022569444
patch: ++ int f CaMeL Val = 0 ;
rank: 759
score: 98.72423206676136
patch: return compute CaMeL Objective CaMeL Value ( 0 ) ;
rank: 759
score: 98.62836371527777
patch: final String x = f CaMeL Val ;
rank: 759
score: 98.60975748697916
patch: return new Point CaMeL Value CaMeL Pair ( x [ iter ] , ;
rank: 759
score: 98.58538818359375
patch: int [ ] x = $NUMBER$ ;
rank: 759
score: 98.50635375976563
patch: if ( iter > 0 ; break ; }
rank: 759
score: 98.45448811848958
patch: ++ iter ; ++ iter ; ++ * * / /
rank: 759
score: 98.22501918247768
patch: j = iter * iter ;
rank: 759
score: 97.98875122070312
patch: iter if ++ ;
rank: 760
score: 98.78658040364583
patch: final double [ ] x = guess ;
rank: 760
score: 98.72169325086806
patch: y = x . clone ( ) ;
rank: 760
score: 98.62623814174107
patch: final double x = 0 ;
rank: 760
score: 98.60973103841145
patch: ++ iter * / ;
rank: 760
score: 98.50542534722223
patch: else { * * * ; * /
rank: 760
score: 98.45433553059895
patch: ++ iter ; ++ * - iter ; ++ iter ;
rank: 760
score: 98.22482735770089
patch: org . ; ++ iter ;
rank: 760
score: 97.98677978515624
patch: public ++ iter ;
rank: 761
score: 98.78584428267045
patch: double [ ] x 1 = x . search (
rank: 761
score: 98.72060818142361
patch: n = x . clone ( ) ;
rank: 761
score: 98.62499237060547
patch: int f CaMeL Val = n ;
rank: 761
score: 98.60963657924107
patch: return new Point CaMeL Value CaMeL Pair ( this , ++ n ;
rank: 761
score: 98.582763671875
patch: if ( n > 0 )
rank: 761
score: 98.50486061789773
patch: } if ( iter == 0 ; return iter ;
rank: 761
score: 98.45416259765625
patch: ++ * * ++ iter ; / / ++ iter ;
rank: 761
score: 98.22393798828125
patch: ret = ++ iter ;
rank: 761
score: 97.9810791015625
patch: ++ length ;
rank: 762
score: 98.78582208806819
patch: final double [ ] f CaMeL Val = 1 ;
rank: 762
score: 98.71970436789773
patch: return compute CaMeL Objective CaMeL Value ( x $NUMBER$ ,
rank: 762
score: 98.62030792236328
patch: double 0 = f CaMeL Val ;
rank: 762
score: 98.609423828125
patch: return new Point CaMeL Value CaMeL Pair ( x , ++ iter ; }
rank: 762
score: 98.58201599121094
patch: int f CaMeL Val = $STRING$ ;
rank: 762
score: 98.50446111505681
patch: if ( iter != null ; return iter ; ;
rank: 762
score: 98.45384632457386
patch: ++ iter ; iter * * / if iter ;
rank: 762
score: 98.22310965401786
patch: float f CaMeL Val = ;
rank: 762
score: 97.97861328125
patch: { ++ iter ;
rank: 763
score: 98.71947132457386
patch: return compute CaMeL Objective CaMeL Value ( iter ) ;
rank: 763
score: 98.60907389322917
patch: return new Point CaMeL Value CaMeL Pair ( ++ n , x ; }
rank: 763
score: 98.50438581194196
patch: else ; ++ iter ; }
rank: 763
score: 98.45334879557292
patch: / * ++ iter ; * / / ++ iter ;
rank: 763
score: 98.22187151227679
patch: ++ iter ; ++ iter )
rank: 763
score: 97.97737426757813
patch: ++ iter ; try
rank: 764
score: 98.78504527698864
patch: double [ ] x 1 = relative CaMeL Threshold ;
rank: 764
score: 98.71607666015625
patch: if ( iter < direc . length )
rank: 764
score: 98.61688910590277
patch: double ++ iter = relative CaMeL Threshold ;
rank: 764
score: 98.60843912760417
patch: ++ iter ; new Point CaMeL Value CaMeL Pair ( iter , x ;
rank: 764
score: 98.57481384277344
patch: int f CaMeL Val = false ;
rank: 764
score: 98.504150390625
patch: else { if iter * 0 . 0 ; }
rank: 764
score: 98.4530537923177
patch: i * ++ ; / * * / ++ iter ;
rank: 764
score: 98.2208964029948
patch: ++ iter ; final ;
rank: 764
score: 97.96595458984375
patch: * ++ iter ;
rank: 765
score: 98.78326416015625
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair > . Point CaMeL Value CaMeL Pair ( checker ) ;
rank: 765
score: 98.7310791015625
patch: int f CaMeL Val 1 = 0 ;
rank: 765
score: 98.7144775390625
patch: if ( iter Point CaMeL Value CaMeL Pair ) {
rank: 765
score: 98.61629231770833
patch: double x = 0 ;
rank: 765
score: 98.60841471354166
patch: return new Point CaMeL Value CaMeL Pair ( x [ iter ] ; }
rank: 765
score: 98.57403564453125
patch: int n = 0 ;
rank: 765
score: 98.5036376953125
patch: / * * * ++ ; ++ iter ;
rank: 765
score: 98.45297241210938
patch: / * * ++ iter * / / ++ iter ;
rank: 765
score: 98.217919921875
patch: int n = ;
rank: 765
score: 97.94406127929688
patch: ++ super ;
rank: 766
score: 98.7831039428711
patch: final Convergence CaMeL Checker ( ) ;
rank: 766
score: 98.71287231445312
patch: y 1 = x . clone ( ) ;
rank: 766
score: 98.61400604248047
patch: if ( 0 < n ) {
rank: 766
score: 98.60788399832589
patch: ++ iter ; if ( iter < n ; ++ iter ) {
rank: 766
score: 98.57391357421875
patch: final double f CaMeL Val = (
rank: 766
score: 98.50360979352679
patch: else if ++ iter ; }
rank: 766
score: 98.45245361328125
patch: ++ iter ; ++ * ++ iter ; ++ iter ;
rank: 766
score: 98.21602376302083
patch: this . ++ iter ;
rank: 766
score: 97.94375
patch: ++ iter ; ++
rank: 767
score: 98.78309326171875
patch: final double iter 1 = f CaMeL Val ;
rank: 767
score: 98.72677612304688
patch: if ( n < 0 ) {
rank: 767
score: 98.60780436197916
patch: ++ iter ; return new Point CaMeL Value CaMeL Pair ( ; ; }
rank: 767
score: 98.57316371372768
patch: while ( true ) { {
rank: 767
score: 98.50336248224431
patch: Iterator < Integer > iter = iter . max ;
rank: 767
score: 98.45219282670455
patch: ++ iter ; ++ iter ; for ++ * /
rank: 767
score: 98.21546282087054
patch: if ( iter != 0 )
rank: 767
score: 97.93787231445313
patch: iter ++ ; ;
rank: 768
score: 98.78168596540179
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val ) , x 1 ) ;
rank: 768
score: 98.72476535373264
patch: while ( ! f CaMeL Val ) {
rank: 768
score: 98.71039496527777
patch: return do CaMeL Optimize ( x ) ;
rank: 768
score: 98.60975477430556
patch: final double $NUMBER$ = f CaMeL Val ;
rank: 768
score: 98.60776192801339
patch: ++ iter ; if ( iter < n ) { break ; }
rank: 768
score: 98.50316162109375
patch: * * * * / ++ iter ; }
rank: 768
score: 98.4520772298177
patch: / * ++ iter ; ++ * / ++ iter ;
rank: 768
score: 98.21136474609375
patch: synchronized ( ++ iter )
rank: 768
score: 97.92975616455078
patch: ++ iter .
rank: 769
score: 98.78118896484375
patch: d = f CaMeL Val ;
rank: 769
score: 98.70997203480114
patch: result = new CaMeL Point CaMeL And CaMeL Direction (
rank: 769
score: 98.60807291666667
patch: double f CaMeL Val ;
rank: 769
score: 98.60667317708334
patch: int n = Double . MAX _ VALUE ; while ( true ) {
rank: 769
score: 98.50285121372768
patch: if ++ iter ; * /
rank: 769
score: 98.45200417258523
patch: / * ] iter ; * / int iter ;
rank: 769
score: 98.21071951729911
patch: int iter = - 1 ;
rank: 770
score: 98.7809814453125
patch: Point CaMeL Value CaMeL Pair checker = null ;
rank: 770
score: 98.70655059814453
patch: return line . clone ( ) ;
rank: 770
score: 98.6066425030048
patch: throw new Unsupported CaMeL Operation CaMeL Exception ( $STRING$ ) ; ;
rank: 770
score: 98.56294250488281
patch: int x = 0 . 0 ;
rank: 770
score: 98.50188337053571
patch: if ( iter == iter ;
rank: 770
score: 98.4517822265625
patch: ++ iter ; ++ * * int / iter ;
rank: 770
score: 98.21037946428571
patch: while ( iter <= iter )
rank: 770
score: 97.90888061523438
patch: ++ - n ;
rank: 771
score: 98.7803622159091
patch: final double [ ] f CaMeL Val = $NUMBER$ ;
rank: 771
score: 98.60631385216347
patch: return new Point CaMeL Value CaMeL Pair ( x [ iter ;
rank: 771
score: 98.60604519314236
patch: double [ ] x 1 = line ;
rank: 771
score: 98.56219482421875
patch: double f CaMeL Val += 0 ;
rank: 771
score: 98.50170026506696
patch: if ++ * iter ; }
rank: 771
score: 98.45164905894886
patch: ++ iter ; / * * ++ * / /
rank: 771
score: 98.20963541666667
patch: iter = ++ n ;
rank: 771
score: 97.90086364746094
patch: int iter ;
rank: 772
score: 98.78014264787946
patch: f CaMeL Val = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , compute CaMeL Objective CaMeL Value ( x 1 ) ) ;
rank: 772
score: 98.7052490234375
patch: if ( true )
rank: 772
score: 98.60609654017857
patch: return new Point CaMeL Value CaMeL Pair ( x , x , ;
rank: 772
score: 98.60222625732422
patch: double [ ] n = 0 ;
rank: 772
score: 98.50102015904018
patch: ++ [ ] ++ iter ;
rank: 772
score: 98.45154825846355
patch: ++ iter ; ++ 1 ; ++ iter ; iter ;
rank: 772
score: 98.20938546316964
patch: long n = ++ n ;
rank: 772
score: 97.89007568359375
patch: ++ iter ++ ;
rank: 773
score: 98.778564453125
patch: Point CaMeL Value CaMeL Pair checker = Math CaMeL Arrays . copy CaMeL Of ( Math CaMeL Arrays . copy CaMeL Of ( direc ) ,
rank: 773
score: 98.70895046657986
patch: d = line . clone ( ) ;
rank: 773
score: 98.60569545200893
patch: ++ iter ; int n = Double . MAX _ VALUE ; ;
rank: 773
score: 98.56026785714286
patch: delta = f CaMeL Val ;
rank: 773
score: 98.50004272460937
patch: else { ( iter * 0 . 0 ;
rank: 773
score: 98.45143821022727
patch: ++ iter ; ++ * * / * / /
rank: 773
score: 98.20889282226562
patch: do { ++ iter ;
rank: 773
score: 97.86858367919922
patch: ++ false ;
rank: 774
score: 98.77853829520089
patch: final Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair < Point CaMeL Value CaMeL Pair > . Point CaMeL Value CaMeL Pair ( line ) ;
rank: 774
score: 98.702783203125
patch: instanceof Univariate CaMeL Point CaMeL Value CaMeL Pair )
rank: 774
score: 98.6053466796875
patch: ++ iter ; while ( ! iter . is CaMeL Empty ( ) ;
rank: 774
score: 98.59979926215277
patch: double iter = f CaMeL Val 1 ;
rank: 774
score: 98.49850899832589
patch: else { * * / }
rank: 774
score: 98.45116077769886
patch: ++ 1 ; ++ iter ; iter * * /
rank: 774
score: 98.20859200613839
patch: long n = ++ iter ;
rank: 774
score: 97.85855102539062
patch: ++ $NUMBER$ ; ;
rank: 775
score: 98.77811104910714
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = Math CaMeL Arrays . copy CaMeL Of ( direc [ n ] ) ;
rank: 775
score: 98.60512288411458
patch: ++ iter ; double f CaMeL Val = ++ iter ;
rank: 775
score: 98.59935167100694
patch: if ( ! relative CaMeL Threshold ) {
rank: 775
score: 98.55640411376953
patch: if ( n != 0 ) {
rank: 775
score: 98.49828229631696
patch: / * ; * / }
rank: 775
score: 98.4511006673177
patch: ++ iter ; ++ * * ++ / ++ iter ;
rank: 775
score: 98.20827229817708
patch: if ( ++ iter ;
rank: 775
score: 97.8580078125
patch: ++ - 0 ;
rank: 776
score: 98.77785818917411
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = Math CaMeL Arrays . copy CaMeL Of ( direc , x $NUMBER$ ) ;
rank: 776
score: 98.60491536458333
patch: return new Point CaMeL Value CaMeL Pair ( x , n , x ;
rank: 776
score: 98.498046875
patch: else { ++ iter ; } / * /
rank: 776
score: 98.45053100585938
patch: ++ iter ; ++ * * iter ; ++ iter ;
rank: 776
score: 98.20819963727679
patch: ++ iter [ n ] ;
rank: 776
score: 97.85092163085938
patch: ++ ++ $NUMBER$ ;
rank: 777
score: 98.69705200195312
patch: ++ iter ; { ++ iter ;
rank: 777
score: 98.69389038085937
patch: int iter = f CaMeL Val . length ;
rank: 777
score: 98.60470145089286
patch: ++ iter ; double iter ;
rank: 777
score: 98.49786931818181
patch: if ( iter == 0 ; return iter ; ;
rank: 777
score: 98.4502840909091
patch: / * ++ iter ; / / / / ;
rank: 777
score: 98.20409138997395
patch: ++ iter ; do {
rank: 777
score: 97.84889526367188
patch: ++ x 1 ;
rank: 778
score: 98.69197082519531
patch: if ( goal == null ) {
rank: 778
score: 98.69183349609375
patch: y 1 = f CaMeL Val ;
rank: 778
score: 98.60440499441964
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + ++ iter ;
rank: 778
score: 98.55377197265625
patch: int [ ] x = 1 ;
rank: 778
score: 98.49769897460938
patch: else { * * * * / * /
rank: 778
score: 98.4498291015625
patch: ++ iter ; ++ * * / * ++ iter ;
rank: 778
score: 98.20404052734375
patch: in = ++ iter ;
rank: 778
score: 97.842822265625
patch: / ; iter ;
rank: 779
score: 98.69036865234375
patch: return compute CaMeL Objective CaMeL Value ( x ;
rank: 779
score: 98.6884765625
patch: if ( iter < 0 ) {
rank: 779
score: 98.60401204427083
patch: throw new Unsupported CaMeL Operation CaMeL Exception ( $STRING$ + n ) ; }
rank: 779
score: 98.59051513671875
patch: double iter = 1 ;
rank: 779
score: 98.55376434326172
patch: ++ [ ] x = 0 ;
rank: 779
score: 98.44960715553977
patch: / * ++ iter ; * / int iter ;
rank: 779
score: 98.20386614118304
patch: while ( n < iter )
rank: 779
score: 97.83969116210938
patch: return ++ iter ;
rank: 780
score: 98.77592250279018
patch: f CaMeL Val = compute CaMeL Objective CaMeL Value ( Math CaMeL Arrays . copy CaMeL Of ( direc , f CaMeL Val ) ) ;
rank: 780
score: 98.68801047585227
patch: return compute CaMeL Objective CaMeL Value ( n ) ;
rank: 780
score: 98.6039794921875
patch: ++ iter ; return new Point CaMeL Value CaMeL Pair ( n ) ;
rank: 780
score: 98.55354309082031
patch: boolean stop = 1 . 0 ;
rank: 780
score: 98.4947176846591
patch: if ( iter == 0 ; return ++ iter ;
rank: 780
score: 98.44944069602273
patch: ++ iter ; iter ; int - * / /
rank: 780
score: 98.19989885602679
patch: while ( iter == 1 )
rank: 780
score: 97.83667755126953
patch: ++ out ;
rank: 781
score: 98.77481515066964
patch: Convergence CaMeL Checker < Point CaMeL Value CaMeL Pair > checker = Math CaMeL Arrays . copy CaMeL Of ( f CaMeL Val , 1 ) ;
rank: 781
score: 98.68540445963542
patch: d = x . clone ( ) ;
rank: 781
score: 98.67644653320312
patch: Iterator <= Point CaMeL Value CaMeL Pair ) {
rank: 781
score: 98.6037841796875
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + ++ iter ) ;
rank: 781
score: 98.58605085100446
patch: final double start = 0 ;
rank: 781
score: 98.55115509033203
patch: if ( checker == null ) {
rank: 781
score: 98.494189453125
patch: Set < ? > iter = iter . ;
rank: 781
score: 98.44940185546875
patch: ++ iter ; ++ * / ++ iter ; iter ;
rank: 781
score: 98.1970723470052
patch: ++ iter ; return ;
rank: 781
score: 97.8341293334961
patch: ++ iterator ;
rank: 782
score: 98.67631225585937
patch: int f CaMeL Val = Math . 0 ;
rank: 782
score: 98.60317993164062
patch: ++ iter ; ; while ( iter < n ) {
rank: 782
score: 98.49415283203125
patch: if ( iter == null ; throw null ;
rank: 782
score: 98.44825236002605
patch: ++ ] ++ iter ;
rank: 782
score: 98.1961669921875
patch: double n = iter ;
rank: 782
score: 97.83203125
patch: } ++ n ;
rank: 783
score: 98.60305989583334
patch: ++ iter ; if ( iter < iter ) { ++ iter ; }
rank: 783
score: 98.55010986328125
patch: if ( n <= n ) {
rank: 783
score: 98.4935635653409
patch: if ( iter == null ) throw null ; }
rank: 783
score: 98.44630940755208
patch: / * ] iter ; / / * / / /
rank: 783
score: 97.82713623046875
patch: ++ 1 ; iter
rank: 784
score: 98.77333762428977
patch: final double [ ] x 1 = x $NUMBER$ ;
rank: 784
score: 98.67530653211806
patch: double f CaMeL Val $NUMBER$ = x ;
rank: 784
score: 98.6692138671875
patch: super . do CaMeL Optimize ( x ) ;
rank: 784
score: 98.60294015066964
patch: ++ iter ; if ( iter != - 1 ) ++ iter ;
rank: 784
score: 98.54804229736328
patch: double [ ] x = n ;
rank: 784
score: 98.493505859375
patch: if ( iter == null ; return $NUMBER$ ;
rank: 784
score: 98.4462890625
patch: ++ * ] iter ; / / * / /
rank: 784
score: 97.82561645507812
patch: ++ max ; ;
rank: 785
score: 98.66764526367187
patch: y $NUMBER$ = x . clone ( ) ;
rank: 785
score: 98.60288492838542
patch: while ( iter < iter ) { ++ iter ; }
rank: 785
score: 98.57481384277344
patch: final double x 1 = 0 ;
rank: 785
score: 98.54757690429688
patch: double f CaMeL Val = guess ;
rank: 785
score: 98.49344889322917
patch: ++ * * * /
rank: 785
score: 98.44606526692708
patch: / * * * * * * / ++ iter ;
rank: 785
score: 98.18491617838542
patch: v = ++ iter ;
rank: 785
score: 97.82284545898438
patch: ++ value ;
rank: 786
score: 98.77068536931819
patch: final double iter = guess . clone ( ) ;
rank: 786
score: 98.60249837239583
patch: return new Point CaMeL Value CaMeL Pair ( x , ++ n ; }
rank: 786
score: 98.49318625710227
patch: if ( ! iter != null ; return iter ;
rank: 786
score: 98.4454854329427
patch: / * ++ iter ; / / / / / /
rank: 786
score: 98.18422444661458
patch: System . arraycopy ( ;
rank: 786
score: 97.81580200195313
patch: ++ start ; ;
rank: 787
score: 98.67101372612848
patch: while ( iter . < n ) {
rank: 787
score: 98.66463894314236
patch: return ( double ) f CaMeL Val ;
rank: 787
score: 98.60117013113839
patch: return new Point CaMeL Value CaMeL Pair ( ++ ++ iter ) ;
rank: 787
score: 98.54452950613839
patch: double CaMeL Value = 0 ;
rank: 787
score: 98.49309747869319
patch: Set < Object > iter = iter . iterator ;
rank: 787
score: 98.44547526041667
patch: ++ iter ; * * * / / ++ iter ;
rank: 787
score: 97.81539306640624
patch: iter iter -- ;
rank: 788
score: 98.66104125976562
patch: while ( iter < true ) {
rank: 788
score: 98.65682983398438
patch: Iterator < Point CaMeL Value CaMeL Pair > {
rank: 788
score: 98.60113118489583
patch: ++ iter ; new Point CaMeL Value CaMeL Pair < ? > ( ;
rank: 788
score: 98.54269409179688
patch: double iter = $NUMBER$ ;
rank: 788
score: 98.49309430803571
patch: else { n -- ; }
rank: 788
score: 98.44477982954545
patch: i * ++ ; / * * * / /
rank: 789
score: 98.65982394748264
patch: final double f CaMeL Val = $STRING$ ;
rank: 789
score: 98.65572102864583
patch: Iterator <= Point CaMeL Value CaMeL Pair >
rank: 789
score: 98.60060337611607
patch: ++ iter ; new Point CaMeL Value CaMeL Pair ( x , ;
rank: 789
score: 98.54058074951172
patch: float [ ] x = 0 ;
rank: 789
score: 98.49307250976562
patch: else { if ; * * / } }
rank: 789
score: 98.44443766276042
patch: ++ iter ; ++ * * ++ * / iter ;
rank: 789
score: 97.81185302734374
patch: ++ ( iter ;
rank: 790
score: 98.64823404947917
patch: r = x . clone ( ) ;
rank: 790
score: 98.6005859375
patch: while ( iter != - 1 ) { ++ iter ;
rank: 790
score: 98.55938720703125
patch: final double f CaMeL Val ;
rank: 790
score: 98.53912353515625
patch: int 0 = f CaMeL Val ;
rank: 790
score: 98.4927978515625
patch: else { if ++ iter ;
rank: 790
score: 98.4438809481534
patch: ++ iter ; ++ * * ++ * * /
rank: 790
score: 97.80866241455078
patch: iter iter else
rank: 791
score: 98.7572265625
patch: final double [ ] x 1 = null ;
rank: 791
score: 98.65386284722223
patch: ++ iter ; if ( true ) {
rank: 791
score: 98.64181179470486
patch: return line . search ( x ) ;
rank: 791
score: 98.60055106026786
patch: throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + name ) ;
rank: 791
score: 98.55258178710938
patch: double name = f CaMeL Val ;
rank: 791
score: 98.49170793805804
patch: / * * ++ iter /
rank: 791
score: 98.44313557942708
patch: else return ++ iter ;
rank: 791
score: 97.80020141601562
patch: ++ * ;
rank: 792
score: 98.63742404513889
patch: return new Point CaMeL Value CaMeL Pair (
rank: 792
score: 98.60021100725446
patch: throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + $STRING$ ) ;
rank: 792
score: 98.55004119873047
patch: double f CaMeL Val = f CaMeL
rank: 792
score: 98.53575897216797
patch: double x = $NUMBER$ . 0 ;
rank: 792
score: 98.49129028320313
patch: / * * * / ++ iter ; }
rank: 792
score: 98.4420166015625
patch: ++ iter ; ++ iter ; int * / ;
rank: 792
score: 98.17320760091145
patch: b = ++ iter ;
rank: 792
score: 97.79105631510417
patch: / ;
rank: 793
score: 98.75027465820312
patch: final double iter $NUMBER$ = f CaMeL Val ;
rank: 793
score: 98.63277762276786
patch: result = f CaMeL Val ;
rank: 793
score: 98.59937395368304
patch: ++ iter ; if ( ! iter . is CaMeL Empty ( ;
rank: 793
score: 98.53502655029297
patch: if ( n >= 0 ) {
rank: 793
score: 98.4910888671875
patch: if ( ! iter . equals ( iter ) )
rank: 793
score: 98.44014485677083
patch: ++ iter ; ++ iter ; ++ / * iter ;
rank: 793
score: 98.16837565104167
patch: id = ++ iter ;
rank: 793
score: 97.7819580078125
patch: } ++ start ;
rank: 794
score: 98.75005493164062
patch: final double [ ] x 1 = 1 ;
rank: 794
score: 98.6318603515625
patch: if ( iter Point CaMeL Value CaMeL Pair )
rank: 794
score: 98.59835815429688
patch: if ( iter >= iter ) { ++ iter ; }
rank: 794
score: 98.54794311523438
patch: if ( n > n ) {
rank: 794
score: 98.53501892089844
patch: double [ ] x = line CaMeL
rank: 794
score: 98.49043782552083
patch: if ++ iter ; }
rank: 794
score: 98.43913130326705
patch: ++ iter ; ++ iter ; int * / }
rank: 794
score: 98.16619873046875
patch: data = ++ iter ;
rank: 794
score: 97.76203918457031
patch: / iter ;
rank: 795
score: 98.65032958984375
patch: final double f CaMeL Val = true ;
rank: 795
score: 98.62556287977431
patch: end = x . clone ( ) ;
rank: 795
score: 98.59747314453125
patch: ++ iter ; while ( iter > 0 ) { ;
rank: 795
score: 98.5260009765625
patch: final int x = 0 ;
rank: 795
score: 98.48971121651786
patch: for ; * * * /
rank: 795
score: 98.43897594105114
patch: ++ iter ; ++ iter ; * * / /
rank: 795
score: 98.16438802083333
patch: node = ++ iter ;
rank: 795
score: 97.76045227050781
patch: ++ iter *
rank: 796
score: 98.62498643663194
patch: if ( f CaMeL Val > 0 )
rank: 796
score: 98.59693254743304
patch: return new Point CaMeL Value CaMeL Pair ( ++ n ; } ;
rank: 796
score: 98.5458475748698
patch: double iter = x ;
rank: 796
score: 98.4894131747159
patch: if ( iter == 0 && iter == 0 ;
rank: 796
score: 98.43894264914773
patch: ++ iter ; ++ iter ; ; / * /
rank: 796
score: 97.74656677246094
patch: ++ ; iter
rank: 797
score: 98.64462716238839
patch: double x $NUMBER$ = 0 ;
rank: 797
score: 98.62441677517361
patch: height = x . clone ( ) ;
rank: 797
score: 98.59677124023438
patch: ++ iter ; if ( iter < iter ) continue ;
rank: 797
score: 98.48884887695313
patch: / * * * / * ++ iter ;
rank: 797
score: 98.43877618963069
patch: ++ iter ; ++ iter ; if - iter ;
rank: 797
score: 98.15787760416667
patch: start = ++ iter ;
rank: 797
score: 97.74214172363281
patch: iter ; else
rank: 798
score: 98.62155151367188
patch: if ( ! f CaMeL Val )
rank: 798
score: 98.59664916992188
patch: ++ iter ; while ( iter < n ; ; )
rank: 798
score: 98.5151611328125
patch: i = 0 ;
rank: 798
score: 98.48856898716518
patch: else { ++ iterator ; }
rank: 798
score: 98.4386874112216
patch: ++ iter ; ++ 1 ; iter * / /
rank: 798
score: 98.1499735514323
patch: t = ++ n ;
rank: 798
score: 97.74093627929688
patch: ++ line ;
rank: 799
score: 98.73283386230469
patch: final double [ ] x 1 [
rank: 799
score: 98.5963846842448
patch: ++ iter ; if ( iter == 1 ) break ;
rank: 799
score: 98.502685546875
patch: double [ ] x ;
rank: 799
score: 98.48828125
patch: if ( iter < 0 ) return null ; }
rank: 799
score: 98.43840997869319
patch: ++ iter ; ++ iter ; / * / ;
rank: 799
score: 97.70262145996094
patch: iter else ;
rank: 800
score: 98.63916693793402
patch: int double f CaMeL Val = 0 ;
rank: 800
score: 98.61711968315973
patch: s = x . clone ( ) ;
rank: 800
score: 98.59606061662946
patch: ++ iter ; double n = Double . MAX _ VALUE ; ;
rank: 800
score: 98.53819274902344
patch: final double ++ iter = 0 ;
rank: 800
score: 98.50184849330357
patch: int f CaMeL Val ++ ;
rank: 800
score: 98.48811479048295
patch: Enumeration iter = iter . iterator ++ ; while ;
rank: 800
score: 98.43827311197917
patch: ++ iter ; ++ iter ; int iter = iter ;
rank: 800
score: 98.12887573242188
patch: pos = - iter ;
rank: 800
score: 97.70231119791667
patch: } iter
rank: 801
score: 98.63836669921875
patch: final int f CaMeL Val = 1 ;
rank: 801
score: 98.61531066894531
patch: y $NUMBER$ = f CaMeL Val ;
rank: 801
score: 98.59548514229911
patch: return new Point CaMeL Value CaMeL Pair ( ++ ++ n ) ;
rank: 801
score: 98.48743785511364
patch: Set < Integer > iter = iter . start ;
rank: 801
score: 98.4378153483073
patch: ++ iter ; ++ value ; ++ iter ; iter ;
rank: 801
score: 98.12698364257812
patch: h = ++ iter ;
rank: 801
score: 97.68645477294922
patch: ++ x ;
rank: 802
score: 98.73082275390625
patch: final double [ ] x $NUMBER$ = 0 ;
rank: 802
score: 98.59446207682292
patch: ++ iter ; double ;
rank: 802
score: 98.53498077392578
patch: double max = f CaMeL Val ;
rank: 802
score: 98.48719133649554
patch: if ( iter < 0 ;
rank: 802
score: 98.4375
patch: / * ++ ++ iter ; * / ++ iter ;
rank: 802
score: 97.6800537109375
patch: else ; iter
rank: 803
score: 98.73042805989583
patch: i = line . clone ( ) ;
rank: 803
score: 98.63285997178819
patch: double f CaMeL Val $NUMBER$ = 1 ;
rank: 803
score: 98.57720075334821
patch: ++ iter ; while ; ;
rank: 803
score: 98.53065708705357
patch: double iter = - 1 ;
rank: 803
score: 98.49778529575893
patch: x = f CaMeL Val ;
rank: 803
score: 98.48699340820312
patch: if ( iter != 0 ; break ; }
rank: 803
score: 98.43707830255681
patch: ++ iter ; / * * / / iter ;
rank: 803
score: 97.66200764973958
patch: iter else
rank: 804
score: 98.63229031032986
patch: ++ iter ; double value = 0 ;
rank: 804
score: 98.6056620279948
patch: return f CaMeL Val ;
rank: 804
score: 98.52694702148438
patch: int line = f CaMeL Val ;
rank: 804
score: 98.48631702769886
patch: if ( ! iter . equals ( && ) ;
rank: 804
score: 98.43698952414773
patch: if ++ iter ; ++ iter ; for iter ;
rank: 804
score: 98.12200317382812
patch: int iter = ;
rank: 804
score: 97.6565933227539
patch: for ++ ;
rank: 805
score: 98.62875366210938
patch: if ( true && true ) {
rank: 805
score: 98.59968784877232
patch: c = f CaMeL Val ;
rank: 805
score: 98.49393136160714
patch: if ( 0 < n )
rank: 805
score: 98.48602294921875
patch: else { -- iter ; }
rank: 805
score: 98.43678792317708
patch: ++ iter ; try ; if iter ; ++ iter ;
rank: 805
score: 98.1212158203125
patch: full = ++ iter ;
rank: 805
score: 97.64544677734375
patch: ++ break ;
rank: 806
score: 98.72418891059027
patch: double [ ] x 1 = guess ;
rank: 806
score: 98.62693956163194
patch: stop = x . clone ( ) ;
rank: 806
score: 98.59514024522569
patch: get CaMeL Goal CaMeL Type ( ) ;
rank: 806
score: 98.52373504638672
patch: double [ ] iter = null ;
rank: 806
score: 98.48578435724431
patch: if ( iter < 0 ; return iter ; }
rank: 806
score: 98.43672318892045
patch: ++ iter ; ++ * * ; int iter ;
rank: 806
score: 98.11974080403645
patch: w = ++ iter ;
rank: 806
score: 97.64424896240234
patch: -- iter ;
rank: 807
score: 98.72107543945313
patch: final double [ ] [ ] x 1 ;
rank: 807
score: 98.62556457519531
patch: while ( iter < 0 ) {
rank: 807
score: 98.59146118164062
patch: [ ] = f CaMeL Val ;
rank: 807
score: 98.52265930175781
patch: double n = relative CaMeL Threshold ;
rank: 807
score: 98.49091448102679
patch: double iter = 0 ; {
rank: 807
score: 98.4857177734375
patch: / * * * ++ / ++ iter ;
rank: 807
score: 98.43625710227273
patch: i * ++ ; ++ iter ; ++ * /
rank: 807
score: 98.11440022786458
patch: float iter = 0 ;
rank: 807
score: 97.62541961669922
patch: ++ ; /
rank: 808
score: 98.71738891601562
patch: double [ ] f CaMeL Val = guess ;
rank: 808
score: 98.62409973144531
patch: double [ ] [ ] x ;
rank: 808
score: 98.58839634486607
patch: o = f CaMeL Val ;
rank: 808
score: 98.5667724609375
patch: ++ iter ; iter = ;
rank: 808
score: 98.48970249720982
patch: double f CaMeL Val -- ;
rank: 808
score: 98.48555297851563
patch: if ( iter == 0 ; return null ;
rank: 808
score: 98.43616739908855
patch: / * * * * / / / ++ iter ;
rank: 808
score: 98.11407470703125
patch: kind = ++ iter ;
rank: 808
score: 97.605712890625
patch: iter else iter
rank: 809
score: 98.58811442057292
patch: return x . clone ( ) ; }
rank: 809
score: 98.56676228841145
patch: ++ iter >= n ;
rank: 809
score: 98.48541259765625
patch: if ( iter == 0 ) break ; }
rank: 809
score: 98.46595110212054
patch: if ( n < 0 )
rank: 809
score: 98.4352315266927
patch: ++ * * ++ iter ; * / ++ iter ;
rank: 809
score: 98.11294555664062
patch: tp = ++ iter ;
rank: 809
score: 97.6053237915039
patch: ++ iter /
rank: 810
score: 98.48366873604911
patch: else { if ; * /
rank: 810
score: 98.46324811662946
patch: int f CaMeL Val = (
rank: 810
score: 98.43511408025569
patch: ++ iter ; ++ iter ; if iter iter ;
rank: 810
score: 98.1123555501302
patch: pos = ++ n ;
rank: 810
score: 97.58522033691406
patch: ++ * /
rank: 811
score: 98.62117767333984
patch: while ( checker != null ) {
rank: 811
score: 98.58702087402344
patch: synchronized ( f CaMeL Val ) {
rank: 811
score: 98.51387023925781
patch: double ( f CaMeL Val ) {
rank: 811
score: 98.48361642020089
patch: if ; ++ iter ; }
rank: 811
score: 98.46119035993304
patch: double [ ] x 1 {
rank: 811
score: 98.43461470170455
patch: ++ iter ; / * * / * / /
rank: 811
score: 98.1118672688802
patch: @ Override ++ iter ;
rank: 811
score: 97.56430053710938
patch: ++ ; *
rank: 812
score: 98.61813693576389
patch: final int iter = guess . length ;
rank: 812
score: 98.58663504464286
patch: p = f CaMeL Val ;
rank: 812
score: 98.48322088068181
patch: if ( n == 0 ; return iter ; }
rank: 812
score: 98.45704868861607
patch: if ( n <= n )
rank: 812
score: 98.43410422585227
patch: ++ * * ++ iter ; iter * / /
rank: 812
score: 98.11147054036458
patch: root = ++ iter ;
rank: 812
score: 97.55377197265625
patch: /
rank: 813
score: 98.58489990234375
patch: n = f CaMeL Val ;
rank: 813
score: 98.56012834821429
patch: while ( false ; ) {
rank: 813
score: 98.4827880859375
patch: try { ++ iter ; } catch ( ;
rank: 813
score: 98.45663016183036
patch: if ( checker == null )
rank: 813
score: 98.43308512369792
patch: ++ iter ; ++ iter ; * / int iter ;
rank: 813
score: 98.1098124186198
patch: changed = ++ iter ;
rank: 813
score: 97.55265045166016
patch: } iter ;
rank: 814
score: 98.58451334635417
patch: if ( iter < 0 . 0 )
rank: 814
score: 98.55136544363839
patch: while ( ! ; ) {
rank: 814
score: 98.48277698863636
patch: try { ++ iter ; } catch ++ iter ;
rank: 814
score: 98.453857421875
patch: int x = $NUMBER$ ;
rank: 814
score: 98.4327901204427
patch: ++ iter ; ++ iter ; int * / break ;
rank: 814
score: 98.10860188802083
patch: int n = iter )
rank: 814
score: 97.55225372314453
patch: int iter *
rank: 815
score: 98.58415391710069
patch: i = x . clone ( ) ;
rank: 815
score: 98.4823974609375
patch: if ( iter >= 0 ; return iter ;
rank: 815
score: 98.44687325613839
patch: ++ x [ 0 ] ;
rank: 815
score: 98.43264770507812
patch: ++ iter ; ++ iter ; if iter ; break ;
rank: 815
score: 98.105224609375
patch: int iter = 1 ;
rank: 815
score: 97.54932403564453
patch: iter ; ;
rank: 816
score: 98.60791015625
patch: if ( x == 0 ) {
rank: 816
score: 98.5836181640625
patch: y = f CaMeL Val ;
rank: 816
score: 98.48237748579545
patch: if ( iter < iter ) return iter ; }
rank: 816
score: 98.44378662109375
patch: double iter = - 0 ;
rank: 816
score: 98.43143717447917
patch: / * ] iter ; * / / ++ iter ;
rank: 816
score: 98.10481770833333
patch: ++ iter & iter ;
rank: 816
score: 97.53441619873047
patch: int 1 ;
rank: 817
score: 98.59678431919643
patch: if ( true ) { {
rank: 817
score: 98.574951171875
patch: if ( f CaMeL Val < 0 )
rank: 817
score: 98.503662109375
patch: int length = f CaMeL Val ;
rank: 817
score: 98.4818115234375
patch: if ( iter == null ; return $NUMBER$ ; }
rank: 817
score: 98.43062337239583
patch: ++ iter ; ++ iter ; for ++ - iter ;
rank: 817
score: 98.10219319661458
patch: ++ iter + $NUMBER$ ;
rank: 817
score: 97.50282287597656
patch: break ; ;
rank: 818
score: 98.69269561767578
patch: final double [ ] x $NUMBER$ ;
rank: 818
score: 98.57462310791016
patch: check CaMeL Parameters ( x ) ;
rank: 818
score: 98.53997802734375
patch: ++ iter - n ; ;
rank: 818
score: 98.50353240966797
patch: double line = f CaMeL Val ;
rank: 818
score: 98.481103515625
patch: else { if ++ [ 1 ] ; }
rank: 818
score: 98.43992396763393
patch: f CaMeL Val = x ;
rank: 818
score: 98.43013509114583
patch: / * ] iter ; / / / * / /
rank: 818
score: 98.10219319661458
patch: data = ++ n ;
rank: 818
score: 97.49771881103516
patch: int 0 ;
rank: 819
score: 98.53821672712054
patch: ++ iter ; return ; }
rank: 819
score: 98.4804354580966
patch: if ( iter == null ; while ++ 0 ;
rank: 819
score: 98.43423025948661
patch: if ( n <= 0 )
rank: 819
score: 98.42995198567708
patch: / * ] * / ++ iter ; ++ iter ;
rank: 819
score: 98.1021728515625
patch: dim = ++ iter ;
rank: 819
score: 97.48872375488281
patch: ++ get ;
rank: 820
score: 98.56742350260417
patch: if ( iter < f CaMeL Val )
rank: 820
score: 98.49989318847656
patch: final double f CaMeL Val -- ;
rank: 820
score: 98.4803466796875
patch: ++ iter ; iter ++ ; if ++ iter ;
rank: 820
score: 98.43331473214286
patch: if ( n != 0 )
rank: 820
score: 98.42992146809895
patch: ++ iter ; / * * * / ++ iter ;
rank: 820
score: 98.10162353515625
patch: k = ++ iter ;
rank: 820
score: 97.473388671875
patch: } iter iter
rank: 821
score: 98.56540934244792
patch: n = line . clone ( ) ;
rank: 821
score: 98.53499930245536
patch: while ( ; ; ) {
rank: 821
score: 98.49949428013393
patch: i -= f CaMeL Val ;
rank: 821
score: 98.48033447265625
patch: else { ++ * * * iter ; }
rank: 821
score: 98.4297587076823
patch: ++ * ++ iter ; ++ iter ; ++ iter ;
rank: 821
score: 98.42637416294643
patch: if ( checker != null )
rank: 821
score: 98.09991455078125
patch: Iterator iter = ;
rank: 821
score: 97.46281433105469
patch: ++ stop ;
rank: 822
score: 98.5815658569336
patch: if ( n == 1 ) {
rank: 822
score: 98.56468963623047
patch: if ( double CaMeL Value ) {
rank: 822
score: 98.52654157366071
patch: ++ iter + 1 ; ;
rank: 822
score: 98.49732208251953
patch: double iter = Math . 0 ;
rank: 822
score: 98.48033447265625
patch: else { * * * * ; } }
rank: 822
score: 98.42935180664062
patch: ++ iter ; ++ * * * * / iter ;
rank: 822
score: 98.42630440848214
patch: if ( n >= 0 )
rank: 822
score: 98.0994873046875
patch: clazz = ++ n ;
rank: 822
score: 97.44966125488281
patch: iter -- ;
rank: 823
score: 98.5812759399414
patch: if ( n > 1 ) {
rank: 823
score: 98.56147596571181
patch: num = x . clone ( ) ;
rank: 823
score: 98.49504089355469
patch: int value = f CaMeL Val ;
rank: 823
score: 98.48026529947917
patch: / * * * /
rank: 823
score: 98.42920939127605
patch: ++ iter ; ++ iter ; ++ * * ; /
rank: 823
score: 98.42457071940105
patch: int x = 1 ;
rank: 823
score: 98.0966288248698
patch: node = ++ n ;
rank: 823
score: 97.44204711914062
patch: ++ in ;
rank: 824
score: 98.56093052455357
patch: return x [ iter ] ;
rank: 824
score: 98.47972412109375
patch: ++ * * * * ++ iter ; }
rank: 824
score: 98.42892456054688
patch: ++ iter ; iter ; / * * / / /
rank: 824
score: 98.41700962611607
patch: double [ ] x ++ ;
rank: 824
score: 98.09649658203125
patch: r = ++ n ;
rank: 824
score: 97.4406509399414
patch: ++ super .
rank: 825
score: 98.55824110243056
patch: return ( int ) f CaMeL Val ;
rank: 825
score: 98.49222819010417
patch: double iter = null ;
rank: 825
score: 98.47913707386364
patch: else { ( ++ * 0 . 0 ; }
rank: 825
score: 98.42775472005208
patch: ++ iter ; ++ iter ; out ; ++ iter ;
rank: 825
score: 98.41688232421875
patch: ++ iter ; {
rank: 825
score: 98.09532674153645
patch: temp = ++ iter ;
rank: 825
score: 97.42524719238281
patch: / iter iter
rank: 826
score: 98.56887817382812
patch: while ( true && true ) {
rank: 826
score: 98.55644226074219
patch: int iter = guess . length ;
rank: 826
score: 98.51715959821429
patch: ++ iter - ++ iter ;
rank: 826
score: 98.47797241210938
patch: * * * * ; ++ iter ; }
rank: 826
score: 98.47083391462054
patch: final double [ ] x ;
rank: 826
score: 98.42529296875
patch: ++ iter ; ++ iter ; for iter ; break ;
rank: 826
score: 98.41261509486607
patch: f CaMeL Val = 1 ;
rank: 826
score: 98.0943603515625
patch: ++ n ; break ;
rank: 826
score: 97.40434265136719
patch: long iter ;
rank: 827
score: 98.55341254340277
patch: len = x . clone ( ) ;
rank: 827
score: 98.51533726283482
patch: ++ iter >> < n ;
rank: 827
score: 98.47703968394886
patch: else { ( iter * 0 . 0 ; }
rank: 827
score: 98.4246317545573
patch: ++ iter ; ++ * * / if ++ iter ;
rank: 827
score: 98.41189139229911
patch: double [ ] x 1 =
rank: 827
score: 98.08634440104167
patch: ++ n + iter ;
rank: 827
score: 97.39183807373047
patch: = iter ;
rank: 828
score: 98.66962541852679
patch: double [ ] x 1 [
rank: 828
score: 98.56143188476562
patch: final double x $NUMBER$ = 0 ;
rank: 828
score: 98.55043538411458
patch: Iterator < double CaMeL Value = 0 ;
rank: 828
score: 98.47681884765625
patch: else { iter [ 0 ] ++ ; }
rank: 828
score: 98.45778982979911
patch: final int n = 0 ;
rank: 828
score: 98.42458089192708
patch: ++ * ++ iter ; if iter ; ++ iter ;
rank: 828
score: 98.41094970703125
patch: double iter = - $NUMBER$ ;
rank: 828
score: 98.08453369140625
patch: attr = ++ iter ;
rank: 828
score: 97.37388610839844
patch: ++ min ;
rank: 829
score: 98.56122698102679
patch: if ( ! stop ) {
rank: 829
score: 98.54873221261161
patch: return x [ 0 ] ;
rank: 829
score: 98.51359340122768
patch: ++ iter - $NUMBER$ ; ;
rank: 829
score: 98.47667236328125
patch: if ( < iter == null ; * /
rank: 829
score: 98.4564717610677
patch: boolean stop = false ;
rank: 829
score: 98.42232259114583
patch: / * ++ ++ iter * / / ++ iter ;
rank: 829
score: 98.40994698660714
patch: double [ ] x = new
rank: 829
score: 98.08311971028645
patch: input . ++ iter ;
rank: 829
score: 97.36774444580078
patch: iter iter iter
rank: 830
score: 98.54448784722223
patch: c = x . clone ( ) ;
rank: 830
score: 98.4757568359375
patch: i ] [ 1 ] = iter ; }
rank: 830
score: 98.42001342773438
patch: ++ iter ; while iter + 0 ; ++ iter ;
rank: 830
score: 98.40604073660714
patch: f CaMeL Val = null ;
rank: 830
score: 98.0822998046875
patch: changed = true ;
rank: 830
score: 97.36555480957031
patch: iter ; *
rank: 831
score: 98.55707550048828
patch: / / if ( true ) {
rank: 831
score: 98.54290771484375
patch: return line . search ( x ;
rank: 831
score: 98.51304408482143
patch: ++ iter ; * ; ;
rank: 831
score: 98.47560813210227
patch: ++ * * * * * / ++ iter ;
rank: 831
score: 98.44972446986607
patch: double = f CaMeL Val ;
rank: 831
score: 98.41929117838542
patch: / * ++ iter ; / / / * / /
rank: 831
score: 98.40509905133929
patch: int x $NUMBER$ = 0 ;
rank: 831
score: 98.08218383789062
patch: base = ++ iter ;
rank: 831
score: 97.35946655273438
patch: / ; ;
rank: 832
score: 98.658935546875
patch: double [ ] iter = true ;
rank: 832
score: 98.54179164341518
patch: synchronized ( direc ) {
rank: 832
score: 98.50846644810268
patch: ++ iter ; * / /
rank: 832
score: 98.47404341264205
patch: if ++ [ 0 ] ; } ++ iter ;
rank: 832
score: 98.4423319498698
patch: double iter = true ;
rank: 832
score: 98.41890462239583
patch: ++ iter ; ++ iter ; int * * iter ;
rank: 832
score: 98.08123779296875
patch: ++ iter ^ iter ;
rank: 832
score: 97.33618927001953
patch: / ; else
rank: 833
score: 98.55415344238281
patch: if ( x != 0 ) {
rank: 833
score: 98.53752305772569
patch: v = line . clone ( ) ;
rank: 833
score: 98.50630696614583
patch: ++ iter > 0 ;
rank: 833
score: 98.4651590983073
patch: else return iter ; }
rank: 833
score: 98.4402567545573
patch: double iter = n ;
rank: 833
score: 98.41776529947917
patch: ++ iter ; ++ * / ++ iter ; break ;
rank: 833
score: 98.0810546875
patch: in = ++ n ;
rank: 833
score: 97.33341217041016
patch: iter * ;
rank: 834
score: 98.65151638454861
patch: i = guess . clone ( ) ;
rank: 834
score: 98.55375671386719
patch: ++ x . clone ( ) ;
rank: 834
score: 98.53729926215277
patch: v = x . clone ( ) ;
rank: 834
score: 98.460693359375
patch: } if ++ 0 ;
rank: 834
score: 98.4176025390625
patch: ++ iter ; ++ 1 ; ++ * * iter ;
rank: 834
score: 98.39903041294643
patch: f CaMeL Val = $NUMBER$ ;
rank: 834
score: 98.07962036132812
patch: column = ++ iter ;
rank: 834
score: 97.3040771484375
patch: for iter {
rank: 835
score: 98.53729926215277
patch: Iterator <= double CaMeL Value = 0 ;
rank: 835
score: 98.50044468470982
patch: final ; ++ iter * /
rank: 835
score: 98.45998128255208
patch: ++ ++ iter ; }
rank: 835
score: 98.42154366629464
patch: double -- iter = 0 ;
rank: 835
score: 98.41731770833333
patch: ++ iter ; ++ * * / ++ iter ; ;
rank: 835
score: 98.07767740885417
patch: tmp = ++ iter ;
rank: 835
score: 97.30340576171875
patch: ++ * *
rank: 836
score: 98.537109375
patch: s = f CaMeL Val ;
rank: 836
score: 98.50030517578125
patch: ++ iter ; / ;
rank: 836
score: 98.45533243815105
patch: if ; * * /
rank: 836
score: 98.4171142578125
patch: ++ iter ; ++ iter ; for iter { ++ ;
rank: 836
score: 98.07351684570312
patch: final ++ iter ; ;
rank: 836
score: 97.29644775390625
patch: iter / ;
rank: 837
score: 98.54442596435547
patch: if ( iter ( ) ) {
rank: 837
score: 98.45452880859375
patch: } return ++ iter ;
rank: 837
score: 98.41836111886161
patch: final double max = 0 ;
rank: 837
score: 98.41708374023438
patch: ++ x - iter ;
rank: 837
score: 98.38615199497768
patch: int x = - 1 ;
rank: 837
score: 98.07278442382812
patch: id = ++ n ;
rank: 837
score: 97.29222106933594
patch: ++ new ;
rank: 838
score: 98.64607747395833
patch: final int value = f CaMeL Val ;
rank: 838
score: 98.498779296875
patch: ++ iter ; / * *
rank: 838
score: 98.44245910644531
patch: } if ;
rank: 838
score: 98.41714477539062
patch: int start = 0 ;
rank: 838
score: 98.41664632161458
patch: ++ iter ; iter * * / / ++ iter ;
rank: 838
score: 98.07241821289062
patch: int iter = iter )
rank: 838
score: 97.27633666992188
patch: ++ $STRING$ *
rank: 839
score: 98.54078674316406
patch: if ( iter < true ) {
rank: 839
score: 98.41424560546875
patch: iter = f CaMeL Val ;
rank: 839
score: 98.38316853841145
patch: int 0 = 0 ;
rank: 839
score: 98.06641387939453
patch: n ++ ;
rank: 839
score: 97.27503458658855
patch: / iter
rank: 840
score: 98.42999267578125
patch: / * / * /
rank: 840
score: 98.4154052734375
patch: ++ iter ; ++ 1 ; int * ++ iter ;
rank: 840
score: 98.06627400716145
patch: it = ++ iter ;
rank: 840
score: 97.2747573852539
patch: * ; iter
rank: 841
score: 98.53216552734375
patch: Iterator iter = guess . length ;
rank: 841
score: 98.42850748697917
patch: if ; ++ 0 ;
rank: 841
score: 98.415283203125
patch: ++ iter ; iter ; * * / ++ iter ;
rank: 841
score: 98.06602783203125
patch: for ; ; )
rank: 841
score: 97.27313995361328
patch: for ++ *
rank: 842
score: 98.53025987413194
patch: Iterator <= Point CaMeL Value CaMeL Pair )
rank: 842
score: 98.428125
patch: else return iter ;
rank: 842
score: 98.41507975260417
patch: this . ++ iter ; ++ iter ; int iter ;
rank: 842
score: 97.2703857421875
patch: ; iter ;
rank: 843
score: 98.53897857666016
patch: if ( true ) { ) {
rank: 843
score: 98.53015814887152
patch: if ( iter < x . length )
rank: 843
score: 98.48411342075893
patch: ++ iter ; * iter ;
rank: 843
score: 98.41678873697917
patch: / * * ; /
rank: 843
score: 98.41501871744792
patch: ++ * ++ iter ; ++ * / ++ iter ;
rank: 843
score: 98.41077532087054
patch: double += f CaMeL Val ;
rank: 843
score: 98.06520589192708
patch: scope = ++ iter ;
rank: 843
score: 97.26704406738281
patch: int n ;
rank: 844
score: 98.5384521484375
patch: if ( 0 > n ) {
rank: 844
score: 98.529541015625
patch: Object f CaMeL Val = 0 ;
rank: 844
score: 98.48204694475446
patch: ++ iter ; final double ;
rank: 844
score: 98.41493733723958
patch: ++ < iter ; }
rank: 844
score: 98.41451009114583
patch: ++ iter ; ++ * * * * / / /
rank: 844
score: 98.40639241536458
patch: boolean stop = true ;
rank: 844
score: 98.06447347005208
patch: ke = ++ iter ;
rank: 844
score: 97.25635528564453
patch: ++ - ;
rank: 845
score: 98.53759765625
patch: double x [ ] = 0 ;
rank: 845
score: 98.52711317274306
patch: x = x . clone ( ) ;
rank: 845
score: 98.41372680664062
patch: ++ * - 0 ;
rank: 845
score: 98.4126688639323
patch: ++ iter ; try ; int iter ; ++ iter ;
rank: 845
score: 98.40498570033482
patch: final double length = 0 ;
rank: 845
score: 98.37827555338542
patch: int iter = $NUMBER$ ;
rank: 845
score: 98.06443277994792
patch: l = ++ iter ;
rank: 845
score: 97.25235748291016
patch: 
rank: 846
score: 98.52701144748264
patch: rs = x . clone ( ) ;
rank: 846
score: 98.41208902994792
patch: ++ iter ; ++ iter ; / * / iter ;
rank: 846
score: 98.41072591145833
patch: ++ * - iter ;
rank: 846
score: 98.40309651692708
patch: double length = 0 ;
rank: 846
score: 98.06154378255208
patch: field = ++ iter ;
rank: 846
score: 97.25146484375
patch: ++ System ;
rank: 847
score: 98.53496551513672
patch: if ( 0 == n ) {
rank: 847
score: 98.52688598632812
patch: = x . clone ( ) ;
rank: 847
score: 98.47269984654018
patch: ++ iter >= - 1 ;
rank: 847
score: 98.41038004557292
patch: ++ iter ; while iter + iter ; ++ iter ;
rank: 847
score: 98.40951538085938
patch: if ; * /
rank: 847
score: 98.38971819196429
patch: double f CaMeL Val = new
rank: 847
score: 98.37157185872395
patch: int f CaMeL Val ;
rank: 847
score: 98.05963134765625
patch: ++ iter )
rank: 847
score: 97.24888610839844
patch: ++ $STRING$ /
rank: 848
score: 98.61420440673828
patch: double [ ] x 1 $NUMBER$ ;
rank: 848
score: 98.5249252319336
patch: if ( do CaMeL Optimize ) {
rank: 848
score: 98.52451578776042
patch: pos = x . clone ( ) ;
rank: 848
score: 98.47042410714286
patch: ++ iter ; int n ;
rank: 848
score: 98.41016642252605
patch: ++ iter ; ++ iter ; out ; int iter ;
rank: 848
score: 98.40719604492188
patch: / * * / }
rank: 848
score: 98.36978585379464
patch: double iter 1 = 0 ;
rank: 848
score: 98.05853271484375
patch: tc = ++ iter ;
rank: 848
score: 97.2471923828125
patch: int start ;
rank: 849
score: 98.51838902064732
patch: state = f CaMeL Val ;
rank: 849
score: 98.47016252790179
patch: ++ iter ; / iter ;
rank: 849
score: 98.40913899739583
patch: ++ iter ; ++ iter ; * / if iter ;
rank: 849
score: 98.40456136067708
patch: for ; * * /
rank: 849
score: 98.37227957589286
patch: double n 1 = 0 ;
rank: 849
score: 98.05279541015625
patch: assert iter != null ;
rank: 849
score: 97.24671173095703
patch: this ; iter
rank: 850
score: 98.51659478081598
patch: p = line . clone ( ) ;
rank: 850
score: 98.51246861049107
patch: if ( f CaMeL Val ;
rank: 850
score: 98.47001139322917
patch: while ( true ; )
rank: 850
score: 98.40892537434895
patch: / * ] iter ; / / * * / /
rank: 850
score: 98.4043701171875
patch: ++ 0 ; }
rank: 850
score: 98.36890520368304
patch: double [ ] x $NUMBER$ ;
rank: 850
score: 98.05155436197917
patch: s = ++ iter ;
rank: 850
score: 97.23810577392578
patch: ++ trim ;
rank: 851
score: 98.51461452907986
patch: < f CaMeL Val ; ++ iter ;
rank: 851
score: 98.40829467773438
patch: ++ iter ; ++ iter ; int * - iter ;
rank: 851
score: 98.40321858723958
patch: ++ ++ [ ] ;
rank: 851
score: 98.3668924967448
patch: double max = 0 ;
rank: 851
score: 98.05068969726562
patch: step = ++ iter ;
rank: 851
score: 97.21304321289062
patch: Iterator 1 ;
rank: 852
score: 98.59275817871094
patch: double [ ] x 1 [ ;
rank: 852
score: 98.50849745008681
patch: p = x . clone ( ) ;
rank: 852
score: 98.50819614955357
patch: ++ while ( true ) {
rank: 852
score: 98.40753173828125
patch: ++ ] iter ++ ;
rank: 852
score: 98.40038452148437
patch: if ( iter ;
rank: 852
score: 98.05026245117188
patch: while ( iter ) {
rank: 852
score: 97.21208190917969
patch: ++ clone ;
rank: 853
score: 98.50529261997768
patch: final int iter = n ;
rank: 853
score: 98.50499616350446
patch: v = f CaMeL Val ;
rank: 853
score: 98.46299235026042
patch: while ( iter ; )
rank: 853
score: 98.406494140625
patch: else if ++ iter ; ++ iter ; ++ iter ;
rank: 853
score: 98.39390258789062
patch: for ; * /
rank: 853
score: 98.04996744791667
patch: mod = ++ iter ;
rank: 853
score: 97.21100616455078
patch: try ; iter
rank: 854
score: 98.50484212239583
patch: ( iter < f CaMeL Val ) {
rank: 854
score: 98.46096365792411
patch: ++ iter * / iter ;
rank: 854
score: 98.4056905110677
patch: ++ iter ; iter ; / * * * / /
rank: 854
score: 98.38846842447917
patch: / * * * ;
rank: 854
score: 98.36439732142857
patch: stop = f CaMeL Val ;
rank: 854
score: 98.36237444196429
patch: final double value = 0 ;
rank: 854
score: 98.04801432291667
patch: z = ++ iter ;
rank: 854
score: 97.21002960205078
patch: ++ 1 iter
rank: 855
score: 98.50355021158855
patch: long iter = 0 ;
rank: 855
score: 98.40541585286458
patch: int iter + 0 ;
rank: 855
score: 98.36131068638393
patch: int f CaMeL Val -- ;
rank: 855
score: 98.04675903320313
patch: double n = ;
rank: 855
score: 97.20780181884766
patch: ++ search ;
rank: 856
score: 98.58414459228516
patch: double [ ] iter = guess ;
rank: 856
score: 98.50084771050348
patch: long f CaMeL Val $NUMBER$ = 0 ;
rank: 856
score: 98.48721749441964
patch: if ( ! true ) {
rank: 856
score: 98.45994349888393
patch: ++ iter ; n ++ ;
rank: 856
score: 98.40362548828125
patch: ++ iter ; ++ iter ; ++ 1 ; iter ;
rank: 856
score: 98.38436889648438
patch: ++ * n ; }
rank: 856
score: 98.35800170898438
patch: boolean stop = 0 ;
rank: 856
score: 98.04529825846355
patch: first = ++ iter ;
rank: 856
score: 97.2062759399414
patch: ++ $NUMBER$ /
rank: 857
score: 98.49858093261719
patch: x 1 = f CaMeL Val ;
rank: 857
score: 98.459228515625
patch: ++ iter ; ; ; ;
rank: 857
score: 98.381787109375
patch: ++ * * /
rank: 857
score: 98.3599853515625
patch: int x = - $NUMBER$ ;
rank: 857
score: 98.04471842447917
patch: assert iter >= iter ;
rank: 857
score: 97.20196533203125
patch: ++ ; else
rank: 858
score: 98.57157135009766
patch: double [ ] [ ] x 1
rank: 858
score: 98.49687194824219
patch: if ( f CaMeL Val ) {
rank: 858
score: 98.45623779296875
patch: ++ n - 1 ;
rank: 858
score: 98.40121459960938
patch: ++ iter ; ++ iter ; int iter + iter ;
rank: 858
score: 98.38048095703125
patch: } = iter ;
rank: 858
score: 98.35856410435268
patch: if ( 0 <= n )
rank: 858
score: 98.04419962565105
patch: match = ++ iter ;
rank: 858
score: 97.2012939453125
patch: / ; /
rank: 859
score: 98.49662950303819
patch: Iterator < Point CaMeL Value CaMeL Pair >>
rank: 859
score: 98.46597290039062
patch: double value = 0 ;
rank: 859
score: 98.45529610770089
patch: ++ iter % * * /
rank: 859
score: 98.40088907877605
patch: / * ++ ++ * * / / ++ iter ;
rank: 859
score: 98.37303670247395
patch: if ++ * iter ;
rank: 859
score: 98.35475376674107
patch: double [ ] = 0 ;
rank: 859
score: 98.0438232421875
patch: int n = 1 ;
rank: 859
score: 97.19935607910156
patch: ++ ; ;
rank: 860
score: 98.40081787109375
patch: ++ iter ; ++ iter ; / / * / /
rank: 860
score: 98.37275390625
patch: / * * ;
rank: 860
score: 98.35472760881696
patch: double ++ iter = x ;
rank: 860
score: 98.04356892903645
patch: if ; ++ n ;
rank: 860
score: 97.19168090820312
patch: if iter :
rank: 861
score: 98.49219512939453
patch: Iterator iter = f CaMeL Val ;
rank: 861
score: 98.45206996372768
patch: ++ iter ; ; while ;
rank: 861
score: 98.40027872721355
patch: ++ iter ; ++ iter ; if iter ; iter ;
rank: 861
score: 98.37033081054688
patch: } if ++ n ;
rank: 861
score: 98.35143171037946
patch: double ++ iter = 1 ;
rank: 861
score: 98.0421651204427
patch: ch = ++ iter ;
rank: 861
score: 97.18690999348958
patch: ++ ;
rank: 862
score: 98.56678771972656
patch: final double = f CaMeL Val ;
rank: 862
score: 98.48344203404018
patch: node = f CaMeL Val ;
rank: 862
score: 98.45287068684895
patch: if ( false ) {
rank: 862
score: 98.45145089285714
patch: if ( ; ++ iter ;
rank: 862
score: 98.3699951171875
patch: ++ [ ] ; }
rank: 862
score: 98.34734235491071
patch: double start 1 = 0 ;
rank: 862
score: 98.04215494791667
patch: hint = ++ iter ;
rank: 862
score: 97.17939758300781
patch: ++ split ;
rank: 863
score: 98.45135498046875
patch: while ( ; ) {
rank: 863
score: 98.36644490559895
patch: * * ++ iter ;
rank: 863
score: 98.34259033203125
patch: int iter = n ;
rank: 863
score: 98.04173787434895
patch: line = ++ iter ;
rank: 863
score: 97.17591857910156
patch: ++ iter +
rank: 864
score: 98.477783203125
patch: Iterator < double [ ] >
rank: 864
score: 98.42966134207589
patch: final double iter = n ;
rank: 864
score: 98.39878336588542
patch: / * ++ iter ; / / * * / /
rank: 864
score: 98.36597696940105
patch: * * ; * /
rank: 864
score: 98.039404296875
patch: j = iter ;
rank: 864
score: 97.17462158203125
patch: iter else else
rank: 865
score: 98.46795654296875
patch: r = f CaMeL Val ;
rank: 865
score: 98.44820149739583
patch: ++ iter % iter ;
rank: 865
score: 98.42794363839286
patch: final double iter = 1 ;
rank: 865
score: 98.39798990885417
patch: ++ iter ; ++ * * / int iter ++ ;
rank: 865
score: 98.36446126302083
patch: / * = iter ;
rank: 865
score: 98.32283528645833
patch: int iter = x ;
rank: 865
score: 98.03568522135417
patch: double iter = iter ;
rank: 865
score: 97.17296600341797
patch: start ++ ;
rank: 866
score: 98.55516052246094
patch: double [ ] iter = $NUMBER$ ;
rank: 866
score: 98.44761439732143
patch: ++ iter * / if ;
rank: 866
score: 98.42565046037946
patch: while ( iter ++ ) {
rank: 866
score: 98.39718627929688
patch: ++ iter ; ++ * * * / / iter ;
rank: 866
score: 98.36292521158855
patch: / * * ++ /
rank: 866
score: 98.3320821126302
patch: boolean stop = $NUMBER$ ;
rank: 866
score: 98.3090108235677
patch: double 1 = 0 ;
rank: 866
score: 97.17218017578125
patch: / ; *
rank: 867
score: 98.42074148995536
patch: if ( true ) { }
rank: 867
score: 98.39614868164062
patch: ++ * ] iter ; * / / ++ iter ;
rank: 867
score: 98.3615010579427
patch: if ( < 0 ;
rank: 867
score: 98.32652064732143
patch: final double n = 1 ;
rank: 867
score: 98.02825927734375
patch: obj = ++ iter ;
rank: 867
score: 97.16439819335938
patch: iter iter }
rank: 868
score: 98.54734802246094
patch: final int x 1 = 0 ;
rank: 868
score: 98.46527862548828
patch: if ( iter < direc .
rank: 868
score: 98.44363403320312
patch: ++ iter % * /
rank: 868
score: 98.3953857421875
patch: ++ iter ; iter ; / / * / / /
rank: 868
score: 98.31930106026786
patch: double < f CaMeL Val ;
rank: 868
score: 98.30572509765625
patch: int max = 0 ;
rank: 868
score: 98.02794799804687
patch: switch ( iter )
rank: 868
score: 97.16397094726562
patch: int $NUMBER$ ;
rank: 869
score: 98.46454620361328
patch: < iter ; iter ++ ) {
rank: 869
score: 98.43953450520833
patch: ++ iter >= $NUMBER$ ;
rank: 869
score: 98.40300641741071
patch: if ( ! false ) {
rank: 869
score: 98.39495849609375
patch: ++ iter ; iter ; * / if ++ iter ;
rank: 869
score: 98.35858154296875
patch: / * * / /
rank: 869
score: 98.31776936848958
patch: double iter = false ;
rank: 869
score: 98.02550252278645
patch: if ( ! ; }
rank: 869
score: 97.16144561767578
patch: ++ $NUMBER$ *
rank: 870
score: 98.46071079799107
patch: ret = f CaMeL Val ;
rank: 870
score: 98.4134012858073
patch: while ( ! ; )
rank: 870
score: 98.40082659040179
patch: double f CaMeL Val $NUMBER$ ;
rank: 870
score: 98.39422607421875
patch: / * / ++ iter * / / ++ iter ;
rank: 870
score: 98.3573486328125
patch: ++ n ; }
rank: 870
score: 98.31658325195312
patch: int ++ iter ;
rank: 870
score: 98.0254414876302
patch: time = ++ iter ;
rank: 870
score: 97.15951538085938
patch: ++ / ;
rank: 871
score: 98.4602279663086
patch: < n ; iter ++ ) {
rank: 871
score: 98.39402262369792
patch: ++ iter ; ++ iter ; ; / * / /
rank: 871
score: 98.35678100585938
patch: ++ += iter ; }
rank: 871
score: 98.02025146484375
patch: ++ iter ] ;
rank: 871
score: 97.15872192382812
patch: } iter else
rank: 872
score: 98.45719691685268
patch: pos = f CaMeL Val ;
rank: 872
score: 98.3928934733073
patch: ++ iter ; ++ * ++ iter ; if iter ;
rank: 872
score: 98.35642496744792
patch: } if ++ 1 ;
rank: 872
score: 98.31534249441964
patch: for ( ++ iter ) {
rank: 872
score: 98.01941935221355
patch: ch = ++ n ;
rank: 872
score: 97.1529541015625
patch: ++ iter iter
rank: 873
score: 98.39202880859375
patch: ++ iter ; ++ iter ; try ; int iter ;
rank: 873
score: 98.37413678850446
patch: while ( iter true ) {
rank: 873
score: 98.34798177083333
patch: ++ * * ; }
rank: 873
score: 98.31516810825893
patch: final double iter = x ;
rank: 873
score: 98.2855224609375
patch: int stop = 0 ;
rank: 873
score: 98.01749267578126
patch: ++ iter iter ;
rank: 873
score: 97.1510009765625
patch: ++ do ;
rank: 874
score: 98.45301818847656
patch: return line . search ( x ,
rank: 874
score: 98.39044189453125
patch: ++ iter ; ++ iter ; for iter ; ; *
rank: 874
score: 98.37374441964286
patch: final double iter = true ;
rank: 874
score: 98.31218610491071
patch: double while ( true ) {
rank: 874
score: 98.27669270833333
patch: double [ ] x =
rank: 874
score: 97.14988708496094
patch: ++ compare ;
rank: 875
score: 98.38973999023438
patch: ++ 1 ; ++ iter ; / * * / /
rank: 875
score: 98.3095703125
patch: double ++ iter = n ;
rank: 875
score: 98.27187093098958
patch: double f CaMeL Val :
rank: 875
score: 98.01353963216145
patch: synchronized ( ++ n )
rank: 875
score: 97.1493428548177
patch: ; iter
rank: 876
score: 98.44719587053571
patch: return guess [ iter ] ;
rank: 876
score: 98.3895263671875
patch: int iter ; / * * / / ++ iter ;
rank: 876
score: 98.26687622070312
patch: double stop = 0 ;
rank: 876
score: 98.01300048828125
patch: i ++ ;
rank: 876
score: 97.12263997395833
patch: else iter
rank: 877
score: 98.44660295758929
patch: id = f CaMeL Val ;
rank: 877
score: 98.388916015625
patch: ++ iter ; try ; if ++ iter ; break ;
rank: 877
score: 98.38558959960938
patch: ++ iter < n ;
rank: 877
score: 98.36098807198661
patch: double < double [ ] ;
rank: 877
score: 98.24852498372395
patch: switch ( n ) {
rank: 877
score: 98.00960286458333
patch: float [ ] ++ ;
rank: 877
score: 97.08553059895833
patch: break ;
rank: 878
score: 98.38890584309895
patch: / * ] iter ; / * * / / /
rank: 878
score: 98.3396708170573
patch: else return null ; }
rank: 878
score: 98.26624552408855
patch: double n = 1 ;
rank: 878
score: 98.24270629882812
patch: int x = n ;
rank: 878
score: 98.00928751627605
patch: long n = iter ;
rank: 878
score: 96.93988037109375
patch: ;
rank: 879
score: 98.44579206194196
patch: key = f CaMeL Val ;
rank: 879
score: 98.38646443684895
patch: ++ iter ; iter ; * * * / / /
rank: 879
score: 98.364501953125
patch: ++ iter * ;
rank: 879
score: 98.35396902901786
patch: final double iter = $NUMBER$ ;
rank: 879
score: 98.33756510416667
patch: / * * ; }
rank: 879
score: 98.25705973307292
patch: double iter = line ;
rank: 879
score: 98.00762939453125
patch: ++ iter = 0 ;
rank: 879
score: 96.85884602864583
patch: { iter
rank: 880
score: 98.38619995117188
patch: ++ iter ; ++ * * * / iter ; /
rank: 880
score: 98.35314069475446
patch: ++ iter ; double ++ ;
rank: 880
score: 98.35167439778645
patch: while ( false ; )
rank: 880
score: 98.33729044596355
patch: ++ ! iter ; }
rank: 880
score: 98.2269795735677
patch: double iter = guess ;
rank: 880
score: 98.00682576497395
patch: style = ++ n ;
rank: 880
score: 96.8101806640625
patch: else ;
rank: 881
score: 98.44060516357422
patch: n $NUMBER$ = f CaMeL Val ;
rank: 881
score: 98.38585408528645
patch: ++ iter ; ++ iter ; ++ * * ++ /
rank: 881
score: 98.35001627604167
patch: ++ iter ; x ;
rank: 881
score: 98.33567301432292
patch: } { ++ iter ;
rank: 881
score: 98.22589111328125
patch: double n = $NUMBER$ ;
rank: 881
score: 98.20724487304688
patch: double $NUMBER$ = 0 ;
rank: 881
score: 98.0067138671875
patch: kind = ++ n ;
rank: 881
score: 96.80935668945312
patch: * ;
rank: 882
score: 98.43702043805804
patch: end = f CaMeL Val ;
rank: 882
score: 98.38560994466145
patch: ++ iter ; ++ iter ; for iter + 0 ;
rank: 882
score: 98.34881591796875
patch: ++ iter * $NUMBER$ ;
rank: 882
score: 98.3322041829427
patch: ++ iter iter ; }
rank: 882
score: 98.20674641927083
patch: double 0 = 0 ;
rank: 882
score: 97.99880981445312
patch: field = ++ n ;
rank: 882
score: 96.60182698567708
patch: continue ;
rank: 883
score: 98.38525390625
patch: ++ iter ; iter ; if ++ iter ; break ;
rank: 883
score: 98.3418680826823
patch: ++ iter * / /
rank: 883
score: 98.32867431640625
patch: ++ * * * ;
rank: 883
score: 98.22066243489583
patch: double min = 0 ;
rank: 883
score: 98.2066141764323
patch: double x = $NUMBER$ ;
rank: 883
score: 97.99520874023438
patch: final ++ iter ; }
rank: 883
score: 96.59877522786458
patch: logger ;
rank: 884
score: 98.43649291992188
patch: Iterator iter = 0 ;
rank: 884
score: 98.38521321614583
patch: / * ++ iter ; / / / / / ;
rank: 884
score: 98.35031563895089
patch: final int iter = true ;
rank: 884
score: 98.2031758626302
patch: if ( stop ) {
rank: 884
score: 97.99242146809895
patch: synchronized ( iter ) {
rank: 884
score: 96.57822672526042
patch: iter }
rank: 885
score: 98.43632507324219
patch: result = x [ 0 ] ;
rank: 885
score: 98.38513793945313
patch: ++ x iter ;
rank: 885
score: 98.3276875813802
patch: ++ iter <= n ;
rank: 885
score: 98.31333414713542
patch: * * * * ;
rank: 885
score: 98.21231079101562
patch: double n = x ;
rank: 885
score: 97.986572265625
patch: b = ++ n ;
rank: 885
score: 96.51611328125
patch: System ;
rank: 886
score: 98.38338216145833
patch: / * ++ iter ; / / * / / /
rank: 886
score: 98.3130391438802
patch: / * += iter ;
rank: 886
score: 97.98519897460938
patch: pos ++ ;
rank: 886
score: 96.51483154296875
patch: start ;
rank: 887
score: 98.43458557128906
patch: return new double [ iter ] ;
rank: 887
score: 98.3831278483073
patch: ++ iter ; ++ * * * * * / /
rank: 887
score: 98.3242899576823
patch: ++ iter >= iter ;
rank: 887
score: 98.30686442057292
patch: ++ * ; * /
rank: 887
score: 97.98421223958333
patch: try { iter = ;
rank: 887
score: 96.50918579101562
patch: try
rank: 888
score: 98.42990548270089
patch: path = f CaMeL Val ;
rank: 888
score: 98.41641671316964
patch: final double [ ] x 1
rank: 888
score: 98.38230387369792
patch: i * ++ ; / * * * * / /
rank: 888
score: 98.34471784319196
patch: if ( ! 0 ) {
rank: 888
score: 98.32347615559895
patch: ++ iter >= 1 ;
rank: 888
score: 97.9828389485677
patch: j = ++ n ;
rank: 888
score: 96.49489339192708
patch: this ;
rank: 889
score: 98.42565155029297
patch: - 1 = f CaMeL Val ;
rank: 889
score: 98.41304234095982
patch: double iter = x 1 ;
rank: 889
score: 98.38203938802083
patch: ++ iter ; / * * * * * / /
rank: 889
score: 98.34395054408482
patch: while ( ! true ) {
rank: 889
score: 97.97991943359375
patch: while ( true ;
rank: 889
score: 96.41542053222656
patch: }
rank: 890
score: 98.41791643415179
patch: obj = f CaMeL Val ;
rank: 890
score: 98.38197835286458
patch: ++ iter ; iter ; int iter ; while iter ;
rank: 890
score: 98.30460611979167
patch: * * * / }
rank: 890
score: 98.17622884114583
patch: double x = x ;
rank: 890
score: 98.17252604166667
patch: if ( direc [
rank: 890
score: 97.97984822591145
patch: boolean iter = false ;
rank: 890
score: 96.38536580403645
patch: iter *
rank: 891
score: 98.41471644810268
patch: return ( double ) iter ;
rank: 891
score: 98.38193766276042
patch: ++ iter ; ++ iter ; iter ; int * /
rank: 891
score: 98.30218505859375
patch: } if ( iter ;
rank: 891
score: 98.1681620279948
patch: int x = x ;
rank: 891
score: 98.1580098470052
patch: double [ ] $NUMBER$ ;
rank: 891
score: 97.9776123046875
patch: pos = iter ;
rank: 891
score: 96.37373860677083
patch: ++ iter
rank: 892
score: 98.38125610351562
patch: ++ iter ; / * * * * / / /
rank: 892
score: 98.30045572916667
patch: ++ iter >= 0 )
rank: 892
score: 98.29955037434895
patch: * * * * /
rank: 892
score: 98.16744995117188
patch: long x = 0 ;
rank: 892
score: 98.15458170572917
patch: int break = 0 ;
rank: 892
score: 96.37148030598958
patch: / else
rank: 893
score: 98.40729631696429
patch: found = f CaMeL Val ;
rank: 893
score: 98.3810526529948
patch: ++ iter ; ++ iter ; try ; if iter ;
rank: 893
score: 98.29824829101562
patch: ++ iter % $NUMBER$ ;
rank: 893
score: 98.29693603515625
patch: if ( iter ; }
rank: 893
score: 98.16440836588542
patch: double f CaMeL Val =
rank: 893
score: 98.14524332682292
patch: final double [ ] ;
rank: 893
score: 97.95145874023437
patch: ++ iter ) {
rank: 893
score: 96.28916931152344
patch: else
rank: 894
score: 98.40703473772321
patch: value = f CaMeL Val ;
rank: 894
score: 98.39583914620536
patch: line = f CaMeL Val ;
rank: 894
score: 98.37959798177083
patch: ++ iter ; ++ iter ; for iter ; ; ;
rank: 894
score: 98.33362688337054
patch: while ( ! stop ) {
rank: 894
score: 98.29207356770833
patch: ++ * - 1 ;
rank: 894
score: 98.2889404296875
patch: ++ iter ; / *
rank: 894
score: 98.1597188313802
patch: double iter = $STRING$ ;
rank: 894
score: 98.13919067382812
patch: double x = 1 ;
rank: 894
score: 96.28118896484375
patch: / /
rank: 895
score: 98.29111735026042
patch: i * * * /
rank: 895
score: 98.28611246744792
patch: ++ n >= n ;
rank: 895
score: 97.9201171875
patch: synchronized ( this )
rank: 895
score: 96.27565511067708
patch: * iter
rank: 896
score: 98.40330287388393
patch: column = f CaMeL Val ;
rank: 896
score: 98.3792012532552
patch: else ++ ++ iter ;
rank: 896
score: 98.2907002766927
patch: Set iter ; while ;
rank: 896
score: 98.28350830078125
patch: ++ iter ; new ;
rank: 896
score: 98.15073649088542
patch: int n = $NUMBER$ ;
rank: 896
score: 97.91471099853516
patch: n -- ;
rank: 896
score: 96.27560424804688
patch: iter /
rank: 897
score: 98.3936055501302
patch: y 1 = 0 ;
rank: 897
score: 98.37851969401042
patch: finally { ++ iter ;
rank: 897
score: 98.28867594401042
patch: * * / * /
rank: 897
score: 98.12746175130208
patch: double [ ] ) {
rank: 897
score: 97.90867919921875
patch: cancelled = true ;
rank: 897
score: 96.23964436848958
patch: result iter
rank: 898
score: 98.39114815848214
patch: entry = f CaMeL Val ;
rank: 898
score: 98.37769571940105
patch: ++ value ; iter ;
rank: 898
score: 98.28548583984374
patch: } if iter ;
rank: 898
score: 98.1205546061198
patch: double start = 1 ;
rank: 898
score: 97.88560791015625
patch: float iter = ;
rank: 898
score: 96.2269795735677
patch: start iter
rank: 899
score: 98.39073835100446
patch: num = f CaMeL Val ;
rank: 899
score: 98.3770039876302
patch: ++ iter ; ++ iter ; / * * ; /
rank: 899
score: 98.28218587239583
patch: ++ -- iter ; }
rank: 899
score: 98.12999471028645
patch: int iter = true ;
rank: 899
score: 97.86309814453125
patch: p = iter ;
rank: 899
score: 96.2213134765625
patch: try ;
rank: 900
score: 98.38893345424107
patch: return line [ iter ] ;
rank: 900
score: 98.37689208984375
patch: ++ iter ; ++ * * ++ iter ; break ;
rank: 900
score: 98.27899169921875
patch: return new ++ iter ;
rank: 900
score: 98.11256917317708
patch: final int ++ iter ;
rank: 900
score: 97.85757446289062
patch: final ++ n ;
rank: 900
score: 96.22074381510417
patch: iterator ;
rank: 901
score: 98.38858468191964
patch: if ( iter < n ;
rank: 901
score: 98.37689208984375
patch: ++ iter ; ++ * * ++ * * / /
rank: 901
score: 98.12646484375
patch: ++ iter ; ) {
rank: 901
score: 97.84498291015625
patch: pos = 0 ;
rank: 901
score: 96.1868184407552
patch: super ;
rank: 902
score: 98.38562883649554
patch: tmp = f CaMeL Val ;
rank: 902
score: 98.37621053059895
patch: ++ iter ; ++ iter ; for iter { iter ;
rank: 902
score: 98.27601318359375
patch: if ( false ;
rank: 902
score: 98.23159790039062
patch: while ( ; ; )
rank: 902
score: 98.11685180664062
patch: switch ( true ) {
rank: 902
score: 98.10430908203125
patch: double x = n ;
rank: 902
score: 96.17417399088542
patch: ++ else
rank: 903
score: 98.27566528320312
patch: ( ++ [ ] ;
rank: 903
score: 98.11654663085938
patch: int f CaMeL Val :
rank: 903
score: 98.10208129882812
patch: int line = 0 ;
rank: 903
score: 97.81415405273438
patch: ++ iter 1 ;
rank: 904
score: 98.38173130580357
patch: y . clone ( ) ;
rank: 904
score: 98.37562052408855
patch: ++ iter ; iter ; / / * * / /
rank: 904
score: 98.27541097005208
patch: / * * ++ ;
rank: 904
score: 98.25424194335938
patch: int value = 0 ;
rank: 904
score: 98.22231038411458
patch: if ; iter ++ ;
rank: 904
score: 98.10128784179688
patch: double n = null ;
rank: 904
score: 97.78416748046875
patch: reader . ++ ;
rank: 904
score: 96.06319173177083
patch: / *
rank: 905
score: 98.37509155273438
patch: else * ++ iter ; / * / ++ iter ;
rank: 905
score: 98.37397984095982
patch: < f CaMeL Val ) {
rank: 905
score: 98.27523193359374
patch: ++ < 0 ;
rank: 905
score: 98.2218017578125
patch: ++ iter / iter ;
rank: 905
score: 97.78406372070313
patch: pos = 1 ;
rank: 905
score: 96.02494303385417
patch: ++ }
rank: 906
score: 98.37417602539062
patch: / * ] iter ; / / / / / ;
rank: 906
score: 98.35894775390625
patch: final double iter = null ;
rank: 906
score: 98.09490966796875
patch: int length = 0 ;
rank: 906
score: 98.07279663085937
patch: ++ n ; {
rank: 906
score: 97.76397094726562
patch: input = iter ;
rank: 906
score: 96.01922607421875
patch: ++ do
rank: 907
score: 98.37162272135417
patch: ++ iter ; ++ iter ; ++ * * * /
rank: 907
score: 98.24193115234375
patch: * * * /
rank: 907
score: 98.21581013997395
patch: ++ iter > 0 )
rank: 907
score: 98.09466552734375
patch: double iter = f CaMeL
rank: 907
score: 98.06032104492188
patch: delta = 0 ;
rank: 907
score: 97.76282958984375
patch: finished = true ;
rank: 907
score: 96.01837158203125
patch: result ;
rank: 908
score: 98.3720703125
patch: Iterator iter = n ;
rank: 908
score: 98.37015787760417
patch: ++ iter ; ++ 1 ; / * * / /
rank: 908
score: 98.23853759765625
patch: i * * /
rank: 908
score: 98.22841186523438
patch: stop = 0 ;
rank: 908
score: 98.21457926432292
patch: ++ iter ; null ;
rank: 908
score: 98.0795389811198
patch: double f CaMeL Val [
rank: 908
score: 97.75553894042969
patch: key = ;
rank: 908
score: 96.0134785970052
patch: buffer ;
rank: 909
score: 98.37193952287946
patch: if ( double CaMeL Value )
rank: 909
score: 98.3700459798177
patch: ++ iter ; ++ iter ; iter ; int 1 ;
rank: 909
score: 98.23818969726562
patch: ++ * * ;
rank: 909
score: 98.2107442220052
patch: new ; ++ iter ;
rank: 909
score: 98.07899983723958
patch: boolean stop = ) {
rank: 909
score: 97.93016967773437
patch: if ( x ;
rank: 909
score: 97.74068603515624
patch: while ( false ;
rank: 909
score: 96.00480143229167
patch: } ;
rank: 910
score: 98.36991373697917
patch: ++ iter ; ++ iter ; ++ iter ; ; ;
rank: 910
score: 98.21041870117188
patch: ++ iter *= $NUMBER$ ;
rank: 910
score: 98.078369140625
patch: int n = x ;
rank: 910
score: 95.99894205729167
patch: default ;
rank: 911
score: 98.36990356445312
patch: if ++ iter ; ++ iter ; ++ iter ; ;
rank: 911
score: 98.20540364583333
patch: if ( iter ; ;
rank: 911
score: 97.73909912109374
patch: long n = ;
rank: 911
score: 95.98631286621094
patch: ++
rank: 912
score: 98.36530412946429
patch: j = f CaMeL Val ;
rank: 912
score: 98.20664469401042
patch: while ( iter ; {
rank: 912
score: 98.20506591796875
patch: i -- ; }
rank: 912
score: 98.1983133951823
patch: ++ n - $NUMBER$ ;
rank: 912
score: 97.7225830078125
patch: node = iter ;
rank: 912
score: 95.9513651529948
patch: end ;
rank: 913
score: 98.369140625
patch: ++ iter ; iter * * * * / / /
rank: 913
score: 98.36315046037946
patch: first = f CaMeL Val ;
rank: 913
score: 98.20603434244792
patch: synchronized ( checker ) {
rank: 913
score: 98.19885864257813
patch: ++ 1 ; }
rank: 913
score: 98.19578043619792
patch: synchronized ( ++ iter ;
rank: 913
score: 98.07644653320312
patch: double start = $NUMBER$ ;
rank: 913
score: 97.9080810546875
patch: double = 0 ;
rank: 913
score: 97.72173461914062
patch: changed = false ;
rank: 913
score: 95.9065450032552
patch: } else
rank: 914
score: 98.36895751953125
patch: ++ iter ; ++ * * iter ; iter * /
rank: 914
score: 98.1932373046875
patch: if ( ;
rank: 914
score: 97.9068603515625
patch: double [ ] {
rank: 914
score: 97.71566772460938
patch: ++ iter -- ;
rank: 914
score: 95.762939453125
patch: *
rank: 915
score: 98.36887613932292
patch: ++ iter ; ++ * * ++ iter ; iter ;
rank: 915
score: 98.35118756975446
patch: temp = f CaMeL Val ;
rank: 915
score: 98.1902567545573
patch: ++ iter ] = ;
rank: 915
score: 98.17462158203125
patch: else { }
rank: 915
score: 97.88831176757813
patch: i = 1 ;
rank: 915
score: 97.71217041015625
patch: c = iter ;
rank: 916
score: 98.36721801757812
patch: ++ iter ; ++ iter ; / * / / /
rank: 916
score: 98.18180338541667
patch: synchronized ( true ) {
rank: 916
score: 98.17288818359376
patch: else return null ;
rank: 916
score: 98.07076009114583
patch: double iter = ) {
rank: 916
score: 97.88189697265625
patch: x = 0 ;
rank: 916
score: 95.4451904296875
patch: throw
rank: 917
score: 98.36688232421875
patch: / * ] ++ iter ; / / * / /
rank: 917
score: 98.34205845424107
patch: iter = guess . length ;
rank: 917
score: 98.18948364257812
patch: for ; ; ; )
rank: 917
score: 98.16166381835937
patch: * * * ;
rank: 917
score: 98.06939697265625
patch: double clone = 0 ;
rank: 917
score: 97.84276733398437
patch: if ( x )
rank: 917
score: 97.70839233398438
patch: running = true ;
rank: 917
score: 95.39590454101562
patch: final
rank: 918
score: 98.36636352539062
patch: / * ++ iter ; / * * * / /
rank: 918
score: 98.34033203125
patch: synchronized ( f CaMeL Val )
rank: 918
score: 98.17977905273438
patch: iter += ++ iter ;
rank: 918
score: 97.69912109375
patch: done = true ;
rank: 918
score: 95.20208740234375
patch: iterator
rank: 919
score: 98.36543782552083
patch: / * ] iter ; / * / / / /
rank: 919
score: 98.34013148716518
patch: self = f CaMeL Val ;
rank: 919
score: 98.1437255859375
patch: if ; * ;
rank: 919
score: 98.06069946289062
patch: int min = 0 ;
rank: 919
score: 97.68233642578124
patch: ++ iter . ;
rank: 919
score: 95.11815643310547
patch: {
rank: 920
score: 98.3646952311198
patch: / ] iter ++ ;
rank: 920
score: 98.33868408203125
patch: z = f CaMeL Val ;
rank: 920
score: 98.14306030273437
patch: ++ x ; }
rank: 920
score: 97.82989501953125
patch: System . else {
rank: 920
score: 97.6809326171875
patch: temp = iter ;
rank: 920
score: 95.11748504638672
patch: return
rank: 921
score: 98.33522251674107
patch: [ ] iter = 0 ;
rank: 921
score: 98.15015665690105
patch: double line = 0 ;
rank: 921
score: 98.1380615234375
patch: if ++ n ;
rank: 921
score: 97.67914428710938
patch: ++ iter $NUMBER$ ;
rank: 921
score: 95.07254028320312
patch: start
rank: 922
score: 98.36307779947917
patch: / * ] ++ iter ; / / / / /
rank: 922
score: 98.32229178292411
patch: item = f CaMeL Val ;
rank: 922
score: 98.17135620117188
patch: ++ iter % n ;
rank: 922
score: 98.13682556152344
patch: } else {
rank: 922
score: 97.81566772460937
patch: alpha [ ] [
rank: 922
score: 97.67646026611328
patch: idx ++ ;
rank: 922
score: 94.91278076171875
patch: public
rank: 923
score: 98.36304728190105
patch: / * ++ iter ; / * * / / /
rank: 923
score: 98.1702168782552
patch: ++ n ; * /
rank: 923
score: 97.81375122070312
patch: ++ direc ;
rank: 923
score: 94.89433288574219
patch: System
rank: 924
score: 98.36207071940105
patch: ++ iter ; ++ iter ; int * * ++ ;
rank: 924
score: 98.31259155273438
patch: synchronized ( direc )
rank: 924
score: 98.16947428385417
patch: ++ iter & $NUMBER$ ;
rank: 924
score: 98.12080078125
patch: ( ++ iter ;
rank: 924
score: 98.04770914713542
patch: double read = 0 ;
rank: 924
score: 97.66336669921876
patch: comparator . ++ ;
rank: 924
score: 94.89153289794922
patch: count
rank: 925
score: 98.36173502604167
patch: ++ * / iter ;
rank: 925
score: 98.11705322265625
patch: j ++ ; }
rank: 925
score: 98.0474141438802
patch: final double ++ iter ;
rank: 925
score: 97.8111328125
patch: while ( iter .
rank: 925
score: 97.66322021484375
patch: try ++ iter ;
rank: 925
score: 94.84922790527344
patch: result
rank: 926
score: 98.36088053385417
patch: ++ iter ; ++ iter ; ++ / * / /
rank: 926
score: 98.2327168782552
patch: double [ ] x 1
rank: 926
score: 98.105224609375
patch: ++ * n ;
rank: 926
score: 98.04534912109375
patch: double ++ iter ;
rank: 926
score: 97.80855102539063
patch: ++ ++ x ;
rank: 926
score: 97.65994262695312
patch: switch ( n )
rank: 926
score: 94.77925109863281
patch: finally
rank: 927
score: 98.36050415039062
patch: / * * ++ * / / / ++ iter ;
rank: 927
score: 98.30748494466145
patch: y $NUMBER$ = 0 ;
rank: 927
score: 98.10369262695312
patch: ++ += iter ;
rank: 927
score: 97.80733642578124
patch: f CaMeL Val ;
rank: 927
score: 97.65887451171875
patch: pos += iter ;
rank: 927
score: 94.6973876953125
patch: next
rank: 928
score: 98.3597920735677
patch: / * ++ iter ; / / / ++ iter ;
rank: 928
score: 98.30664934430804
patch: previous = f CaMeL Val ;
rank: 928
score: 98.11815795898437
patch: return new ; }
rank: 928
score: 98.0989013671875
patch: / * ++ ;
rank: 928
score: 98.01923828125
patch: double [ ] ;
rank: 928
score: 97.80538940429688
patch: double < 0 ;
rank: 928
score: 97.65703125
patch: y n ++ ;
rank: 928
score: 94.68878173828125
patch: this
rank: 929
score: 98.35976155598958
patch: this . ++ iter ; ++ iter ; iter * /
rank: 929
score: 98.30648367745536
patch: Iterator < double [ ] ;
rank: 929
score: 98.1155029296875
patch: throw new ; }
rank: 929
score: 98.09482421875
patch: iter ++ ; }
rank: 929
score: 97.65448608398438
patch: start = iter ;
rank: 929
score: 94.67167663574219
patch: ret
rank: 930
score: 98.35958862304688
patch: ++ iter ; ++ * * / ++ iter ; /
rank: 930
score: 98.30428641183036
patch: name = f CaMeL Val ;
rank: 930
score: 98.2082010904948
patch: double [ ] iter ;
rank: 930
score: 98.1141357421875
patch: iter += iter ;
rank: 930
score: 97.79180908203125
patch: i = $NUMBER$ ;
rank: 930
score: 97.64903564453125
patch: ++ iter 0 ;
rank: 930
score: 94.65953826904297
patch: default
rank: 931
score: 98.08181762695312
patch: double name = 0 ;
rank: 931
score: 98.0813232421875
patch: int 0 ; }
rank: 931
score: 97.78348999023437
patch: d = 0 ;
rank: 931
score: 97.64769287109375
patch: synchronized ( this ;
rank: 931
score: 94.62318420410156
patch: in
rank: 932
score: 98.359130859375
patch: ++ iter ; ++ iter ; if ++ iter ; ;
rank: 932
score: 98.2954813639323
patch: < f CaMeL Val ;
rank: 932
score: 98.07589721679688
patch: else { break ;
rank: 932
score: 98.04049072265624
patch: ++ iter ; )
rank: 932
score: 97.87061767578125
patch: final double [ ]
rank: 932
score: 97.64708251953125
patch: left = iter ;
rank: 932
score: 94.60758972167969
patch: logger
rank: 933
score: 98.35801188151042
patch: i * ++ ; / * / / ++ iter ;
rank: 933
score: 97.77005615234376
patch: i = x ;
rank: 933
score: 97.64465942382813
patch: key = iter ;
rank: 933
score: 94.4679183959961
patch: current
rank: 934
score: 98.35800170898438
patch: / * ] ++ iter ; / * / / /
rank: 934
score: 98.01205444335938
patch: if ( ; ;
rank: 934
score: 97.64235229492188
patch: @ Override public ;
rank: 934
score: 94.44599914550781
patch: end
rank: 935
score: 98.06312255859375
patch: return ++ 1 ;
rank: 935
score: 97.83007049560547
patch: double [ ]
rank: 935
score: 94.36564636230469
patch: c
rank: 936
score: 98.35382080078125
patch: ++ ++ - iter ;
rank: 936
score: 98.25283813476562
patch: += f CaMeL Val ;
rank: 936
score: 98.00699462890626
patch: final int iter ;
rank: 936
score: 97.63529205322266
patch: return new ;
rank: 936
score: 94.2659912109375
patch: num
rank: 937
score: 98.34658813476562
patch: ++ * ++ 1 ;
rank: 937
score: 98.13724772135417
patch: final double = 0 ;
rank: 937
score: 98.05611419677734
patch: break ; }
rank: 937
score: 97.99471435546874
patch: iter -= iter ;
rank: 937
score: 97.782080078125
patch: double < n ;
rank: 937
score: 97.747900390625
patch: i = n ;
rank: 937
score: 97.62723795572917
patch: try {
rank: 937
score: 94.22982788085938
patch: super
rank: 938
score: 98.24208984375
patch: iter = 0 ;
rank: 938
score: 98.1299336751302
patch: Iterator ( true ) {
rank: 938
score: 98.04912109375
patch: ++ iterator ; }
rank: 938
score: 97.99431762695312
patch: ++ iter >= ;
rank: 938
score: 97.76975708007812
patch: final double x ;
rank: 938
score: 97.73937377929687
patch: ++ x ; ;
rank: 938
score: 94.20628356933594
patch: last
rank: 939
score: 98.2271016438802
patch: Iterator < double ) {
rank: 939
score: 98.0399658203125
patch: ++ < 1 ;
rank: 939
score: 97.89285888671876
patch: ++ true ; {
rank: 939
score: 97.761083984375
patch: double [ ] }
rank: 939
score: 97.60447184244792
patch: return ;
rank: 939
score: 94.18296813964844
patch: max
rank: 940
score: 98.19578857421875
patch: n = 0 ;
rank: 940
score: 98.037109375
patch: ++ $NUMBER$ ; }
rank: 940
score: 97.74769287109375
patch: ++ iter ; final
rank: 940
score: 97.72532958984375
patch: ++ x ; {
rank: 940
score: 97.59601593017578
patch: y ++ ;
rank: 940
score: 94.13705444335938
patch: pos
rank: 941
score: 98.336767578125
patch: j * ++ ;
rank: 941
score: 98.17152709960938
patch: ( true ) {
rank: 941
score: 98.05469360351563
patch: final double iter ;
rank: 941
score: 97.96806640625
patch: while ++ iter ;
rank: 941
score: 97.85537109375
patch: while ( iter ;
rank: 941
score: 97.7335205078125
patch: double ( iter .
rank: 941
score: 97.72401428222656
patch: direc [
rank: 941
score: 97.58501434326172
patch: j ++ ;
rank: 941
score: 94.12134552001953
patch: do
rank: 942
score: 98.29308471679687
patch: ++ ] iter ;
rank: 942
score: 98.16165771484376
patch: end = 0 ;
rank: 942
score: 98.043603515625
patch: double x 1 ;
rank: 942
score: 98.03221435546875
patch: Set ++ iter ;
rank: 942
score: 97.82237548828125
patch: double < double ;
rank: 942
score: 97.59151458740234
patch: double $NUMBER$ ;
rank: 942
score: 94.08956146240234
patch: offset
rank: 943
score: 98.031884765625
patch: return ++ $NUMBER$ ;
rank: 943
score: 97.68292236328125
patch: final double n ;
rank: 943
score: 97.56935119628906
patch: j = ;
rank: 943
score: 97.5455830891927
patch: else {
rank: 943
score: 94.05433654785156
patch: found
rank: 944
score: 98.13052978515626
patch: y = 0 ;
rank: 944
score: 98.02694091796874
patch: } ++ 0 ;
rank: 944
score: 97.56857299804688
patch: pos -- ;
rank: 944
score: 97.54218292236328
patch: System . else
rank: 944
score: 94.04541015625
patch: p
rank: 945
score: 98.09573974609376
patch: state = 0 ;
rank: 945
score: 98.024560546875
patch: / * ; }
rank: 945
score: 97.74561157226563
patch: ++ true ; ;
rank: 945
score: 97.67908325195313
patch: final double ) {
rank: 945
score: 97.53817749023438
patch: c = ;
rank: 945
score: 94.02727508544922
patch: value
rank: 946
score: 98.08172607421875
patch: Iterator < double )
rank: 946
score: 98.019921875
patch: else ++ n ;
rank: 946
score: 97.92021484375
patch: ++ iter = ;
rank: 946
score: 97.74156494140625
patch: ++ true ; }
rank: 946
score: 97.66940307617188
patch: i -= n ;
rank: 946
score: 97.52448272705078
patch: input = ;
rank: 946
score: 93.93299102783203
patch: line
rank: 947
score: 98.04506225585938
patch: i = iter ;
rank: 947
score: 97.6587890625
patch: if ( ) {
rank: 947
score: 97.52204895019531
patch: / * /
rank: 947
score: 97.52056884765625
patch: z ++ ;
rank: 947
score: 93.92304992675781
patch: size
rank: 948
score: 98.0289306640625
patch: result = 0 ;
rank: 948
score: 97.88676147460937
patch: i ++ ; ;
rank: 948
score: 97.70953369140625
patch: while ( iter {
rank: 948
score: 97.65155029296875
patch: double iter ;
rank: 948
score: 97.51830291748047
patch: j -- ;
rank: 948
score: 93.90474700927734
patch: it
rank: 949
score: 98.23526000976562
patch: ++ start ++ ;
rank: 949
score: 98.024658203125
patch: r = 0 ;
rank: 949
score: 97.99957275390625
patch: ++ length ; }
rank: 949
score: 97.51311492919922
patch: cl = ;
rank: 949
score: 97.43253326416016
patch: double 1 ;
rank: 949
score: 93.89825439453125
patch: j
rank: 950
score: 98.0205078125
patch: j = 0 ;
rank: 950
score: 97.98790283203125
patch: ++ < $NUMBER$ ;
rank: 950
score: 97.92821655273437
patch: double x $NUMBER$ ;
rank: 950
score: 97.87598266601563
patch: for ++ iter ;
rank: 950
score: 97.6925048828125
patch: stop ( ) ;
rank: 950
score: 97.47126007080078
patch: node = ;
rank: 950
score: 93.88580322265625
patch: obj
rank: 951
score: 98.01566162109376
patch: synchronized ( checker )
rank: 951
score: 97.98583984375
patch: / ; * /
rank: 951
score: 97.872509765625
patch: i iter ++ ;
rank: 951
score: 97.49996185302734
patch: double x ;
rank: 951
score: 97.42206573486328
patch: x ++ ;
rank: 951
score: 97.40367126464844
patch: return x ;
rank: 951
score: 93.88514709472656
patch: l
rank: 952
score: 98.18768310546875
patch: ++ 1 iter ;
rank: 952
score: 97.98523559570313
patch: * * / }
rank: 952
score: 97.49871826171875
patch: double ) {
rank: 952
score: 97.40725708007812
patch: t = ;
rank: 952
score: 97.39049530029297
patch: * * /
rank: 952
score: 93.86918640136719
patch: r
rank: 953
score: 98.182958984375
patch: catch ++ iter ;
rank: 953
score: 98.00996704101563
patch: num = 0 ;
rank: 953
score: 97.98101196289062
patch: ++ * iter /
rank: 953
score: 97.8856689453125
patch: final double $NUMBER$ ;
rank: 953
score: 97.83411865234375
patch: while ( ; )
rank: 953
score: 97.39016723632812
patch: z -- ;
rank: 953
score: 93.84693908691406
patch: e
rank: 954
score: 98.167724609375
patch: else iter ++ ;
rank: 954
score: 98.00548095703125
patch: found = 0 ;
rank: 954
score: 97.980078125
patch: return iter iter ;
rank: 954
score: 97.38310241699219
patch: i -- ;
rank: 954
score: 93.83922576904297
patch: total
rank: 955
score: 98.0022705078125
patch: result = null ;
rank: 955
score: 97.9775390625
patch: / * ;
rank: 955
score: 97.80995483398438
patch: / iter * /
rank: 955
score: 97.38259887695312
patch: p = ;
rank: 955
score: 97.37086486816406
patch: double n ;
rank: 955
score: 97.29536437988281
patch: ++ guess ;
rank: 955
score: 93.83200073242188
patch: n
rank: 956
score: 97.9979248046875
patch: start = 0 ;
rank: 956
score: 97.8316650390625
patch: int x 1 ;
rank: 956
score: 97.80064697265625
patch: ++ n * /
rank: 956
score: 97.28623962402344
patch: int x ;
rank: 956
score: 93.8171157836914
patch: out
rank: 957
score: 98.12364501953125
patch: ++ value iter ;
rank: 957
score: 97.37036895751953
patch: state = ;
rank: 957
score: 93.81048583984375
patch: key
rank: 958
score: 97.99202880859374
patch: s = 0 ;
rank: 958
score: 97.36869049072266
patch: final ; ;
rank: 958
score: 93.7635498046875
patch: :
rank: 959
score: 97.990576171875
patch: return null ; }
rank: 959
score: 97.7982177734375
patch: final double 1 ;
rank: 959
score: 97.79129028320312
patch: i -= iter ;
rank: 959
score: 97.40973663330078
patch: for ( int
rank: 959
score: 97.36734008789062
patch: temp = ;
rank: 959
score: 97.25575256347656
patch: if ( x
rank: 959
score: 93.72892761230469
patch: Logger
rank: 960
score: 97.9781494140625
patch: -- iter ; }
rank: 960
score: 97.36460876464844
patch: y -- ;
rank: 960
score: 93.706298828125
patch: input
rank: 961
score: 97.79613037109375
patch: i = iter .
rank: 961
score: 97.34819793701172
patch: return ; }
rank: 961
score: 97.23051452636719
patch: x 1 [
rank: 961
score: 93.70185852050781
patch: index
rank: 962
score: 97.96795043945312
patch: return 0 ; }
rank: 962
score: 97.33808898925781
patch: iter = ;
rank: 962
score: 97.23040771484375
patch: int ) {
rank: 962
score: 97.19230651855469
patch: final double }
rank: 962
score: 93.69412231445312
patch: cur
rank: 963
score: 98.09434204101562
patch: Integer iter ++ ;
rank: 963
score: 97.33376057942708
patch: final ;
rank: 963
score: 97.22509765625
patch: ++ checker ;
rank: 963
score: 97.18573760986328
patch: double iter .
rank: 963
score: 93.64002227783203
patch: s
rank: 964
score: 97.9311279296875
patch: p = 0 ;
rank: 964
score: 97.33206176757812
patch: idx -- ;
rank: 964
score: 97.22509765625
patch: ++ iter :
rank: 964
score: 93.63236999511719
patch: My@@
rank: 965
score: 98.08449096679688
patch: i ] ++ ;
rank: 965
score: 97.91978149414062
patch: entry = 0 ;
rank: 965
score: 97.77265167236328
patch: Set iter ;
rank: 965
score: 97.76337890625
patch: d = null ;
rank: 965
score: 97.59423828125
patch: ii ++ ;
rank: 965
score: 97.3260498046875
patch: r = ;
rank: 965
score: 93.62769317626953
patch: error
rank: 966
score: 98.07142944335938
patch: ++ value ++ ;
rank: 966
score: 97.3175048828125
patch: pos = ;
rank: 966
score: 97.14167785644531
patch: final double {
rank: 966
score: 93.59901428222656
patch: m
rank: 967
score: 97.72241973876953
patch: if ; }
rank: 967
score: 97.30610656738281
patch: b = ;
rank: 967
score: 97.21359252929688
patch: else break ;
rank: 967
score: 97.13895416259766
patch: double Math ;
rank: 967
score: 93.57750701904297
patch: i
rank: 968
score: 98.0656982421875
patch: } int iter ;
rank: 968
score: 97.8657455444336
patch: return null ;
rank: 968
score: 97.72178955078125
patch: double iter 1 ;
rank: 968
score: 97.212890625
patch: else { {
rank: 968
score: 97.19306182861328
patch: ++ continue ;
rank: 968
score: 97.12753295898438
patch: final double ;
rank: 968
score: 93.56391143798828
patch: list
rank: 969
score: 97.86251831054688
patch: return 0 ;
rank: 969
score: 97.6531982421875
patch: } * /
rank: 969
score: 97.29258219401042
patch: while ;
rank: 969
score: 97.14071655273438
patch: ++ SIZE ;
rank: 969
score: 93.5537109375
patch: buffer
rank: 970
score: 97.62162780761719
patch: * * ;
rank: 970
score: 97.51717376708984
patch: counter ++ ;
rank: 970
score: 97.28916931152344
patch: path = ;
rank: 970
score: 97.09616088867188
patch: double f CaMeL
rank: 970
score: 93.54617309570312
patch: context
rank: 971
score: 97.60527038574219
patch: return false ;
rank: 971
score: 97.51168060302734
patch: while ; ;
rank: 971
score: 97.26731872558594
patch: v = ;
rank: 971
score: 97.09027099609375
patch: double start ;
rank: 971
score: 93.46253967285156
patch: d
rank: 972
score: 97.45671081542969
patch: iter += ;
rank: 972
score: 97.26602935791016
patch: result = ;
rank: 972
score: 93.45376586914062
patch: @
rank: 973
score: 98.04007568359376
patch: key { ++ ;
rank: 973
score: 97.4542236328125
patch: new ++ ;
rank: 973
score: 97.26033020019531
patch: k ++ ;
rank: 973
score: 97.08943939208984
patch: if ( {
rank: 973
score: 97.07429504394531
patch: return 1 ;
rank: 973
score: 96.86781819661458
patch: for (
rank: 973
score: 93.44053649902344
patch: java
rank: 974
score: 98.03656005859375
patch: return false ; ;
rank: 974
score: 97.66622161865234
patch: if ( iter
rank: 974
score: 96.83006795247395
patch: * /
rank: 974
score: 96.648681640625
patch: double }
rank: 974
score: 93.40498352050781
patch: sb
rank: 975
score: 98.03388671875
patch: iter * ++ ;
rank: 975
score: 97.65750122070312
patch: ( iter ;
rank: 975
score: 97.22898864746094
patch: clazz = ;
rank: 975
score: 96.71217854817708
patch: x [
rank: 975
score: 93.39926147460938
patch: thread
rank: 976
score: 97.6488037109375
patch: return guess ;
rank: 976
score: 97.22093963623047
patch: s = ;
rank: 976
score: 93.39668273925781
patch: self
rank: 977
score: 96.65720621744792
patch: do {
rank: 977
score: 93.36953735351562
patch: curr
rank: 978
score: 97.62071228027344
patch: Iterator < double
rank: 978
score: 97.52119445800781
patch: else * /
rank: 978
score: 97.21306610107422
patch: ++ n )
rank: 978
score: 96.42913818359375
patch: double ;
rank: 978
score: 93.36103820800781
patch: original
rank: 979
score: 97.5108413696289
patch: else return ;
rank: 979
score: 97.42144775390625
patch: Iterator * ;
rank: 979
score: 97.39203643798828
patch: if ; ;
rank: 979
score: 97.2021255493164
patch: data = ;
rank: 979
score: 96.40297444661458
patch: double {
rank: 979
score: 93.35491180419922
patch: Asserts
rank: 980
score: 97.68521118164062
patch: i * /
rank: 980
score: 97.17475891113281
patch: x -- ;
rank: 980
score: 96.46907552083333
patch: 0 ;
rank: 980
score: 96.39613850911458
patch: double <
rank: 980
score: 93.35285949707031
patch: matching
rank: 981
score: 97.50846862792969
patch: else continue ;
rank: 981
score: 97.17232513427734
patch: cp = ;
rank: 981
score: 96.4490458170573
patch: final .
rank: 981
score: 93.34986877441406
patch: number
rank: 982
score: 97.68077850341797
patch: return true ;
rank: 982
score: 97.56004333496094
patch: / * *
rank: 982
score: 97.1485595703125
patch: root = ;
rank: 982
score: 96.37288411458333
patch: if (
rank: 982
score: 93.34176635742188
patch: copy
rank: 983
score: 97.65977478027344
patch: value ++ ;
rank: 983
score: 97.54363250732422
patch: ( true )
rank: 983
score: 97.50104522705078
patch: int length ;
rank: 983
score: 97.13238525390625
patch: try { ;
rank: 983
score: 96.34083048502605
patch: double [
rank: 983
score: 93.33479309082031
patch: true
rank: 984
score: 97.6539535522461
patch: Token iter ;
rank: 984
score: 97.54322814941406
patch: return line ;
rank: 984
score: 97.50022888183594
patch: Iterator iter ;
rank: 984
score: 97.13028717041016
patch: t ++ ;
rank: 984
score: 93.31904602050781
patch: internal
rank: 985
score: 97.63986206054688
patch: i * ;
rank: 985
score: 97.52438354492188
patch: / * }
rank: 985
score: 97.49501037597656
patch: else ; }
rank: 985
score: 97.2392578125
patch: new ; ;
rank: 985
score: 97.11500040690105
patch: if ;
rank: 985
score: 96.23842366536458
patch: final double
rank: 985
score: 93.31272888183594
patch: min
rank: 986
score: 97.63143157958984
patch: Integer iter ;
rank: 986
score: 97.50288391113281
patch: return converged ;
rank: 986
score: 97.22972106933594
patch: int * ;
rank: 986
score: 96.26137288411458
patch: int {
rank: 986
score: 96.2255147298177
patch: d .
rank: 986
score: 93.31117248535156
patch: set
rank: 987
score: 96.19024658203125
patch: ++ {
rank: 987
score: 96.17120361328125
patch: 0 :
rank: 987
score: 96.16766357421875
patch: final else
rank: 987
score: 93.3035888671875
patch: skip
rank: 988
score: 97.47415161132812
patch: continue ; }
rank: 988
score: 97.20441436767578
patch: float iter ;
rank: 988
score: 97.20418548583984
patch: Iterator $NUMBER$ ;
rank: 988
score: 96.15475463867188
patch: { {
rank: 988
score: 96.13323974609375
patch: f CaMeL
rank: 988
score: 93.29955291748047
patch: prev
rank: 989
score: 97.15813446044922
patch: final ) {
rank: 989
score: 96.15443929036458
patch: ) {
rank: 989
score: 96.13138834635417
patch: i ;
rank: 989
score: 96.11555989583333
patch: int <
rank: 989
score: 93.2856674194336
patch: org
rank: 990
score: 97.53886413574219
patch: iter * /
rank: 990
score: 97.17367553710938
patch: throw ; }
rank: 990
score: 97.13932800292969
patch: final / /
rank: 990
score: 97.0139872233073
patch: finally {
rank: 990
score: 96.49119059244792
patch: input ;
rank: 990
score: 96.12240600585938
patch: 0 1
rank: 990
score: 93.28338623046875
patch: stop
rank: 991
score: 97.16539764404297
patch: long start ;
rank: 991
score: 96.1343994140625
patch: x ;
rank: 991
score: 96.10286458333333
patch: double CaMeL
rank: 991
score: 93.27883911132812
patch: len
rank: 992
score: 97.50362396240234
patch: boolean iter ;
rank: 992
score: 97.16146850585938
patch: it ++ ;
rank: 992
score: 96.83314005533855
patch: Iterator }
rank: 992
score: 96.46284993489583
patch: float ;
rank: 992
score: 96.02293904622395
patch: d ;
rank: 992
score: 93.25084686279297
patch: state
rank: 993
score: 97.50187683105469
patch: int value ;
rank: 993
score: 96.25144449869792
patch: synchronized ;
rank: 993
score: 93.24673461914062
patch: abs
rank: 994
score: 96.461181640625
patch: throw ;
rank: 994
score: 96.22102864583333
patch: p ;
rank: 994
score: 96.02541097005208
patch: double f
rank: 994
score: 93.24057006835938
patch: initial
rank: 995
score: 96.68832397460938
patch: } }
rank: 995
score: 96.19816080729167
patch: Object ;
rank: 995
score: 94.95059204101562
patch: double
rank: 995
score: 93.23785400390625
patch: tree
rank: 996
score: 96.19472249348958
patch: long ;
rank: 996
score: 95.07469177246094
patch: int
rank: 996
score: 93.22212219238281
patch: .
rank: 997
score: 96.67643229166667
patch: } {
rank: 997
score: 96.15494791666667
patch: I ;
rank: 997
score: 95.73444366455078
patch: Iterator
rank: 997
score: 93.20972442626953
patch: after
rank: 999
score: 95.45930480957031
patch: ?
rank: 999
score: 93.20350646972656
patch: param
rank: 1000
score: 93.1904525756836
patch: visible
